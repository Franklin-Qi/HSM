
/*********************************************************/
/* Header File                                           */
/*********************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

#include "APIEBank.h"

typedef unsigned int   UINT;
typedef unsigned char BYTE;
typedef BYTE *PBYTE;
typedef const BYTE CBYTE;
typedef const BYTE *PCBYTE;

typedef int RESULT;
#define NORMAL 0;
#define LOG_LABLE 0;
#define bufclr(cDest)        memset(cDest, 0, sizeof(cDest))
int nDeviceHandle=-1, nHandle=-1;

/*********************************************************/
/* Macro                                                 */
/*********************************************************/

#define TIMEDECLEAR \
          struct timeval tpstart; \
          struct timeval tpend;
#define TIMECOST \
          ((tpend.tv_sec - tpstart.tv_sec)*1000000 + (tpend.tv_usec - tpstart.tv_usec))
#define TIMESTART \
          { \
              int k = 1; \
              for(; k <= 1; k++) \
              { \
                  if(k%10 == 1) \
                  { \
                      gettimeofday(&tpstart, NULL); \
                  }
#define TIMEEND(s) \
                  if(k%10 == 1) \
                  { \
                      gettimeofday(&tpend, NULL); \
                      printf("[%06s][%04d]COST: %09d\n", s, __LINE__, TIMECOST); \
                  } \
              } \
          }


#define SM_SERVER_ADDR "10.1.100.138"
#define SM_SERVER_PORT 8
#define SM_TIME_OUT    32

/* test lable macro */
#define XXX_TEST_START_XXX \
    {printf(">>>>>>>>>> %s START >>>>>>>>>>", __func__);}
#define XXX_TEST_END_XXX \
    {printf("<<<<<<<<<< %s  END  <<<<<<<<<<\n\n", __func__); return;}

static int CASE_NO = 0;
static int iscontinue = 1;
FILE * fp = NULL;

/* log lable */
#define XXX_CASE_XXX(c) \
    {CASE_NO = c; printf("\n=============      Case %-2d     =============\n", c);}

#ifdef LOG_LABLE
static int LF_FLAG = 0;

#define LF_FLAG_CTRL \
    {if((LF_FLAG ^= 1)) printf("\n");}

#define XXX_INPUT_XXX \
    {LF_FLAG_CTRL \
     printf("------------- Input  Parameter -------------\n");}

#define XXX_OUTPUT_XXX \
    {LF_FLAG_CTRL \
     printf("************* Output Parameter *************\n");}

#define XXX_RESULT_XXX \
    {LF_FLAG_CTRL \
     printf("~~~~~~~~~~~~~   Return Value   ~~~~~~~~~~~~~\n");}
#else
#define XXX_INPUT_XXX
#define XXX_OUTPUT_XXX
#define XXX_RESULT_XXX
#endif

#define XXX_INPUT_NONE_XXX  {printf("[IN ] <None>\n");}
#define XXX_OUTPUT_NONE_XXX {printf("[OUT]<None>\n");}

#define ASSERT_RESULT(r, e, m) \
    { \
        if(!((e == 0 && r == e) || (e > 0 && r > 0 && r < 50))) \
        { \
            fprintf(stdout, "\n<%-30s><%02d>\t\t\t ### ASSERT RETURN ERROR! ###\n", \
                __func__, CASE_NO); \
            fprintf(stdout, "\t[RET]result = %d, expect = %d\n", r, e); \
			if(e == 0) \
            	fprintf(stdout, "\t[MSG]%s\n\n", m); \
            fflush(stdout); \
        } \
        else if(e > 0 && e != r) \
        { \
			fprintf(stdout, "\n*** WARNING e = %d r = %d ***\n\t[MSG]%s\n\n", e, r, m); \
            fflush(stdout); \
        } \
    }

#define ASSERT_OUT(r, e) \
    { \
        if(r != e) \
        { \
            fprintf(stdout, "\n<%-30s><%02d>\t\t\t ### ASSERT OUTPUT ERROR! ###\n", \
                __func__, CASE_NO); \
            fprintf(stdout, "\t[OUT]result = %d, expect = %d\n", r, e); \
            fflush(stdout); \
        } \
    }

#define ASSERT_OUT2(r, e1, e2) \
    { \
        if(r != e1 && r != e2) \
        { \
            fprintf(stdout, "\n<%-30s><%02d>\t\t\t ### ASSERT OUTPUT NG! ###\n", \
                __func__, CASE_NO); \
            fprintf(stdout, "\t[OUT]result = %d, expect = %d|%d\n", r, e1, e2); \
            fflush(stdout); \
        } \
    }

#define ASSERT_OUT_HEX(r, e, l) \
    { \
        if(memcmp(r, e, l) != 0) \
        { \
            fprintf(stdout, "\n<%-30s><%02d>\t\t\t ### ASSERT OUTPUT ERROR! ###\n", \
                __func__, CASE_NO); \
            fflush(stdout); \
            DspErrHex("[OUT]result = ", r, l); \
            DspErrHex("[OUT]expect = ", e, l); \
        } \
		else \
		{ \
			fprintf(stdout,"\n[RESULT] <%s> SUCCESS\n",__func__); \
            fflush(stdout); \
		} \
    }
#define GetCharFromNum(n) ((n) >= 10 ? (n) - 10 + 'A' : (n) + '0')
/* Test Function Type */
typedef void(*TESTFUNC)(void);

/* SM Sock */
static int SM_SOCK = -1;

int ShiftHexToChar(const char* pcHex, char* pcChar, UINT nSize)
{
    UINT n;

    if (nSize == 0)
        return NORMAL;
    for (n = 0; n < nSize; n++)
    {
        pcChar[2 * n] = GetCharFromNum((pcHex[n] & 0xF0) >> 4);
        pcChar[2 * n + 1] = GetCharFromNum(pcHex[n] & 0x0F);
    }

    return NORMAL;
}

void DspHex(const char *pszInfo, const PBYTE pbHexStr, const int nStrLen)
{
    int i,j,m,n;
    PBYTE pbHex = pbHexStr;
#if 1
    i = j = 0;
    m = nStrLen / 16;
    n = nStrLen % 16;

    printf("%s\n     0x%08X %d\n", pszInfo, pbHexStr, nStrLen);

    if(nStrLen == 0)
        return;

    if(m)
    {
        for(i = 0; i < m; i++)
        {
            printf("     %08X: ", i*16);
            for(j = 0; j < 16; j++)
            {
                printf("%02X ", pbHex[j]);
            }
            printf("; ");
            for(j = 0; j < 16; j++)
            {
                //printf("%c", (char)pbHex[j]);
            }
            printf("\n");
            pbHex += 16;
        }
    }
    if(n)
    {
        printf("     %08X: ", i*16);
        for(j = 0; j < 16; j++)
        {
            if(j < n)
                printf("%02X ", pbHex[j]);
            else
                printf("   ");
        }
        printf("; ");
        for(j = 0; j < n; j++)
        {
            //printf("%c", (char)pbHex[j]);
        }
        printf("\n");
    }
#endif
    return;
}

void DspHexExt(const char *pszInfo, const PBYTE pbHexStr, const int nStrLen)
{
    int i,j,m,n;
    PBYTE pbHex = pbHexStr;
#if 1
    i = j = 0;
    m = nStrLen / 16;
    n = nStrLen % 16;

    printf("%s\n     0x%08X %d\n", pszInfo, pbHexStr, nStrLen);

    if(nStrLen == 0)
        return;

    if(m)
    {
        for(i = 0; i < m; i++)
        {
            for(j = 0; j < 16; j++)
            {
                printf("%02X", pbHex[j]);
            }
            pbHex += 16;
        }
    }
    if(n)
    {
        for(j = 0; j < 16; j++)
        {
            if(j < n)
                printf("%02X", pbHex[j]);
        }
        for(j = 0; j < n; j++)
        {
            //printf("%c", (char)pbHex[j]);
        }
    }
    printf("\n");
#endif
    return;
}

void DspErrHex(const char *pszInfo, const PBYTE pbHexStr, const int nStrLen)
{
#if 1
    int i,j,m,n;
    PBYTE pbHex = pbHexStr;

    i = j = 0;
    m = nStrLen / 16;
    n = nStrLen % 16;

    fprintf(stdout, "\t%s\n\t     0x%08X %d\n", pszInfo, pbHexStr, nStrLen);

    if(nStrLen == 0)
        return;

    if(m)
    {
        for(i = 0; i < m; i++)
        {
            fprintf(stdout, "\t     %08X: ", i*16);
            for(j = 0; j < 16; j++)
            {
                fprintf(stdout, "%02X ", pbHex[j]);
            }
            fprintf(stdout, "; ");
            for(j = 0; j < 16; j++)
            {
                //fprintf(stdout, "%c", (char)pbHex[j]);
            }
            fprintf(stdout, "\n");
            pbHex += 16;

            if(i > 0 && (i % 64 == 0))
                fflush(stdout);
        }
    }
    if(n)
    {
        fprintf(stdout, "\t     %08X: ", i*16);
        for(j = 0; j < 16; j++)
        {
            if(j < n)
                fprintf(stdout, "%02X ", pbHex[j]);
            else
                fprintf(stdout, "   ");
        }
        fprintf(stdout, "; ");
        for(j = 0; j < n; j++)
        {
            //fprintf(stdout, "%c", (char)pbHex[j]);
        }
        fprintf(stdout, "\n");
    }

    fflush(stdout);
#endif
    return;
}

/*▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼*/
static const char hex_to_char[16] = \
{
    /* '0' - '9' */
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
    /* 'A' - 'F' */
    0x41, 0x42, 0x43, 0x44, 0x45, 0x46
};

void SSMHexToChar(PCBYTE pbHex, char *pcChar, UINT nSize)
{
    int i;

    for (i = 0; i < nSize; i++)
    {
        pcChar[2*i] = hex_to_char[((pbHex[i] & 0xF0) >> 4)];
        pcChar[2*i + 1] = hex_to_char[(pbHex[i] & 0x0F)];
    }

    return;
}

void SSMMakeOddBinStr_Test(PBYTE pbBin, UINT nLen)
{
    int i;
    BYTE x;

    for(i = 0; i < nLen; i++)
    {
        x = pbBin[i];

        x = ((x & 0x55) + ((x >> 1) & 0x55));
        x = ((x & 0x33) + ((x >> 2) & 0x33));
        x = ((x & 0x0f) + ((x >> 4) & 0x0f));
        if((x & 0x01) == 0)
        {
            pbBin[i] ^= 0x01;
        }
    }

    return;
}

void SSMBinStrXOR(PBYTE pbDst, PBYTE pbSrc1, PBYTE pbSrc2, UINT nLen)
{
    UINT i;

    for(i = 0; i < nLen; i++)
        pbDst[i] = pbSrc1[i] ^ pbSrc2[i];

    return;
}
/*▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲*/

/*********************************************************/
/* Test Function                                         */
/*********************************************************/
void ConnectSM_Test_01(void)
{
    XXX_TEST_START_XXX

    char szAddr[20];
    UINT nPort;
    UINT nTimeOut;
    UINT nSock;
    UINT *pnSock;
    char szInfo[100];
    int  nRet;

    bufclr(szAddr);
    bufclr(szInfo);

    strcpy(szAddr, SM_SERVER_ADDR);
    nPort = SM_SERVER_PORT;
    nTimeOut = SM_TIME_OUT;
    pnSock = &nSock;

    XXX_INPUT_XXX
    printf("[IN ]szAddr   = %s\n", szAddr);
    printf("[IN ]nPort    = %d\n", nPort);
    printf("[IN ]nTimeOut = %d\n", nTimeOut);
    printf("[IN ]nSock    = 0x%p\n", pnSock);
    printf("[IN ]szInfo   = 0x%p\n", szInfo);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIConnectSM(szAddr, nPort, nTimeOut, pnSock, szInfo);

    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "连接加密机未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]nSock  = %d\n", nSock);
    printf("[OUT]szInfo = %s\n", szInfo);
    XXX_OUTPUT_XXX

    SM_SOCK = nSock;
    XXX_TEST_END_XXX
}

void ConnectSM_Test_02(void)
{
    XXX_TEST_START_XXX

    char szAddr[20];
    UINT nPort;
    UINT nTimeOut;
    UINT nSock;
    UINT *pnSock;
    char szInfo[100];
    int  nRet;

    bufclr(szAddr);
    bufclr(szInfo);

    nSock = 0;
    bufclr(szInfo);

    strcpy(szAddr, "0.0.0.0");
    nPort = SM_SERVER_PORT;
    nTimeOut = SM_TIME_OUT;
    pnSock = &nSock;

    XXX_INPUT_XXX
    printf("[IN ]szAddr   = %s\n", szAddr);
    printf("[IN ]nPort    = %d\n", nPort);
    printf("[IN ]nTimeOut = %d\n", nTimeOut);
    printf("[IN ]nSock    = 0x%p\n", pnSock);
    printf("[IN ]szInfo   = 0x%p\n", szInfo);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIConnectSM(szAddr, nPort, nTimeOut, pnSock, szInfo);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 4, "非加密机IP地址测试失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ConnectSM_Test_03(void)
{
    XXX_TEST_START_XXX

    char szAddr[20];
    UINT nPort;
    UINT nTimeOut;
    UINT nSock;
    UINT *pnSock;
    char szInfo[100];
    int  nRet;

    bufclr(szAddr);
    bufclr(szInfo);

    nSock = 0;
    bufclr(szInfo);

    strcpy(szAddr, "abc");
    nPort = SM_SERVER_PORT;
    nTimeOut = SM_TIME_OUT;
    pnSock = &nSock;

    XXX_INPUT_XXX
    printf("[IN ]szAddr   = %s\n", szAddr);
    printf("[IN ]nPort    = %d\n", nPort);
    printf("[IN ]nTimeOut = %d\n", nTimeOut);
    printf("[IN ]nSock    = 0x%p\n", pnSock);
    printf("[IN ]szInfo   = 0x%p\n", szInfo);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIConnectSM(szAddr, nPort, nTimeOut, pnSock, szInfo);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 4, "无效IP地址测试失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ConnectSM_Test_04(void)
{
    XXX_TEST_START_XXX

    char szAddr[20];
    UINT nPort;
    UINT nTimeOut;
    UINT nSock;
    UINT *pnSock;
    char szInfo[100];
    int  nRet;

    bufclr(szAddr);
    bufclr(szInfo);

    nSock = 0;
    bufclr(szInfo);

    strcpy(szAddr, SM_SERVER_ADDR);
    nPort = 1111;
    nTimeOut = SM_TIME_OUT;
    pnSock = &nSock;

    XXX_INPUT_XXX
    printf("[IN ]szAddr   = %s\n", szAddr);
    printf("[IN ]nPort    = %d\n", nPort);
    printf("[IN ]nTimeOut = %d\n", nTimeOut);
    printf("[IN ]nSock    = 0x%p\n", pnSock);
    printf("[IN ]szInfo   = 0x%p\n", szInfo);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIConnectSM(szAddr, nPort, nTimeOut, pnSock, szInfo);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 4, "无效端口测试失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ConnectSM_Test_05(void)
{
    XXX_TEST_START_XXX

    char szAddr[20];
    UINT nPort;
    UINT nTimeOut;
    UINT nSock;
    UINT *pnSock;
    char szInfo[100];
    int  nRet;

    bufclr(szAddr);
    bufclr(szInfo);

    nSock = 0;
    bufclr(szInfo);

    strcpy(szAddr, SM_SERVER_ADDR);
    nPort = SM_SERVER_PORT;
    nTimeOut = SM_TIME_OUT;
    pnSock = &nSock;

    XXX_INPUT_XXX
    printf("[IN ]szAddr   = 0x%p\n", NULL);
    printf("[IN ]nPort    = %d\n", nPort);
    printf("[IN ]nTimeOut = %d\n", nTimeOut);
    printf("[IN ]nSock    = 0x%p\n", pnSock);
    printf("[IN ]szInfo   = 0x%p\n", szInfo);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIConnectSM(NULL, nPort, nTimeOut, pnSock, szInfo);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "存放IP地址的数组是空指针测试失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ConnectSM_Test_06(void)
{
    XXX_TEST_START_XXX

    char szAddr[20];
    UINT nPort;
    UINT nTimeOut;
    UINT nSock;
    UINT *pnSock;
    char szInfo[100];
    int  nRet;

    bufclr(szAddr);
    bufclr(szInfo);

    nSock = 0;
    bufclr(szInfo);

    pnSock = NULL;

    XXX_INPUT_XXX
    printf("[IN ]szAddr   = %s\n", szAddr);
    printf("[IN ]nPort    = %d\n", nPort);
    printf("[IN ]nTimeOut = %d\n", nTimeOut);
    printf("[IN ]nSock    = 0x%p\n", pnSock);
    printf("[IN ]szInfo   = 0x%p\n", szInfo);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIConnectSM(szAddr, nPort, nTimeOut, pnSock, szInfo);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "输入参数pnSock为空指针测试失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DisconnectSM_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDisconnectSM(nSock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "正常断开连接未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DisconnectSM_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDisconnectSM(nSock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "异常Sock[0]断开连接未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DisconnectSM_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = -1;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDisconnectSM(nSock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "异常Sock[-1]断开连接未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

//三未信安    zhaomx 2017-06-14
void DecryptEncrypt_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szCheckValue[16];
    int  decryptKeyIndex;
    UINT decryptMech;
    char encryptKey[64];
    UINT encryptMech;
    char data_org[1024];
    char data_tmp[1024];
    char data[1024];
    char decryptIV[32];
    char encryptIV[32];
    char outData[1024];
    char data_exp[1024];

    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(encryptKey);
    bufclr(data_org);
    bufclr(data_tmp);
    bufclr(data);
    bufclr(decryptIV);
    bufclr(encryptIV);
    bufclr(outData);
    bufclr(data_exp);

    decryptKeyIndex = 258;
    decryptMech = 20;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(encryptKey,
           "A2C0B0F8F7F5EE21FB5C6AEBE714E53A",
           32);
    encryptMech = 20;

    nRet = SMAPIGenerateKey(nSock, 16, "ZZZZZZZZZZ", 10, \
                            2, decryptKeyIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");

    memcpy(data_org,
           "\x30\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42" \
           "\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42" \
           "\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42" \
           "\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x39" \
           , 64);
    nRet = SMAPIEncryptData(nSock, 1, 0, decryptKeyIndex, data_org, 64, data_tmp);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptData NG");
    SSMHexToChar(data_tmp, data, 64);

    memcpy(data_exp, "C9AF9A5820243A8F322EA2FA878BC4AE"
                     "322EA2FA878BC4AE322EA2FA878BC4AE"
                     "322EA2FA878BC4AE322EA2FA878BC4AE"
                     "322EA2FA878BC4AE71AA8BE6D7CE2C1E"
                     , 128);

    memset(decryptIV, '0', 16);
    memset(encryptIV, '0', 16);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]decryptKeyIndex = %d\n", decryptKeyIndex);
    printf("[IN ]decryptMech = %d\n", decryptMech);
    printf("[IN ]encryptKey  = %s\n", encryptKey);
    printf("[IN ]encryptMech = %d\n", encryptMech);
    printf("[IN ]data        = %s\n", data);
    printf("[IN ]decryptIV   = %s\n", decryptIV);
    printf("[IN ]encryptIV   = %s\n", encryptIV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptEncrypt(nSock, decryptKeyIndex, decryptMech, \
                               encryptKey, encryptMech, data, \
                               decryptIV, encryptIV, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "ECB转ECB测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(outData, data_exp, 128);
    printf("[OUT]outData  = %s\n", outData);
    printf("[OUT]data_exp = %s\n", data_exp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptEncrypt_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szCheckValue[16];
    int  decryptKeyIndex;
    UINT decryptMech;
    char encryptKey[64];
    UINT encryptMech;
    char data_org[1024];
    char data_tmp[1024];
    char data[1024];
    char decryptIV[32];
    char encryptIV[32];
    char outData[1024];
    char data_exp[1024];

    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(encryptKey);
    bufclr(data_org);
    bufclr(data_tmp);
    bufclr(data);
    bufclr(decryptIV);
    bufclr(encryptIV);
    bufclr(outData);
    bufclr(data_exp);

    decryptKeyIndex = 258;
    decryptMech = 17;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(encryptKey,
           "A2C0B0F8F7F5EE21FB5C6AEBE714E53A",
           32);
    encryptMech = 17;

    nRet = SMAPIGenerateKey(nSock, 16, "ZZZZZZZZZZ", 10, \
                            2, decryptKeyIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");

    memcpy(data_org,
           "\x30\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42" \
           "\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42" \
           "\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42" \
           "\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x39" \
           , 64);
    nRet = SMAPIEncryptData(nSock, 1, 1, decryptKeyIndex, data_org, 64, data_tmp);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptData NG");
    SSMHexToChar(data_tmp, data, 64);

    memcpy(data_exp, "C9AF9A5820243A8FACED8916C5EDD75A"
                     "15F05A7AB0A03B7BC77393E44B464F4D"
                     "FAF2845DD3EDCFECC4C349829CFD0F2A"
                     "CFD249005B3E6667A7D50E60FD9F0226"
                     , 128);

    memset(decryptIV, '0', 16);
    memset(encryptIV, '0', 16);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]decryptKeyIndex = %d\n", decryptKeyIndex);
    printf("[IN ]decryptMech = %d\n", decryptMech);
    printf("[IN ]encryptKey  = %s\n", encryptKey);
    printf("[IN ]encryptMech = %d\n", encryptMech);
    printf("[IN ]data        = %s\n", data);
    printf("[IN ]decryptIV   = %s\n", decryptIV);
    printf("[IN ]encryptIV   = %s\n", encryptIV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptEncrypt(nSock, decryptKeyIndex, decryptMech, \
                               encryptKey, encryptMech, data, \
                               decryptIV, encryptIV, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "CBC转CBC测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(outData, data_exp, 128);
    printf("[OUT]outData  = %s\n", outData);
    printf("[OUT]data_exp = %s\n", data_exp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptEncrypt_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szCheckValue[16];
    int  decryptKeyIndex;
    UINT decryptMech;
    char encryptKey[64];
    UINT encryptMech;
    char data_org[1024];
    char data_tmp[1024];
    char data[1024];
    char decryptIV[32];
    char encryptIV[32];
    char outData[1024];
    char data_exp[1024];

    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(encryptKey);
    bufclr(data_org);
    bufclr(data_tmp);
    bufclr(data);
    bufclr(decryptIV);
    bufclr(encryptIV);
    bufclr(outData);
    bufclr(data_exp);

    decryptKeyIndex = 258;
    decryptMech = 17;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(encryptKey,
           "A2C0B0F8F7F5EE21FB5C6AEBE714E53A",
           32);
    encryptMech = 20;

    nRet = SMAPIGenerateKey(nSock, 16, "ZZZZZZZZZZ", 10, \
                            2, decryptKeyIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");

    memcpy(data_org,
           "\x30\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42" \
           "\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42" \
           "\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42" \
           "\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x39" \
           , 64);
    nRet = SMAPIEncryptData(nSock, 1, 1, decryptKeyIndex, data_org, 64, data_tmp);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptData NG");
    SSMHexToChar(data_tmp, data, 64);

    memcpy(data_exp, "C9AF9A5820243A8F322EA2FA878BC4AE"
                     "322EA2FA878BC4AE322EA2FA878BC4AE"
                     "322EA2FA878BC4AE322EA2FA878BC4AE"
                     "322EA2FA878BC4AE71AA8BE6D7CE2C1E"
                     , 128);

    memset(decryptIV, '0', 16);
    memset(encryptIV, '0', 16);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]decryptKeyIndex = %d\n", decryptKeyIndex);
    printf("[IN ]decryptMech = %d\n", decryptMech);
    printf("[IN ]encryptKey  = %s\n", encryptKey);
    printf("[IN ]encryptMech = %d\n", encryptMech);
    printf("[IN ]data        = %s\n", data);
    printf("[IN ]decryptIV   = %s\n", decryptIV);
    printf("[IN ]encryptIV   = %s\n", encryptIV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptEncrypt(nSock, decryptKeyIndex, decryptMech, \
                               encryptKey, encryptMech, data, \
                               decryptIV, encryptIV, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "CBC转ECB测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(outData, data_exp, 128);
    printf("[OUT]outData  = %s\n", outData);
    printf("[OUT]data_exp = %s\n", data_exp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptEncrypt_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szCheckValue[16];
    int  decryptKeyIndex;
    UINT decryptMech;
    char encryptKey[64];
    UINT encryptMech;
    char data_org[1024];
    char data_tmp[1024];
    char data[1024];
    char decryptIV[33];
    char encryptIV[33];
    char outData[1024];
    char data_exp[1024];

    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(encryptKey);
    bufclr(data_org);
    bufclr(data_tmp);
    bufclr(data);
    bufclr(decryptIV);
    bufclr(encryptIV);
    bufclr(outData);
    bufclr(data_exp);

    decryptKeyIndex = 258;
    decryptMech = 20;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(encryptKey,
           "A2C0B0F8F7F5EE21FB5C6AEBE714E53A",
           32);
    encryptMech = 17;

    nRet = SMAPIGenerateKey(nSock, 16, "ZZZZZZZZZZ", 10, \
                            2, decryptKeyIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");

    memcpy(data_org,
           "\x30\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42" \
           "\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42" \
           "\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42" \
           "\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x39" \
           , 64);
    nRet = SMAPIEncryptData(nSock, 1, 0, decryptKeyIndex, data_org, 64, data_tmp);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptData NG");
    SSMHexToChar(data_tmp, data, 64);

    memcpy(data_exp, "C9AF9A5820243A8FACED8916C5EDD75A"
                     "15F05A7AB0A03B7BC77393E44B464F4D"
                     "FAF2845DD3EDCFECC4C349829CFD0F2A"
                     "CFD249005B3E6667A7D50E60FD9F0226"
                     , 128);

    memset(decryptIV, '0', 16);
    memset(encryptIV, '0', 16);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]decryptKeyIndex = %d\n", decryptKeyIndex);
    printf("[IN ]decryptMech = %d\n", decryptMech);
    printf("[IN ]encryptKey  = %s\n", encryptKey);
    printf("[IN ]encryptMech = %d\n", encryptMech);
    printf("[IN ]data        = %s\n", data);
    printf("[IN ]decryptIV   = %s\n", decryptIV);
    printf("[IN ]encryptIV   = %s\n", encryptIV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptEncrypt(nSock, decryptKeyIndex, decryptMech, \
                               encryptKey, encryptMech, data, \
                               decryptIV, encryptIV, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "ECB转CBC测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(outData, data_exp, 128);
    printf("[OUT]outData  = %s\n", outData);
    printf("[OUT]data_exp = %s\n", data_exp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptEncrypt_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szCheckValue[16];
    int  decryptKeyIndex;
    UINT decryptMech;
    char encryptKey[64];
    UINT encryptMech;
    char data_org[1024];
    char data[1024];
    char decryptIV[33];
    char encryptIV[33];
    char outData[1024];
    char data_exp[1024];

    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(encryptKey);
    bufclr(data_org);
    bufclr(data);
    bufclr(decryptIV);
    bufclr(encryptIV);
    bufclr(outData);
    bufclr(data_exp);

    decryptKeyIndex = 258;
    decryptMech = 3;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(encryptKey,
           "A2C0B0F8F7F5EE21FB5C6AEBE714E53A",
           32);
    encryptMech = 3;

    nRet = SMAPIGenerateKey(nSock, 16, "ZZZZZZZZZZ", 10, \
                            2, decryptKeyIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");
DspHexExt("bKey = ", bKey, 16);
    memcpy(data_org, 
           "30424242424242424242424242424242" \
           "42424242424242424242424242424242" \
           "42424242424242424242424242424242" \
           "42424242424242424242424242424239" \
           , 128);
    nRet = SMAPIEncrypt_index(nSock, decryptKeyIndex, decryptMech, data_org, decryptIV, data);
    ASSERT_RESULT(nRet, 0, "SMAPIEncrypt_index NG");

    /* 88C77F3AA6A29E4E2031657E3848A463C5F811F608BBF54F669F9D1DE7C1E6E5C5F811F608BBF54F669F9D1DE7C1E6E5822AD6A14D0A65313812078F057725B5 */
    memcpy(data_exp, 
           "88C77F3AA6A29E4E2031657E3848A463" \
           "C5F811F608BBF54F669F9D1DE7C1E6E5" \
           "C5F811F608BBF54F669F9D1DE7C1E6E5" \
           "822AD6A14D0A65313812078F057725B5"
           , 128);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]decryptKeyIndex = %d\n", decryptKeyIndex);
    printf("[IN ]decryptMech = %d\n", decryptMech);
    printf("[IN ]encryptKey  = %s\n", encryptKey);
    printf("[IN ]encryptMech = %d\n", encryptMech);
    printf("[IN ]data        = %s\n", data);
    printf("[IN ]decryptIV   = %s\n", decryptIV);
    printf("[IN ]encryptIV   = %s\n", encryptIV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptEncrypt(nSock, decryptKeyIndex, decryptMech, \
                               encryptKey, encryptMech, data, \
                               decryptIV, encryptIV, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "SM4_ECB转SM4_ECB测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(outData, data_exp, 128);
    printf("[OUT]outData  = %s\n", outData);
    printf("[OUT]data_exp = %s\n", data_exp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptEncrypt_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szCheckValue[16];
    int  decryptKeyIndex;
    UINT decryptMech;
    char encryptKey[64];
    UINT encryptMech;
    char data_org[1024];
    char data[1024];
    char decryptIV[33];
    char encryptIV[33];
    char outData[1024];
    char data_exp[1024];

    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(encryptKey);
    bufclr(data_org);
    bufclr(data);
    bufclr(decryptIV);
    bufclr(encryptIV);
    bufclr(outData);
    bufclr(data_exp);

    memset(decryptIV, 0x30, 32);
    memset(encryptIV, 0x30, 32);

    decryptKeyIndex = 258;
    decryptMech = 4;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(encryptKey,
           "A2C0B0F8F7F5EE21FB5C6AEBE714E53A",
           32);
    encryptMech = 4;

    nRet = SMAPIGenerateKey(nSock, 16, "ZZZZZZZZZZ", 10, \
                            2, decryptKeyIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");
DspHexExt("bKey =", bKey, 16);
    memcpy(data_org, 
           "30424242424242424242424242424242" \
           "42424242424242424242424242424242" \
           "42424242424242424242424242424242" \
           "42424242424242424242424242424239" \
           , 128);
    nRet = SMAPIEncrypt_index(nSock, decryptKeyIndex, decryptMech, data_org, decryptIV, data);
    ASSERT_RESULT(nRet, 0, "SMAPIEncrypt_index NG");

    /* 88C77F3AA6A29E4E2031657E3848A463E263A2B0C43EF4EFA9F9C5A722A157A0EB60D8E5FC56BAB836620A7FF5404668A98DB8B683A0819B732428B22A5F4D68 */
    memcpy(data_exp, 
           "88C77F3AA6A29E4E2031657E3848A463" \
           "E263A2B0C43EF4EFA9F9C5A722A157A0" \
           "EB60D8E5FC56BAB836620A7FF5404668" \
           "A98DB8B683A0819B732428B22A5F4D68" \
           , 128);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]decryptKeyIndex = %d\n", decryptKeyIndex);
    printf("[IN ]decryptMech = %d\n", decryptMech);
    printf("[IN ]encryptKey  = %s\n", encryptKey);
    printf("[IN ]encryptMech = %d\n", encryptMech);
    printf("[IN ]data        = %s\n", data);
    printf("[IN ]decryptIV   = %s\n", decryptIV);
    printf("[IN ]encryptIV   = %s\n", encryptIV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptEncrypt(nSock, decryptKeyIndex, decryptMech, \
                               encryptKey, encryptMech, data, \
                               decryptIV, encryptIV, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "SM4_CBC转SM4_CBC测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(outData, data_exp, 128);
    printf("[OUT]outData  = %s\n", outData);
    printf("[OUT]data_exp = %s\n", data_exp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptEncrypt_Test_07(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szCheckValue[16];
    int  decryptKeyIndex;
    UINT decryptMech;
    char encryptKey[64];
    UINT encryptMech;
    char data_org[1024];
    char data[1024];
    char decryptIV[32];
    char encryptIV[32];
    char outData[1024];
    char data_exp[1024];

    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(encryptKey);
    bufclr(data_org);
    bufclr(data);
    bufclr(decryptIV);
    bufclr(encryptIV);
    bufclr(outData);
    bufclr(data_exp);

    memset(decryptIV, 0x30, 32);

    decryptKeyIndex = 258;
    decryptMech = 4;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(encryptKey,
           "A2C0B0F8F7F5EE21FB5C6AEBE714E53A",
           32);
    encryptMech = 3;

    nRet = SMAPIGenerateKey(nSock, 16, "ZZZZZZZZZZ", 10, \
                            2, decryptKeyIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");
DspHexExt("bKey =", bKey, 16);
    memcpy(data_org, 
           "30424242424242424242424242424242" \
           "42424242424242424242424242424242" \
           "42424242424242424242424242424242" \
           "42424242424242424242424242424239" \
           , 128);
    nRet = SMAPIEncrypt_index(nSock, decryptKeyIndex, decryptMech, data_org, decryptIV, data);
    ASSERT_RESULT(nRet, 0, "SMAPIEncrypt_index NG");

    /* 88C77F3AA6A29E4E2031657E3848A463C5F811F608BBF54F669F9D1DE7C1E6E5C5F811F608BBF54F669F9D1DE7C1E6E5822AD6A14D0A65313812078F057725B5 */
    memcpy(data_exp, 
           "88C77F3AA6A29E4E2031657E3848A463" \
           "C5F811F608BBF54F669F9D1DE7C1E6E5" \
           "C5F811F608BBF54F669F9D1DE7C1E6E5" \
           "822AD6A14D0A65313812078F057725B5"
           , 128);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]decryptKeyIndex = %d\n", decryptKeyIndex);
    printf("[IN ]decryptMech = %d\n", decryptMech);
    printf("[IN ]encryptKey  = %s\n", encryptKey);
    printf("[IN ]encryptMech = %d\n", encryptMech);
    printf("[IN ]data        = %s\n", data);
    printf("[IN ]decryptIV   = %s\n", decryptIV);
    printf("[IN ]encryptIV   = %s\n", encryptIV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptEncrypt(nSock, decryptKeyIndex, decryptMech, \
                               encryptKey, encryptMech, data, \
                               decryptIV, encryptIV, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "SM4_CBC转SM4_ECB测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(outData, data_exp, 128);
    printf("[OUT]outData  = %s\n", outData);
    printf("[OUT]data_exp = %s\n", data_exp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptEncrypt_Test_08(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szCheckValue[16];
    int  decryptKeyIndex;
    UINT decryptMech;
    char encryptKey[64];
    UINT encryptMech;
    char data_org[1024];
    char data[1024];
    char decryptIV[32];
    char encryptIV[32];
    char outData[1024];
    char data_exp[1024];

    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(encryptKey);
    bufclr(data_org);
    bufclr(data);
    bufclr(decryptIV);
    bufclr(encryptIV);
    bufclr(outData);
    bufclr(data_exp);

    memset(encryptIV, 0x30, 32);

    decryptKeyIndex = 258;
    decryptMech = 3;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(encryptKey,
           "A2C0B0F8F7F5EE21FB5C6AEBE714E53A",
           32);
    encryptMech = 4;

    nRet = SMAPIGenerateKey(nSock, 16, "ZZZZZZZZZZ", 10, \
                            2, decryptKeyIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");
DspHexExt("bKey =", bKey, 16);
    memcpy(data_org, 
           "30424242424242424242424242424242" \
           "42424242424242424242424242424242" \
           "42424242424242424242424242424242" \
           "42424242424242424242424242424239" \
           , 128);
    nRet = SMAPIEncrypt_index(nSock, decryptKeyIndex, decryptMech, data_org, decryptIV, data);
    ASSERT_RESULT(nRet, 0, "SMAPIEncrypt_index NG");

    /* 88C77F3AA6A29E4E2031657E3848A463E263A2B0C43EF4EFA9F9C5A722A157A0EB60D8E5FC56BAB836620A7FF5404668A98DB8B683A0819B732428B22A5F4D68 */
    memcpy(data_exp, 
           "88C77F3AA6A29E4E2031657E3848A463" \
           "E263A2B0C43EF4EFA9F9C5A722A157A0" \
           "EB60D8E5FC56BAB836620A7FF5404668" \
           "A98DB8B683A0819B732428B22A5F4D68" \
           , 128);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]decryptKeyIndex = %d\n", decryptKeyIndex);
    printf("[IN ]decryptMech = %d\n", decryptMech);
    printf("[IN ]encryptKey  = %s\n", encryptKey);
    printf("[IN ]encryptMech = %d\n", encryptMech);
    printf("[IN ]data        = %s\n", data);
    printf("[IN ]decryptIV   = %s\n", decryptIV);
    printf("[IN ]encryptIV   = %s\n", encryptIV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptEncrypt(nSock, decryptKeyIndex, decryptMech, \
                               encryptKey, encryptMech, data, \
                               decryptIV, encryptIV, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "SM4_ECB转SM4_CBC测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(outData, data_exp, 128);
    printf("[OUT]outData  = %s\n", outData);
    printf("[OUT]data_exp = %s\n", data_exp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}


void Encrypt_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    char encryptKey[64];
    UINT mech;
    char data[1024];
    char IV[32];
    char outData[1024];
    char outDataExp[1024];

    bufclr(encryptKey);
    bufclr(data);
    bufclr(IV);
    bufclr(outData);
    bufclr(outDataExp);

    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(encryptKey,
           "A2C0B0F8F7F5EE21FB5C6AEBE714E53A",
           32);
    mech = 20;
    memcpy(data, "30424242424242424242424242424242"
                 "42424242424242424242424242424242"
                 "42424242424242424242424242424242"
                 "42424242424242424242424242424239"
                 , 128);
    memset(IV, '0', 16);
    memcpy(outDataExp, "C9AF9A5820243A8F322EA2FA878BC4AE"
                       "322EA2FA878BC4AE322EA2FA878BC4AE"
                       "322EA2FA878BC4AE322EA2FA878BC4AE"
                       "322EA2FA878BC4AE71AA8BE6D7CE2C1E"
                       , 128);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]encryptKey = %s\n", encryptKey);
    printf("[IN ]mech       = %d\n", mech);
    printf("[IN ]data       = %s\n", data);
    printf("[IN ]IV         = %s\n", IV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncrypt(nSock, encryptKey, mech, data, IV, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "ECB测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]outData    = %s\n", outData);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void Encrypt_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    char encryptKey[64];
    UINT mech;
    char data[1024];
    char IV[32];
    char outData[1024];
    char outDataExp[1024];

    bufclr(encryptKey);
    bufclr(data);
    bufclr(IV);
    bufclr(outData);
    bufclr(outDataExp);

    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(encryptKey,
           "A2C0B0F8F7F5EE21FB5C6AEBE714E53A",
           32);
    mech = 17;
    memcpy(data, "30424242424242424242424242424242"
                 "42424242424242424242424242424242"
                 "42424242424242424242424242424242"
                 "42424242424242424242424242424239"
                 , 128);
    memset(IV, '0', 16);
    memcpy(outDataExp, "C9AF9A5820243A8FACED8916C5EDD75A"
                       "15F05A7AB0A03B7BC77393E44B464F4D"
                       "FAF2845DD3EDCFECC4C349829CFD0F2A"
                       "CFD249005B3E6667A7D50E60FD9F0226"
                       , 128);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]encryptKey = %s\n", encryptKey);
    printf("[IN ]mech       = %d\n", mech);
    printf("[IN ]data       = %s\n", data);
    printf("[IN ]IV         = %s\n", IV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncrypt(nSock, encryptKey, mech, data, IV, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "CBC测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]outData    = %s\n", outData);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void Encrypt_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    char encryptKey[64];
    UINT mech;
    char data[1024];
    char IV[33];
    char outData[1024];
    char outDataExp[1024];

    bufclr(encryptKey);
    bufclr(data);
    bufclr(IV);
    bufclr(outData);
    bufclr(outDataExp);

    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(encryptKey,
           "A2C0B0F8F7F5EE21FB5C6AEBE714E53A",
           32);
    mech = 3;
    memcpy(data, "30424242424242424242424242424242"
                 "42424242424242424242424242424242"
                 "42424242424242424242424242424242"
                 "42424242424242424242424242424239"
                 , 128);
    memset(IV, '0', 32);
    /* 88C77F3AA6A29E4E2031657E3848A463C5F811F608BBF54F669F9D1DE7C1E6E5C5F811F608BBF54F669F9D1DE7C1E6E5822AD6A14D0A65313812078F057725B5 */
    memcpy(outDataExp, 
           "88C77F3AA6A29E4E2031657E3848A463" \
           "C5F811F608BBF54F669F9D1DE7C1E6E5" \
           "C5F811F608BBF54F669F9D1DE7C1E6E5" \
           "822AD6A14D0A65313812078F057725B5"
           , 128);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]encryptKey = %s\n", encryptKey);
    printf("[IN ]mech       = %d\n", mech);
    printf("[IN ]data       = %s\n", data);
    printf("[IN ]IV         = %s\n", IV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncrypt(nSock, encryptKey, mech, data, IV, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "SM4_ECB测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]outData    = %s\n", outData);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void Encrypt_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    char encryptKey[64];
    UINT mech;
    char data[1024];
    char IV[33];
    char outData[1024];
    char outDataExp[1024];

    bufclr(encryptKey);
    bufclr(data);
    bufclr(IV);
    bufclr(outData);
    bufclr(outDataExp);

    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(encryptKey,
           "A2C0B0F8F7F5EE21FB5C6AEBE714E53A",
           32);
    mech = 4;
    memcpy(data, "30424242424242424242424242424242"
                 "42424242424242424242424242424242"
                 "42424242424242424242424242424242"
                 "42424242424242424242424242424239"
                 , 128);
    memset(IV, '0', 32);
    /* 88C77F3AA6A29E4E2031657E3848A463E263A2B0C43EF4EFA9F9C5A722A157A0EB60D8E5FC56BAB836620A7FF5404668A98DB8B683A0819B732428B22A5F4D68 */
    memcpy(outDataExp, 
           "88C77F3AA6A29E4E2031657E3848A463" \
           "E263A2B0C43EF4EFA9F9C5A722A157A0" \
           "EB60D8E5FC56BAB836620A7FF5404668" \
           "A98DB8B683A0819B732428B22A5F4D68" \
           , 128);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]encryptKey = %s\n", encryptKey);
    printf("[IN ]mech       = %d\n", mech);
    printf("[IN ]data       = %s\n", data);
    printf("[IN ]IV         = %s\n", IV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncrypt(nSock, encryptKey, mech, data, IV, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "SM4_CBC测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]outData    = %s\n", outData);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptIndex_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szCheckValue[16];
    int  encryptKeyIndex;
    UINT mech;
    char data_tmp[1024];
    char data[1024];
    char inData[1024];
    char IV[32];
    char outData[1024];
    char outDataExp[1024];

    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(data_tmp);
    bufclr(data);
    bufclr(inData);
    bufclr(IV);
    bufclr(outData);
    bufclr(outDataExp);

    encryptKeyIndex = 258;
    mech = 20;
    memcpy(data,
           "\x30\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42" \
           "\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42" \
           "\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42" \
           "\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x39" \
           , 64);
    memcpy(inData, "30424242424242424242424242424242"
                   "42424242424242424242424242424242"
                   "42424242424242424242424242424242"
                   "42424242424242424242424242424239"
                   , 128);

    nRet = SMAPIGenerateKey(nSock, 16, "ZZZZZZZZZZ", 10, \
                            2, encryptKeyIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");

    nRet = SMAPIEncryptData(nSock, 1, 0, encryptKeyIndex, data, 64, data_tmp);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptData NG");
    SSMHexToChar(data_tmp, outDataExp, 64);

    memset(IV, '0', 16);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]encryptKeyIndex = %d\n", encryptKeyIndex);
    printf("[IN ]mech            = %d\n", mech);
    printf("[IN ]inData          = %s\n", inData);
    printf("[IN ]IV              = %s\n", IV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncrypt_index(nSock, encryptKeyIndex, mech, inData, IV, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "ECB测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]outData    = %s\n", outData);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptIndex_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szCheckValue[16];
    int  encryptKeyIndex;
    UINT mech;
    char data_tmp[1024];
    char data[1024];
    char inData[1024];
    char IV[32];
    char outData[1024];
    char outDataExp[1024];

    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(data_tmp);
    bufclr(data);
    bufclr(inData);
    bufclr(IV);
    bufclr(outData);
    bufclr(outDataExp);

    encryptKeyIndex = 258;
    mech = 17;
    memcpy(data,
           "\x30\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42" \
           "\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42" \
           "\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42" \
           "\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x39" \
           , 64);
    memcpy(inData, "30424242424242424242424242424242"
                   "42424242424242424242424242424242"
                   "42424242424242424242424242424242"
                   "42424242424242424242424242424239"
                   , 128);

    nRet = SMAPIGenerateKey(nSock, 16, "ZZZZZZZZZZ", 10, \
                            2, encryptKeyIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");

    nRet = SMAPIEncryptData(nSock, 1, 1, encryptKeyIndex, data, 64, data_tmp);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptData NG");
    SSMHexToChar(data_tmp, outDataExp, 64);

    memset(IV, '0', 16);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]encryptKeyIndex = %d\n", encryptKeyIndex);
    printf("[IN ]mech            = %d\n", mech);
    printf("[IN ]inData          = %s\n", inData);
    printf("[IN ]IV              = %s\n", IV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncrypt_index(nSock, encryptKeyIndex, mech, inData, IV, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "CBC测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]outData    = %s\n", outData);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptIndex_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szCheckValue[16];
    int  encryptKeyIndex;
    UINT mech;
    char data_tmp[1024];
    char data[1024];
    char inData[1024];
    char IV[33];
    char outData[1024];
    char outDataExp[1024];

    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(data_tmp);
    bufclr(data);
    bufclr(inData);
    bufclr(IV);
    bufclr(outData);
    bufclr(outDataExp);

    encryptKeyIndex = 258;
    mech = 3;
    memcpy(data,
           "\x30\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42" \
           "\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42" \
           "\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42" \
           "\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x39" \
           , 64);
    memcpy(inData, "30424242424242424242424242424242"
                   "42424242424242424242424242424242"
                   "42424242424242424242424242424242"
                   "42424242424242424242424242424239"
                   , 128);

    nRet = SMAPIGenerateKey(nSock, 16, "ZZZZZZZZZZ", 10, \
                            2, encryptKeyIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");

    nRet = SMAPISm4Calc(nSock, 1, 0, bKey, data, 64, IV, data_tmp);
    ASSERT_RESULT(nRet, 0, "SMAPISm4Calc NG");
    SSMHexToChar(data_tmp, outDataExp, 64);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]encryptKeyIndex = %d\n", encryptKeyIndex);
    printf("[IN ]mech            = %d\n", mech);
    printf("[IN ]inData          = %s\n", inData);
    printf("[IN ]IV              = %s\n", IV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncrypt_index(nSock, encryptKeyIndex, mech, inData, IV, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "SM4_ECB测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(outData, outDataExp, 128);
    printf("[OUT]outData    = %s\n", outData);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptIndex_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szCheckValue[16];
    int  encryptKeyIndex;
    UINT mech;
    char data_tmp[1024];
    char data[1024];
    char inData[1024];
    char IV[33];
    char outData[1024];
    char outDataExp[1024];

    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(data_tmp);
    bufclr(data);
    bufclr(inData);
    bufclr(IV);
    bufclr(outData);
    bufclr(outDataExp);

    encryptKeyIndex = 258;
    mech = 4;
    memcpy(data,
           "\x30\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42" \
           "\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42" \
           "\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42" \
           "\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x39" \
           , 64);
    memcpy(inData, "30424242424242424242424242424242"
                   "42424242424242424242424242424242"
                   "42424242424242424242424242424242"
                   "42424242424242424242424242424239"
                   , 128);

    nRet = SMAPIGenerateKey(nSock, 16, "ZZZZZZZZZZ", 10, \
                            2, encryptKeyIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");
DspHexExt("bKey =", bKey, 16);
    nRet = SMAPISm4Calc(nSock, 1, 1, bKey, data, 64, IV, data_tmp);
    ASSERT_RESULT(nRet, 0, "SMAPISm4Calc NG");
    SSMHexToChar(data_tmp, outDataExp, 64);

    memset(IV, '0', 32);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]encryptKeyIndex = %d\n", encryptKeyIndex);
    printf("[IN ]mech            = %d\n", mech);
    printf("[IN ]inData          = %s\n", inData);
    printf("[IN ]IV              = %s\n", IV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncrypt_index(nSock, encryptKeyIndex, mech, inData, IV, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "SM4_CBC测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(outData, outDataExp, 128);
    printf("[OUT]outData    = %s\n", outData);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void Decrypt_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    char DecryptKey[64];
    UINT mech;
    char data[1024];
    char IV[32];
    char outData[1024];
    char outDataExp[1024];

    bufclr(DecryptKey);
    bufclr(data);
    bufclr(IV);
    bufclr(outData);
    bufclr(outDataExp);

    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(DecryptKey,
           "A2C0B0F8F7F5EE21FB5C6AEBE714E53A",
           32);
    mech = 20;
    memcpy(data, "C9AF9A5820243A8F322EA2FA878BC4AE"
                 "322EA2FA878BC4AE322EA2FA878BC4AE"
                 "322EA2FA878BC4AE322EA2FA878BC4AE"
                 "322EA2FA878BC4AE71AA8BE6D7CE2C1E"
                 , 128);
    memset(IV, '0', 16);
    memcpy(outDataExp, "30424242424242424242424242424242"
                       "42424242424242424242424242424242"
                       "42424242424242424242424242424242"
                       "42424242424242424242424242424239"
                       , 128);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]DecryptKey = %s\n", DecryptKey);
    printf("[IN ]mech       = %d\n", mech);
    printf("[IN ]data       = %s\n", data);
    printf("[IN ]IV         = %s\n", IV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecrypt(nSock, DecryptKey, mech, data, IV, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "ECB测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]outData    = %s\n", outData);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    ASSERT_OUT_HEX(outData, outDataExp, 128);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void Decrypt_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    char DecryptKey[64];
    UINT mech;
    char data[1024];
    char IV[32];
    char outData[1024];
    char outDataExp[1024];

    bufclr(DecryptKey);
    bufclr(data);
    bufclr(IV);
    bufclr(outData);
    bufclr(outDataExp);

    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(DecryptKey,
           "A2C0B0F8F7F5EE21FB5C6AEBE714E53A",
           32);
    mech = 17;
    memcpy(data, "C9AF9A5820243A8FACED8916C5EDD75A"
                 "15F05A7AB0A03B7BC77393E44B464F4D"
                 "FAF2845DD3EDCFECC4C349829CFD0F2A"
                 "CFD249005B3E6667A7D50E60FD9F0226"
                 , 128);
    memset(IV, '0', 16);
    memcpy(outDataExp, "30424242424242424242424242424242"
                       "42424242424242424242424242424242"
                       "42424242424242424242424242424242"
                       "42424242424242424242424242424239"
                       , 128);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]DecryptKey = %s\n", DecryptKey);
    printf("[IN ]mech       = %d\n", mech);
    printf("[IN ]data       = %s\n", data);
    printf("[IN ]IV         = %s\n", IV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecrypt(nSock, DecryptKey, mech, data, IV, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "CBC测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]outData    = %s\n", outData);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    ASSERT_OUT_HEX(outData, outDataExp, 128);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void Decrypt_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    char DecryptKey[64];
    UINT mech;
    char data[1024];
    char IV[33];
    char outData[1024];
    char outDataExp[1024];

    bufclr(DecryptKey);
    bufclr(data);
    bufclr(IV);
    bufclr(outData);
    bufclr(outDataExp);

    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(DecryptKey,
           "A2C0B0F8F7F5EE21FB5C6AEBE714E53A",
           32);
    mech = 3;
    memcpy(data,
           "88C77F3AA6A29E4E2031657E3848A463" \
           "C5F811F608BBF54F669F9D1DE7C1E6E5" \
           "C5F811F608BBF54F669F9D1DE7C1E6E5" \
           "822AD6A14D0A65313812078F057725B5"
           , 128);
    memset(IV, '0', 32);
    memcpy(outDataExp, "30424242424242424242424242424242"
                       "42424242424242424242424242424242"
                       "42424242424242424242424242424242"
                       "42424242424242424242424242424239"
                       , 128);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]DecryptKey = %s\n", DecryptKey);
    printf("[IN ]mech       = %d\n", mech);
    printf("[IN ]data       = %s\n", data);
    printf("[IN ]IV         = %s\n", IV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecrypt(nSock, DecryptKey, mech, data, IV, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "SM4_ECB测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]outData    = %s\n", outData);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    ASSERT_OUT_HEX(outData, outDataExp, 128);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void Decrypt_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    char DecryptKey[64];
    UINT mech;
    char data[1024];
    char IV[33];
    char outData[1024];
    char outDataExp[1024];

    bufclr(DecryptKey);
    bufclr(data);
    bufclr(IV);
    bufclr(outData);
    bufclr(outDataExp);

    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(DecryptKey,
           "A2C0B0F8F7F5EE21FB5C6AEBE714E53A",
           32);
    mech = 4;
    memcpy(data,
           "88C77F3AA6A29E4E2031657E3848A463" \
           "E263A2B0C43EF4EFA9F9C5A722A157A0" \
           "EB60D8E5FC56BAB836620A7FF5404668" \
           "A98DB8B683A0819B732428B22A5F4D68" \
           , 128);
    memset(IV, '0', 32);
    memcpy(outDataExp, "30424242424242424242424242424242"
                       "42424242424242424242424242424242"
                       "42424242424242424242424242424242"
                       "42424242424242424242424242424239"
                       , 128);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]DecryptKey = %s\n", DecryptKey);
    printf("[IN ]mech       = %d\n", mech);
    printf("[IN ]data       = %s\n", data);
    printf("[IN ]IV         = %s\n", IV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecrypt(nSock, DecryptKey, mech, data, IV, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "SM4_CBC测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]outData    = %s\n", outData);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    ASSERT_OUT_HEX(outData, outDataExp, 128);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptIndex_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szCheckValue[16];
    int  DecryptKeyIndex;
    UINT mech;
    char data_tmp[1024];
    char data[1024];
    char inData[1024];
    char IV[32];
    char outData[1024];
    char outDataExp[1024];

    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(data_tmp);
    bufclr(data);
    bufclr(inData);
    bufclr(IV);
    bufclr(outData);
    bufclr(outDataExp);

    DecryptKeyIndex = 258;
    mech = 20;
    memcpy(data,
           "\x30\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42" \
           "\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42" \
           "\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42" \
           "\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x39" \
           , 64);
    memcpy(inData, "30424242424242424242424242424242"
                   "42424242424242424242424242424242"
                   "42424242424242424242424242424242"
                   "42424242424242424242424242424239"
                   , 128);

    nRet = SMAPIGenerateKey(nSock, 16, "ZZZZZZZZZZ", 10, \
                            2, DecryptKeyIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");

    nRet = SMAPIEncryptData(nSock, 0, 0, DecryptKeyIndex, data, 64, data_tmp);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptData NG");
    SSMHexToChar(data_tmp, outDataExp, 64);

    memset(IV, '0', 16);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]DecryptKeyIndex = %d\n", DecryptKeyIndex);
    printf("[IN ]mech            = %d\n", mech);
    printf("[IN ]inData          = %s\n", inData);
    printf("[IN ]IV              = %s\n", IV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecrypt_index(nSock, DecryptKeyIndex, mech, inData, IV, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "ECB测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]outData    = %s\n", outData);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    ASSERT_OUT_HEX(outData, outDataExp, 128);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptIndex_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szCheckValue[16];
    int  DecryptKeyIndex;
    UINT mech;
    char data_tmp[1024];
    char data[1024];
    char inData[1024];
    char IV[32];
    char outData[1024];
    char outDataExp[1024];

    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(data_tmp);
    bufclr(data);
    bufclr(inData);
    bufclr(IV);
    bufclr(outData);
    bufclr(outDataExp);

    DecryptKeyIndex = 258;
    mech = 17;
    memcpy(data,
           "\x30\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42" \
           "\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42" \
           "\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42" \
           "\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x39" \
           , 64);
    memcpy(inData, "30424242424242424242424242424242"
                   "42424242424242424242424242424242"
                   "42424242424242424242424242424242"
                   "42424242424242424242424242424239"
                   , 128);

    nRet = SMAPIGenerateKey(nSock, 16, "ZZZZZZZZZZ", 10, \
                            2, DecryptKeyIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");

    nRet = SMAPIEncryptData(nSock, 0, 1, DecryptKeyIndex, data, 64, data_tmp);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptData NG");
    SSMHexToChar(data_tmp, outDataExp, 64);

    memset(IV, '0', 16);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]DecryptKeyIndex = %d\n", DecryptKeyIndex);
    printf("[IN ]mech            = %d\n", mech);
    printf("[IN ]inData          = %s\n", inData);
    printf("[IN ]IV              = %s\n", IV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecrypt_index(nSock, DecryptKeyIndex, mech, inData, IV, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "CBC测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]outData    = %s\n", outData);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    ASSERT_OUT_HEX(outData, outDataExp, 128);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptIndex_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szCheckValue[16];
    int  DecryptKeyIndex;
    UINT mech;
    char data_tmp[1024];
    char data[1024];
    char inData[1024];
    char IV[33];
    char outData[1024];
    char outDataExp[1024];

    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(data_tmp);
    bufclr(data);
    bufclr(inData);
    bufclr(IV);
    bufclr(outData);
    bufclr(outDataExp);

    DecryptKeyIndex = 258;
    mech = 3;
    memcpy(data,
           "\x30\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42" \
           "\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42" \
           "\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42" \
           "\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x39" \
           , 64);
    memcpy(inData, "30424242424242424242424242424242"
                   "42424242424242424242424242424242"
                   "42424242424242424242424242424242"
                   "42424242424242424242424242424239"
                   , 128);

    nRet = SMAPIGenerateKey(nSock, 16, "ZZZZZZZZZZ", 10, \
                            2, DecryptKeyIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");
DspHexExt("bKey =", bKey, 16);
    nRet = SMAPISm4Calc(nSock, 0, 0, bKey, data, 64, IV, data_tmp);
    ASSERT_RESULT(nRet, 0, "SMAPISm4Calc NG");
    SSMHexToChar(data_tmp, outDataExp, 64);

    memset(IV, '0', 32);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]DecryptKeyIndex = %d\n", DecryptKeyIndex);
    printf("[IN ]mech            = %d\n", mech);
    printf("[IN ]inData          = %s\n", inData);
    printf("[IN ]IV              = %s\n", IV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecrypt_index(nSock, DecryptKeyIndex, mech, inData, IV, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "SM4_ECB测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]outData    = %s\n", outData);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    ASSERT_OUT_HEX(outData, outDataExp, 128);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptIndex_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szCheckValue[16];
    int  DecryptKeyIndex;
    UINT mech;
    char data_tmp[1024];
    char data[1024];
    char inData[1024];
    char IV[33];
    char outData[1024];
    char outDataExp[1024];

    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(data_tmp);
    bufclr(data);
    bufclr(inData);
    bufclr(IV);
    bufclr(outData);
    bufclr(outDataExp);

    DecryptKeyIndex = 258;
    mech = 4;
    memcpy(data,
           "\x30\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42" \
           "\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42" \
           "\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42" \
           "\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x42\x39" \
           , 64);
    memcpy(inData, "30424242424242424242424242424242"
                   "42424242424242424242424242424242"
                   "42424242424242424242424242424242"
                   "42424242424242424242424242424239"
                   , 128);

    nRet = SMAPIGenerateKey(nSock, 16, "ZZZZZZZZZZ", 10, \
                            2, DecryptKeyIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");
DspHexExt("bKey =", bKey, 16);
    nRet = SMAPISm4Calc(nSock, 0, 1, bKey, data, 64, IV, data_tmp);
    ASSERT_RESULT(nRet, 0, "SMAPISm4Calc NG");
    SSMHexToChar(data_tmp, outDataExp, 64);

    memset(IV, '0', 32);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]DecryptKeyIndex = %d\n", DecryptKeyIndex);
    printf("[IN ]mech            = %d\n", mech);
    printf("[IN ]inData          = %s\n", inData);
    printf("[IN ]IV              = %s\n", IV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecrypt_index(nSock, DecryptKeyIndex, mech, inData, IV, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "SM4_CBC测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]outData    = %s\n", outData);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    ASSERT_OUT_HEX(outData, outDataExp, 128);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DeriveKey_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    char masterKey[64];
    UINT mech;
    char divdata[128];
    char IV[32];
    char derivedKey[128];
    char outDataExp[128];

    bufclr(masterKey);
    bufclr(divdata);
    bufclr(IV);
    bufclr(derivedKey);
    bufclr(outDataExp);

    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(masterKey, "A2C0B0F8F7F5EE21FB5C6AEBE714E53A", 32);
    mech = 20;
    memcpy(divdata, "0123456789ABF001CDEFFEDCBA980F01", 32);
    memset(IV, '0', 16);
    /* 4103248290BA8439884DE503EDF390C9 */
    memcpy(outDataExp, "9C2BEDCF6B7569D37155C5063F2337E9", 32);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]masterKey = %s\n", masterKey);
    printf("[IN ]mech      = %d\n", mech);
    printf("[IN ]divdata   = %s\n", divdata);
    printf("[IN ]IV        = %s\n", IV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIderiveKey(nSock, masterKey, mech, divdata, IV, derivedKey);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "ECB测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]derivedKey = %s\n", derivedKey);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    ASSERT_OUT_HEX(derivedKey, outDataExp, 32);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DeriveKey_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    char masterKey[64];
    UINT mech;
    char divdata[128];
    char IV[32];
    char derivedKey[128];
    char outDataExp[128];

    bufclr(masterKey);
    bufclr(divdata);
    bufclr(IV);
    bufclr(derivedKey);
    bufclr(outDataExp);

    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(masterKey, "A2C0B0F8F7F5EE21FB5C6AEBE714E53A", 32);
    mech = 17;
    memcpy(divdata, "0123456789ABF001CDEFFEDCBA980F01", 32);
    memset(IV, '0', 16);
    /* 4103248290BA84391D327EF0341ABEC2 */
    memcpy(outDataExp, "9C2BEDCF6B7569D3ADC89F18CF58119F", 32);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]masterKey = %s\n", masterKey);
    printf("[IN ]mech      = %d\n", mech);
    printf("[IN ]divdata   = %s\n", divdata);
    printf("[IN ]IV        = %s\n", IV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIderiveKey(nSock, masterKey, mech, divdata, IV, derivedKey);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "CBC测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]derivedKey = %s\n", derivedKey);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DeriveKey_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    char masterKey[64];
    UINT mech;
    char divdata[128];
    char IV[33];
    char derivedKey[128];
    char outDataExp[128];

    bufclr(masterKey);
    bufclr(divdata);
    bufclr(IV);
    bufclr(derivedKey);
    bufclr(outDataExp);

    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(masterKey, "A2C0B0F8F7F5EE21FB5C6AEBE714E53A", 32);
    mech = 3;
    memcpy(divdata, "0123456789ABF001CDEFFEDCBA980F010123456789ABF001CDEFFEDCBA980F01", 64);
    memset(IV, '0', 32);
    /* 1A4964D4943A036833DEEC1C9E94AD6E1A4964D4943A036833DEEC1C9E94AD6E */
    memcpy(outDataExp, "82A7EAD25706A76BB7EDBAE51B2FD96A82A7EAD25706A76BB7EDBAE51B2FD96A", 64);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]masterKey = %s\n", masterKey);
    printf("[IN ]mech      = %d\n", mech);
    printf("[IN ]divdata   = %s\n", divdata);
    printf("[IN ]IV        = %s\n", IV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIderiveKey(nSock, masterKey, mech, divdata, IV, derivedKey);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "SM4_ECB测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]derivedKey = %s\n", derivedKey);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DeriveKey_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    char masterKey[64];
    UINT mech;
    char divdata[128];
    char IV[33];
    char derivedKey[128];
    char outDataExp[128];

    bufclr(masterKey);
    bufclr(divdata);
    bufclr(IV);
    bufclr(derivedKey);
    bufclr(outDataExp);

    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(masterKey, "A2C0B0F8F7F5EE21FB5C6AEBE714E53A", 32);
    mech = 4;
    memcpy(divdata, "0123456789ABF001CDEFFEDCBA980F010123456789ABF001CDEFFEDCBA980F01", 64);
    memset(IV, '0', 32);
    /* 1A4964D4943A036833DEEC1C9E94AD6E856193B9EF3592CE790924CF8074978C */
    memcpy(outDataExp, "82A7EAD25706A76BB7EDBAE51B2FD96AD5A71E3376BA9F2273813B17D84739C3", 64);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]masterKey = %s\n", masterKey);
    printf("[IN ]mech      = %d\n", mech);
    printf("[IN ]divdata   = %s\n", divdata);
    printf("[IN ]IV        = %s\n", IV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIderiveKey(nSock, masterKey, mech, divdata, IV, derivedKey);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "SM4_CBC测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]derivedKey = %s\n", derivedKey);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DeriveKeyIndex_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szCheckValue[16];
    int  masterKeyIndex;
    UINT mech;
    char divdata[128];
    char data[128];
    char IV[32];
    char derivedKey[128];
    char outDataTmp[128];
    char outDataExp[128];

    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(divdata);
    bufclr(data);
    bufclr(IV);
    bufclr(derivedKey);
    bufclr(outDataTmp);
    bufclr(outDataExp);

    masterKeyIndex = 444;
    mech = 20;

    memcpy(data, "\x01\x23\x45\x67\x89\xAB\xF0\x01\xCD\xEF\xFE\xDC\xBA\x98\x0F\x01", 16);
    nRet = SMAPIGenerateKey(nSock, 16, "ZZZZZZZZZZ", 10, \
                            2, masterKeyIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");

    nRet = SMAPIEncryptData(nSock, 1, 0, masterKeyIndex, data, 16, outDataExp);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptData NG");

    SSMMakeOddBinStr_Test(outDataTmp, 16);
    nRet = SMAPIEncryptKey(nSock, outDataExp, 16, outDataTmp);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptKey NG");

    SSMHexToChar(outDataTmp, outDataExp, 16);

    memcpy(divdata, "0123456789ABF001CDEFFEDCBA980F01", 32);
    memset(IV, '0', 16);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]masterKeyIndex = %d\n", masterKeyIndex);
    printf("[IN ]mech           = %d\n", mech);
    printf("[IN ]divdata        = %s\n", divdata);
    printf("[IN ]IV             = %s\n", IV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIderiveKey_index(nSock, masterKeyIndex, mech, divdata, IV, derivedKey);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "ECB测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]derivedKey = %s\n", derivedKey);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DeriveKeyIndex_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szCheckValue[16];
    int  masterKeyIndex;
    UINT mech;
    char divdata[128];
    char data[128];
    char IV[32];
    char derivedKey[128];
    char outDataTmp[128];
    char outDataExp[128];

    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(divdata);
    bufclr(data);
    bufclr(IV);
    bufclr(derivedKey);
    bufclr(outDataTmp);
    bufclr(outDataExp);

    masterKeyIndex = 444;
    mech = 17;

    memcpy(data, "\x01\x23\x45\x67\x89\xAB\xF0\x01\xCD\xEF\xFE\xDC\xBA\x98\x0F\x01", 16);
    nRet = SMAPIGenerateKey(nSock, 16, "ZZZZZZZZZZ", 10, \
                            2, masterKeyIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");

    nRet = SMAPIEncryptData(nSock, 1, 1, masterKeyIndex, data, 16, outDataExp);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptData NG");

    SSMMakeOddBinStr_Test(outDataTmp, 16);
    nRet = SMAPIEncryptKey(nSock, outDataExp, 16, outDataTmp);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptKey NG");

    SSMHexToChar(outDataTmp, outDataExp, 16);

    memcpy(divdata, "0123456789ABF001CDEFFEDCBA980F01", 32);
    memset(IV, '0', 16);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]masterKeyIndex = %d\n", masterKeyIndex);
    printf("[IN ]mech           = %d\n", mech);
    printf("[IN ]divdata        = %s\n", divdata);
    printf("[IN ]IV             = %s\n", IV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIderiveKey_index(nSock, masterKeyIndex, mech, divdata, IV, derivedKey);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "CBC测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]derivedKey = %s\n", derivedKey);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DeriveKeyIndex_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szCheckValue[16];
    int  masterKeyIndex;
    UINT mech;
    char divdata[128];
    char data[128];
    char IV[33];
    char derivedKey[128];
    char outDataTmp[128];
    char outDataExp[128];

    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(divdata);
    bufclr(data);
    bufclr(IV);
    bufclr(derivedKey);
    bufclr(outDataTmp);
    bufclr(outDataExp);

    masterKeyIndex = 444;
    mech = 3;

    memcpy(data, 
           "\x01\x23\x45\x67\x89\xAB\xF0\x01\xCD\xEF\xFE\xDC\xBA\x98\x0F\x01"
           , 16);
    nRet = SMAPIGenerateKey(nSock, 16, "ZZZZZZZZZZ", 10, \
                            2, masterKeyIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");

    nRet = SMAPISm4Calc(nSock, 1, 0, bKey, data, 16, IV, outDataExp);
    ASSERT_RESULT(nRet, 0, "SMAPISm4Calc NG");

    nRet = SMAPIEncryptKey(nSock, outDataExp, 16, outDataTmp);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptKey NG");

    SSMHexToChar(outDataTmp, outDataExp, 16);

    memcpy(divdata, "0123456789ABF001CDEFFEDCBA980F01", 32);
    memset(IV, '0', 32);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]masterKeyIndex = %d\n", masterKeyIndex);
    printf("[IN ]mech           = %d\n", mech);
    printf("[IN ]divdata        = %s\n", divdata);
    printf("[IN ]IV             = %s\n", IV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIderiveKey_index(nSock, masterKeyIndex, mech, divdata, IV, derivedKey);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "SM4_ECB测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]derivedKey = %s\n", derivedKey);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DeriveKeyIndex_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szCheckValue[16];
    int  masterKeyIndex;
    UINT mech;
    char divdata[128];
    char data[128];
    char IV[33];
    char derivedKey[128];
    char outDataTmp[128];
    char outDataExp[128];

    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(divdata);
    bufclr(data);
    bufclr(IV);
    bufclr(derivedKey);
    bufclr(outDataTmp);
    bufclr(outDataExp);

    masterKeyIndex = 444;
    mech = 4;

    memcpy(data, 
           "\x01\x23\x45\x67\x89\xAB\xF0\x01\xCD\xEF\xFE\xDC\xBA\x98\x0F\x01"
           "\x01\x23\x45\x67\x89\xAB\xF0\x01\xCD\xEF\xFE\xDC\xBA\x98\x0F\x01"
           , 32);
    nRet = SMAPIGenerateKey(nSock, 16, "ZZZZZZZZZZ", 10, \
                            2, masterKeyIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");

    nRet = SMAPISm4Calc(nSock, 1, 1, bKey, data, 32, IV, outDataExp);
    ASSERT_RESULT(nRet, 0, "SMAPISm4Calc NG");

    nRet = SMAPIEncryptKey(nSock, outDataExp, 16, outDataTmp);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptKey NG");

    nRet = SMAPIEncryptKey(nSock, &outDataExp[16], 16, &outDataTmp[16]);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptKey NG");

    SSMHexToChar(outDataTmp, outDataExp, 32);

    memcpy(divdata, "0123456789ABF001CDEFFEDCBA980F010123456789ABF001CDEFFEDCBA980F01", 64);
    memset(IV, '0', 32);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]masterKeyIndex = %d\n", masterKeyIndex);
    printf("[IN ]mech           = %d\n", mech);
    printf("[IN ]divdata        = %s\n", divdata);
    printf("[IN ]IV             = %s\n", IV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIderiveKey_index(nSock, masterKeyIndex, mech, divdata, IV, derivedKey);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "SM4_CBC测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]derivedKey = %s\n", derivedKey);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenerateRandom_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  rdmLength;
    char outData[1024];

    bufclr(outData);

    rdmLength = 31;

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]rdmLength = %d\n", rdmLength);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenerateRandom(nSock, rdmLength, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "产生31位随机数测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]outData    = %s\n", outData);
    ASSERT_OUT(strlen(outData), 62);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void Wrap_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    char wrapKey[64];
    UINT mech;
    char key[1024];
    char IV[32];
    char outData[1024];
    char outDataExp[1024];

    bufclr(wrapKey);
    bufclr(key);
    bufclr(IV);
    bufclr(outData);
    bufclr(outDataExp);

    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(wrapKey, "A2C0B0F8F7F5EE21FB5C6AEBE714E53A", 32);
    mech = 20;
    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(key, "FB5C6AEBE714E53AA2C0B0F8F7F5EE21", 32);
    memset(IV, '0', 16);
    memcpy(outDataExp, "1FD1B02B237AF9AE1A4D672DCA6CB335", 32);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]encryptKey = %s\n", wrapKey);
    printf("[IN ]mech       = %d\n", mech);
    printf("[IN ]key        = %s\n", key);
    printf("[IN ]IV         = %s\n", IV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIwrap(nSock, wrapKey, mech, key, IV, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "ECB测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]outData    = %s\n", outData);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void Wrap_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    char wrapKey[64];
    UINT mech;
    char key[1024];
    char IV[32];
    char outData[1024];
    char outDataExp[1024];

    bufclr(wrapKey);
    bufclr(key);
    bufclr(IV);
    bufclr(outData);
    bufclr(outDataExp);

    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(wrapKey, "A2C0B0F8F7F5EE21FB5C6AEBE714E53A", 32);
    mech = 17;
    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(key, "FB5C6AEBE714E53AA2C0B0F8F7F5EE21", 32);
    memset(IV, '0', 16);
    memcpy(outDataExp, "1FD1B02B237AF9AE3702240E7080EA4C", 32);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]encryptKey = %s\n", wrapKey);
    printf("[IN ]mech       = %d\n", mech);
    printf("[IN ]key        = %s\n", key);
    printf("[IN ]IV         = %s\n", IV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIwrap(nSock, wrapKey, mech, key, IV, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "CBC测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]outData    = %s\n", outData);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void WrapIndex_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

/////////////////////////////////////////////
    BYTE bKey[32];
    char szCheckValue[16];
    int  masterKeyIndex;
    UINT mech;
    char data[128];
    char IV[32];
    char key[64];
    char outDataTmp[128];
    char outDataExp[128];
    char outData[1024];

    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(data);
    bufclr(IV);
    bufclr(key);
    bufclr(outDataTmp);
    bufclr(outDataExp);
    bufclr(outData);

    masterKeyIndex = 444;
    mech = 20;

    memcpy(data, "\x01\x23\x45\x67\x89\xAB\xF0\x01\xCD\xEF\xFE\xDC\xBA\x98\x0F\x01", 16);
    SSMMakeOddBinStr_Test(data, 16);
    nRet = SMAPIGenerateKey(nSock, 16, "ZZZZZZZZZZ", 10, \
                            2, masterKeyIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");

    nRet = SMAPIEncryptData(nSock, 1, 0, masterKeyIndex, data, 16, outDataTmp);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptData NG");

    SSMHexToChar(outDataTmp, outDataExp, 16);

    nRet = SMAPIEncryptKey(nSock, data, 16, outDataTmp);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptKey NG");
    SSMHexToChar(outDataTmp, key, 16);
///////////////////////////////

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]index = %d\n", masterKeyIndex);
    printf("[IN ]mech  = %d\n", mech);
    printf("[IN ]key   = %s\n", key);
    printf("[IN ]IV    = %s\n", IV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIwrap_index(nSock, masterKeyIndex, mech, key, IV, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "ECB测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]outData    = %s\n", outData);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void WrapIndex_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

/////////////////////////////////////////////
    BYTE bKey[32];
    char szCheckValue[16];
    int  masterKeyIndex;
    UINT mech;
    char data[128];
    char IV[32];
    char key[64];
    char outDataTmp[128];
    char outDataExp[128];
    char outData[1024];

    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(data);
    bufclr(IV);
    bufclr(key);
    bufclr(outDataTmp);
    bufclr(outDataExp);
    bufclr(outData);

    masterKeyIndex = 444;
    mech = 17;
    
    memset(IV, '0', 16);

    memcpy(data, "\x01\x23\x45\x67\x89\xAB\xF0\x01\xCD\xEF\xFE\xDC\xBA\x98\x0F\x01", 16);
    SSMMakeOddBinStr_Test(data, 16);
    nRet = SMAPIGenerateKey(nSock, 16, "ZZZZZZZZZZ", 10, \
                            2, masterKeyIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");

    nRet = SMAPIEncryptData(nSock, 1, 1, masterKeyIndex, data, 16, outDataTmp);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptData NG");

    SSMHexToChar(outDataTmp, outDataExp, 16);

    nRet = SMAPIEncryptKey(nSock, data, 16, outDataTmp);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptKey NG");
    SSMHexToChar(outDataTmp, key, 16);
///////////////////////////////

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]index = %d\n", masterKeyIndex);
    printf("[IN ]mech  = %d\n", mech);
    printf("[IN ]key   = %s\n", key);
    printf("[IN ]IV    = %s\n", IV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIwrap_index(nSock, masterKeyIndex, mech, key, IV, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "CBC测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]outData    = %s\n", outData);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PBOCMAC_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    char macKey[64];
    UINT mech;
    char data[1024];
    char IV[32];
    char outData[1024];
    char outDataExp[1024];

    bufclr(macKey);
    bufclr(data);
    bufclr(IV);
    bufclr(outData);
    bufclr(outDataExp);

    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(macKey, "A2C0B0F8F7F5EE21FB5C6AEBE714E53A", 32);
    mech = 1;

    memcpy(data, "FB5C6AEBE714E53AA2C0B0F8F7F5EE21", 32);
    memset(IV, '0', 16);
    /* B961 CDDD 0FFA 31DD */
    memcpy(outDataExp, "B961CDDD0FFA31DD", 16);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]encryptKey = %s\n", macKey);
    printf("[IN ]mech       = %d\n", mech);
    printf("[IN ]key        = %s\n", data);
    printf("[IN ]IV         = %s\n", IV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPBOCMAC(nSock, macKey, mech, data, IV, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "X9.19测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]outData    = %s\n", outData);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PBOCMAC_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    char macKey[64];
    UINT mech;
    char data[1024];
    char IV[32];
    char outData[1024];
    char outDataExp[1024];

    bufclr(macKey);
    bufclr(data);
    bufclr(IV);
    bufclr(outData);
    bufclr(outDataExp);

    /* 0123 4567 89AB CDEF */
    memcpy(macKey, "A2C0B0F8F7F5EE21", 16);
    mech = 2;

    memcpy(data, "FB5C6AEBE714E53AA2C0B0F8F7F5EE21", 32);
    memset(IV, '0', 16);
    /* A093 169B ECAE AD38 */
    memcpy(outDataExp, "A093169BECAEAD38", 16);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]encryptKey = %s\n", macKey);
    printf("[IN ]mech       = %d\n", mech);
    printf("[IN ]key        = %s\n", data);
    printf("[IN ]IV         = %s\n", IV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPBOCMAC(nSock, macKey, mech, data, IV, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "X9.9测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]outData    = %s\n", outData);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PBOCMAC_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    char macKey[64];
    UINT mech;
    char data[1024];
    char IV[33];
    char outData[1024];
    char outDataExp[1024];

    bufclr(macKey);
    bufclr(data);
    bufclr(IV);
    bufclr(outData);
    bufclr(outDataExp);

    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(macKey, "A2C0B0F8F7F5EE21FB5C6AEBE714E53A", 32);
    mech = 3;

    memcpy(data, "B8C833FC470446C9C2B694CAF675E3882AED6A93BF279B07E0675269588B", 60);
    memset(IV, '0', 32);
    /* 1C99169517F7E2A8C67C077BFECC8117D0366BF3D7C588907E4C12BE3BF0824D */
    memcpy(outDataExp, "D0366BF3D7C588907E4C12BE3BF0824D", 32);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]encryptKey = %s\n", macKey);
    printf("[IN ]mech       = %d\n", mech);
    printf("[IN ]key        = %s\n", data);
    printf("[IN ]IV         = %s\n", IV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPBOCMAC(nSock, macKey, mech, data, IV, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "PBOC MAC SM4测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]outData    = %s\n", outData);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PBOCMACIndex_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

/////////////////////////////////////////////
    BYTE bKey[32];
    char szCheckValue[16];
    int  masterKeyIndex;
    UINT mech;
    char data[128];
    char IV[32];
    char key[64];
    char outDataTmp[128];
    char outDataExp[128];
    char outData[1024];

    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(data);
    bufclr(IV);
    bufclr(key);
    bufclr(outDataTmp);
    bufclr(outDataExp);
    bufclr(outData);

    masterKeyIndex = 444;
    mech = 1;
    memset(IV, '0', 16);

    memcpy(data, "\x01\x23\x45\x67\x89\xAB\xF0\x01" \
                 "\xCD\xEF\xFE\xDC\xBA\x98\x0F\x01" \
                 "\x80\x00\x00\x00\x00\x00\x00\x00", 24);
    nRet = SMAPIGenerateKey(nSock, 16, "ZZZZZZZZZZ", 10, \
                            2, masterKeyIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");

    nRet = SMAPICalcMac(nSock, 3, bKey, 16, data, 24, outDataTmp);
    ASSERT_RESULT(nRet, 0, "SMAPICalcMac NG");

    SSMHexToChar(outDataTmp, outDataExp, 8);

    SSMHexToChar(data, outDataTmp, 16);
///////////////////////////////

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]index = %d\n", masterKeyIndex);
    printf("[IN ]mech  = %d\n", mech);
    printf("[IN ]data  = %s\n", outDataTmp);
    printf("[IN ]IV    = %s\n", IV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPBOCMAC_index(nSock, masterKeyIndex, mech, outDataTmp, IV, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "X9.9测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(outData, outDataExp, 16);
    printf("[OUT]outData    = %s\n", outData);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PBOCMACIndex_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

/////////////////////////////////////////////
    BYTE bKey[32];
    char szCheckValue[16];
    int  masterKeyIndex;
    UINT mech;
    char data[128];
    char IV[32];
    char key[64];
    char outDataTmp[128];
    char outDataExp[128];
    char outData[1024];

    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(data);
    bufclr(IV);
    bufclr(key);
    bufclr(outDataTmp);
    bufclr(outDataExp);
    bufclr(outData);

    masterKeyIndex = 444;
    mech = 2;
    memset(IV, '0', 16);

    memcpy(data, "\x01\x23\x45\x67\x89\xAB\xF0\x01" \
                 "\xCD\xEF\xFE\xDC\xBA\x98\x0F\x01" \
                 "\x80\x00\x00\x00\x00\x00\x00\x00", 24);
    nRet = SMAPIGenerateKey(nSock, 8, "ZZZZZZZZZZ", 10, \
                            2, masterKeyIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");
    DspHex("bKey =", bKey, 8);

    nRet = SMAPICalcMac(nSock, 2, bKey, 8, data, 24, outDataTmp);
    ASSERT_RESULT(nRet, 0, "SMAPICalcMac NG");

    SSMHexToChar(outDataTmp, outDataExp, 8);

    SSMHexToChar(data, outDataTmp, 16);
///////////////////////////////

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]index = %d\n", masterKeyIndex);
    printf("[IN ]mech  = %d\n", mech);
    printf("[IN ]data  = %s\n", outDataTmp);
    printf("[IN ]IV    = %s\n", IV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPBOCMAC_index(nSock, masterKeyIndex, mech, outDataTmp, IV, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "X9.19测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(outData, outDataExp, 16);
    printf("[OUT]outData    = %s\n", outData);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PBOCMACIndex_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

/////////////////////////////////////////////
    BYTE bKey[32];
    char szCheckValue[16];
    int  masterKeyIndex;
    UINT mech;
    char data[128];
    char IV[33];
    char key[64];
    char outDataTmp[128];
    char outDataExp[128];
    char outData[1024];

    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(data);
    bufclr(IV);
    bufclr(key);
    bufclr(outDataTmp);
    bufclr(outDataExp);
    bufclr(outData);

    masterKeyIndex = 444;
    mech = 3;
    memset(IV, '0', 32);

    memcpy(data, "B8C833FC470446C9C2B694CAF675E3882AED6A93BF279B07E0675269588B", 62);
    nRet = SMAPIGenerateKey(nSock, 16, "ZZZZZZZZZZ", 10, \
                            2, masterKeyIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");
DspHexExt("bKey =", bKey, 16);
    SSMHexToChar(bKey, outDataTmp, 16);


    nRet = SMAPIPBOCMAC(nSock, outDataTmp, mech, data, IV, outDataExp);
    ASSERT_RESULT(nRet, 0, "SMAPIPBOCMAC NG");

///////////////////////////////

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]index = %d\n", masterKeyIndex);
    printf("[IN ]mech  = %d\n", mech);
    printf("[IN ]data  = %s\n", data);
    printf("[IN ]IV    = %s\n", IV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPBOCMAC_index(nSock, masterKeyIndex, mech, data, IV, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "PBOC MAC SM4测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(outData, outDataExp, 32);
    printf("[OUT]outData    = %s\n", outData);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void WrapEnhance_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    char wrapKey[64];
    UINT mech;
    char key[1024];
    char IV[32];
    char outData[1024];
    char outDataExp[1024];
    char prePix[64];

    bufclr(wrapKey);
    bufclr(key);
    bufclr(IV);
    bufclr(outData);
    bufclr(outDataExp);
    bufclr(prePix);

    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(wrapKey, "A2C0B0F8F7F5EE21FB5C6AEBE714E53A", 32);
    mech = 20;
    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(key, "FB5C6AEBE714E53AA2C0B0F8F7F5EE21", 32);
    memset(IV, '0', 16);
    memcpy(prePix, "0987654321", 10);
    /* 15 0987654321 FEDCBA98765432100123456789ABCDEF 8000*/
    memcpy(outDataExp, "344ECA0E117EE934942211E4290682DBB1092A25993BD5C6", 48);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]encryptKey = %s\n", wrapKey);
    printf("[IN ]mech       = %d\n", mech);
    printf("[IN ]key        = %s\n", key);
    printf("[IN ]IV         = %s\n", IV);
    printf("[IN ]prePix     = %s\n", prePix);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIwrapEnhance(nSock, wrapKey, mech, key, IV, prePix, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "ECB测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]outData    = %s\n", outData);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void WrapEnhance_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    char wrapKey[64];
    UINT mech;
    char key[1024];
    char IV[32];
    char outData[1024];
    char outDataExp[1024];
    char prePix[64];

    bufclr(wrapKey);
    bufclr(key);
    bufclr(IV);
    bufclr(outData);
    bufclr(outDataExp);
    bufclr(prePix);

    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(wrapKey, "A2C0B0F8F7F5EE21FB5C6AEBE714E53A", 32);
    mech = 17;
    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(key, "FB5C6AEBE714E53AA2C0B0F8F7F5EE21", 32);
    memset(IV, '0', 16);
    memcpy(prePix, "0987654321", 10);
    /* 15 0987654321 FEDCBA98765432100123456789ABCDEF 8000*/
    memcpy(outDataExp, "344ECA0E117EE93418A70A2A3F0565B108255AE9DCE945A5", 48);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]encryptKey = %s\n", wrapKey);
    printf("[IN ]mech       = %d\n", mech);
    printf("[IN ]key        = %s\n", key);
    printf("[IN ]IV         = %s\n", IV);
    printf("[IN ]prePix     = %s\n", prePix);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIwrapEnhance(nSock, wrapKey, mech, key, IV, prePix, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "CBC测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]outData    = %s\n", outData);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void WrapEnhanceIndex_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

/////////////////////////////////////////////
    BYTE bKey[32];
    char szCheckValue[16];
    int  masterKeyIndex;
    UINT mech;
    char data[128];
    char dataTmp[128];
    char IV[32];
    char key[64];
    char outDataTmp[128];
    char outDataExp[128];
    char outData[1024];
    char prePix[64];

    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(data);
    bufclr(dataTmp);
    bufclr(IV);
    bufclr(key);
    bufclr(outDataTmp);
    bufclr(outDataExp);
    bufclr(outData);
    bufclr(prePix);

    masterKeyIndex = 444;
    mech = 20;

    memcpy(data, "\x01\x23\x45\x67\x89\xAB\xF1\x01\xCD\xEF\xFE\xDC\xBA\x98\x0E\x01", 16);
    SSMMakeOddBinStr_Test(data, 16);
    nRet = SMAPIEncryptKey(nSock, data, 16, outDataTmp);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptKey NG");
    SSMHexToChar(outDataTmp, key, 16);
    memset(IV, '0', 16);

    nRet = SMAPIGenerateKey(nSock, 16, "ZZZZZZZZZZ", 10, \
                            2, masterKeyIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");
    DspHex("bKey =", bKey, 16);

    memcpy(prePix, "0987654321", 10);

    memcpy(dataTmp, "\x15\x09\x87\x65\x43\x21\x01\x23"
                    "\x45\x67\x89\xAB\xF1\x01\xCD\xEF"
                    "\xFE\xDC\xBA\x98\x0E\x01\x80\x00", 24);
    nRet = SMAPIEncryptData(nSock, 1, 0, masterKeyIndex, dataTmp, 24, outDataTmp);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptData NG");

    SSMHexToChar(outDataTmp, outDataExp, 24);

///////////////////////////////

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]index = %d\n", masterKeyIndex);
    printf("[IN ]mech  = %d\n", mech);
    printf("[IN ]key   = %s\n", key);
    printf("[IN ]IV    = %s\n", IV);
    printf("[IN ]prePix     = %s\n", prePix);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIwrapEnhance_index(nSock, masterKeyIndex, mech, key, IV, prePix, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "ECB测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]outData    = %s\n", outData);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void WrapEnhanceIndex_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

/////////////////////////////////////////////
    BYTE bKey[32];
    char szCheckValue[16];
    int  masterKeyIndex;
    UINT mech;
    char data[128];
    char dataTmp[128];
    char IV[32];
    char key[64];
    char outDataTmp[128];
    char outDataExp[128];
    char outData[1024];
    char prePix[64];

    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(data);
    bufclr(dataTmp);
    bufclr(IV);
    bufclr(key);
    bufclr(outDataTmp);
    bufclr(outDataExp);
    bufclr(outData);
    bufclr(prePix);

    masterKeyIndex = 444;
    mech = 17;

    memcpy(data, "\x01\x23\x45\x67\x89\xAB\xF1\x01\xCD\xEF\xFE\xDC\xBA\x98\x0E\x01", 16);
    SSMMakeOddBinStr_Test(data, 16);
    nRet = SMAPIEncryptKey(nSock, data, 16, outDataTmp);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptKey NG");
    SSMHexToChar(outDataTmp, key, 16);
    memset(IV, '0', 16);

    nRet = SMAPIGenerateKey(nSock, 16, "ZZZZZZZZZZ", 10, \
                            2, masterKeyIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");
    DspHex("bKey =", bKey, 16);

    memcpy(prePix, "0987654321", 10);

    memcpy(dataTmp, "\x15\x09\x87\x65\x43\x21\x01\x23"
                    "\x45\x67\x89\xAB\xF1\x01\xCD\xEF"
                    "\xFE\xDC\xBA\x98\x0E\x01\x80\x00", 24);
    nRet = SMAPIEncryptData(nSock, 1, 1, masterKeyIndex, dataTmp, 24, outDataTmp);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptData NG");

    SSMHexToChar(outDataTmp, outDataExp, 24);

///////////////////////////////

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]index = %d\n", masterKeyIndex);
    printf("[IN ]mech  = %d\n", mech);
    printf("[IN ]key   = %s\n", key);
    printf("[IN ]IV    = %s\n", IV);
    printf("[IN ]prePix     = %s\n", prePix);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIwrapEnhance_index(nSock, masterKeyIndex, mech, key, IV, prePix, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "ECB测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]outData    = %s\n", outData);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void WrapExt_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    char wrapKey[64];
    UINT mech;
    char keyMac[128];
    char keyEnc[128];
    char keyDek[128];
    char keyTmp[256];
    char IV[32];
    char outData[1024];
    char outDataExp[1024];
    char KeyHeader[64];

    bufclr(wrapKey);
    bufclr(keyMac);
    bufclr(keyEnc);
    bufclr(keyDek);
    bufclr(keyTmp);
    bufclr(IV);
    bufclr(outData);
    bufclr(outDataExp);
    bufclr(KeyHeader);

    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(wrapKey, "A2C0B0F8F7F5EE21FB5C6AEBE714E53A", 32);
    mech = 20;
    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    /* 88F7 8BB7 9D61 436D 9C05 0C92 E6A8 E031 */
    /* 89F7 8AB6 9D61 436D 9D04 0D92 E6A8 E031 */
    memcpy(keyMac, "753BCB191136C1489875E273DC3447C9", 32);
    /* CE37 5619 0B2C 9548 9A16 69DA 6B2C 8928 */
    /* CE37 5719 0B2C 9449 9B16 68DA 6B2C 8929 */
    memcpy(keyEnc, "6A6014F8C0E94945866FAE94B6547E33", 32);
    /* 51F5 367B 7286 C9BA 847E 5C6A B3D4 87FB */
    /* 51F4 377A 7386 C8BA 857F 5D6B B3D5 86FB */
    memcpy(keyDek, "0B0879A346D705AB1C530B5EE7BB0446", 32);
    memcpy(keyTmp, "1634EAD5E5CB1F9E836D38233E51EFE3", 32);
    memset(IV, '0', 16);
    memcpy(KeyHeader, "0987654321", 10);
    /* 15 0987654321 1634EAD5E5CB1F9E836D38233E51EFE3 8000*/
    memcpy(outDataExp, "8FBEDB484785F53E66C9E4BDB324F7711EB98E4BBFD2B1DA", 48);

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]keyMac    = %s\n", keyMac);
    printf("[IN ]keyEnc    = %s\n", keyEnc);
    printf("[IN ]keyDek    = %s\n", keyDek);
    printf("[IN ]KeyHeader = %s\n", KeyHeader);
    printf("[IN ]wrapKey   = %s\n", wrapKey);
    printf("[IN ]mech      = %d\n", mech);
    printf("[IN ]IV        = %s\n", IV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIwrap_ext(nSock, keyMac, keyEnc, keyDek, KeyHeader, wrapKey, mech, IV, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "ECB测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]outData    = %s\n", outData);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void WrapExt_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    char wrapKey[64];
    UINT mech;
    char keyMac[128];
    char keyEnc[128];
    char keyDek[128];
    char keyTmp[256];
    char IV[32];
    char outData[1024];
    char outDataExp[1024];
    char KeyHeader[64];

    bufclr(wrapKey);
    bufclr(keyMac);
    bufclr(keyEnc);
    bufclr(keyDek);
    bufclr(keyTmp);
    bufclr(IV);
    bufclr(outData);
    bufclr(outDataExp);
    bufclr(KeyHeader);

    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(wrapKey, "A2C0B0F8F7F5EE21FB5C6AEBE714E53A", 32);
    mech = 17;
    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    /* 88F7 8BB7 9D61 436D 9C05 0C92 E6A8 E031 */
    /* 89F7 8AB6 9D61 436D 9D04 0D92 E6A8 E031 */
    memcpy(keyMac, "753BCB191136C1489875E273DC3447C9", 32);
    /* CE37 5619 0B2C 9548 9A16 69DA 6B2C 8928 */
    /* CE37 5719 0B2C 9449 9B16 68DA 6B2C 8929 */
    memcpy(keyEnc, "6A6014F8C0E94945866FAE94B6547E33", 32);
    /* 51F5 367B 7286 C9BA 847E 5C6A B3D4 87FB */
    /* 51F4 377A 7386 C8BA 857F 5D6B B3D5 86FB */
    memcpy(keyDek, "0B0879A346D705AB1C530B5EE7BB0446", 32);
    memcpy(keyTmp, "1634EAD5E5CB1F9E836D38233E51EFE3", 32);
    memset(IV, '0', 16);
    memcpy(KeyHeader, "0987654321", 10);
    /* 15 0987654321 1634EAD5E5CB1F9E836D38233E51EFE3 8000*/
    memcpy(outDataExp, "8FBEDB484785F53E63D723446F42EC156F645A073E917568", 48);

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]keyMac    = %s\n", keyMac);
    printf("[IN ]keyEnc    = %s\n", keyEnc);
    printf("[IN ]keyDek    = %s\n", keyDek);
    printf("[IN ]KeyHeader = %s\n", KeyHeader);
    printf("[IN ]wrapKey   = %s\n", wrapKey);
    printf("[IN ]mech      = %d\n", mech);
    printf("[IN ]IV        = %s\n", IV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIwrap_ext(nSock, keyMac, keyEnc, keyDek, KeyHeader, wrapKey, mech, IV, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "CBC测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]outData    = %s\n", outData);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void WrapExtIndex_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

/////////////////////////////////////////////
    BYTE bKey[32];
    char szCheckValue[16];
    int  masterKeyIndex;
    UINT mech;
    char data[128];
    char dataTmp[128];
    char IV[32];
    char keyMac[64];
    char keyEnc[64];
    char keyDek[64];
    char outDataTmp[128];
    char outDataExp[128];
    char outData[1024];
    char KeyHeader[64];

    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(data);
    bufclr(dataTmp);
    bufclr(IV);
    bufclr(keyMac);
    bufclr(keyEnc);
    bufclr(keyDek);
    bufclr(outDataTmp);
    bufclr(outDataExp);
    bufclr(outData);
    bufclr(KeyHeader);

    masterKeyIndex = 444;
    mech = 20;

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    /* 88F7 8BB7 9D61 436D 9C05 0C92 E6A8 E031 */
    /* 89F7 8AB6 9D61 436D 9D04 0D92 E6A8 E031 */
    memcpy(keyMac, "753BCB191136C1489875E273DC3447C9", 32);
    /* CE37 5619 0B2C 9548 9A16 69DA 6B2C 8928 */
    /* CE37 5719 0B2C 9449 9B16 68DA 6B2C 8929 */
    memcpy(keyEnc, "6A6014F8C0E94945866FAE94B6547E33", 32);
    /* 51F5 367B 7286 C9BA 847E 5C6A B3D4 87FB */
    /* 51F4 377A 7386 C8BA 857F 5D6B B3D5 86FB */
    memcpy(keyDek, "0B0879A346D705AB1C530B5EE7BB0446", 32);

    nRet = SMAPIGenerateKey(nSock, 16, "ZZZZZZZZZZ", 10, \
                            2, masterKeyIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");

    memcpy(KeyHeader, "0987654321", 10);

    /* 15 0987654321 1634EAD5E5CB1F9E836D38233E51EFE3 8000*/
    memcpy(dataTmp, "\x15\x09\x87\x65\x43\x21\x16\x34"
                    "\xEA\xD5\xE5\xCB\x1F\x9E\x83\x6D"
                    "\x38\x23\x3E\x51\xEF\xE3\x80\x00", 24);
    nRet = SMAPIEncryptData(nSock, 1, 0, masterKeyIndex, dataTmp, 24, outDataTmp);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptData NG");

    SSMHexToChar(outDataTmp, outDataExp, 24);

    memset(IV, '0', 16);
///////////////////////////////

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]index     = %d\n", masterKeyIndex);
    printf("[IN ]mech      = %d\n", mech);
    printf("[IN ]keyMac    = %s\n", keyMac);
    printf("[IN ]keyEnc    = %s\n", keyEnc);
    printf("[IN ]keyDek    = %s\n", keyDek);
    printf("[IN ]KeyHeader = %s\n", KeyHeader);
    printf("[IN ]IV        = %s\n", IV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIwrap_ext_index(nSock, keyMac, keyEnc, keyDek, KeyHeader, masterKeyIndex, mech, IV, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "ECB测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]outData    = %s\n", outData);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void WrapExtIndex_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

/////////////////////////////////////////////
    BYTE bKey[32];
    char szCheckValue[16];
    int  masterKeyIndex;
    UINT mech;
    char data[128];
    char dataTmp[128];
    char IV[32];
    char keyMac[64];
    char keyEnc[64];
    char keyDek[64];
    char outDataTmp[128];
    char outDataExp[128];
    char outData[1024];
    char KeyHeader[64];

    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(data);
    bufclr(dataTmp);
    bufclr(IV);
    bufclr(keyMac);
    bufclr(keyEnc);
    bufclr(keyDek);
    bufclr(outDataTmp);
    bufclr(outDataExp);
    bufclr(outData);
    bufclr(KeyHeader);

    masterKeyIndex = 444;
    mech = 17;

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    /* 88F7 8BB7 9D61 436D 9C05 0C92 E6A8 E031 */
    /* 89F7 8AB6 9D61 436D 9D04 0D92 E6A8 E031 */
    memcpy(keyMac, "753BCB191136C1489875E273DC3447C9", 32);
    /* CE37 5619 0B2C 9548 9A16 69DA 6B2C 8928 */
    /* CE37 5719 0B2C 9449 9B16 68DA 6B2C 8929 */
    memcpy(keyEnc, "6A6014F8C0E94945866FAE94B6547E33", 32);
    /* 51F5 367B 7286 C9BA 847E 5C6A B3D4 87FB */
    /* 51F4 377A 7386 C8BA 857F 5D6B B3D5 86FB */
    memcpy(keyDek, "0B0879A346D705AB1C530B5EE7BB0446", 32);

    nRet = SMAPIGenerateKey(nSock, 16, "ZZZZZZZZZZ", 10, \
                            2, masterKeyIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");

    memcpy(KeyHeader, "0987654321", 10);

    /* 15 0987654321 1634EAD5E5CB1F9E836D38233E51EFE3 8000*/
    memcpy(dataTmp, "\x15\x09\x87\x65\x43\x21\x16\x34"
                    "\xEA\xD5\xE5\xCB\x1F\x9E\x83\x6D"
                    "\x38\x23\x3E\x51\xEF\xE3\x80\x00", 24);
    nRet = SMAPIEncryptData(nSock, 1, 1, masterKeyIndex, dataTmp, 24, outDataTmp);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptData NG");

    SSMHexToChar(outDataTmp, outDataExp, 24);

    memset(IV, '0', 16);
///////////////////////////////

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]index     = %d\n", masterKeyIndex);
    printf("[IN ]mech      = %d\n", mech);
    printf("[IN ]keyMac    = %s\n", keyMac);
    printf("[IN ]keyEnc    = %s\n", keyEnc);
    printf("[IN ]keyDek    = %s\n", keyDek);
    printf("[IN ]KeyHeader = %s\n", KeyHeader);
    printf("[IN ]IV        = %s\n", IV);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIwrap_ext_index(nSock, keyMac, keyEnc, keyDek, KeyHeader, masterKeyIndex, mech, IV, outData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "CBC测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]outData    = %s\n", outData);
    printf("[OUT]outDataExp = %s\n", outDataExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}
/*********************************************************************************************************************/


void EncryptPinX98A_GM_Test_01(void)
{
	XXX_TEST_START_XXX
	int nRet;
	int nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);
	
	nAlgo = 4;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "1234");
    sprintf(bCryptPinExp, "\xAB\x3A\xF4\x98\x7A\x58\x13\x10\x90\x14\x56\x4D\x7D\x77\x0C\x92");
    
	XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98A_GM(nSock, nAlgo, bPinKey, szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "4位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptPin  =", bCryptPin, 16);
    DspHex("[OUT]expect     =", bCryptPinExp,16);
    ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98A_GM_Test_02(void)
{
	XXX_TEST_START_XXX
	int nRet;
	int nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);
	
	nAlgo = 4;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "12345");
	sprintf(bCryptPinExp, "\xAB\x65\xBC\xF1\x08\xF5\xF2\x87\x51\x31\xB2\x3B\x7A\xD3\x01\xFD");
    
	XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98A_GM(nSock, nAlgo, bPinKey, szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "5位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptPin  =", bCryptPin, 16);
    DspHex("[OUT]expect     =", bCryptPinExp, 16);
    ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98A_GM_Test_03(void)
{
	XXX_TEST_START_XXX
	int nRet;
	int nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);
	
	nAlgo = 4;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "123456");
	sprintf(bCryptPinExp, "\x3A\x47\xF1\x66\xDE\xC4\x88\x0E\x91\x69\xA6\xF5\xB1\x40\xDC\x0A");
    
	XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98A_GM(nSock, nAlgo, bPinKey, szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "6位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptPin  =", bCryptPin, 16);
    DspHex("[OUT]expect     =", bCryptPinExp, 16);
    ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98A_GM_Test_04(void)
{
	XXX_TEST_START_XXX
	int nRet;
	int nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);
	
	nAlgo = 4;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "1234567");
	sprintf(bCryptPinExp, "\xD1\x0B\x13\x7A\x50\x47\xF0\xCE\x53\xA1\x81\x68\xA3\x5D\xA3\xB7");
    
	XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98A_GM(nSock, nAlgo, bPinKey, szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "7位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptPin  =", bCryptPin, 16);
    DspHex("[OUT]expect     =", bCryptPinExp, 16);
    ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98A_GM_Test_05(void)
{
	XXX_TEST_START_XXX
	int nRet;
	int nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);
	
	nAlgo = 4;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "12345678");
	sprintf(bCryptPinExp, "\xDC\x4C\xED\x11\x8B\xF9\xFE\xF5\xAB\x12\x6D\x7B\x6B\x5B\x93\x1E");
    
	XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98A_GM(nSock, nAlgo, bPinKey, szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "8位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptPin  =", bCryptPin, 16);
    DspHex("[OUT]expect     =", bCryptPinExp, 16);
    ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98A_GM_Test_06(void)
{
	XXX_TEST_START_XXX
	int nRet;
	int nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);
	
	nAlgo = 4;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "123456789");
	memcpy(bCryptPinExp, "\x34\x4E\x32\x49\x00\x5C\x9B\x40\x73\xFC\x42\xFF\x65\x77\xB2\x61", 16);
    
	XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98A_GM(nSock, nAlgo, bPinKey, szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "9位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptPin  =", bCryptPin, 16);
    DspHex("[OUT]expect     =", bCryptPinExp, 16);
    ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98A_GM_Test_07(void)
{
	XXX_TEST_START_XXX
	int nRet;
	int nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);
	
	nAlgo = 4;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "1234567890");
	sprintf(bCryptPinExp, "\x0E\x2A\xBA\xDB\x0F\x72\x88\xC0\xA1\x04\xCB\x7D\x2A\x68\x5F\x07");
    
	XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98A_GM(nSock, nAlgo, bPinKey, szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "10位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptPin  =", bCryptPin, 16);
    DspHex("[OUT]expect     =", bCryptPinExp, 16);
    ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98A_GM_Test_08(void)
{
	XXX_TEST_START_XXX
	int nRet;
	int nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);
	
	nAlgo = 4;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "12345678901");
	sprintf(bCryptPinExp, "\xDB\xBA\x32\x42\x7A\x74\x35\xDC\xCC\x64\xF2\xA4\xFE\x90\xC5\xF9");
    
	XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98A_GM(nSock, nAlgo, bPinKey, szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "11位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptPin  =", bCryptPin, 16);
    DspHex("[OUT]expect     =", bCryptPinExp, 16);
    ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98A_GM_Test_09(void)
{
	XXX_TEST_START_XXX
	int nRet;
	int nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);
	
	nAlgo = 4;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "123456789012");
	sprintf(bCryptPinExp, "\x98\x20\xC8\x71\xB7\x30\xCD\xBF\xEE\x8F\x46\xAC\x32\x2D\xCF\xE0");
    
	XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98A_GM(nSock, nAlgo, bPinKey, szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "12位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptPin  =", bCryptPin, 16);
    DspHex("[OUT]expect     =", bCryptPinExp, 16);
    ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98A_GM_Test_10(void)
{
	XXX_TEST_START_XXX
	int nRet;
	int nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);
	
	nAlgo = 4;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "123");
    
	XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98A_GM(nSock, nAlgo, bPinKey, szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "3位PIN测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
	XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98A_GM_Test_11(void)
{
	XXX_TEST_START_XXX
	int nRet;
	int nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);
	
	nAlgo = 4;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "1234567890123");
    
	XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98A_GM(nSock, nAlgo, bPinKey, szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "13位PIN测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
	XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98A_GM_Test_12(void)
{
	XXX_TEST_START_XXX
	int nRet;
	int nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);
	
	nAlgo = 1;
    /* plain key = 0123456789ABCDEFF */ 
	sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");

    sprintf(szPlainPin, "123456");
	sprintf(bCryptPinExp, "\x2F\x2B\x15\xB0\xF0\x9A\xD4\xD1");
    
	XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 8);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98A_GM(nSock, nAlgo, bPinKey, szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "单倍长密钥测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
	DspHex("[OUT]bCryptPin  =", bCryptPin, 8);
	DspHex("[OUT]expect     =", bCryptPinExp, 8);
    ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98A_GM_Test_13(void)
{
	XXX_TEST_START_XXX
	int nRet;
	int nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);
	
	nAlgo = 2;
	/* plain key = 0123456789ABCDEFFEDCBA9876543210 */
	sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
	           "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "123456");
	sprintf(bCryptPinExp, "\x43\xE9\x45\x58\x8E\xD5\x66\xD9");
    
	XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98A_GM(nSock, nAlgo, bPinKey, szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "双倍长密钥测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
	DspHex("[OUT]bCryptPin  =", bCryptPin, 8);
	DspHex("[OUT]expect     =", bCryptPinExp, 8);
    ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98A_GM_Test_14(void)
{
	XXX_TEST_START_XXX
	int nRet;
	int nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);
	
	nAlgo = 3;
	/* plain key = 0123456789ABCDEFFEDCBA98765432108796A5B4C3D2E1F0 */
	sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
			"\x59\x99\xC3\x06\xAB\x84\x01\xB2");
	sprintf(szPlainPin, "123456");
	sprintf(bCryptPinExp, "\x59\x92\xA5\x8F\x5E\x1A\x77\x52");
    
	XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 24);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98A_GM(nSock, nAlgo, bPinKey, szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "三倍长密钥测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
	DspHex("[OUT]bCryptPin  =", bCryptPin, 8);
	DspHex("[OUT]expect     =", bCryptPinExp, 8);
    ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98A_GM_Test_15(void)
{
	XXX_TEST_START_XXX
	int nRet;
	int nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);
	
	nAlgo = 4;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
	sprintf(szPlainPin, "123az!");
    
	XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98A_GM(nSock, nAlgo, bPinKey, szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 6, "无效密码-密码中含有非数字字符测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
	XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98A_GM_Test_16(void)
{
	XXX_TEST_START_XXX
	int nRet;
	int nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);
	
	nAlgo = 4;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
	sprintf(szPlainPin, "123abc");
    
	XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98A_GM(nSock, nAlgo, bPinKey, szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 6, "无效密码-密码中含有非数字字符测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
	XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98A_GM_Test_17(void)
{
	XXX_TEST_START_XXX
	int nRet;
	int nSock = -1;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);
	
	nAlgo = 4;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
	sprintf(szPlainPin, "123456");
    
	XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98A_GM(nSock, nAlgo, bPinKey, szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 3, "无效Socket ID[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
	XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX
  	
	nSock = SM_SOCK;
    
	XXX_TEST_END_XXX
}

void EncryptPinX98A_GM_Test_18(void)
{
	XXX_TEST_START_XXX
	int nRet;
	int nSock = 8;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);
	
	nAlgo = 4;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
	sprintf(szPlainPin, "123456");
    
	XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98A_GM(nSock, nAlgo, bPinKey, szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 3, "无效Socket ID[8]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
	XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX
  	
	nSock = SM_SOCK;
    
	XXX_TEST_END_XXX
}

void EncryptPinX98A_GM_Test_19(void)
{
	XXX_TEST_START_XXX
	int nRet;
	int nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);
	
	nAlgo = 0;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
	sprintf(szPlainPin, "123456");
    
	XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98A_GM(nSock, nAlgo, bPinKey, szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 1, "无效算法类型[0]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
	XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX
    
	XXX_TEST_END_XXX
}

void EncryptPinX98A_GM_Test_20(void)
{
	XXX_TEST_START_XXX
	int nRet;
	int nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);
	
	nAlgo = 5;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
	sprintf(szPlainPin, "123456");
    
	XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98A_GM(nSock, nAlgo, bPinKey, szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 1, "无效算法类型[5]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
	XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX
    
	XXX_TEST_END_XXX
}

void EncryptPinX98B_GM_Test_01(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bPinKey[32];
	char szPlainPin[16];
	BYTE bCryptPin[8];
	BYTE bCryptPinExp[8];
	char szPan[24];
	int  nPanLen;

	bufclr(szPlainPin);
	bufclr(bPinKey);
	bufclr(szPan);
	bufclr(bCryptPin);
	bufclr(bCryptPinExp);

	nAlgo = 4;
	/* plain key = 0123456789ABCDEFFEDCBA9876543210 */
	sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

	sprintf(szPlainPin, "1234");
	sprintf(szPan, "1234567890123456");
	nPanLen = 16;
	memcpy(bCryptPinExp, "\x14\x52\xF0\x20\x74\x6C\xDF\x39\x48\x06\x0E\xE3\xA0\x22\xAE\x9F", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock      = %d\n", nSock);
	printf("[IN ]nAlgo      = %d\n", nAlgo);
	printf("[IN ]szPan      = %s\n", szPan);
	printf("[IN ]nPanLen    = %d\n", nPanLen);
	DspHex("[IN ]bPinKey    =", bPinKey, 16);
	printf("[IN ]szPlainPin = %s\n", szPlainPin);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPIEncryptPinX98B_GM(nSock, nAlgo, szPan, nPanLen, bPinKey, \
				szPlainPin, bCryptPin);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "4位PIN测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX	
	DspHex("[OUT]bCryptPin  =", bCryptPin, 16);
	DspHex("[OUT]expect     =", bCryptPinExp, 16);
	ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 16);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void EncryptPinX98B_GM_Test_02(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bPinKey[32];
	char szPlainPin[16];
	BYTE bCryptPin[8];
	BYTE bCryptPinExp[8];
	char szPan[24];
	int  nPanLen;

	bufclr(szPlainPin);
	bufclr(bPinKey);
	bufclr(szPan);
	bufclr(bCryptPin);
	bufclr(bCryptPinExp);

	nAlgo = 4;
	/* plain key = 0123456789ABCDEFFEDCBA9876543210 */
	sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

	sprintf(szPlainPin, "12345");
	sprintf(szPan, "1234567890123456");
	nPanLen = 16;
	memcpy(bCryptPinExp, "\x41\x8C\x95\x81\x36\x82\xDB\x6D\x0F\x75\x74\xAD\x98\x54\xA0\x0B", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock      = %d\n", nSock);
	printf("[IN ]nAlgo      = %d\n", nAlgo);
	printf("[IN ]szPan      = %s\n", szPan);
	printf("[IN ]nPanLen    = %d\n", nPanLen);
	DspHex("[IN ]bPinKey    =", bPinKey, 16);
	printf("[IN ]szPlainPin = %s\n", szPlainPin);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPIEncryptPinX98B_GM(nSock, nAlgo, szPan, nPanLen, bPinKey, \
				szPlainPin, bCryptPin);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "5位PIN测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX	
	DspHex("[OUT]bCryptPin  =", bCryptPin, 16);
	DspHex("[OUT]expect     =", bCryptPinExp, 16);
	ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 16);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void EncryptPinX98B_GM_Test_03(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bPinKey[32];
	char szPlainPin[16];
	BYTE bCryptPin[8];
	BYTE bCryptPinExp[8];
	char szPan[24];
	int  nPanLen;

	bufclr(szPlainPin);
	bufclr(bPinKey);
	bufclr(szPan);
	bufclr(bCryptPin);
	bufclr(bCryptPinExp);

	nAlgo = 4;
	/* plain key = 0123456789ABCDEFFEDCBA9876543210 */
	sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

	sprintf(szPlainPin, "123456");
	sprintf(szPan, "1234567890123456");
	nPanLen = 16;
	memcpy(bCryptPinExp, "\x17\xF4\xE8\xF0\x85\x67\x91\xEF\xFD\x6A\x5F\xCE\xB2\x1A\x62\x3F", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock      = %d\n", nSock);
	printf("[IN ]nAlgo      = %d\n", nAlgo);
	printf("[IN ]szPan      = %s\n", szPan);
	printf("[IN ]nPanLen    = %d\n", nPanLen);
	DspHex("[IN ]bPinKey    =", bPinKey, 16);
	printf("[IN ]szPlainPin = %s\n", szPlainPin);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPIEncryptPinX98B_GM(nSock, nAlgo, szPan, nPanLen, bPinKey, \
				szPlainPin, bCryptPin);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "6位PIN测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX	
	DspHex("[OUT]bCryptPin  =", bCryptPin, 16);
	DspHex("[OUT]expect     =", bCryptPinExp, 16);
	ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 16);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void EncryptPinX98B_GM_Test_04(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bPinKey[32];
	char szPlainPin[16];
	BYTE bCryptPin[8];
	BYTE bCryptPinExp[8];
	char szPan[24];
	int  nPanLen;

	bufclr(szPlainPin);
	bufclr(bPinKey);
	bufclr(szPan);
	bufclr(bCryptPin);
	bufclr(bCryptPinExp);

	nAlgo = 4;
	/* plain key = 0123456789ABCDEFFEDCBA9876543210 */
	sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

	sprintf(szPlainPin, "1234567");
	sprintf(szPan, "1234567890123456");
	nPanLen = 16;
	memcpy(bCryptPinExp, "\x1F\x01\xF1\x65\xA8\x07\x60\x8C\xA3\xF0\x9C\xCA\x7B\x80\x83\xEA", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock      = %d\n", nSock);
	printf("[IN ]nAlgo      = %d\n", nAlgo);
	printf("[IN ]szPan      = %s\n", szPan);
	printf("[IN ]nPanLen    = %d\n", nPanLen);
	DspHex("[IN ]bPinKey    =", bPinKey, 16);
	printf("[IN ]szPlainPin = %s\n", szPlainPin);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPIEncryptPinX98B_GM(nSock, nAlgo, szPan, nPanLen, bPinKey, \
				szPlainPin, bCryptPin);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "7位PIN测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX	
	DspHex("[OUT]bCryptPin  =", bCryptPin, 16);
	DspHex("[OUT]expect     =", bCryptPinExp, 16);
	ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 16);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void EncryptPinX98B_GM_Test_05(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bPinKey[32];
	char szPlainPin[16];
	BYTE bCryptPin[8];
	BYTE bCryptPinExp[8];
	char szPan[24];
	int  nPanLen;

	bufclr(szPlainPin);
	bufclr(bPinKey);
	bufclr(szPan);
	bufclr(bCryptPin);
	bufclr(bCryptPinExp);

	nAlgo = 4;
	/* plain key = 0123456789ABCDEFFEDCBA9876543210 */
	sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

	sprintf(szPlainPin, "12345678");
	sprintf(szPan, "1234567890123456");
	nPanLen = 16;
	memcpy(bCryptPinExp, "\xB3\x2B\x21\x80\x98\xFD\x75\xA0\x93\x56\xAF\xF3\xD6\xA8\x38\xA8", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock      = %d\n", nSock);
	printf("[IN ]nAlgo      = %d\n", nAlgo);
	printf("[IN ]szPan      = %s\n", szPan);
	printf("[IN ]nPanLen    = %d\n", nPanLen);
	DspHex("[IN ]bPinKey    =", bPinKey, 16);
	printf("[IN ]szPlainPin = %s\n", szPlainPin);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPIEncryptPinX98B_GM(nSock, nAlgo, szPan, nPanLen, bPinKey, \
				szPlainPin, bCryptPin);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "8位PIN测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX	
	DspHex("[OUT]bCryptPin  =", bCryptPin, 16);
	DspHex("[OUT]expect     =", bCryptPinExp, 16);
	ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 16);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void EncryptPinX98B_GM_Test_06(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bPinKey[32];
	char szPlainPin[16];
	BYTE bCryptPin[8];
	BYTE bCryptPinExp[8];
	char szPan[24];
	int  nPanLen;

	bufclr(szPlainPin);
	bufclr(bPinKey);
	bufclr(szPan);
	bufclr(bCryptPin);
	bufclr(bCryptPinExp);

	nAlgo = 4;
	/* plain key = 0123456789ABCDEFFEDCBA9876543210 */
	sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

	sprintf(szPlainPin, "123456789");
	sprintf(szPan, "1234567890123456");
	nPanLen = 16;
	memcpy(bCryptPinExp, "\x9E\xFA\x14\x59\x6B\x52\xCA\x9C\x94\xDC\x1B\x0D\xBA\x3E\x1B\x9D", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock      = %d\n", nSock);
	printf("[IN ]nAlgo      = %d\n", nAlgo);
	printf("[IN ]szPan      = %s\n", szPan);
	printf("[IN ]nPanLen    = %d\n", nPanLen);
	DspHex("[IN ]bPinKey    =", bPinKey, 16);
	printf("[IN ]szPlainPin = %s\n", szPlainPin);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPIEncryptPinX98B_GM(nSock, nAlgo, szPan, nPanLen, bPinKey, \
				szPlainPin, bCryptPin);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "9位PIN测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX	
	DspHex("[OUT]bCryptPin  =", bCryptPin, 16);
	DspHex("[OUT]expect     =", bCryptPinExp, 16);
	ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 16);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void EncryptPinX98B_GM_Test_07(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bPinKey[32];
	char szPlainPin[16];
	BYTE bCryptPin[8];
	BYTE bCryptPinExp[8];
	char szPan[24];
	int  nPanLen;

	bufclr(szPlainPin);
	bufclr(bPinKey);
	bufclr(szPan);
	bufclr(bCryptPin);
	bufclr(bCryptPinExp);

	nAlgo = 4;
	/* plain key = 0123456789ABCDEFFEDCBA9876543210 */
	sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

	sprintf(szPlainPin, "1234567890");
	sprintf(szPan, "1234567890123456");
	nPanLen = 16;
	memcpy(bCryptPinExp, "\x59\x8F\x1C\xC2\xE7\xD4\x36\x3C\x61\x50\x6C\xFA\x0F\xF7\xA7\xA5", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock      = %d\n", nSock);
	printf("[IN ]nAlgo      = %d\n", nAlgo);
	printf("[IN ]szPan      = %s\n", szPan);
	printf("[IN ]nPanLen    = %d\n", nPanLen);
	DspHex("[IN ]bPinKey    =", bPinKey, 16);
	printf("[IN ]szPlainPin = %s\n", szPlainPin);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPIEncryptPinX98B_GM(nSock, nAlgo, szPan, nPanLen, bPinKey, \
				szPlainPin, bCryptPin);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "10位PIN测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX	
	DspHex("[OUT]bCryptPin  =", bCryptPin, 16);
	DspHex("[OUT]expect     =", bCryptPinExp, 16);
	ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 16);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void EncryptPinX98B_GM_Test_08(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bPinKey[32];
	char szPlainPin[16];
	BYTE bCryptPin[8];
	BYTE bCryptPinExp[8];
	char szPan[24];
	int  nPanLen;

	bufclr(szPlainPin);
	bufclr(bPinKey);
	bufclr(szPan);
	bufclr(bCryptPin);
	bufclr(bCryptPinExp);

	nAlgo = 4;
	/* plain key = 0123456789ABCDEFFEDCBA9876543210 */
	sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

	sprintf(szPlainPin, "12345678901");
	sprintf(szPan, "1234567890123456");
	nPanLen = 16;
	memcpy(bCryptPinExp, "\x99\x1F\x84\x59\xBA\x66\xBD\x55\x0B\x75\xFF\x45\xDD\x8A\xB2\x31", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock      = %d\n", nSock);
	printf("[IN ]nAlgo      = %d\n", nAlgo);
	printf("[IN ]szPan      = %s\n", szPan);
	printf("[IN ]nPanLen    = %d\n", nPanLen);
	DspHex("[IN ]bPinKey    =", bPinKey, 16);
	printf("[IN ]szPlainPin = %s\n", szPlainPin);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPIEncryptPinX98B_GM(nSock, nAlgo, szPan, nPanLen, bPinKey, \
				szPlainPin, bCryptPin);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "11位PIN测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX	
	DspHex("[OUT]bCryptPin  =", bCryptPin, 16);
	DspHex("[OUT]expect     =", bCryptPinExp, 16);
	ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 16);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void EncryptPinX98B_GM_Test_09(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bPinKey[32];
	char szPlainPin[16];
	BYTE bCryptPin[8];
	BYTE bCryptPinExp[8];
	char szPan[24];
	int  nPanLen;

	bufclr(szPlainPin);
	bufclr(bPinKey);
	bufclr(szPan);
	bufclr(bCryptPin);
	bufclr(bCryptPinExp);

	nAlgo = 4;
	/* plain key = 0123456789ABCDEFFEDCBA9876543210 */
	sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

	sprintf(szPlainPin, "123456789012");
	sprintf(szPan, "1234567890123456");
	nPanLen = 16;
	memcpy(bCryptPinExp, "\x2E\x7C\x3B\xF8\x68\x86\xCF\xA2\xF1\x29\xBE\x9E\xE5\x5C\xA7\xBF", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock      = %d\n", nSock);
	printf("[IN ]nAlgo      = %d\n", nAlgo);
	printf("[IN ]szPan      = %s\n", szPan);
	printf("[IN ]nPanLen    = %d\n", nPanLen);
	DspHex("[IN ]bPinKey    =", bPinKey, 16);
	printf("[IN ]szPlainPin = %s\n", szPlainPin);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPIEncryptPinX98B_GM(nSock, nAlgo, szPan, nPanLen, bPinKey, \
				szPlainPin, bCryptPin);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "12位PIN测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX	
	DspHex("[OUT]bCryptPin  =", bCryptPin, 16);
	DspHex("[OUT]expect     =", bCryptPinExp, 16);
	ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 16);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void EncryptPinX98B_GM_Test_10(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bPinKey[32];
	char szPlainPin[16];
	BYTE bCryptPin[8];
	BYTE bCryptPinExp[8];
	char szPan[24];
	int  nPanLen;

	bufclr(szPlainPin);
	bufclr(bPinKey);
	bufclr(szPan);
	bufclr(bCryptPin);
	bufclr(bCryptPinExp);

	nAlgo = 4;
	/* plain key = 0123456789ABCDEFFEDCBA9876543210 */
	sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

	sprintf(szPlainPin, "123");
	sprintf(szPan, "1234567890123456");
	nPanLen = 16;

	XXX_INPUT_XXX
	printf("[IN ]nSock      = %d\n", nSock);
	printf("[IN ]nAlgo      = %d\n", nAlgo);
	printf("[IN ]szPan      = %s\n", szPan);
	printf("[IN ]nPanLen    = %d\n", nPanLen);
	DspHex("[IN ]bPinKey    =", bPinKey, 16);
	printf("[IN ]szPlainPin = %s\n", szPlainPin);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPIEncryptPinX98B_GM(nSock, nAlgo, szPan, nPanLen, bPinKey, \
				szPlainPin, bCryptPin);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 1, "3位PIN测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX	
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void EncryptPinX98B_GM_Test_11(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bPinKey[32];
	char szPlainPin[16];
	BYTE bCryptPin[8];
	BYTE bCryptPinExp[8];
	char szPan[24];
	int  nPanLen;

	bufclr(szPlainPin);
	bufclr(bPinKey);
	bufclr(szPan);
	bufclr(bCryptPin);
	bufclr(bCryptPinExp);

	nAlgo = 4;
	/* plain key = 0123456789ABCDEFFEDCBA9876543210 */
	sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

	sprintf(szPlainPin, "1234567890123");
	sprintf(szPan, "1234567890123456");
	nPanLen = 16;

	XXX_INPUT_XXX
	printf("[IN ]nSock      = %d\n", nSock);
	printf("[IN ]nAlgo      = %d\n", nAlgo);
	printf("[IN ]szPan      = %s\n", szPan);
	printf("[IN ]nPanLen    = %d\n", nPanLen);
	DspHex("[IN ]bPinKey    =", bPinKey, 16);
	printf("[IN ]szPlainPin = %s\n", szPlainPin);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPIEncryptPinX98B_GM(nSock, nAlgo, szPan, nPanLen, bPinKey, \
				szPlainPin, bCryptPin);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 1, "13位PIN测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX	
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void EncryptPinX98B_GM_Test_12(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bPinKey[32];
	char szPlainPin[16];
	BYTE bCryptPin[8];
	BYTE bCryptPinExp[8];
	char szPan[24];
	int  nPanLen;

	bufclr(szPlainPin);
	bufclr(bPinKey);
	bufclr(szPan);
	bufclr(bCryptPin);
	bufclr(bCryptPinExp);

	nAlgo = 1;
	/* plain key = 0123456789ABCDEF */
	sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");

	sprintf(szPlainPin, "123456");
	sprintf(szPan, "1234567890123456");
	nPanLen = 16;
    memcpy(bCryptPinExp, "\x68\x67\x90\xAC\x2D\x5B\x2F\xFD", 8);

	XXX_INPUT_XXX
	printf("[IN ]nSock      = %d\n", nSock);
	printf("[IN ]nAlgo      = %d\n", nAlgo);
	printf("[IN ]szPan      = %s\n", szPan);
	printf("[IN ]nPanLen    = %d\n", nPanLen);
	DspHex("[IN ]bPinKey    =", bPinKey, 8);
	printf("[IN ]szPlainPin = %s\n", szPlainPin);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPIEncryptPinX98B_GM(nSock, nAlgo, szPan, nPanLen, bPinKey, \
				szPlainPin, bCryptPin);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "单倍长密钥测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[OUT]bCryptPin  =", bCryptPin, 8);
	DspHex("[OUT]expect     =", bCryptPinExp, 8);
	ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 8);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void EncryptPinX98B_GM_Test_13(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bPinKey[32];
	char szPlainPin[16];
	BYTE bCryptPin[8];
	BYTE bCryptPinExp[8];
	char szPan[24];
	int  nPanLen;

	bufclr(szPlainPin);
	bufclr(bPinKey);
	bufclr(szPan);
	bufclr(bCryptPin);
	bufclr(bCryptPinExp);

	nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
	sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
		       "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

	sprintf(szPlainPin, "123456");
	sprintf(szPan, "1234567890123456");
	nPanLen = 16;
    memcpy(bCryptPinExp, "\x79\x3A\xE1\xFC\xD3\x06\x49\x68", 8);

	XXX_INPUT_XXX
	printf("[IN ]nSock      = %d\n", nSock);
	printf("[IN ]nAlgo      = %d\n", nAlgo);
	printf("[IN ]szPan      = %s\n", szPan);
	printf("[IN ]nPanLen    = %d\n", nPanLen);
	DspHex("[IN ]bPinKey    =", bPinKey, 16);
	printf("[IN ]szPlainPin = %s\n", szPlainPin);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPIEncryptPinX98B_GM(nSock, nAlgo, szPan, nPanLen, bPinKey, \
				szPlainPin, bCryptPin);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "双倍长密钥测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[OUT]bCryptPin  =", bCryptPin, 8);
	DspHex("[OUT]expect     =", bCryptPinExp, 8);
	ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 8);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void EncryptPinX98B_GM_Test_14(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bPinKey[32];
	char szPlainPin[16];
	BYTE bCryptPin[8];
	BYTE bCryptPinExp[8];
	char szPan[24];
	int  nPanLen;

	bufclr(szPlainPin);
	bufclr(bPinKey);
	bufclr(szPan);
	bufclr(bCryptPin);
	bufclr(bCryptPinExp);

	nAlgo = 3;
	/* plain key = 0123456789ABCDEFFEDCBA98765432108796A5B4C3D2E1F0 */
	sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
			"\x59\x99\xC3\x06\xAB\x84\x01\xB2");

	sprintf(szPlainPin, "123456");
	sprintf(szPan, "1234567890123456");
	nPanLen = 16;
    memcpy(bCryptPinExp, "\x6C\x88\xF0\xE4\xCD\x99\xB8\xA4", 8);

	XXX_INPUT_XXX
	printf("[IN ]nSock      = %d\n", nSock);
	printf("[IN ]nAlgo      = %d\n", nAlgo);
	printf("[IN ]szPan      = %s\n", szPan);
	printf("[IN ]nPanLen    = %d\n", nPanLen);
	DspHex("[IN ]bPinKey    =", bPinKey, 24);
	printf("[IN ]szPlainPin = %s\n", szPlainPin);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPIEncryptPinX98B_GM(nSock, nAlgo, szPan, nPanLen, bPinKey, \
				szPlainPin, bCryptPin);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "三倍长密钥测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[OUT]bCryptPin  =", bCryptPin, 8);
	DspHex("[OUT]expect     =", bCryptPinExp, 8);
	ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 8);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void EncryptPinX98B_GM_Test_15(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bPinKey[32];
	char szPlainPin[16];
	BYTE bCryptPin[8];
	BYTE bCryptPinExp[8];
	char szPan[24];
	int  nPanLen;

	bufclr(szPlainPin);
	bufclr(bPinKey);
	bufclr(szPan);
	bufclr(bCryptPin);
	bufclr(bCryptPinExp);

	nAlgo = 4;
	/* plain key = 0123456789ABCDEFFEDCBA9876543210 */
	sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

	sprintf(szPlainPin, "123abc");
	sprintf(szPan, "1234567890123456");
	nPanLen = 16;
	memcpy(bCryptPinExp, "\x17\xF4\xE8\xF0\x85\x67\x91\xEF\xFD\x6A\x5F\xCE\xB2\x1A\x62\x3F", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock      = %d\n", nSock);
	printf("[IN ]nAlgo      = %d\n", nAlgo);
	printf("[IN ]szPan      = %s\n", szPan);
	printf("[IN ]nPanLen    = %d\n", nPanLen);
	DspHex("[IN ]bPinKey    =", bPinKey, 16);
	printf("[IN ]szPlainPin = %s\n", szPlainPin);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPIEncryptPinX98B_GM(nSock, nAlgo, szPan, nPanLen, bPinKey, \
				szPlainPin, bCryptPin);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 6, "无效密码-密码中含有非数字字符测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX	
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void EncryptPinX98B_GM_Test_16(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = -1;

	int  nAlgo;
	BYTE bPinKey[32];
	char szPlainPin[16];
	BYTE bCryptPin[8];
	BYTE bCryptPinExp[8];
	char szPan[24];
	int  nPanLen;

	bufclr(szPlainPin);
	bufclr(bPinKey);
	bufclr(szPan);
	bufclr(bCryptPin);
	bufclr(bCryptPinExp);

	nAlgo = 4;
	/* plain key = 0123456789ABCDEFFEDCBA9876543210 */
	sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

	sprintf(szPlainPin, "123456");
	sprintf(szPan, "1234567890123456");
	nPanLen = 16;

	XXX_INPUT_XXX
	printf("[IN ]nSock      = %d\n", nSock);
	printf("[IN ]nAlgo      = %d\n", nAlgo);
	printf("[IN ]szPan      = %s\n", szPan);
	printf("[IN ]nPanLen    = %d\n", nPanLen);
	DspHex("[IN ]bPinKey    =", bPinKey, 16);
	printf("[IN ]szPlainPin = %s\n", szPlainPin);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPIEncryptPinX98B_GM(nSock, nAlgo, szPan, nPanLen, bPinKey, \
				szPlainPin, bCryptPin);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 3, "无效Socket ID[-1]测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX	
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	nSock = SM_SOCK;

	XXX_TEST_END_XXX
}

void EncryptPinX98B_GM_Test_17(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = 8;

	int  nAlgo;
	BYTE bPinKey[32];
	char szPlainPin[16];
	BYTE bCryptPin[8];
	BYTE bCryptPinExp[8];
	char szPan[24];
	int  nPanLen;

	bufclr(szPlainPin);
	bufclr(bPinKey);
	bufclr(szPan);
	bufclr(bCryptPin);
	bufclr(bCryptPinExp);

	nAlgo = 4;
	/* plain key = 0123456789ABCDEFFEDCBA9876543210 */
	sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

	sprintf(szPlainPin, "123456");
	sprintf(szPan, "1234567890123456");
	nPanLen = 16;

	XXX_INPUT_XXX
	printf("[IN ]nSock      = %d\n", nSock);
	printf("[IN ]nAlgo      = %d\n", nAlgo);
	printf("[IN ]szPan      = %s\n", szPan);
	printf("[IN ]nPanLen    = %d\n", nPanLen);
	DspHex("[IN ]bPinKey    =", bPinKey, 16);
	printf("[IN ]szPlainPin = %s\n", szPlainPin);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPIEncryptPinX98B_GM(nSock, nAlgo, szPan, nPanLen, bPinKey, \
				szPlainPin, bCryptPin);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 3, "无效Socket ID[8]测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX	
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	nSock = SM_SOCK;

	XXX_TEST_END_XXX
}

void EncryptPinX98B_GM_Test_18(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bPinKey[32];
	char szPlainPin[16];
	BYTE bCryptPin[8];
	BYTE bCryptPinExp[8];
	char szPan[24];
	int  nPanLen;

	bufclr(szPlainPin);
	bufclr(bPinKey);
	bufclr(szPan);
	bufclr(bCryptPin);
	bufclr(bCryptPinExp);

	nAlgo = 4;
	/* plain key = 0123456789ABCDEFFEDCBA9876543210 */
	sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

	sprintf(szPlainPin, "123456");
	sprintf(szPan, "1234567890123");
	nPanLen = 13;
	memcpy(bCryptPinExp, "\xD6\x64\xC0\x7B\xA2\x19\x56\x2A\x23\x98\x41\x63\x2F\x09\x25\x77", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock      = %d\n", nSock);
	printf("[IN ]nAlgo      = %d\n", nAlgo);
	printf("[IN ]szPan      = %s\n", szPan);
	printf("[IN ]nPanLen    = %d\n", nPanLen);
	DspHex("[IN ]bPinKey    =", bPinKey, 16);
	printf("[IN ]szPlainPin = %s\n", szPlainPin);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPIEncryptPinX98B_GM(nSock, nAlgo, szPan, nPanLen, bPinKey, \
				szPlainPin, bCryptPin);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "13位PAN测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX	
	DspHex("[OUT]bCryptPin  =", bCryptPin, 16);
	DspHex("[OUT]expect     =", bCryptPinExp, 16);
	ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 16);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void EncryptPinX98B_GM_Test_19(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bPinKey[32];
	char szPlainPin[16];
	BYTE bCryptPin[8];
	BYTE bCryptPinExp[8];
	char szPan[24];
	int  nPanLen;

	bufclr(szPlainPin);
	bufclr(bPinKey);
	bufclr(szPan);
	bufclr(bCryptPin);
	bufclr(bCryptPinExp);

	nAlgo = 4;
	/* plain key = 0123456789ABCDEFFEDCBA9876543210 */
	sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

	sprintf(szPlainPin, "123456");
	sprintf(szPan, "12345678901234");
	nPanLen = 14;
	memcpy(bCryptPinExp, "\x6E\x2E\x00\x96\x7E\x4B\x02\x27\x68\x67\x68\xED\xE3\x93\x68\xEB", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock      = %d\n", nSock);
	printf("[IN ]nAlgo      = %d\n", nAlgo);
	printf("[IN ]szPan      = %s\n", szPan);
	printf("[IN ]nPanLen    = %d\n", nPanLen);
	DspHex("[IN ]bPinKey    =", bPinKey, 16);
	printf("[IN ]szPlainPin = %s\n", szPlainPin);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPIEncryptPinX98B_GM(nSock, nAlgo, szPan, nPanLen, bPinKey, \
				szPlainPin, bCryptPin);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "14位PAN测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX	
	DspHex("[OUT]bCryptPin  =", bCryptPin, 16);
	DspHex("[OUT]expect     =", bCryptPinExp, 16);
	ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 16);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void EncryptPinX98B_GM_Test_20(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bPinKey[32];
	char szPlainPin[16];
	BYTE bCryptPin[8];
	BYTE bCryptPinExp[8];
	char szPan[24];
	int  nPanLen;

	bufclr(szPlainPin);
	bufclr(bPinKey);
	bufclr(szPan);
	bufclr(bCryptPin);
	bufclr(bCryptPinExp);

	nAlgo = 4;
	/* plain key = 0123456789ABCDEFFEDCBA9876543210 */
	sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

	sprintf(szPlainPin, "123456");
	sprintf(szPan, "123456789012345");
	nPanLen = 15;
	memcpy(bCryptPinExp, "\x2D\xE4\xFA\x64\x5A\x5A\xEE\x6E\xE0\x3B\x33\x90\x9F\x58\x5E\xAC", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock      = %d\n", nSock);
	printf("[IN ]nAlgo      = %d\n", nAlgo);
	printf("[IN ]szPan      = %s\n", szPan);
	printf("[IN ]nPanLen    = %d\n", nPanLen);
	DspHex("[IN ]bPinKey    =", bPinKey, 16);
	printf("[IN ]szPlainPin = %s\n", szPlainPin);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPIEncryptPinX98B_GM(nSock, nAlgo, szPan, nPanLen, bPinKey, \
				szPlainPin, bCryptPin);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "15位PAN测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX	
	DspHex("[OUT]bCryptPin  =", bCryptPin, 16);
	DspHex("[OUT]expect     =", bCryptPinExp, 16);
	ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 16);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void EncryptPinX98B_GM_Test_21(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bPinKey[32];
	char szPlainPin[16];
	BYTE bCryptPin[8];
	BYTE bCryptPinExp[8];
	char szPan[24];
	int  nPanLen;

	bufclr(szPlainPin);
	bufclr(bPinKey);
	bufclr(szPan);
	bufclr(bCryptPin);
	bufclr(bCryptPinExp);

	nAlgo = 4;
	/* plain key = 0123456789ABCDEFFEDCBA9876543210 */
	sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

	sprintf(szPlainPin, "123456");
	sprintf(szPan, "12345678901234567");
	nPanLen = 17;
	memcpy(bCryptPinExp, "\x6A\xC7\x01\x9A\xCF\x50\x1A\x96\x99\x61\xB3\x23\x93\xFC\xFB\x47", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock      = %d\n", nSock);
	printf("[IN ]nAlgo      = %d\n", nAlgo);
	printf("[IN ]szPan      = %s\n", szPan);
	printf("[IN ]nPanLen    = %d\n", nPanLen);
	DspHex("[IN ]bPinKey    =", bPinKey, 16);
	printf("[IN ]szPlainPin = %s\n", szPlainPin);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPIEncryptPinX98B_GM(nSock, nAlgo, szPan, nPanLen, bPinKey, \
				szPlainPin, bCryptPin);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "17位PAN测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX	
	DspHex("[OUT]bCryptPin  =", bCryptPin, 16);
	DspHex("[OUT]expect     =", bCryptPinExp, 16);
	ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 16);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void EncryptPinX98B_GM_Test_22(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bPinKey[32];
	char szPlainPin[16];
	BYTE bCryptPin[8];
	BYTE bCryptPinExp[8];
	char szPan[24];
	int  nPanLen;

	bufclr(szPlainPin);
	bufclr(bPinKey);
	bufclr(szPan);
	bufclr(bCryptPin);
	bufclr(bCryptPinExp);

	nAlgo = 4;
	/* plain key = 0123456789ABCDEFFEDCBA9876543210 */
	sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

	sprintf(szPlainPin, "123456");
	sprintf(szPan, "123456789012345678");
	nPanLen = 18;
	memcpy(bCryptPinExp, "\x52\xDF\x1B\xC9\x45\x10\x41\x17\x90\xB4\x00\x8A\xE8\xA1\xE7\x97", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock      = %d\n", nSock);
	printf("[IN ]nAlgo      = %d\n", nAlgo);
	printf("[IN ]szPan      = %s\n", szPan);
	printf("[IN ]nPanLen    = %d\n", nPanLen);
	DspHex("[IN ]bPinKey    =", bPinKey, 16);
	printf("[IN ]szPlainPin = %s\n", szPlainPin);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPIEncryptPinX98B_GM(nSock, nAlgo, szPan, nPanLen, bPinKey, \
				szPlainPin, bCryptPin);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "18位PAN测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX	
	DspHex("[OUT]bCryptPin  =", bCryptPin, 16);
	DspHex("[OUT]expect     =", bCryptPinExp, 16);
	ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 16);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void EncryptPinX98B_GM_Test_23(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bPinKey[32];
	char szPlainPin[16];
	BYTE bCryptPin[8];
	BYTE bCryptPinExp[8];
	char szPan[24];
	int  nPanLen;

	bufclr(szPlainPin);
	bufclr(bPinKey);
	bufclr(szPan);
	bufclr(bCryptPin);
	bufclr(bCryptPinExp);

	nAlgo = 4;
	/* plain key = 0123456789ABCDEFFEDCBA9876543210 */
	sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

	sprintf(szPlainPin, "123456789012");
	sprintf(szPan, "1234567890123456789");
	nPanLen = 19;
	memcpy(bCryptPinExp, "\xB0\x48\xC8\x8B\xD3\x55\x34\x2C\x15\xAF\x61\xE7\xA1\x77\x0F\x4F", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock      = %d\n", nSock);
	printf("[IN ]nAlgo      = %d\n", nAlgo);
	printf("[IN ]szPan      = %s\n", szPan);
	printf("[IN ]nPanLen    = %d\n", nPanLen);
	DspHex("[IN ]bPinKey    =", bPinKey, 16);
	printf("[IN ]szPlainPin = %s\n", szPlainPin);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPIEncryptPinX98B_GM(nSock, nAlgo, szPan, nPanLen, bPinKey, \
				szPlainPin, bCryptPin);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "12位PIN19位PAN测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX	
	DspHex("[OUT]bCryptPin  =", bCryptPin, 16);
	DspHex("[OUT]expect     =", bCryptPinExp, 16);
	ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 16);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void EncryptPinX98B_GM_Test_24(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bPinKey[32];
	char szPlainPin[16];
	BYTE bCryptPin[8];
	BYTE bCryptPinExp[8];
	char szPan[24];
	int  nPanLen;

	bufclr(szPlainPin);
	bufclr(bPinKey);
	bufclr(szPan);
	bufclr(bCryptPin);
	bufclr(bCryptPinExp);

	nAlgo = 4;
	/* plain key = 0123456789ABCDEFFEDCBA9876543210 */
	sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

	sprintf(szPlainPin, "123456");
	sprintf(szPan, "123456789012");
	nPanLen = 12;

	XXX_INPUT_XXX
	printf("[IN ]nSock      = %d\n", nSock);
	printf("[IN ]nAlgo      = %d\n", nAlgo);
	printf("[IN ]szPan      = %s\n", szPan);
	printf("[IN ]nPanLen    = %d\n", nPanLen);
	DspHex("[IN ]bPinKey    =", bPinKey, 16);
	printf("[IN ]szPlainPin = %s\n", szPlainPin);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPIEncryptPinX98B_GM(nSock, nAlgo, szPan, nPanLen, bPinKey, \
				szPlainPin, bCryptPin);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 1, "12位PAN测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX	
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void EncryptPinX98B_GM_Test_25(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bPinKey[32];
	char szPlainPin[16];
	BYTE bCryptPin[8];
	BYTE bCryptPinExp[8];
	char szPan[24];
	int  nPanLen;

	bufclr(szPlainPin);
	bufclr(bPinKey);
	bufclr(szPan);
	bufclr(bCryptPin);
	bufclr(bCryptPinExp);

	nAlgo = 4;
	/* plain key = 0123456789ABCDEFFEDCBA9876543210 */
	sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

	sprintf(szPlainPin, "123456");
	sprintf(szPan, "12345678901234567890");
	nPanLen = 20;

	XXX_INPUT_XXX
	printf("[IN ]nSock      = %d\n", nSock);
	printf("[IN ]nAlgo      = %d\n", nAlgo);
	printf("[IN ]szPan      = %s\n", szPan);
	printf("[IN ]nPanLen    = %d\n", nPanLen);
	DspHex("[IN ]bPinKey    =", bPinKey, 16);
	printf("[IN ]szPlainPin = %s\n", szPlainPin);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPIEncryptPinX98B_GM(nSock, nAlgo, szPan, nPanLen, bPinKey, \
				szPlainPin, bCryptPin);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 1, "20位PAN测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX	
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void EncryptPinX98B_GM_Test_26(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bPinKey[32];
	char szPlainPin[16];
	BYTE bCryptPin[8];
	BYTE bCryptPinExp[8];
	char szPan[24];
	int  nPanLen;

	bufclr(szPlainPin);
	bufclr(bPinKey);
	bufclr(szPan);
	bufclr(bCryptPin);
	bufclr(bCryptPinExp);

	nAlgo = 4;
	/* plain key = 0123456789ABCDEFFEDCBA9876543210 */
	sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

	sprintf(szPlainPin, "123456");
	sprintf(szPan, "1234567abc123456");
	nPanLen = 16;

	XXX_INPUT_XXX
	printf("[IN ]nSock      = %d\n", nSock);
	printf("[IN ]nAlgo      = %d\n", nAlgo);
	printf("[IN ]szPan      = %s\n", szPan);
	printf("[IN ]nPanLen    = %d\n", nPanLen);
	DspHex("[IN ]bPinKey    =", bPinKey, 16);
	printf("[IN ]szPlainPin = %s\n", szPlainPin);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPIEncryptPinX98B_GM(nSock, nAlgo, szPan, nPanLen, bPinKey, \
				szPlainPin, bCryptPin);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 1, "无效账号-账号中含有非数字字符测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX	
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void EncryptPinX98B_GM_Test_27(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bPinKey[32];
	char szPlainPin[16];
	BYTE bCryptPin[8];
	BYTE bCryptPinExp[8];
	char szPan[24];
	int  nPanLen;

	bufclr(szPlainPin);
	bufclr(bPinKey);
	bufclr(szPan);
	bufclr(bCryptPin);
	bufclr(bCryptPinExp);

	nAlgo = 4;
	/* plain key = 0123456789ABCDEFFEDCBA9876543210 */
	sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

	sprintf(szPlainPin, "123456");
	sprintf(szPan, "abc1234567123456");
	nPanLen = 16;

	XXX_INPUT_XXX
	printf("[IN ]nSock      = %d\n", nSock);
	printf("[IN ]nAlgo      = %d\n", nAlgo);
	printf("[IN ]szPan      = %s\n", szPan);
	printf("[IN ]nPanLen    = %d\n", nPanLen);
	DspHex("[IN ]bPinKey    =", bPinKey, 16);
	printf("[IN ]szPlainPin = %s\n", szPlainPin);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPIEncryptPinX98B_GM(nSock, nAlgo, szPan, nPanLen, bPinKey, \
				szPlainPin, bCryptPin);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 1, "无效账号-账号中含有非数字字符测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX	
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}
void EncryptPinX98B_GM_Test_28(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bPinKey[32];
	char szPlainPin[16];
	BYTE bCryptPin[8];
	BYTE bCryptPinExp[8];
	char szPan[24];
	int  nPanLen;

	bufclr(szPlainPin);
	bufclr(bPinKey);
	bufclr(szPan);
	bufclr(bCryptPin);
	bufclr(bCryptPinExp);

	nAlgo = 4;
	/* plain key = 0123456789ABCDEFFEDCBA9876543210 */
	sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

	sprintf(szPlainPin, "123456");
	sprintf(szPan, "1234567123456ABC");
	nPanLen = 16;

	XXX_INPUT_XXX
	printf("[IN ]nSock      = %d\n", nSock);
	printf("[IN ]nAlgo      = %d\n", nAlgo);
	printf("[IN ]szPan      = %s\n", szPan);
	printf("[IN ]nPanLen    = %d\n", nPanLen);
	DspHex("[IN ]bPinKey    =", bPinKey, 16);
	printf("[IN ]szPlainPin = %s\n", szPlainPin);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPIEncryptPinX98B_GM(nSock, nAlgo, szPan, nPanLen, bPinKey, \
				szPlainPin, bCryptPin);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 1, "无效账号-账号中含有非数字字符测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX	
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void EncryptPinX98B_GM_Test_29(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bPinKey[32];
	char szPlainPin[16];
	BYTE bCryptPin[8];
	BYTE bCryptPinExp[8];
	char szPan[24];
	int  nPanLen;

	bufclr(szPlainPin);
	bufclr(bPinKey);
	bufclr(szPan);
	bufclr(bCryptPin);
	bufclr(bCryptPinExp);

	nAlgo = 0;
	/* plain key = 0123456789ABCDEFFEDCBA9876543210 */
	sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

	sprintf(szPlainPin, "123456");
	sprintf(szPan, "1234567890123456");
	nPanLen = 16;

	XXX_INPUT_XXX
	printf("[IN ]nSock      = %d\n", nSock);
	printf("[IN ]nAlgo      = %d\n", nAlgo);
	printf("[IN ]szPan      = %s\n", szPan);
	printf("[IN ]nPanLen    = %d\n", nPanLen);
	DspHex("[IN ]bPinKey    =", bPinKey, 16);
	printf("[IN ]szPlainPin = %s\n", szPlainPin);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPIEncryptPinX98B_GM(nSock, nAlgo, szPan, nPanLen, bPinKey, \
				szPlainPin, bCryptPin);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 1, "无效算法类型[0]测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX	
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void EncryptPinX98B_GM_Test_30(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bPinKey[32];
	char szPlainPin[16];
	BYTE bCryptPin[8];
	BYTE bCryptPinExp[8];
	char szPan[24];
	int  nPanLen;

	bufclr(szPlainPin);
	bufclr(bPinKey);
	bufclr(szPan);
	bufclr(bCryptPin);
	bufclr(bCryptPinExp);

	nAlgo = 5;
	/* plain key = 0123456789ABCDEFFEDCBA9876543210 */
	sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

	sprintf(szPlainPin, "123456");
	sprintf(szPan, "1234567890123456");
	nPanLen = 16;

	XXX_INPUT_XXX
	printf("[IN ]nSock      = %d\n", nSock);
	printf("[IN ]nAlgo      = %d\n", nAlgo);
	printf("[IN ]szPan      = %s\n", szPan);
	printf("[IN ]nPanLen    = %d\n", nPanLen);
	DspHex("[IN ]bPinKey    =", bPinKey, 16);
	printf("[IN ]szPlainPin = %s\n", szPlainPin);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPIEncryptPinX98B_GM(nSock, nAlgo, szPan, nPanLen, bPinKey, \
				szPlainPin, bCryptPin);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 1, "无效算法类型[5]测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX	
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void CalcMAC_GM_Test_01(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;
	int  nMode;
	BYTE bMacKey[32];
	int  nMakLen;
	BYTE bMsgBuf[2056];
	int  nMsgLen;
	BYTE bMAC[16];
	BYTE bMACExp[16];
	BYTE bIV[32]; 

	bufclr(bMacKey);
	bufclr(bMsgBuf);
	bufclr(bMAC);
	bufclr(bMACExp);
	bufclr(bIV);

	nMode = 1;
	nMakLen = 8;
	nMsgLen = 8;
	//MsgBuf = 2B2C2C2C2C2C2C3F0000000000000000
	memset(bMsgBuf, 0x2C, 8);
	bMsgBuf[0] = 0x2B;
	bMsgBuf[7] = 0x3F;
	//Plain MAK = 0123 4567 89AB CDEF
	memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
	memcpy(bMACExp, "\xE6\xAB\x82\xB3\xFF\xBC\xC0\xFD", 8);
	memcpy(bIV, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock   = %d\n", nSock);
	printf("[IN ]nMode   = %d\n", nMode);
	DspHex("[IN ]bMacKey =", bMacKey, 8);
	DspHex("[IN ]bMsgBuf =", bMsgBuf, 8);
	printf("[IN ]nMsgLen = %d\n", nMsgLen);
	DspHex("[IN ]bIV =", bIV, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPICalcMac_GM(nSock, nMode, bMacKey,  \
			bMsgBuf, nMsgLen, bIV, bMAC);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "Mode=1,MsgLen=8测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[IN ]bMAC    =", bMAC, 16);
	DspHex("[IN ]bMACExp =", bMACExp, 16);
	ASSERT_OUT_HEX(bMAC, bMACExp, 8);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void CalcMAC_GM_Test_02(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;
	int  nMode;
	BYTE bMacKey[32];
	int  nMakLen;
	BYTE bMsgBuf[2056];
	int  nMsgLen;
	BYTE bMAC[16];
	BYTE bMACExp[16];
	BYTE bIV[32]; 

	bufclr(bMacKey);
	bufclr(bMsgBuf);
	bufclr(bMAC);
	bufclr(bMACExp);
	bufclr(bIV);

	nMode = 2;
	nMakLen = 8;
	nMsgLen = 8;
	memset(bMsgBuf, 0x2C, 8);
	bMsgBuf[0] = 0x2B;
	bMsgBuf[7] = 0x3F;
	//Plain MAK = 0123 4567 89AB CDEF
	memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
	memcpy(bMACExp, "\xE6\xAB\x82\xB3\xFF\xBC\xC0\xFD", 8);
	memcpy(bIV, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock   = %d\n", nSock);
	printf("[IN ]nMode   = %d\n", nMode);
	DspHex("[IN ]bMacKey =", bMacKey, 8);
	DspHex("[IN ]bMsgBuf =", bMsgBuf, 8);
	printf("[IN ]nMsgLen = %d\n", nMsgLen);
	DspHex("[IN ]bIV =", bIV, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPICalcMac_GM(nSock, nMode, bMacKey,  \
			bMsgBuf, nMsgLen, bIV, bMAC);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "Mode=2,MsgLen=8测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[IN ]bMAC    =", bMAC, 16);
	DspHex("[IN ]bMACExp =", bMACExp, 16);
	ASSERT_OUT_HEX(bMAC, bMACExp, 8);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void CalcMAC_GM_Test_03(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;
	int  nMode;
	BYTE bMacKey[32];
	int  nMakLen;
	BYTE bMsgBuf[2056];
	int  nMsgLen;
	BYTE bMAC[16];
	BYTE bMACExp[16];
	BYTE bIV[32]; 

	bufclr(bMacKey);
	bufclr(bMsgBuf);
	bufclr(bMAC);
	bufclr(bMACExp);
	bufclr(bIV);

	nMode = 3;
	nMakLen = 16;
	nMsgLen = 8;
	memset(bMsgBuf, 0x2C, 8);
	bMsgBuf[0] = 0x2B;
	bMsgBuf[7] = 0x3F;
	//Plain MAK = 0123 4567 89AB CDEF FEDC BA98 7654 3210 
	memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
		    "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
		    16);
	memcpy(bMACExp, "\xD6\x6B\x65\xFE\x05\xEC\x11\xE8", 8);
	memcpy(bIV, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock   = %d\n", nSock);
	printf("[IN ]nMode   = %d\n", nMode);
	DspHex("[IN ]bMacKey =", bMacKey, 16);
	DspHex("[IN ]bMsgBuf =", bMsgBuf, 8);
	printf("[IN ]nMsgLen = %d\n", nMsgLen);
	DspHex("[IN ]bIV =", bIV, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPICalcMac_GM(nSock, nMode, bMacKey,  \
			bMsgBuf, nMsgLen, bIV, bMAC);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "Mode=3,MsgLen=8测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[IN ]bMAC    =", bMAC, 16);
	DspHex("[IN ]bMACExp =", bMACExp, 16);
	ASSERT_OUT_HEX(bMAC, bMACExp, 8);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void CalcMAC_GM_Test_04(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;
	int  nMode;
	BYTE bMacKey[32];
	int  nMakLen;
	BYTE bMsgBuf[2056];
	int  nMsgLen;
	BYTE bMAC[16];
	BYTE bMACExp[16];
	BYTE bIV[32]; 

	bufclr(bMacKey);
	bufclr(bMsgBuf);
	bufclr(bMAC);
	bufclr(bMACExp);
	bufclr(bIV);

	nMode = 4;
	nMakLen = 16;
	nMsgLen = 8;
	memset(bMsgBuf, 0x2C, 8);
	bMsgBuf[0] = 0x2B;
	bMsgBuf[7] = 0x3F;
	//Plain MAK = 0123 4567 89AB CDEF FEDC BA98 7654 3210 
	memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
		    "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
		    16);
	memcpy(bMACExp, "\x70\xD0\x52\xB8\xF0\x7F\x42\x16\xEE\x20\x6E\xAA\x17\x2F\xA7\xDE", 16);
	memcpy(bIV, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock   = %d\n", nSock);
	printf("[IN ]nMode   = %d\n", nMode);
	DspHex("[IN ]bMacKey =", bMacKey, 16);
	DspHex("[IN ]bMsgBuf =", bMsgBuf, 8);
	printf("[IN ]nMsgLen = %d\n", nMsgLen);
	DspHex("[IN ]bIV =", bIV, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPICalcMac_GM(nSock, nMode, bMacKey,  \
			bMsgBuf, nMsgLen, bIV, bMAC);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "Mode=4,MsgLen=8测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[IN ]bMAC    =", bMAC, 16);
	DspHex("[IN ]bMACExp =", bMACExp, 16);
	ASSERT_OUT_HEX(bMAC, bMACExp, 16);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void CalcMAC_GM_Test_05(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;
	int  nMode;
	BYTE bMacKey[32];
	int  nMakLen;
	BYTE bMsgBuf[2056];
	int  nMsgLen;
	BYTE bMAC[16];
	BYTE bMACExp[16];
	BYTE bIV[32]; 

	bufclr(bMacKey);
	bufclr(bMsgBuf);
	bufclr(bMAC);
	bufclr(bMACExp);
	bufclr(bIV);

	nMode = 5;
	nMakLen = 16;
	nMsgLen = 8;
	memset(bMsgBuf, 0x2C, 8);
	bMsgBuf[0] = 0x2B;
	bMsgBuf[7] = 0x3F;
	//Plain MAK = 0123 4567 89AB CDEF FEDC BA98 7654 3210 
	memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
		    "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
		    16);
	memcpy(bMACExp, "\x70\xD0\x52\xB8\xF0\x7F\x42\x16\xEE\x20\x6E\xAA\x17\x2F\xA7\xDE", 16);
	memcpy(bIV, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock   = %d\n", nSock);
	printf("[IN ]nMode   = %d\n", nMode);
	DspHex("[IN ]bMacKey =", bMacKey, 16);
	DspHex("[IN ]bMsgBuf =", bMsgBuf, 8);
	printf("[IN ]nMsgLen = %d\n", nMsgLen);
	DspHex("[IN ]bIV =", bIV, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPICalcMac_GM(nSock, nMode, bMacKey,  \
			bMsgBuf, nMsgLen, bIV, bMAC);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "Mode=5,MsgLen=8测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[IN ]bMAC    =", bMAC, 16);
	DspHex("[IN ]bMACExp =", bMACExp, 16);
	ASSERT_OUT_HEX(bMAC, bMACExp, 16);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void CalcMAC_GM_Test_06(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;
	int  nMode;
	BYTE bMacKey[32];
	int  nMakLen;
	BYTE bMsgBuf[2056];
	int  nMsgLen;
	BYTE bMAC[16];
	BYTE bMACExp[16];
	BYTE bIV[32]; 

	bufclr(bMacKey);
	bufclr(bMsgBuf);
	bufclr(bMAC);
	bufclr(bMACExp);
	bufclr(bIV);

	nMode = 6;
	nMakLen = 16;
	nMsgLen = 8;
	memset(bMsgBuf, 0x2C, 8);
	bMsgBuf[0] = 0x2B;
	bMsgBuf[7] = 0x3F;
	//Plain MAK = 0123 4567 89AB CDEF FEDC BA98 7654 3210 
	memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
		    "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
		    16);
	memcpy(bMACExp, "\x41\x00\x59\xB5\x50\x48\xDD\xB4\x4C\x75\x47\x13\xB0\x84\x33\xDF", 16);
	memcpy(bIV, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock   = %d\n", nSock);
	printf("[IN ]nMode   = %d\n", nMode);
	DspHex("[IN ]bMacKey =", bMacKey, 16);
	DspHex("[IN ]bMsgBuf =", bMsgBuf, 8);
	printf("[IN ]nMsgLen = %d\n", nMsgLen);
	DspHex("[IN ]bIV =", bIV, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPICalcMac_GM(nSock, nMode, bMacKey,  \
			bMsgBuf, nMsgLen, bIV, bMAC);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "Mode=6,MsgLen=8测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[IN ]bMAC    =", bMAC, 16);
	DspHex("[IN ]bMACExp =", bMACExp, 16);
	ASSERT_OUT_HEX(bMAC, bMACExp, 16);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void CalcMAC_GM_Test_07(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;
	int  nMode;
	BYTE bMacKey[32];
	int  nMakLen;
	BYTE bMsgBuf[2056];
	int  nMsgLen;
	BYTE bMAC[16];
	BYTE bMACExp[16];
	BYTE bIV[32]; 

	bufclr(bMacKey);
	bufclr(bMsgBuf);
	bufclr(bMAC);
	bufclr(bMACExp);
	bufclr(bIV);

	nMode = 7;
	nMakLen = 16;
	nMsgLen = 8;
	memset(bMsgBuf, 0x2C, 8);
	bMsgBuf[0] = 0x2B;
	bMsgBuf[7] = 0x3F;
	//Plain MAK = 0123 4567 89AB CDEF FEDC BA98 7654 3210 
	memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
		    "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
		    16);
	memcpy(bMACExp, "\x41\x00\x59\xB5\x50\x48\xDD\xB4\x4C\x75\x47\x13\xB0\x84\x33\xDF", 16);
	memcpy(bIV, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock   = %d\n", nSock);
	printf("[IN ]nMode   = %d\n", nMode);
	DspHex("[IN ]bMacKey =", bMacKey, 16);
	DspHex("[IN ]bMsgBuf =", bMsgBuf, 8);
	printf("[IN ]nMsgLen = %d\n", nMsgLen);
	DspHex("[IN ]bIV =", bIV, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPICalcMac_GM(nSock, nMode, bMacKey,  \
			bMsgBuf, nMsgLen, bIV, bMAC);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "Mode=7,MsgLen=8测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[IN ]bMAC    =", bMAC, 16);
	DspHex("[IN ]bMACExp =", bMACExp, 16);
	ASSERT_OUT_HEX(bMAC, bMACExp, 16);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void CalcMAC_GM_Test_08(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;
	int  nMode;
	BYTE bMacKey[32];
	int  nMakLen;
	BYTE bMsgBuf[4000];
	int  nMsgLen;
	BYTE bMAC[16];
	BYTE bMACExp[16];
	BYTE bIV[32]; 

	bufclr(bMacKey);
	bufclr(bMsgBuf);
	bufclr(bMAC);
	bufclr(bMACExp);
	bufclr(bIV);

	nMode = 4;
	nMakLen = 16;
	nMsgLen = 4000;
	memset(bMsgBuf, 0x2C, 4000);
	bMsgBuf[0] = 0x2B;
	bMsgBuf[3999] = 0x3F;
	//Plain MAK = 0123 4567 89AB CDEF FEDC BA98 7654 3210 
	memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
		    "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
		    16);
	memcpy(bMACExp, "\xCF\xE0\x9F\xAD\x70\x96\x19\xB7\xCA\x09\x03\xBF\xE1\xAB\xF3\xCE", 16);
	memcpy(bIV, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock   = %d\n", nSock);
	printf("[IN ]nMode   = %d\n", nMode);
	DspHex("[IN ]bMacKey =", bMacKey, 16);
	//DspHex("[IN ]bMsgBuf =", bMsgBuf, 4000);
	printf("[IN ]nMsgLen = %d\n", nMsgLen);
	DspHex("[IN ]bIV =", bIV, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPICalcMac_GM(nSock, nMode, bMacKey,  \
			bMsgBuf, nMsgLen, bIV, bMAC);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "Mode=4,MsgLen=4000测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[IN ]bMAC    =", bMAC, 16);
	DspHex("[IN ]bMACExp =", bMACExp, 16);
	ASSERT_OUT_HEX(bMAC, bMACExp, 16);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void CalcMAC_GM_Test_09(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;
	int  nMode;
	BYTE bMacKey[32];
	int  nMakLen;
	BYTE bMsgBuf[4000];
	int  nMsgLen;
	BYTE bMAC[16];
	BYTE bMACExp[16];
	BYTE bIV[32]; 

	bufclr(bMacKey);
	bufclr(bMsgBuf);
	bufclr(bMAC);
	bufclr(bMACExp);
	bufclr(bIV);

	nMode = 5;
	nMakLen = 16;
	nMsgLen = 3984;
	memset(bMsgBuf, 0x2C, 3984);
	bMsgBuf[0] = 0x2B;
	bMsgBuf[3983] = 0x3F;
	//Plain MAK = 0123 4567 89AB CDEF FEDC BA98 7654 3210 
	memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
		    "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
		    16);
	memcpy(bMACExp, "\x54\xD4\xFF\xDB\x21\x30\xA2\xE4\xA4\x4D\x48\x78\xB0\x2F\x12\x6C", 16);
	memcpy(bIV, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock   = %d\n", nSock);
	printf("[IN ]nMode   = %d\n", nMode);
	DspHex("[IN ]bMacKey =", bMacKey, 16);
	//DspHex("[IN ]bMsgBuf =", bMsgBuf, 3984);
	printf("[IN ]nMsgLen = %d\n", nMsgLen);
	DspHex("[IN ]bIV =", bIV, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPICalcMac_GM(nSock, nMode, bMacKey,  \
			bMsgBuf, nMsgLen, bIV, bMAC);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "Mode=5,MsgLen=3984测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[IN ]bMAC    =", bMAC, 16);
	DspHex("[IN ]bMACExp =", bMACExp, 16);
	ASSERT_OUT_HEX(bMAC, bMACExp, 16);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void CalcMAC_GM_Test_10(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;
	int  nMode;
	BYTE bMacKey[32];
	int  nMakLen;
	BYTE bMsgBuf[4000];
	int  nMsgLen;
	BYTE bMAC[16];
	BYTE bMACExp[16];
	BYTE bIV[32]; 

	bufclr(bMacKey);
	bufclr(bMsgBuf);
	bufclr(bMAC);
	bufclr(bMACExp);
	bufclr(bIV);

	nMode = 6;
	nMakLen = 16;
	nMsgLen = 3984;
	memset(bMsgBuf, 0x2C, 3984);
	bMsgBuf[0] = 0x2B;
	bMsgBuf[3983] = 0x3F;
	//Plain MAK = 0123 4567 89AB CDEF FEDC BA98 7654 3210 
	memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
		    "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
		    16);
	memcpy(bMACExp, "\xF6\x5C\xB9\x20\xEA\x10\x4C\x2D\x7C\x37\xDC\xF0\x91\xC8\x76\x55", 16);
	memcpy(bIV, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock   = %d\n", nSock);
	printf("[IN ]nMode   = %d\n", nMode);
	DspHex("[IN ]bMacKey =", bMacKey, 16);
//	DspHex("[IN ]bMsgBuf =", bMsgBuf, 3984);
	printf("[IN ]nMsgLen = %d\n", nMsgLen);
	DspHex("[IN ]bIV =", bIV, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPICalcMac_GM(nSock, nMode, bMacKey,  \
			bMsgBuf, nMsgLen, bIV, bMAC);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "Mode=6,MsgLen=3984测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[IN ]bMAC    =", bMAC, 16);
	DspHex("[IN ]bMACExp =", bMACExp, 16);
	ASSERT_OUT_HEX(bMAC, bMACExp, 16);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}


void CalcMAC_GM_Test_11(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;
	int  nMode;
	BYTE bMacKey[32];
	int  nMakLen;
	BYTE bMsgBuf[4000];
	int  nMsgLen;
	BYTE bMAC[16];
	BYTE bMACExp[16];
	BYTE bIV[32]; 

	bufclr(bMacKey);
	bufclr(bMsgBuf);
	bufclr(bMAC);
	bufclr(bMACExp);
	bufclr(bIV);

	nMode = 7;
	nMakLen = 16;
	nMsgLen = 3984;
	memset(bMsgBuf, 0x2C, 3984);
	bMsgBuf[0] = 0x2B;
	bMsgBuf[3983] = 0x3F;
	//Plain MAK = 0123 4567 89AB CDEF FEDC BA98 7654 3210 
	memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
		    "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
		    16);
	memcpy(bMACExp, "\x3E\x2F\xFD\x47\x7B\x97\xD7\xB2\xFA\xF2\xE4\x4C\x49\x1F\xEF\x8E", 16);
	memcpy(bIV, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock   = %d\n", nSock);
	printf("[IN ]nMode   = %d\n", nMode);
	DspHex("[IN ]bMacKey =", bMacKey, 16);
//	DspHex("[IN ]bMsgBuf =", bMsgBuf, 3984);
	printf("[IN ]nMsgLen = %d\n", nMsgLen);
	DspHex("[IN ]bIV =", bIV, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPICalcMac_GM(nSock, nMode, bMacKey,  \
			bMsgBuf, nMsgLen, bIV, bMAC);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "Mode=7,MsgLen=3984测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[IN ]bMAC    =", bMAC, 16);
	DspHex("[IN ]bMACExp =", bMACExp, 16);
	ASSERT_OUT_HEX(bMAC, bMACExp, 16);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void CalcMAC_GM_Test_12(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;
	int  nMode;
	BYTE bMacKey[32];
	int  nMakLen;
	BYTE bMsgBuf[2056];
	int  nMsgLen;
	BYTE bMAC[8];
	BYTE bMACExp[8];
	BYTE bIV[32]; 

	bufclr(bMacKey);
	bufclr(bMsgBuf);
	bufclr(bMAC);
	bufclr(bMACExp);
	bufclr(bIV);

	nMode = 1;
	nMakLen = 8;
	nMsgLen = 2048;
	memset(bMsgBuf, 0x2C, 2048);
	bMsgBuf[0] = 0x2B;
	bMsgBuf[2047] = 0x3F;
	memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
	memcpy(bMACExp, "\xA0\x20\x7B\x55\x7C\xFE\x2D\xFE", 8);
	memcpy(bIV, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock   = %d\n", nSock);
	printf("[IN ]nMode   = %d\n", nMode);
	DspHex("[IN ]bMacKey =", bMacKey, 8);
//	DspHex("[IN ]bMsgBuf =", bMsgBuf, 2048);
	printf("[IN ]nMsgLen = %d\n", nMsgLen);
	DspHex("[IN ]bIV =", bIV, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPICalcMac_GM(nSock, nMode, bMacKey,  \
			bMsgBuf, nMsgLen, bIV, bMAC);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "nMode=1,MsgLen=2048测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[IN ]bMAC    =", bMAC, 8);
	DspHex("[IN ]bMACExp =", bMACExp, 8);
	ASSERT_OUT_HEX(bMAC, bMACExp, 8);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void CalcMAC_GM_Test_13(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;
	int  nMode;
	BYTE bMacKey[32];
	int  nMakLen;
	BYTE bMsgBuf[2056];
	int  nMsgLen;
	BYTE bMAC[8];
	BYTE bMACExp[8];
	BYTE bIV[32]; 

	bufclr(bMacKey);
	bufclr(bMsgBuf);
	bufclr(bMAC);
	bufclr(bMACExp);
	bufclr(bIV);

	nMode = 2;
	nMakLen = 8;
	nMsgLen = 2048;
	memset(bMsgBuf, 0x2C, 2048);
	bMsgBuf[0] = 0x2B;
	bMsgBuf[2047] = 0x3F;
	memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
	memcpy(bMACExp, "\x5E\x8C\xFC\x5E\x43\x5F\x5E\x65", 8);
	
	XXX_INPUT_XXX
	printf("[IN ]nSock   = %d\n", nSock);
	printf("[IN ]nMode   = %d\n", nMode);
	DspHex("[IN ]bMacKey =", bMacKey, 8);
//	DspHex("[IN ]bMsgBuf =", bMsgBuf, 2048);
	printf("[IN ]nMsgLen = %d\n", nMsgLen);
	DspHex("[IN ]bIV =", bIV, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPICalcMac_GM(nSock, nMode, bMacKey,  \
			bMsgBuf, nMsgLen, bIV, bMAC);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "nMode=2,MsgLen=2048测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[IN ]bMAC    =", bMAC, 8);
	DspHex("[IN ]bMACExp =", bMACExp, 8);
	ASSERT_OUT_HEX(bMAC, bMACExp, 8);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void CalcMAC_GM_Test_14(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;
	int  nMode;
	BYTE bMacKey[32];
	int  nMakLen;
	BYTE bMsgBuf[2056];
	int  nMsgLen;
	BYTE bMAC[8];
	BYTE bMACExp[8];
	BYTE bIV[32]; 

	bufclr(bMacKey);
	bufclr(bMsgBuf);
	bufclr(bMAC);
	bufclr(bMACExp);
	bufclr(bIV);

	nMode = 3;
	nMakLen = 16;
	nMsgLen = 2048;
	memset(bMsgBuf, 0x2C, 2048);
	bMsgBuf[0] = 0x2B;
	bMsgBuf[2047] = 0x3F;
    memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
              "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
			   16);
 	memcpy(bMACExp, "\x13\xE4\xEF\x64\x67\xD6\xE3\xE3", 8);

	XXX_INPUT_XXX
	printf("[IN ]nSock   = %d\n", nSock);
	printf("[IN ]nMode   = %d\n", nMode);
	DspHex("[IN ]bMacKey =", bMacKey, 8);
//	DspHex("[IN ]bMsgBuf =", bMsgBuf, 2048);
	printf("[IN ]nMsgLen = %d\n", nMsgLen);
	DspHex("[IN ]bIV =", bIV, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPICalcMac_GM(nSock, nMode, bMacKey,  \
			bMsgBuf, nMsgLen, bIV, bMAC);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "nMode=3,MsgLen=2048测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[IN ]bMAC    =", bMAC, 8);
	DspHex("[IN ]bMACExp =", bMACExp, 8);
	ASSERT_OUT_HEX(bMAC, bMACExp, 8);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void CalcMAC_GM_Test_15(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = -1;
	int  nMode;
	BYTE bMacKey[32];
	int  nMakLen;
	BYTE bMsgBuf[2056];
	int  nMsgLen;
	BYTE bMAC[16];
	BYTE bMACExp[16];
	BYTE bIV[32]; 

	bufclr(bMacKey);
	bufclr(bMsgBuf);
	bufclr(bMAC);
	bufclr(bMACExp);
	bufclr(bIV);

	nMode = 5;
	nMakLen = 16;
	nMsgLen = 8;
	memset(bMsgBuf, 0x2C, 8);
	bMsgBuf[0] = 0x2B;
	bMsgBuf[7] = 0x3F;
	//Plain MAK = 0123 4567 89AB CDEF FEDC BA98 7654 3210 
	memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
		    "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
		    16);
	memcpy(bIV, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock   = %d\n", nSock);
	printf("[IN ]nMode   = %d\n", nMode);
	DspHex("[IN ]bMacKey =", bMacKey, 16);
	DspHex("[IN ]bMsgBuf =", bMsgBuf, 8);
	printf("[IN ]nMsgLen = %d\n", nMsgLen);
	DspHex("[IN ]bIV =", bIV, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPICalcMac_GM(nSock, nMode, bMacKey,  \
			bMsgBuf, nMsgLen, bIV, bMAC);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 3, "无效Socket ID[-1]测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void CalcMAC_GM_Test_16(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = 8;
	int  nMode;
	BYTE bMacKey[32];
	int  nMakLen;
	BYTE bMsgBuf[2056];
	int  nMsgLen;
	BYTE bMAC[16];
	BYTE bMACExp[16];
	BYTE bIV[32]; 

	bufclr(bMacKey);
	bufclr(bMsgBuf);
	bufclr(bMAC);
	bufclr(bMACExp);
	bufclr(bIV);

	nMode = 5;
	nMakLen = 16;
	nMsgLen = 8;
	memset(bMsgBuf, 0x2C, 8);
	bMsgBuf[0] = 0x2B;
	bMsgBuf[7] = 0x3F;
	//Plain MAK = 0123 4567 89AB CDEF FEDC BA98 7654 3210 
	memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
		    "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
		    16);
	memcpy(bIV, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock   = %d\n", nSock);
	printf("[IN ]nMode   = %d\n", nMode);
	DspHex("[IN ]bMacKey =", bMacKey, 16);
	DspHex("[IN ]bMsgBuf =", bMsgBuf, 8);
	printf("[IN ]nMsgLen = %d\n", nMsgLen);
	DspHex("[IN ]bIV =", bIV, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPICalcMac_GM(nSock, nMode, bMacKey,  \
			bMsgBuf, nMsgLen, bIV, bMAC);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 3, "无效Socket ID[8]测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void CalcMAC_GM_Test_17(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;
	int  nMode;
	BYTE bMacKey[32];
	int  nMakLen;
	BYTE bMsgBuf[2056];
	int  nMsgLen;
	BYTE bMAC[16];
	BYTE bMACExp[16];
	BYTE bIV[32]; 

	bufclr(bMacKey);
	bufclr(bMsgBuf);
	bufclr(bMAC);
	bufclr(bMACExp);
	bufclr(bIV);

	nMode = 0;
	nMakLen = 16;
	nMsgLen = 8;
	memset(bMsgBuf, 0x2C, 8);
	bMsgBuf[0] = 0x2B;
	bMsgBuf[7] = 0x3F;
	//Plain MAK = 0123 4567 89AB CDEF FEDC BA98 7654 3210 
	memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
		    "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
		    16);
	memcpy(bIV, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock   = %d\n", nSock);
	printf("[IN ]nMode   = %d\n", nMode);
	DspHex("[IN ]bMacKey =", bMacKey, 16);
	DspHex("[IN ]bMsgBuf =", bMsgBuf, 8);
	printf("[IN ]nMsgLen = %d\n", nMsgLen);
	DspHex("[IN ]bIV =", bIV, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPICalcMac_GM(nSock, nMode, bMacKey,  \
			bMsgBuf, nMsgLen, bIV, bMAC);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 1, "无效算法类型[0]测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void CalcMAC_GM_Test_18(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;
	int  nMode;
	BYTE bMacKey[32];
	int  nMakLen;
	BYTE bMsgBuf[2056];
	int  nMsgLen;
	BYTE bMAC[16];
	BYTE bMACExp[16];
	BYTE bIV[32]; 

	bufclr(bMacKey);
	bufclr(bMsgBuf);
	bufclr(bMAC);
	bufclr(bMACExp);
	bufclr(bIV);

	nMode = 8;
	nMakLen = 16;
	nMsgLen = 8;
	memset(bMsgBuf, 0x2C, 8);
	bMsgBuf[0] = 0x2B;
	bMsgBuf[7] = 0x3F;
	//Plain MAK = 0123 4567 89AB CDEF FEDC BA98 7654 3210 
	memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
		    "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
		    16);
	memcpy(bIV, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock   = %d\n", nSock);
	printf("[IN ]nMode   = %d\n", nMode);
	DspHex("[IN ]bMacKey =", bMacKey, 16);
	DspHex("[IN ]bMsgBuf =", bMsgBuf, 8);
	printf("[IN ]nMsgLen = %d\n", nMsgLen);
	DspHex("[IN ]bIV =", bIV, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPICalcMac_GM(nSock, nMode, bMacKey,  \
			bMsgBuf, nMsgLen, bIV, bMAC);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 1, "无效算法类型[8]测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void CalcMAC_GM_Test_19(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;
	int  nMode;
	BYTE bMacKey[32];
	int  nMakLen;
	BYTE bMsgBuf[2056];
	int  nMsgLen;
	BYTE bMAC[16];
	BYTE bMACExp[16];
	BYTE bIV[32]; 

	bufclr(bMacKey);
	bufclr(bMsgBuf);
	bufclr(bMAC);
	bufclr(bMACExp);
	bufclr(bIV);

	nMode = 5;
	nMakLen = 0;
	nMsgLen = 8;
	memset(bMsgBuf, 0x2C, 8);
	bMsgBuf[0] = 0x2B;
	bMsgBuf[7] = 0x3F;
	memcpy(bIV, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock   = %d\n", nSock);
	printf("[IN ]nMode   = %d\n", nMode);
	DspHex("[IN ]bMacKey =", bMacKey, 0);
	DspHex("[IN ]bMsgBuf =", bMsgBuf, 8);
	printf("[IN ]nMsgLen = %d\n", nMsgLen);
	DspHex("[IN ]bIV =", bIV, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPICalcMac_GM(nSock, nMode, bMacKey,  \
			bMsgBuf, nMsgLen, bIV, bMAC);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 1, "无效密钥长度[0]测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void CalcMAC_GM_Test_20(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;
	int  nMode;
	BYTE bMacKey[32];
	int  nMakLen;
	BYTE bMsgBuf[2056];
	int  nMsgLen;
	BYTE bMAC[16];
	BYTE bMACExp[16];
	BYTE bIV[32]; 

	bufclr(bMacKey);
	bufclr(bMsgBuf);
	bufclr(bMAC);
	bufclr(bMACExp);
	bufclr(bIV);

	nMode = 5;
	nMakLen = 24;
	nMsgLen = 8;
	memset(bMsgBuf, 0x2C, 8);
	bMsgBuf[0] = 0x2B;
	bMsgBuf[7] = 0x3F;
	memcpy(bIV, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 16);
	memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
			"\x59\x99\xC3\x06\xAB\x84\x01\xB2",\
			24);

	XXX_INPUT_XXX
	printf("[IN ]nSock   = %d\n", nSock);
	printf("[IN ]nMode   = %d\n", nMode);
	DspHex("[IN ]bMacKey =", bMacKey, 24);
	DspHex("[IN ]bMsgBuf =", bMsgBuf, 8);
	printf("[IN ]nMsgLen = %d\n", nMsgLen);
	DspHex("[IN ]bIV =", bIV, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPICalcMac_GM(nSock, nMode, bMacKey,  \
			bMsgBuf, nMsgLen, bIV, bMAC);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 1, "无效密钥长度[24]测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void CalcMAC_GM_Test_21(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;
	int  nMode;
	BYTE bMacKey[32];
	int  nMakLen;
	BYTE bMsgBuf[2056];
	int  nMsgLen;
	BYTE bMAC[16];
	BYTE bMACExp[16];
	BYTE bIV[32]; 

	bufclr(bMacKey);
	bufclr(bMsgBuf);
	bufclr(bMAC);
	bufclr(bMACExp);
	bufclr(bIV);

	nMode = 5;
	nMakLen = 16;
	nMsgLen = 8;
	memcpy(bIV, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 16);
	memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
		    "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
		    16);
	memcpy(bMACExp, "\x26\x77\xF4\x6B\x09\xC1\x22\xCC\x97\x55\x33\x10\x5B\xD4\xA2\x2A",16);

	XXX_INPUT_XXX
	printf("[IN ]nSock   = %d\n", nSock);
	printf("[IN ]nMode   = %d\n", nMode);
	DspHex("[IN ]bMacKey =", bMacKey, 16);
	DspHex("[IN ]bMsgBuf =", bMsgBuf, 16);
	printf("[IN ]nMsgLen = %d\n", nMsgLen);
	DspHex("[IN ]bIV =", bIV, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPICalcMac_GM(nSock, nMode, bMacKey,  \
			bMsgBuf, nMsgLen, bIV, bMAC);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "nMode=5空消息测试未成功");	
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[IN ]bMAC    =", bMAC, 16);
	DspHex("[IN ]bMACExp =", bMACExp, 16);
	ASSERT_OUT_HEX(bMAC, bMACExp, 16);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void CalcMAC_GM_Test_22(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;
	int  nMode;
	BYTE bMacKey[32];
	int  nMakLen;
	BYTE bMsgBuf[2056];
	int  nMsgLen;
	BYTE bMAC[16];
	BYTE bMACExp[16];
	BYTE bIV[32]; 

	bufclr(bMacKey);
	bufclr(bMsgBuf);
	bufclr(bMAC);
	bufclr(bMACExp);
	bufclr(bIV);

	nMode = 5;
	nMakLen = 16;
	nMsgLen = 0;
	memcpy(bIV, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 16);
	memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
		    "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
		    16);
	memcpy(bMACExp, "\x26\x77\xF4\x6B\x09\xC1\x22\xCC\x97\x55\x33\x10\x5B\xD4\xA2\x2A",16);

	XXX_INPUT_XXX
	printf("[IN ]nSock   = %d\n", nSock);
	printf("[IN ]nMode   = %d\n", nMode);
	DspHex("[IN ]bMacKey =", bMacKey, 16);
	DspHex("[IN ]bMsgBuf =", bMsgBuf, 16);
	printf("[IN ]nMsgLen = %d\n", nMsgLen);
	DspHex("[IN ]bIV =", bIV, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPICalcMac_GM(nSock, nMode, bMacKey,  \
			bMsgBuf, nMsgLen, bIV, bMAC);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 1, "nMode=5无效消息长度[0]测试未失败");	
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void CalcMAC_GM_Test_23(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;
	int  nMode;
	BYTE bMacKey[32];
	int  nMakLen;
	BYTE bMsgBuf[2056];
	int  nMsgLen;
	BYTE bMAC[16];
	BYTE bMACExp[16];
	BYTE bIV[32]; 

	bufclr(bMacKey);
	bufclr(bMsgBuf);
	bufclr(bMAC);
	bufclr(bMACExp);
	bufclr(bIV);

	nMode = 5;
	nMakLen = 16;
	nMsgLen = 8;
	memcpy(bMsgBuf, "\x2B\x2C\x2C\x2C\x00\x2C\x2C\x3F", 8);
	memcpy(bIV, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 16);
	memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
		    "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
		    16);
	memcpy(bMACExp, "\xD6\x80\xA4\xEB\xBA\x06\x85\xE6\x78\xB8\x44\xDF\x91\x09\x5C\x4E", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock   = %d\n", nSock);
	printf("[IN ]nMode   = %d\n", nMode);
	DspHex("[IN ]bMacKey =", bMacKey, 16);
	DspHex("[IN ]bMsgBuf =", bMsgBuf, 8);
	printf("[IN ]nMsgLen = %d\n", nMsgLen);
	DspHex("[IN ]bIV =", bIV, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPICalcMac_GM(nSock, nMode, bMacKey,  \
			bMsgBuf, nMsgLen, bIV, bMAC);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "消息是由两条字符串拼接而成，中间含'\\0'测试未成功");	
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[IN ]bMAC    =", bMAC, 16);
	DspHex("[IN ]bMACExp =", bMACExp, 16);
	ASSERT_OUT_HEX(bMAC, bMACExp, 16);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void CalcMAC_GM_Test_24(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;
	int  nMode;
	BYTE bMacKey[32];
	int  nMakLen;
	BYTE bMsgBuf[4000];
	int  nMsgLen;
	BYTE bMAC[16];
	BYTE bMACExp[16];
	BYTE bIV[32]; 

	bufclr(bMacKey);
	bufclr(bMsgBuf);
	bufclr(bMAC);
	bufclr(bMACExp);
	bufclr(bIV);

	nMode = 5;
	nMakLen = 16;
	nMsgLen = 4000;
	memset(bMsgBuf, 0x2C, 4000);
	bMsgBuf[0] = 0x2B;
	bMsgBuf[3999] = 0x3F;
	//Plain MAK = 0123 4567 89AB CDEF FEDC BA98 7654 3210 
	memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
		    "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
		    16);
	memcpy(bIV, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock   = %d\n", nSock);
	printf("[IN ]nMode   = %d\n", nMode);
	DspHex("[IN ]bMacKey =", bMacKey, 16);
	//DspHex("[IN ]bMsgBuf =", bMsgBuf, 4000);
	printf("[IN ]nMsgLen = %d\n", nMsgLen);
	DspHex("[IN ]bIV =", bIV, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPICalcMac_GM(nSock, nMode, bMacKey,  \
			bMsgBuf, nMsgLen, bIV, bMAC);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 1, "Mode=5,MsgLen=4000测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void CalcMAC_GM_Test_25(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;
	int  nMode;
	BYTE bMacKey[32];
	int  nMakLen;
	BYTE bMsgBuf[4000];
	int  nMsgLen;
	BYTE bMAC[16];
	BYTE bMACExp[16];
	BYTE bIV[32]; 

	bufclr(bMacKey);
	bufclr(bMsgBuf);
	bufclr(bMAC);
	bufclr(bMACExp);
	bufclr(bIV);

	nMode = 7;
	nMakLen = 16;
	nMsgLen = 0;
	//Plain MAK = 0123 4567 89AB CDEF FEDC BA98 7654 3210 
	memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
		    "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
		    16);
	memcpy(bIV, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock   = %d\n", nSock);
	printf("[IN ]nMode   = %d\n", nMode);
	DspHex("[IN ]bMacKey =", bMacKey, 16);
	//DspHex("[IN ]bMsgBuf =", bMsgBuf, 0);
	printf("[IN ]nMsgLen = %d\n", nMsgLen);
	DspHex("[IN ]bIV =", bIV, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPICalcMac_GM(nSock, nMode, bMacKey,  \
			bMsgBuf, nMsgLen, bIV, bMAC);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 1, "无效消息长度[0]测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void CalcMAC_GM_Test_26(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;
	int  nMode;
	BYTE bMacKey[32];
	int  nMakLen;
	BYTE bMsgBuf[4000];
	int  nMsgLen;
	BYTE bMAC[16];
	BYTE bMACExp[16];
	BYTE bIV[32]; 

	bufclr(bMacKey);
	bufclr(bMsgBuf);
	bufclr(bMAC);
	bufclr(bMACExp);
	bufclr(bIV);

	nMode = 7;
	nMakLen = 16;
	nMsgLen = 8;

	//Plain MAK = 0123 4567 89AB CDEF FEDC BA98 7654 3210 
	memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
		    "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
		    16);
	memcpy(bMACExp, "\x54\x50\x01\x0D\x4D\x35\x7C\xB4\x71\x48\x80\xA1\x5E\xD6\x55\x80", 16);
	memcpy(bIV, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock   = %d\n", nSock);
	printf("[IN ]nMode   = %d\n", nMode);
	DspHex("[IN ]bMacKey =", bMacKey, 16);
	//DspHex("[IN ]bMsgBuf =", bMsgBuf, 8);
	printf("[IN ]nMsgLen = %d\n", nMsgLen);
	DspHex("[IN ]bIV =", bIV, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPICalcMac_GM(nSock, nMode, bMacKey,  \
			bMsgBuf, nMsgLen, bIV, bMAC);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "Mode=7空消息测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[IN ]bMAC    =", bMAC, 16);
	DspHex("[IN ]bMACExp =", bMACExp, 16);
	ASSERT_OUT_HEX(bMAC, bMACExp, 16);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void CalcMAC_GM_Test_27(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;
	int  nMode;
	BYTE bMacKey[32];
	int  nMakLen;
	BYTE bMsgBuf[4000];
	int  nMsgLen;
	BYTE bMAC[16];
	BYTE bMACExp[16];
	BYTE bIV[32]; 

	bufclr(bMacKey);
	bufclr(bMsgBuf);
	bufclr(bMAC);
	bufclr(bMACExp);
	bufclr(bIV);

	nMode = 7;
	nMakLen = 16;
	nMsgLen = 4000;

	memset(bMsgBuf, 0x2C, 4000);
	bMsgBuf[0] = 0x2B;
	bMsgBuf[3999] = 0x3F;
	//Plain MAK = 0123 4567 89AB CDEF FEDC BA98 7654 3210 
	memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
		    "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
		    16);
	memcpy(bIV, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock   = %d\n", nSock);
	printf("[IN ]nMode   = %d\n", nMode);
	DspHex("[IN ]bMacKey =", bMacKey, 16);
	//DspHex("[IN ]bMsgBuf =", bMsgBuf, 4000);
	printf("[IN ]nMsgLen = %d\n", nMsgLen);
	DspHex("[IN ]bIV =", bIV, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPICalcMac_GM(nSock, nMode, bMacKey,  \
			bMsgBuf, nMsgLen, bIV, bMAC);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 1, "Mode=7无效消息长度[4000]测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void CalcMAC_GM_Test_28(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;
	int  nMode;
	BYTE bMacKey[32];
	int  nMakLen;
	BYTE bMsgBuf[4000];
	int  nMsgLen;
	BYTE bMAC[16];
	BYTE bMACExp[16];
	BYTE bIV[32]; 

	bufclr(bMacKey);
	bufclr(bMsgBuf);
	bufclr(bMAC);
	bufclr(bMACExp);
	bufclr(bIV);

	nMode = 7;
	nMakLen = 16;
	nMsgLen = 8;

	memcpy(bMsgBuf, "\x2B\x2C\x2C\x2C\x00\x2C\x2C\x3F", 8);
	//Plain MAK = 0123 4567 89AB CDEF FEDC BA98 7654 3210 
	memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
			16);
	memcpy(bIV, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 16);
	memcpy(bMACExp, "\x07\x84\x62\x71\x59\x74\x70\x8C\xCF\xAB\x32\x90\x6D\xE6\x21\x6F", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock   = %d\n", nSock);
	printf("[IN ]nMode   = %d\n", nMode);
	DspHex("[IN ]bMacKey =", bMacKey, 16);
	//DspHex("[IN ]bMsgBuf =", bMsgBuf, 4000);
	printf("[IN ]nMsgLen = %d\n", nMsgLen);
	DspHex("[IN ]bIV =", bIV, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPICalcMac_GM(nSock, nMode, bMacKey,  \
			bMsgBuf, nMsgLen, bIV, bMAC);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "Mode=7消息是由两条字符串拼接而成，中间含'\\0'测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[IN ]bMAC    =", bMAC, 16);
	DspHex("[IN ]bMACExp =", bMACExp, 16);
	ASSERT_OUT_HEX(bMAC, bMACExp, 16);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void CalcMAC_GM_Test_29(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;
	int  nMode;
	BYTE bMacKey[32];
	int  nMakLen;
	BYTE bMsgBuf[4000];
	int  nMsgLen;
	BYTE bMAC[16];
	BYTE bMACExp[16];
	BYTE bIV[32]; 

	bufclr(bMacKey);
	bufclr(bMsgBuf);
	bufclr(bMAC);
	bufclr(bMACExp);
	bufclr(bIV);

	nMode = 7;
	nMakLen = 16;
	nMsgLen = 16;

	memset(bMsgBuf,0x2C, 16);
	bMsgBuf[0]=0x2B;
	bMsgBuf[15]=0x3F;
	//Plain MAK = 0123 4567 89AB CDEF FEDC BA98 7654 3210 
	memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
			16);
	memcpy(bIV, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 16);
	memcpy(bMACExp, "\x2C\xF1\xDC\xA6\x14\x3E\x92\xD2\xCA\xC0\xD9\xDA\x4B\xB3\x3B\x12", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock   = %d\n", nSock);
	printf("[IN ]nMode   = %d\n", nMode);
	DspHex("[IN ]bMacKey =", bMacKey, 16);
	DspHex("[IN ]bMsgBuf =", bMsgBuf, 16);
	printf("[IN ]nMsgLen = %d\n", nMsgLen);
	DspHex("[IN ]bIV =", bIV, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPICalcMac_GM(nSock, nMode, bMacKey,  \
			bMsgBuf, nMsgLen, bIV, bMAC);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "Mode=7消息长度[16]未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[IN ]bMAC    =", bMAC, 16);
	DspHex("[IN ]bMACExp =", bMACExp, 16);
	ASSERT_OUT_HEX(bMAC, bMACExp, 16);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void CalcMAC_GM_Test_30(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;
	int  nMode;
	BYTE bMacKey[32];
	int  nMakLen;
	BYTE bMsgBuf[4000];
	int  nMsgLen;
	BYTE bMAC[16];
	BYTE bMACExp[16];
	BYTE bIV[32]; 

	bufclr(bMacKey);
	bufclr(bMsgBuf);
	bufclr(bMAC);
	bufclr(bMACExp);
	bufclr(bIV);

	nMode = 5;
	nMakLen = 16;
	nMsgLen = 17;

	memset(bMsgBuf,0x2C, 17);
	bMsgBuf[0]=0x2B;
	bMsgBuf[16]=0x3F;
	//Plain MAK = 0123 4567 89AB CDEF FEDC BA98 7654 3210 
	memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
			16);
	memcpy(bIV, "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 16);
	memcpy(bMACExp, "\x65\xB5\xF0\xC4\x52\x38\x98\x79\x69\x95\xE7\xA4\x7B\x75\xC3\x20", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock   = %d\n", nSock);
	printf("[IN ]nMode   = %d\n", nMode);
	DspHex("[IN ]bMacKey =", bMacKey, 16);
	DspHex("[IN ]bMsgBuf =", bMsgBuf, 17);
	printf("[IN ]nMsgLen = %d\n", nMsgLen);
	DspHex("[IN ]bIV =", bIV, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPICalcMac_GM(nSock, nMode, bMacKey,  \
			bMsgBuf, nMsgLen, bIV, bMAC);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "Mode=5消息长度[17]未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[IN ]bMAC    =", bMAC, 16);
	DspHex("[IN ]bMACExp =", bMACExp, 16);
	ASSERT_OUT_HEX(bMAC, bMACExp, 16);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

/*DES -> DES*/
void ConvertPinX98A_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
	
    /*plain key = 0123456789ABCDEF*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nSrcPinKeyLen = strlen(bSrcPinKey);
    /*plain key = FEDCBA9876543210*/
    sprintf(bDestPinKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nDestPinKeyLen = strlen(bDestPinKey);
	
    sprintf(szPlainPin, "123456");
    /*pin block = 06123456FFFFFFFF*/
    sprintf(bSrcPinCipher, "\x2F\x2B\x15\xB0\xF0\x9A\xD4\xD1");
    sprintf(bDestPinCipherExp, "\x08\xAD\x2E\x83\x33\x88\x4D\xEF");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 1\n");
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 8);
    printf("nSrcPinKeyLen=%d\n",nSrcPinKeyLen);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 8);
    printf("nDestPinKeyLen=%d\n",nDestPinKeyLen);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98A(nSock, 1, bSrcPinKey, 8, bDestPinKey, 8, bSrcPinCipher, bDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=1,des->des,pinlen=6测试未成功");
    XXX_RESULT_XXX
	
    XXX_OUTPUT_XXX
    printf("[OUT]nRet = %d\n", nRet);
    DspHex("[OUT]bDestPinCipher  =", bDestPinCipher, 8);
    DspHex("[OUT]bDestPinCipherExp     =", bDestPinCipherExp, 8);
    ASSERT_OUT_HEX(bDestPinCipher, bDestPinCipherExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

/*DES -> SM4*/
void ConvertPinX98A_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);

    /*plain key = 0123456789ABCDEF*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nSrcPinKeyLen = strlen(bSrcPinKey);	
    /*plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bDestPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nDestPinKeyLen = strlen(bDestPinKey);

    sprintf(szPlainPin, "123456");
    /*pin block = 06123456FFFFFFFF*/
    sprintf(bSrcPinCipher, "\x2F\x2B\x15\xB0\xF0\x9A\xD4\xD1");
    /*pin block = 06123456FFFFFFFFFFFFFFFFFFFFFFFF*/
    sprintf(bDestPinCipherExp, "\x3A\x47\xF1\x66\xDE\xC4\x88\x0E\x91\x69\xA6\xF5\xB1\x40\xDC\x0A");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 2\n");
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 8);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 16);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98A(nSock, 2, bSrcPinKey, 8, bDestPinKey, 16, bSrcPinCipher, bDestPinCipher);
    /* Call Test Target Function End */
    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=2,des->sm4,pinlen=6测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX    
    printf("[OUT]nRet  = %d\n", nRet);
    DspHex("[OUT]bDestPinCipher  =", bDestPinCipher, 16);
    DspHex("[OUT]bDestPinCipherExp     =", bDestPinCipherExp, 16);
    ASSERT_OUT_HEX(bDestPinCipher, bDestPinCipherExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

/*SM4 ->DES*/
void ConvertPinX98A_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);

    /*plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nSrcPinKeyLen = strlen(bSrcPinKey);
    /*plain key = 0123456789ABCDEF*/
    sprintf(bDestPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nDestPinKeyLen= strlen(bDestPinKey);

    sprintf(szPlainPin, "123456");
    /*pin block = 06123456FFFFFFFFFFFFFFFFFFFFFFFF*/
    sprintf(bSrcPinCipher, "\x3A\x47\xF1\x66\xDE\xC4\x88\x0E\x91\x69\xA6\xF5\xB1\x40\xDC\x0A");
    /*pin block = 06123456FFFFFFFF*/
    sprintf(bDestPinCipherExp, "\x2F\x2B\x15\xB0\xF0\x9A\xD4\xD1");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 2\n");
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 16);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 8);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 16);	
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98A(nSock, 3, bSrcPinKey, 16, bDestPinKey, 8, bSrcPinCipher, bDestPinCipher);
    /* Call Test Target Function End */
    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=3,sm4->des,pinlen=6测试未成功");
    XXX_RESULT_XXX
		
    XXX_OUTPUT_XXX    
    printf("[OUT]nRet  = %d\n", nRet);
    DspHex("[OUT]bDestPinCipher  =", bDestPinCipher, 8);
    DspHex("[OUT]bDestPinCipherExp     =", bDestPinCipherExp, 8);
    ASSERT_OUT_HEX(bDestPinCipher, bDestPinCipherExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

/*SM4 ->SM4*/
void ConvertPinX98A_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);

    /*plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nSrcPinKeyLen = strlen(bSrcPinKey);
    /*plain key = FEDCBA98765432100123456789ABCEDF*/
    sprintf(bDestPinKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A\x68\x75\x8D\x83\x92\x51\x56\x58");
    nDestPinKeyLen= strlen(bDestPinKey);

    sprintf(szPlainPin, "123456");
    /*pin block = 06123456FFFFFFFFFFFFFFFFFFFFFFFF*/
    sprintf(bSrcPinCipher, "\x3A\x47\xF1\x66\xDE\xC4\x88\x0E\x91\x69\xA6\xF5\xB1\x40\xDC\x0A");
    /*pin block = 06123456FFFFFFFFFFFFFFFFFFFFFFFF*/
    sprintf(bDestPinCipherExp, "\xAF\x65\x7E\x6E\x46\x08\xBE\xF8\xBE\x8C\xAD\x74\x8E\x85\x49\x77");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 2\n");
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 16);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 16);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 16);	
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98A(nSock, 4, bSrcPinKey, 16, bDestPinKey, 16, bSrcPinCipher, bDestPinCipher);
    /* Call Test Target Function End */
    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=4,sm4->sm4,pinlen=6测试未成功");
    XXX_RESULT_XXX
	
    XXX_OUTPUT_XXX    
    printf("[OUT]nRet  = %d\n", nRet);
    DspHex("[OUT]bDestPinCipher  =", bDestPinCipher, 16);
    DspHex("[OUT]bDestPinCipherExp     =", bDestPinCipherExp, 16);
    ASSERT_OUT_HEX(bDestPinCipher, bDestPinCipherExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ConvertPinX98A_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
	
    /*plain key = 0123456789ABCDEF*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nSrcPinKeyLen = strlen(bSrcPinKey);
    /*plain key = FEDCBA9876543210*/
    sprintf(bDestPinKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nDestPinKeyLen = strlen(bDestPinKey);
	
    sprintf(szPlainPin, "123456");
    /*pin block = 0C123456789012FF*/
    sprintf(bSrcPinCipher,  "\x5E\x76\x66\xDC\x52\x01\x70\xA4");
    sprintf(bDestPinCipherExp, "\x2B\x26\x5F\xBD\x8B\xDE\x6A\xFC");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 1\n");
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 8);
    printf("nSrcPinKeyLen=%d\n",nSrcPinKeyLen);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 8);
    printf("nDestPinKeyLen=%d\n",nDestPinKeyLen);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98A(nSock, 1, bSrcPinKey, 8, bDestPinKey, 8, bSrcPinCipher, bDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=1,des->des,pinlen=12测试未成功");
    XXX_RESULT_XXX
	
    XXX_OUTPUT_XXX
    printf("[OUT]nRet = %d\n", nRet);
    DspHex("[OUT]bDestPinCipher  =", bDestPinCipher, 8);
    DspHex("[OUT]bDestPinCipherExp     =", bDestPinCipherExp, 8);
    ASSERT_OUT_HEX(bDestPinCipher, bDestPinCipherExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

/*DES -> SM4*/
void ConvertPinX98A_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);

    /*plain key = 0123456789ABCDEF*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nSrcPinKeyLen = strlen(bSrcPinKey);	
    /*plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bDestPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nDestPinKeyLen = strlen(bDestPinKey);

    sprintf(szPlainPin, "123456");
    /*pin block = 0C123456789012FF*/
    sprintf(bSrcPinCipher, "\x5E\x76\x66\xDC\x52\x01\x70\xA4");
    /*pin block = 0C123456789012FFFFFFFFFFFFFFFFFF*/
    sprintf(bDestPinCipherExp, "\x98\x20\xC8\x71\xB7\x30\xCD\xBF\xEE\x8F\x46\xAC\x32\x2D\xCF\xE0");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 2\n");
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 8);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 16);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98A(nSock, 2, bSrcPinKey, 8, bDestPinKey, 16, bSrcPinCipher, bDestPinCipher);
    /* Call Test Target Function End */
    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=2,des->sm4,pinlen=12,测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX    
    printf("[OUT]nRet  = %d\n", nRet);
    DspHex("[OUT]bDestPinCipher  =", bDestPinCipher, 16);
    DspHex("[OUT]bDestPinCipherExp     =", bDestPinCipherExp, 16);
    ASSERT_OUT_HEX(bDestPinCipher, bDestPinCipherExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

/*SM4 ->DES*/
void ConvertPinX98A_Test_07(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);

    /*plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nSrcPinKeyLen = strlen(bSrcPinKey);
    /*plain key = 0123456789ABCDEF*/
    sprintf(bDestPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nDestPinKeyLen= strlen(bDestPinKey);

    sprintf(szPlainPin, "123456");
    /*pin block = 0C123456789012FFFFFFFFFFFFFFFFFF*/
    sprintf(bSrcPinCipher, "\x98\x20\xC8\x71\xB7\x30\xCD\xBF\xEE\x8F\x46\xAC\x32\x2D\xCF\xE0");
    /*pin block = 0C123456789012FF*/
    sprintf(bDestPinCipherExp, "\x5E\x76\x66\xDC\x52\x01\x70\xA4");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 3\n");
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 16);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 8);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 16);	
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98A(nSock, 3, bSrcPinKey, 16, bDestPinKey, 8, bSrcPinCipher, bDestPinCipher);
    /* Call Test Target Function End */
    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=3,sm4->des, pinlen=12,测试未成功");
    XXX_RESULT_XXX
		
    XXX_OUTPUT_XXX    
    printf("[OUT]nRet  = %d\n", nRet);
    DspHex("[OUT]bDestPinCipher  =", bDestPinCipher, 8);
    DspHex("[OUT]bDestPinCipherExp     =", bDestPinCipherExp, 8);
    ASSERT_OUT_HEX(bDestPinCipher, bDestPinCipherExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

/*SM4 ->SM4*/
void ConvertPinX98A_Test_08(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);

    /*plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nSrcPinKeyLen = strlen(bSrcPinKey);
    /*plain key = FEDCBA98765432100123456789ABCEDF*/
    sprintf(bDestPinKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A\x68\x75\x8D\x83\x92\x51\x56\x58");
    nDestPinKeyLen= strlen(bDestPinKey);

    sprintf(szPlainPin, "123456");
    /*pin block = 0C123456789012FFFFFFFFFFFFFFFFFF*/
    sprintf(bSrcPinCipher, "\x98\x20\xC8\x71\xB7\x30\xCD\xBF\xEE\x8F\x46\xAC\x32\x2D\xCF\xE0");
    /*pin block = 0C123456789012FFFFFFFFFFFFFFFFFF*/
    sprintf(bDestPinCipherExp, "\x81\x18\xF8\x7A\x2E\x1B\x30\xE2\xC7\x9B\x8F\xB8\x45\x39\x76\x97");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 4\n");
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 16);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 16);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 16);	
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98A(nSock, 4, bSrcPinKey, 16, bDestPinKey, 16, bSrcPinCipher, bDestPinCipher);
    /* Call Test Target Function End */
    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=4,sm4->sm4, pinlen=12,测试未成功");
    XXX_RESULT_XXX
	
    XXX_OUTPUT_XXX    
    printf("[OUT]nRet  = %d\n", nRet);
    DspHex("[OUT]bDestPinCipher  =", bDestPinCipher, 16);
    DspHex("[OUT]bDestPinCipherExp     =", bDestPinCipherExp, 16);
    ASSERT_OUT_HEX(bDestPinCipher, bDestPinCipherExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ConvertPinX98A_Test_09(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);

    /*plain key = 0123456789ABCDEF*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nSrcPinKeyLen = strlen(bSrcPinKey);	
    /*plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bDestPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nDestPinKeyLen = strlen(bDestPinKey);

    sprintf(szPlainPin, "123");
    /*pin block = 03123FFFFFFFFFFF*/
    sprintf(bSrcPinCipher, "\xF4\x50\xB8\xDF\x71\x06\xE5\xC3");
    /*pin block = 03123FFFFFFFFFFFFFFFFFFFFFFFFFFF*/
    sprintf(bDestPinCipherExp, "\xF0\x55\xA0\xA8\xD8\x35\xA4\x41\x1A\x3C\xA0\x45\x50\x53\x81\xC6");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 2\n");
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 8);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 16);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98A(nSock, 2, bSrcPinKey, 8, bDestPinKey, 16, bSrcPinCipher, bDestPinCipher);
    /* Call Test Target Function End */
    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=2,des->sm4,pinlen=3测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX    
    printf("[OUT]nRet  = %d\n", nRet);
    DspHex("[OUT]bDestPinCipher  =", bDestPinCipher, 16);
    DspHex("[OUT]bDestPinCipherExp     =", bDestPinCipherExp, 16);
    ASSERT_OUT_HEX(bDestPinCipher, bDestPinCipherExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}


/*NULL*/
void ConvertPinX98A_Test_10(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
	
    /*plain key = 0123456789ABCDEF*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nSrcPinKeyLen = strlen(bSrcPinKey);
    /*plain key = FEDCBA9876543210*/
    sprintf(bDestPinKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nDestPinKeyLen = strlen(bDestPinKey);
	
    sprintf(szPlainPin, "123456");
    /*pin block = 06123456FFFFFFFF*/
    sprintf(bSrcPinCipher, "\x2F\x2B\x15\xB0\xF0\x9A\xD4\xD1");
    sprintf(bDestPinCipherExp, "\x08\xAD\x2E\x83\x33\x88\x4D\xEF");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 1\n");
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 8);
    printf("nSrcPinKeyLen=%d\n",nSrcPinKeyLen);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 8);
    printf("nDestPinKeyLen=%d\n",nDestPinKeyLen);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98A(nSock, 1, NULL, 8, bDestPinKey, 8, bSrcPinCipher, bDestPinCipher);
    /* Call Test Target Function End */
    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "mode=1, null指针,测试未成功");
    XXX_RESULT_XXX
	
    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

/*nSrcPinKeyLen=0*/
void ConvertPinX98A_Test_11(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
	
    /*plain key = 0123456789ABCDEF
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");*/
    nSrcPinKeyLen = 0;
    /*plain key = FEDCBA9876543210*/
    sprintf(bDestPinKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nDestPinKeyLen = strlen(bDestPinKey);
	
    sprintf(szPlainPin, "123456");
    /*pin block = 06123456FFFFFFFF*/
    sprintf(bSrcPinCipher, "\x2F\x2B\x15\xB0\xF0\x9A\xD4\xD1");
    sprintf(bDestPinCipherExp, "\x08\xAD\x2E\x83\x33\x88\x4D\xEF");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 1\n");
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 8);
    printf("nSrcPinKeyLen=%d\n",nSrcPinKeyLen);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 8);
    printf("nDestPinKeyLen=%d\n",nDestPinKeyLen);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98A(nSock, 1, bSrcPinKey, 0, bDestPinKey, 8, bSrcPinCipher, bDestPinCipher);
    /* Call Test Target Function End */
    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "mode=1, nSrcPinKeyLen=0,测试未成功");
    XXX_RESULT_XXX
	
    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

/*bSrcPinKey=全0*/
void ConvertPinX98A_Test_12(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
	
    /*plain key = 6672 13A7 8B96 9FC0
    sprintf(bSrcPinKey, "\x00\x00\x00\x00\x00\x00\x00\x00");*/

    /*plain key = FEDCBA9876543210*/
    sprintf(bDestPinKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nDestPinKeyLen = strlen(bDestPinKey);
	
    sprintf(szPlainPin, "123456");
    /*pin block = 06123456FFFFFFFF*/
    sprintf(bSrcPinCipher, "\xE9\x64\x32\xBE\xA2\x8F\x9C\xAC");
    sprintf(bDestPinCipherExp, "\x08\xAD\x2E\x83\x33\x88\x4D\xEF");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 1\n" );
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 8);
    printf("nSrcPinKeyLen=%d\n",nSrcPinKeyLen);		
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 8);
    printf("nDestPinKeyLen=%d\n",nDestPinKeyLen);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98A(nSock, 1, bSrcPinKey, 8, bDestPinKey, 8, bSrcPinCipher, bDestPinCipher);
    /* Call Test Target Function End */
    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=1, bSrcPinKey=全0串,测试未成功");
    XXX_RESULT_XXX
	
    XXX_OUTPUT_XXX
    printf("[OUT]nRet = %d\n", nRet);
    DspHex("[OUT]bDestPinCipher  =", bDestPinCipher, 8);
    DspHex("[OUT]bDestPinCipherExp     =", bDestPinCipherExp, 8);
    ASSERT_OUT_HEX(bDestPinCipher, bDestPinCipherExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

/*传空串""*/
void ConvertPinX98A_Test_13(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
	
    /*plain key = 0123456789ABCDEF*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nSrcPinKeyLen = strlen(bSrcPinKey);
    /*plain key = FEDCBA9876543210*/
    sprintf(bDestPinKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nDestPinKeyLen = strlen(bDestPinKey);
	
    sprintf(szPlainPin, "123456");
    /*pin block = 06123456FFFFFFFF*/
    sprintf(bSrcPinCipher, "\x2F\x2B\x15\xB0\xF0\x9A\xD4\xD1");
    sprintf(bDestPinCipherExp, "\x08\xAD\x2E\x83\x33\x88\x4D\xEF");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 1\n");
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 8);
    printf("nSrcPinKeyLen=%d\n",nSrcPinKeyLen);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 8);
    printf("nDestPinKeyLen=%d\n",nDestPinKeyLen);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98A(nSock, 1, bSrcPinKey, 8, bDestPinKey, 8, "", bDestPinCipher);
    /* Call Test Target Function End */
    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "mode=1, 空字符串,测试未成功");
    XXX_RESULT_XXX
	
    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}


/*mode = 5*/
void ConvertPinX98A_Test_14(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
	
    /*plain key = 0123456789ABCDEF*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nSrcPinKeyLen = strlen(bSrcPinKey);
    /*plain key = FEDCBA9876543210*/
    sprintf(bDestPinKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nDestPinKeyLen = strlen(bDestPinKey);
	
    sprintf(szPlainPin, "123456");
    /*pin block = 06123456FFFFFFFF*/
    sprintf(bSrcPinCipher, "\x2F\x2B\x15\xB0\xF0\x9A\xD4\xD1");
    sprintf(bDestPinCipherExp, "\x08\xAD\x2E\x83\x33\x88\x4D\xEF");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 1\n");
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 8);
    printf("nSrcPinKeyLen=%d\n",nSrcPinKeyLen);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 8);
    printf("nDestPinKeyLen=%d\n",nDestPinKeyLen);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98A(nSock, 5, bSrcPinKey, 8, bDestPinKey, 8, bSrcPinCipher, bDestPinCipher);
    /* Call Test Target Function End */
    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "mode=5,异常模式,测试未成功");
    XXX_RESULT_XXX
	
    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}


void ConvertPinX98A_Test_15(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);

    /*plain key = 0123456789ABCDEF*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nSrcPinKeyLen = strlen(bSrcPinKey);	
    /*plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bDestPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nDestPinKeyLen = strlen(bDestPinKey);

    sprintf(szPlainPin, "123456");
    /*pin block = 06123456FFFFFFFF*/
    sprintf(bSrcPinCipher, "\x2F\x2B\x15\xB0\xF0\x9A\xD4\xD1");
    /*pin block = 06123456FFFFFFFFFFFFFFFFFFFFFFFF*/
    sprintf(bDestPinCipherExp, "\x3A\x47\xF1\x66\xDE\xC4\x88\x0E\x91\x69\xA6\xF5\xB1\x40\xDC\x0A");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 2\n");
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 8);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 16);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98A(-1, 2, bSrcPinKey, 8, bDestPinKey, 16, bSrcPinCipher, bDestPinCipher);
    /* Call Test Target Function End */
    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "mode=2,des->sm4,无效socket[-1]测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX    
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ConvertPinX98A_Test_16(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);

    /*plain key = 0123456789ABCDEF*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nSrcPinKeyLen = strlen(bSrcPinKey);	
    /*plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bDestPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nDestPinKeyLen = strlen(bDestPinKey);

    sprintf(szPlainPin, "123456");
    /*pin block = 06123456FFFFFFFF*/
    sprintf(bSrcPinCipher, "\x2F\x2B\x15\xB0\xF0\x9A\xD4\xD1");
    /*pin block = 06123456FFFFFFFFFFFFFFFFFFFFFFFF*/
    sprintf(bDestPinCipherExp, "\x3A\x47\xF1\x66\xDE\xC4\x88\x0E\x91\x69\xA6\xF5\xB1\x40\xDC\x0A");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 2\n");
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 8);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 16);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98A(98, 2, bSrcPinKey, 8, bDestPinKey, 16, bSrcPinCipher, bDestPinCipher);
    /* Call Test Target Function End */
    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "mode=2,des->sm4,无效socket[98]测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX    
    XXX_OUTPUT_NONE_XXX    
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

/*DES -> DES*/
void ConvertPinX98B_DoublePan_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet, nPanLen;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
    char szSrcPan[19+1];
	int nSrcPanLen;
	char szDstPan[19+1];
	int nDstPanLen;
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
    bufclr(szSrcPan);
	bufclr(szDstPan);
	
    /*plain key = 0123456789ABCDEFFEDCBA9876543210*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nSrcPinKeyLen = strlen(bSrcPinKey);
    /*plain key = FEDCBA98765432100123456789ABCDEF*/
    sprintf(bDestPinKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nDestPinKeyLen = strlen(bDestPinKey);
    sprintf(szPlainPin, "123456");
    sprintf(szSrcPan, "1234567890123456");
	sprintf(szDstPan,"6543210987654321");
    nSrcPanLen = 16;
	nDstPanLen = 16;

    /*pinblock = 06123456FFFFFFFF*/
    /*srcpanblock = 0000456789012345*/
    /*srcfinalblock = 0612713176FEDCBA*/
    sprintf(bSrcPinCipher, "\x79\x3A\xE1\xFC\xD3\x06\x49\x68");
	//dstpanblock = 0000321098765432
	//dstfinalblock = 061206466789ABCD
    sprintf(bDestPinCipherExp, "\xAD\x8B\xB4\xC0\x2E\xA1\xB0\xBE");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 1\n");
    printf("[IN ]szSrcPan	  =%s\n", szSrcPan);
    printf("[IN ]nSrcPanLen=%d\n",nSrcPanLen);
    printf("[IN ]szDstPan	  =%s\n", szDstPan);
    printf("[IN ]nDstPanLen=%d\n",nDstPanLen);
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 16);
    printf("[IN ]nSrcPinKeyLen=%d\n",nSrcPinKeyLen);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 16);
    printf("[IN ]nDestPinKeyLen=%d\n",nDestPinKeyLen);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98B_DoublePan(nSock,1,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDestPinKey,nDestPinKeyLen,bSrcPinCipher,bDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=1,2des->2des, pinlen=6,测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]nRet = %d\n", nRet);
    DspHex("[OUT]bDestPinCipher  =", bDestPinCipher, 8);
    DspHex("[OUT]bDestPinCipherExp     =", bDestPinCipherExp, 8);
    ASSERT_OUT_HEX(bDestPinCipher, bDestPinCipherExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

/*DES -> SM4*/
void ConvertPinX98B_DoublePan_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet, nPanLen;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
    char szSrcPan[19+1];
	int nSrcPanLen;
	char szDstPan[19+1];
	int nDstPanLen;
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
    bufclr(szSrcPan);
	bufclr(szDstPan);
	
    /*plain key = 0123456789ABCDEFFEDCBA9876543210*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nSrcPinKeyLen = strlen(bSrcPinKey);
    /*plain key = FEDCBA98765432100123456789ABCDEF*/
    sprintf(bDestPinKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nDestPinKeyLen = strlen(bDestPinKey);
    sprintf(szPlainPin, "123456");
    sprintf(szSrcPan, "1234567890123456");
	sprintf(szDstPan,"6543210987654321");
    nSrcPanLen = 16;
	nDstPanLen = 16;

    /*pinblock = 06123456FFFFFFFF*/
    /*srcpanblock = 0000456789012345*/
    /*srcfinalblock = 0612713176FEDCBA*/
    sprintf(bSrcPinCipher, "\x79\x3A\xE1\xFC\xD3\x06\x49\x68");
	//dstpanblock = 0000321098765432
	//dstfinalblock = 061206466789ABCD
    sprintf(bDestPinCipherExp, "\xB0\xFF\x98\x6F\xD4\xA5\x0E\x90\x9D\xAD\x8F\xD2\xCC\xD9\x9E\x9F");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 1\n");
    printf("[IN ]szSrcPan	  =%s\n", szSrcPan);
    printf("[IN ]nSrcPanLen=%d\n",nSrcPanLen);
    printf("[IN ]szDstPan	  =%s\n", szDstPan);
    printf("[IN ]nDstPanLen=%d\n",nDstPanLen);
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 16);
    printf("[IN ]nSrcPinKeyLen=%d\n",nSrcPinKeyLen);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 16);
    printf("[IN ]nDestPinKeyLen=%d\n",nDestPinKeyLen);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98B_DoublePan(nSock,2,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDestPinKey,nDestPinKeyLen,bSrcPinCipher,bDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=2,2des->sm4, pinlen=6,测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]nRet = %d\n", nRet);
    DspHex("[OUT]bDestPinCipher  =", bDestPinCipher, 16);
    DspHex("[OUT]bDestPinCipherExp     =", bDestPinCipherExp, 16);
    ASSERT_OUT_HEX(bDestPinCipher, bDestPinCipherExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

/*SM4 -> DES*/
void ConvertPinX98B_DoublePan_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet, nPanLen;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
    char szSrcPan[19+1];
	int nSrcPanLen;
	char szDstPan[19+1];
	int nDstPanLen;
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
    bufclr(szSrcPan);
	bufclr(szDstPan);
	
    /*plain key = 0123456789ABCDEFFEDCBA9876543210*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nSrcPinKeyLen = strlen(bSrcPinKey);
    /*plain key = FEDCBA98765432100123456789ABCDEF*/
    sprintf(bDestPinKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nDestPinKeyLen = strlen(bDestPinKey);
    sprintf(szPlainPin, "123456");
    sprintf(szSrcPan, "1234567890123456");
	sprintf(szDstPan,"6543210987654321");
    nSrcPanLen = 16;
	nDstPanLen = 16;

    /*pinblock = 06123456FFFFFFFFFFFFFFFFFFFFFFFF*/
    /*srcpanblock = 00000000000000000000456789012345*/
    /*srcfinalblock = 06123456FFFFFFFFFFFFBA9876FEDCBA*/
    sprintf(bSrcPinCipher, "\x17\xF4\xE8\xF0\x85\x67\x91\xEF\xFD\x6A\x5F\xCE\xB2\x1A\x62\x3F");
	//dstpanblock = 0000321098765432
	//dstfinalblock = 061206466789ABCD
    sprintf(bDestPinCipherExp, "\xAD\x8B\xB4\xC0\x2E\xA1\xB0\xBE");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 1\n");
    printf("[IN ]szSrcPan	  =%s\n", szSrcPan);
    printf("[IN ]nSrcPanLen=%d\n",nSrcPanLen);
    printf("[IN ]szDstPan	  =%s\n", szDstPan);
    printf("[IN ]nDstPanLen=%d\n",nDstPanLen);
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 16);
    printf("[IN ]nSrcPinKeyLen=%d\n",nSrcPinKeyLen);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 16);
    printf("[IN ]nDestPinKeyLen=%d\n",nDestPinKeyLen);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 16);	
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98B_DoublePan(nSock,3,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDestPinKey,nDestPinKeyLen,bSrcPinCipher,bDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=3,sm4->2des, pinlen=6,测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]nRet = %d\n", nRet);
    DspHex("[OUT]bDestPinCipher  =", bDestPinCipher, 8);
    DspHex("[OUT]bDestPinCipherExp     =", bDestPinCipherExp, 8);
    ASSERT_OUT_HEX(bDestPinCipher, bDestPinCipherExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

/*SM4 -> SM4*/
void ConvertPinX98B_DoublePan_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet, nPanLen;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
    char szSrcPan[19+1];
	int nSrcPanLen;
	char szDstPan[19+1];
	int nDstPanLen;
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
    bufclr(szSrcPan);
	bufclr(szDstPan);
	
    /*plain key = 0123456789ABCDEFFEDCBA9876543210*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nSrcPinKeyLen = strlen(bSrcPinKey);
    /*plain key = FEDCBA98765432100123456789ABCDEF*/
    sprintf(bDestPinKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nDestPinKeyLen = strlen(bDestPinKey);
    sprintf(szPlainPin, "123456");
    sprintf(szSrcPan, "1234567890123456");
	sprintf(szDstPan,"6543210987654321");
    nSrcPanLen = 16;
	nDstPanLen = 16;

    /*pinblock = 06123456FFFFFFFFFFFFFFFFFFFFFFFF*/
    /*srcpanblock = 00000000000000000000456789012345*/
    /*srcfinalblock = 06123456FFFFFFFFFFFFBA9876FEDCBA*/
    sprintf(bSrcPinCipher, "\x17\xF4\xE8\xF0\x85\x67\x91\xEF\xFD\x6A\x5F\xCE\xB2\x1A\x62\x3F");

    /*pinblock = 06123456FFFFFFFFFFFFFFFFFFFFFFFF*/
    /*srcpanblock = 00000000000000000000321098765432*/
    /*srcfinalblock = 06123456 FFFFFFFF FFFFCDEF 6789ABCD*/
    sprintf(bDestPinCipherExp, "\xB0\xFF\x98\x6F\xD4\xA5\x0E\x90\x9D\xAD\x8F\xD2\xCC\xD9\x9E\x9F");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 1\n");
    printf("[IN ]szSrcPan	  =%s\n", szSrcPan);
    printf("[IN ]nSrcPanLen=%d\n",nSrcPanLen);
    printf("[IN ]szDstPan	  =%s\n", szDstPan);
    printf("[IN ]nDstPanLen=%d\n",nDstPanLen);
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 16);
    printf("[IN ]nSrcPinKeyLen=%d\n",nSrcPinKeyLen);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 16);
    printf("[IN ]nDestPinKeyLen=%d\n",nDestPinKeyLen);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 16);	
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98B_DoublePan(nSock,4,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDestPinKey,nDestPinKeyLen,bSrcPinCipher,bDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=4,sm4->sm4, pinlen=6,测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]nRet = %d\n", nRet);
    DspHex("[OUT]bDestPinCipher  =", bDestPinCipher, 16);
    DspHex("[OUT]bDestPinCipherExp     =", bDestPinCipherExp, 16);
    ASSERT_OUT_HEX(bDestPinCipher, bDestPinCipherExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ConvertPinX98B_DoublePan_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet, nPanLen;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
    char szSrcPan[19+1];
	int nSrcPanLen;
	char szDstPan[19+1];
	int nDstPanLen;
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
    bufclr(szSrcPan);
	bufclr(szDstPan);
	
    /*plain key = 0123456789ABCDEFFEDCBA9876543210*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nSrcPinKeyLen = strlen(bSrcPinKey);
    /*plain key = FEDCBA98765432100123456789ABCDEF*/
    sprintf(bDestPinKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nDestPinKeyLen = strlen(bDestPinKey);
    sprintf(szPlainPin, "123456789012");
    sprintf(szSrcPan, "1234567890123456");
	sprintf(szDstPan,"6543210987654321");
    nSrcPanLen = 16;
	nDstPanLen = 16;

    /*pinblock = 0C123456789012FF*/
    /*srcpanblock = 0000456789012345*/
    /*srcfinalblock = 0C127131 F19131BA*/
    sprintf(bSrcPinCipher, "\xD4\x0C\xFB\x50\x16\xFB\xC1\x18");
	//dstpanblock = 0000321098765432
	//dstfinalblock = 0C120646 E0E646CD
    sprintf(bDestPinCipherExp, "\xC7\xFD\x1B\x66\x62\xF0\x14\xBD");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 1\n");
    printf("[IN ]szSrcPan	  =%s\n", szSrcPan);
    printf("[IN ]nSrcPanLen=%d\n",nSrcPanLen);
    printf("[IN ]szDstPan	  =%s\n", szDstPan);
    printf("[IN ]nDstPanLen=%d\n",nDstPanLen);
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 16);
    printf("[IN ]nSrcPinKeyLen=%d\n",nSrcPinKeyLen);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 16);
    printf("[IN ]nDestPinKeyLen=%d\n",nDestPinKeyLen);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98B_DoublePan(nSock,1,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDestPinKey,nDestPinKeyLen,bSrcPinCipher,bDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=1,2des->2des, pinlen=12,测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]nRet = %d\n", nRet);
    DspHex("[OUT]bDestPinCipher  =", bDestPinCipher, 8);
    DspHex("[OUT]bDestPinCipherExp     =", bDestPinCipherExp, 8);
    ASSERT_OUT_HEX(bDestPinCipher, bDestPinCipherExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ConvertPinX98B_DoublePan_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet, nPanLen;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
    char szSrcPan[19+1];
	int nSrcPanLen;
	char szDstPan[19+1];
	int nDstPanLen;
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
    bufclr(szSrcPan);
	bufclr(szDstPan);
	
    /*plain key = 0123456789ABCDEFFEDCBA9876543210*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nSrcPinKeyLen = strlen(bSrcPinKey);
    /*plain key = FEDCBA98765432100123456789ABCDEF*/
    sprintf(bDestPinKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nDestPinKeyLen = strlen(bDestPinKey);
    sprintf(szPlainPin, "123456789012");
    sprintf(szSrcPan, "1234567890123456");
	sprintf(szDstPan,"6543210987654321");
    nSrcPanLen = 16;
	nDstPanLen = 16;

    /*pinblock = 0C123456789012FF*/
    /*srcpanblock = 0000456789012345*/
    /*srcfinalblock = 0C127131 F19131BA*/
    sprintf(bSrcPinCipher, "\xD4\x0C\xFB\x50\x16\xFB\xC1\x18");
    /*pinblock = 0C123456789012FFFFFFFFFFFFFFFFFF*/
	//dstpanblock = 00000000000000000000321098765432
	//dstfinalblock = 0C123456 789012FF FFFFCDEF 6789ABCD
    sprintf(bDestPinCipherExp, "\xC4\x1C\x66\xFC\x99\x17\x6E\xF5\x4B\xB2\x32\x5C\x76\xB9\x81\x3F");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 1\n");
    printf("[IN ]szSrcPan	  =%s\n", szSrcPan);
    printf("[IN ]nSrcPanLen=%d\n",nSrcPanLen);
    printf("[IN ]szDstPan	  =%s\n", szDstPan);
    printf("[IN ]nDstPanLen=%d\n",nDstPanLen);
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 16);
    printf("[IN ]nSrcPinKeyLen=%d\n",nSrcPinKeyLen);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 16);
    printf("[IN ]nDestPinKeyLen=%d\n",nDestPinKeyLen);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98B_DoublePan(nSock,2,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDestPinKey,nDestPinKeyLen,bSrcPinCipher,bDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=2,2des->sm4, pinlen=12,测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]nRet = %d\n", nRet);
    DspHex("[OUT]bDestPinCipher  =", bDestPinCipher, 16);
    DspHex("[OUT]bDestPinCipherExp     =", bDestPinCipherExp, 16);
    ASSERT_OUT_HEX(bDestPinCipher, bDestPinCipherExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ConvertPinX98B_DoublePan_Test_07(void)
{
    XXX_TEST_START_XXX
    int  nRet, nPanLen;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
    char szSrcPan[19+1];
	int nSrcPanLen;
	char szDstPan[19+1];
	int nDstPanLen;
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
    bufclr(szSrcPan);
	bufclr(szDstPan);
	
    /*plain key = 0123456789ABCDEFFEDCBA9876543210*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nSrcPinKeyLen = strlen(bSrcPinKey);
    /*plain key = FEDCBA98765432100123456789ABCDEF*/
    sprintf(bDestPinKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nDestPinKeyLen = strlen(bDestPinKey);
    sprintf(szPlainPin, "123456789012");
    sprintf(szSrcPan, "1234567890123456");
	sprintf(szDstPan,"6543210987654321");
    nSrcPanLen = 16;
	nDstPanLen = 16;

    /*pinblock = 0C123456789012FFFFFFFFFFFFFFFFFF*/
    /*srcpanblock = 00000000000000000000456789012345*/
    /*srcfinalblock = 0C123456 789012FF FFFFBA98 76FEDCBA*/
    sprintf(bSrcPinCipher, "\x2E\x7C\x3B\xF8\x68\x86\xCF\xA2\xF1\x29\xBE\x9E\xE5\x5C\xA7\xBF");
    /*pinblock = 0C123456789012FF*/
	//dstpanblock = 0000321098765432
	//dstfinalblock = 0C120646 E0E646CD
    sprintf(bDestPinCipherExp, "\xC7\xFD\x1B\x66\x62\xF0\x14\xBD");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 1\n");
    printf("[IN ]szSrcPan	  =%s\n", szSrcPan);
    printf("[IN ]nSrcPanLen=%d\n",nSrcPanLen);
    printf("[IN ]szDstPan	  =%s\n", szDstPan);
    printf("[IN ]nDstPanLen=%d\n",nDstPanLen);
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 16);
    printf("[IN ]nSrcPinKeyLen=%d\n",nSrcPinKeyLen);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 16);
    printf("[IN ]nDestPinKeyLen=%d\n",nDestPinKeyLen);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 16);	
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98B_DoublePan(nSock,3,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDestPinKey,nDestPinKeyLen,bSrcPinCipher,bDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=3,sm4->2des, pinlen=12,测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]nRet = %d\n", nRet);
    DspHex("[OUT]bDestPinCipher  =", bDestPinCipher, 8);
    DspHex("[OUT]bDestPinCipherExp     =", bDestPinCipherExp, 8);
    ASSERT_OUT_HEX(bDestPinCipher, bDestPinCipherExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ConvertPinX98B_DoublePan_Test_08(void)
{
    XXX_TEST_START_XXX
    int  nRet, nPanLen;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
    char szSrcPan[19+1];
	int nSrcPanLen;
	char szDstPan[19+1];
	int nDstPanLen;
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
    bufclr(szSrcPan);
	bufclr(szDstPan);
	
    /*plain key = 0123456789ABCDEFFEDCBA9876543210*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nSrcPinKeyLen = strlen(bSrcPinKey);
    /*plain key = FEDCBA98765432100123456789ABCDEF*/
    sprintf(bDestPinKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nDestPinKeyLen = strlen(bDestPinKey);
    sprintf(szPlainPin, "123456");
    sprintf(szSrcPan, "1234567890123456");
	sprintf(szDstPan,"6543210987654321");
    nSrcPanLen = 16;
	nDstPanLen = 16;

    /*pinblock = 0C123456789012FFFFFFFFFFFFFFFFFF*/
    /*srcpanblock = 00000000000000000000456789012345*/
    /*srcfinalblock = 0C123456 789012FF FFFFBA98 76FEDCBA*/
    sprintf(bSrcPinCipher, "\x2E\x7C\x3B\xF8\x68\x86\xCF\xA2\xF1\x29\xBE\x9E\xE5\x5C\xA7\xBF");

    /*pinblock = 0C123456789012FFFFFFFFFFFFFFFFFF*/
    /*srcpanblock = 00000000000000000000321098765432*/
    /*srcfinalblock = 0C123456 789012FF FFFFCDEF 6789ABCD*/
    sprintf(bDestPinCipherExp, "\xC4\x1C\x66\xFC\x99\x17\x6E\xF5\x4B\xB2\x32\x5C\x76\xB9\x81\x3F");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 1\n");
    printf("[IN ]szSrcPan	  =%s\n", szSrcPan);
    printf("[IN ]nSrcPanLen=%d\n",nSrcPanLen);
    printf("[IN ]szDstPan	  =%s\n", szDstPan);
    printf("[IN ]nDstPanLen=%d\n",nDstPanLen);
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 16);
    printf("[IN ]nSrcPinKeyLen=%d\n",nSrcPinKeyLen);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 16);
    printf("[IN ]nDestPinKeyLen=%d\n",nDestPinKeyLen);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 16);	
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98B_DoublePan(nSock,4,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDestPinKey,nDestPinKeyLen,bSrcPinCipher,bDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=4,sm4->sm4, pinlen=12,测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]nRet = %d\n", nRet);
    DspHex("[OUT]bDestPinCipher  =", bDestPinCipher, 16);
    DspHex("[OUT]bDestPinCipherExp     =", bDestPinCipherExp, 16);
    ASSERT_OUT_HEX(bDestPinCipher, bDestPinCipherExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ConvertPinX98B_DoublePan_Test_09(void)
{
    XXX_TEST_START_XXX
    int  nRet, nPanLen;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
    char szSrcPan[19+1];
	int nSrcPanLen;
	char szDstPan[19+1];
	int nDstPanLen;
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
    bufclr(szSrcPan);
	bufclr(szDstPan);
	
    /*plain key = 0123456789ABCDEFFEDCBA9876543210*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nSrcPinKeyLen = strlen(bSrcPinKey);
    /*plain key = FEDCBA98765432100123456789ABCDEF*/
    sprintf(bDestPinKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nDestPinKeyLen = strlen(bDestPinKey);
    sprintf(szPlainPin, "123");
    sprintf(szSrcPan, "1234567890123456");
	sprintf(szDstPan,"6543210987654321");
    nSrcPanLen = 16;
	nDstPanLen = 16;

    /*pinblock = 03123FFFFFFFFFFF*/
    /*srcpanblock = 0000456789012345*/
    /*srcfinalblock = 03127A98 76FEDCBA*/
    sprintf(bSrcPinCipher, "\xEA\x39\x38\xF4\x8F\x9F\x73\xEA");
	//dstpanblock = 0000321098765432
	//dstfinalblock = 03120DEF 6789ABCD
    sprintf(bDestPinCipherExp, "\x5E\x2B\x0D\x4F\x1D\xAF\x10\xA2");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 1\n");
    printf("[IN ]szSrcPan	  =%s\n", szSrcPan);
    printf("[IN ]nSrcPanLen=%d\n",nSrcPanLen);
    printf("[IN ]szDstPan	  =%s\n", szDstPan);
    printf("[IN ]nDstPanLen=%d\n",nDstPanLen);
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 16);
    printf("[IN ]nSrcPinKeyLen=%d\n",nSrcPinKeyLen);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 16);
    printf("[IN ]nDestPinKeyLen=%d\n",nDestPinKeyLen);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98B_DoublePan(nSock,1,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDestPinKey,nDestPinKeyLen,bSrcPinCipher,bDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=1,2des->2des, pinlen=3,测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]nRet = %d\n", nRet);
    DspHex("[OUT]bDestPinCipher  =", bDestPinCipher, 8);
    DspHex("[OUT]bDestPinCipherExp     =", bDestPinCipherExp, 8);
    ASSERT_OUT_HEX(bDestPinCipher, bDestPinCipherExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ConvertPinX98B_DoublePan_Test_10(void)
{
    XXX_TEST_START_XXX
    int  nRet, nPanLen;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
    char szSrcPan[19+1];
	int nSrcPanLen;
	char szDstPan[19+1];
	int nDstPanLen;
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
    bufclr(szSrcPan);
	bufclr(szDstPan);
	
    /*plain key = 0123456789ABCDEFFEDCBA9876543210*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nSrcPinKeyLen = strlen(bSrcPinKey);
    /*plain key = FEDCBA98765432100123456789ABCDEF*/
    sprintf(bDestPinKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nDestPinKeyLen = strlen(bDestPinKey);
    sprintf(szPlainPin, "123");
    sprintf(szSrcPan, "1234567890123456");
	sprintf(szDstPan,"6543210987654321");
    nSrcPanLen = 16;
	nDstPanLen = 16;

    /*pinblock = 03123FFFFFFFFFFF*/
    /*srcpanblock = 0000456789012345*/
    /*srcfinalblock = 03127A98 76FEDCBA*/
    sprintf(bSrcPinCipher, "\xEA\x39\x38\xF4\x8F\x9F\x73\xEA");
	//dstpanblock = 0000321098765432
	//dstfinalblock = 03120DEF 6789ABCD
    sprintf(bDestPinCipherExp, "\x5E\x2B\x0D\x4F\x1D\xAF\x10\xA2");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 1\n");
    printf("[IN ]szSrcPan	  =%s\n", szSrcPan);
    printf("[IN ]nSrcPanLen=%d\n",nSrcPanLen);
    printf("[IN ]szDstPan	  =%s\n", szDstPan);
    printf("[IN ]nDstPanLen=%d\n",nDstPanLen);
    DspHex("[IN ]bSrcPinKey	  =", NULL, 0);
    printf("[IN ]nSrcPinKeyLen=%d\n",0);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 16);
    printf("[IN ]nDestPinKeyLen=%d\n",nDestPinKeyLen);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);
    XXX_INPUT_XXX
	
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98B_DoublePan(nSock,1,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,NULL,0,bDestPinKey,nDestPinKeyLen,bSrcPinCipher,bDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "mode=1,2des->2des,PIK=NULL,测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ConvertPinX98B_DoublePan_Test_11(void)
{
    XXX_TEST_START_XXX
    int  nRet, nPanLen;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
    char szSrcPan[19+1];
	int nSrcPanLen;
	char szDstPan[19+1];
	int nDstPanLen;
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
    bufclr(szSrcPan);
	bufclr(szDstPan);
	
    /*plain key = 0123456789ABCDEFFEDCBA9876543210*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nSrcPinKeyLen = strlen(bSrcPinKey);
    /*plain key = FEDCBA98765432100123456789ABCDEF*/
    sprintf(bDestPinKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nDestPinKeyLen = strlen(bDestPinKey);
    sprintf(szPlainPin, "123");
    sprintf(szSrcPan, "1234567890123456");
	sprintf(szDstPan,"6543210987654321");
    nSrcPanLen = 16;
	nDstPanLen = 16;

    /*pinblock = 03123FFFFFFFFFFF*/
    /*srcpanblock = 0000456789012345*/
    /*srcfinalblock = 03127A98 76FEDCBA*/
    sprintf(bSrcPinCipher, "\xEA\x39\x38\xF4\x8F\x9F\x73\xEA");
	//dstpanblock = 0000321098765432
	//dstfinalblock = 03120DEF 6789ABCD
    sprintf(bDestPinCipherExp, "\x5E\x2B\x0D\x4F\x1D\xAF\x10\xA2");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 1\n");
    printf("[IN ]szSrcPan	  =%s\n", NULL);
    printf("[IN ]nSrcPanLen=%d\n",0);
    printf("[IN ]szDstPan	  =%s\n", szDstPan);
    printf("[IN ]nDstPanLen=%d\n",nDstPanLen);
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 16);
    printf("[IN ]nSrcPinKeyLen=%d\n",nSrcPinKeyLen);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 16);
    printf("[IN ]nDestPinKeyLen=%d\n",nDestPinKeyLen);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98B_DoublePan(nSock,1,NULL,0,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDestPinKey,nDestPinKeyLen,bSrcPinCipher,bDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "mode=1,2des->2des,PAN=NULL,测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ConvertPinX98B_DoublePan_Test_12(void)
{
    XXX_TEST_START_XXX
    int  nRet, nPanLen;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
    char szSrcPan[19+1];
	int nSrcPanLen;
	char szDstPan[19+1];
	int nDstPanLen;
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
    bufclr(szSrcPan);
	bufclr(szDstPan);
	
    /*plain key = 0123456789ABCDEFFEDCBA9876543210*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nSrcPinKeyLen = strlen(bSrcPinKey);
    /*plain key = FEDCBA98765432100123456789ABCDEF*/
    sprintf(bDestPinKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nDestPinKeyLen = strlen(bDestPinKey);
    sprintf(szPlainPin, "123");
    sprintf(szSrcPan, "1234567890123456");
	sprintf(szDstPan,"6543210987654321");
    nSrcPanLen = 16;
	nDstPanLen = 16;

    /*pinblock = 03123FFFFFFFFFFF*/
    /*srcpanblock = 0000456789012345*/
    /*srcfinalblock = 03127A98 76FEDCBA*/
    sprintf(bSrcPinCipher, "\xEA\x39\x38\xF4\x8F\x9F\x73\xEA");
	//dstpanblock = 0000321098765432
	//dstfinalblock = 03120DEF 6789ABCD
    sprintf(bDestPinCipherExp, "\x5E\x2B\x0D\x4F\x1D\xAF\x10\xA2");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 1\n");
    printf("[IN ]szSrcPan	  =%s\n", szSrcPan);
    printf("[IN ]nSrcPanLen=%d\n",nSrcPanLen);
    printf("[IN ]szDstPan	  =%s\n", szDstPan);
    printf("[IN ]nDstPanLen=%d\n",nDstPanLen);
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 16);
    printf("[IN ]nSrcPinKeyLen=%d\n",nSrcPinKeyLen);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 16);
    printf("[IN ]nDestPinKeyLen=%d\n",nDestPinKeyLen);
    DspHex("[IN ]bSrcPinCipher	  =", NULL, 0);	
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98B_DoublePan(nSock,1,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDestPinKey,nDestPinKeyLen,NULL,bDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "mode=1,2des->2des,bSrcPinCipher=NULL,测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ConvertPinX98B_DoublePan_Test_13(void)
{
    XXX_TEST_START_XXX
    int  nRet, nPanLen;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
    char szSrcPan[19+1];
	int nSrcPanLen;
	char szDstPan[19+1];
	int nDstPanLen;
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
    bufclr(szSrcPan);
	bufclr(szDstPan);
	
    /*plain key = 0123456789ABCDEFFEDCBA9876543210*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nSrcPinKeyLen = strlen(bSrcPinKey);
    /*plain key = FEDCBA98765432100123456789ABCDEF*/
    sprintf(bDestPinKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nDestPinKeyLen = strlen(bDestPinKey);
    sprintf(szPlainPin, "123456");
    sprintf(szSrcPan, "1234567890123456789");
	sprintf(szDstPan,"9876543210987654321");
    nSrcPanLen = 19;
	nDstPanLen = 19;

    /*pinblock = 06123456FFFFFFFF*/
    /*srcpanblock = 0000789012345678*/
    /*srcfinalblock = 06124CC6EDCBA987*/
    sprintf(bSrcPinCipher, "\x1F\x08\x67\x41\x3F\x39\x1C\x47");
	//dstpanblock = 0000321098765432
	//dstfinalblock = 061206466789ABCD
    sprintf(bDestPinCipherExp, "\xAD\x8B\xB4\xC0\x2E\xA1\xB0\xBE");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 1\n");
    printf("[IN ]szSrcPan	  =%s\n", szSrcPan);
    printf("[IN ]nSrcPanLen=%d\n",nSrcPanLen);
    printf("[IN ]szDstPan	  =%s\n", szDstPan);
    printf("[IN ]nDstPanLen=%d\n",nDstPanLen);
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 16);
    printf("[IN ]nSrcPinKeyLen=%d\n",nSrcPinKeyLen);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 16);
    printf("[IN ]nDestPinKeyLen=%d\n",nDestPinKeyLen);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98B_DoublePan(nSock,1,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDestPinKey,nDestPinKeyLen,bSrcPinCipher,bDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=1,2des->2des, PanLen=19,测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]nRet = %d\n", nRet);
    DspHex("[OUT]bDestPinCipher  =", bDestPinCipher, 8);
    DspHex("[OUT]bDestPinCipherExp     =", bDestPinCipherExp, 8);
    ASSERT_OUT_HEX(bDestPinCipher, bDestPinCipherExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ConvertPinX98B_DoublePan_Test_14(void)
{
    XXX_TEST_START_XXX
    int  nRet, nPanLen;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
    char szSrcPan[19+1];
	int nSrcPanLen;
	char szDstPan[19+1];
	int nDstPanLen;
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
    bufclr(szSrcPan);
	bufclr(szDstPan);
	
    /*plain key = 0123456789ABCDEFFEDCBA9876543210*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nSrcPinKeyLen = strlen(bSrcPinKey);
    /*plain key = FEDCBA98765432100123456789ABCDEF*/
    sprintf(bDestPinKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nDestPinKeyLen = strlen(bDestPinKey);
    sprintf(szPlainPin, "123456");
    sprintf(szSrcPan, "12345678901234567890");
	sprintf(szDstPan,"98765432109876543210");
    nSrcPanLen = 20;
	nDstPanLen = 20;

    /*pinblock = 06123456FFFFFFFF*/
    /*srcpanblock = 0000890123456789*/
    /*srcfinalblock = 0612BD57 DCBA9876*/
    sprintf(bSrcPinCipher, "\xFA\xFC\x32\x01\xAC\xFF\x4A\x24");
	//dstpanblock = 0000210987654321
	//dstfinalblock = 0612155F 789ABCDE
    sprintf(bDestPinCipherExp, "\xB0\x23\xC9\x16\xF9\x2B\x48\xA0");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 1\n");
    printf("[IN ]szSrcPan	  =%s\n", szSrcPan);
    printf("[IN ]nSrcPanLen=%d\n",nSrcPanLen);
    printf("[IN ]szDstPan	  =%s\n", szDstPan);
    printf("[IN ]nDstPanLen=%d\n",nDstPanLen);
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 16);
    printf("[IN ]nSrcPinKeyLen=%d\n",nSrcPinKeyLen);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 16);
    printf("[IN ]nDestPinKeyLen=%d\n",nDestPinKeyLen);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98B_DoublePan(nSock,1,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDestPinKey,nDestPinKeyLen,bSrcPinCipher,bDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "mode=1,2des->2des, PanLen=20,测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ConvertPinX98B_DoublePan_Test_15(void)
{
    XXX_TEST_START_XXX
    int  nRet, nPanLen;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
    char szSrcPan[19+1];
	int nSrcPanLen;
	char szDstPan[19+1];
	int nDstPanLen;
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
    bufclr(szSrcPan);
	bufclr(szDstPan);
	
    /*plain key = 0123456789ABCDEFFEDCBA9876543210*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nSrcPinKeyLen = strlen(bSrcPinKey);
    /*plain key = FEDCBA98765432100123456789ABCDEF*/
    sprintf(bDestPinKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nDestPinKeyLen = strlen(bDestPinKey);
    sprintf(szPlainPin, "123456");
    sprintf(szSrcPan, "1a34567890123456");
	sprintf(szDstPan,"9b76543210987654");
    nSrcPanLen = 16;
	nDstPanLen = 16;

    /*pinblock = 06123456FFFFFFFF*/
    /*srcpanblock = 0000789012345678*/
    /*srcfinalblock = 06124CC6EDCBA987*/
    sprintf(bSrcPinCipher, "\x1F\x08\x67\x41\x3F\x39\x1C\x47");
	//dstpanblock = 0000321098765432
	//dstfinalblock = 061206466789ABCD
    sprintf(bDestPinCipherExp, "\xAD\x8B\xB4\xC0\x2E\xA1\xB0\xBE");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 1\n");
    printf("[IN ]szSrcPan	  =%s\n", szSrcPan);
    printf("[IN ]nSrcPanLen=%d\n",nSrcPanLen);
    printf("[IN ]szDstPan	  =%s\n", szDstPan);
    printf("[IN ]nDstPanLen=%d\n",nDstPanLen);
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 16);
    printf("[IN ]nSrcPinKeyLen=%d\n",nSrcPinKeyLen);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 16);
    printf("[IN ]nDestPinKeyLen=%d\n",nDestPinKeyLen);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98B_DoublePan(nSock,1,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDestPinKey,nDestPinKeyLen,bSrcPinCipher,bDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "mode=1,2des->2des,Pan号含有非数字字符,测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ConvertPinX98B_DoublePan_Test_16(void)
{
    XXX_TEST_START_XXX
    int  nRet, nPanLen;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
    char szSrcPan[19+1];
	int nSrcPanLen;
	char szDstPan[19+1];
	int nDstPanLen;
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
    bufclr(szSrcPan);
	bufclr(szDstPan);
	
    /*plain key = 0123456789ABCDEFFEDCBA9876543210*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nSrcPinKeyLen = strlen(bSrcPinKey);
    /*plain key = FEDCBA98765432100123456789ABCDEF*/
    sprintf(bDestPinKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nDestPinKeyLen = strlen(bDestPinKey);
    sprintf(szPlainPin, "123456");
    sprintf(szSrcPan, "1234567890123456");
	sprintf(szDstPan,"9876543210987654");
    nSrcPanLen = 16;
	nDstPanLen = 16;

    /*pinblock = 06123456FFFFFFFF*/
    /*srcpanblock = 0000789012345678*/
    /*srcfinalblock = 06124CC6EDCBA987*/
    sprintf(bSrcPinCipher, "\x1F\x08\x67\x41\x3F\x39\x1C\x47");
	//dstpanblock = 0000321098765432
	//dstfinalblock = 061206466789ABCD
    sprintf(bDestPinCipherExp, "\xAD\x8B\xB4\xC0\x2E\xA1\xB0\xBE");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 5\n");
    printf("[IN ]szSrcPan	  =%s\n", szSrcPan);
    printf("[IN ]nSrcPanLen=%d\n",nSrcPanLen);
    printf("[IN ]szDstPan	  =%s\n", szDstPan);
    printf("[IN ]nDstPanLen=%d\n",nDstPanLen);
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 16);
    printf("[IN ]nSrcPinKeyLen=%d\n",nSrcPinKeyLen);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 16);
    printf("[IN ]nDestPinKeyLen=%d\n",nDestPinKeyLen);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98B_DoublePan(nSock,5,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDestPinKey,nDestPinKeyLen,bSrcPinCipher,bDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "mode=5,测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ConvertPinX98B_DoublePan_Test_17(void)
{
    XXX_TEST_START_XXX
    int  nRet, nPanLen;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
    char szSrcPan[19+1];
	int nSrcPanLen;
	char szDstPan[19+1];
	int nDstPanLen;
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
    bufclr(szSrcPan);
	bufclr(szDstPan);
	
    /*plain key = 0123456789ABCDEFFEDCBA9876543210*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nSrcPinKeyLen = strlen(bSrcPinKey);
    /*plain key = FEDCBA98765432100123456789ABCDEF*/
    sprintf(bDestPinKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nDestPinKeyLen = strlen(bDestPinKey);
    sprintf(szPlainPin, "123456");
    sprintf(szSrcPan, "1234567890123456");
	sprintf(szDstPan,"9876543210987654");
    nSrcPanLen = 16;
	nDstPanLen = 16;

    /*pinblock = 06123456FFFFFFFF*/
    /*srcpanblock = 0000789012345678*/
    /*srcfinalblock = 06124CC6EDCBA987*/
    sprintf(bSrcPinCipher, "\x1F\x08\x67\x41\x3F\x39\x1C\x47");
	//dstpanblock = 0000321098765432
	//dstfinalblock = 061206466789ABCD
    sprintf(bDestPinCipherExp, "\xAD\x8B\xB4\xC0\x2E\xA1\xB0\xBE");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 0\n");
    printf("[IN ]szSrcPan	  =%s\n", szSrcPan);
    printf("[IN ]nSrcPanLen=%d\n",nSrcPanLen);
    printf("[IN ]szDstPan	  =%s\n", szDstPan);
    printf("[IN ]nDstPanLen=%d\n",nDstPanLen);
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 16);
    printf("[IN ]nSrcPinKeyLen=%d\n",nSrcPinKeyLen);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 16);
    printf("[IN ]nDestPinKeyLen=%d\n",nDestPinKeyLen);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98B_DoublePan(nSock,0,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDestPinKey,nDestPinKeyLen,bSrcPinCipher,bDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "mode=0,测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ConvertPinX98B_DoublePan_Test_18(void)
{
    XXX_TEST_START_XXX
    int  nRet, nPanLen;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
    char szSrcPan[19+1];
	int nSrcPanLen;
	char szDstPan[19+1];
	int nDstPanLen;
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
    bufclr(szSrcPan);
	bufclr(szDstPan);
	
    /*plain key = 0123456789ABCDEFFEDCBA9876543210*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nSrcPinKeyLen = strlen(bSrcPinKey);
    /*plain key = FEDCBA98765432100123456789ABCDEF*/
    sprintf(bDestPinKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nDestPinKeyLen = strlen(bDestPinKey);
    sprintf(szPlainPin, "123456");
    sprintf(szSrcPan, "1234567890123456");
	sprintf(szDstPan,"9876543210987654");
    nSrcPanLen = 16;
	nDstPanLen = 16;

    /*pinblock = 06123456FFFFFFFF*/
    /*srcpanblock = 0000789012345678*/
    /*srcfinalblock = 06124CC6EDCBA987*/
    sprintf(bSrcPinCipher, "\x1F\x08\x67\x41\x3F\x39\x1C\x47");
	//dstpanblock = 0000321098765432
	//dstfinalblock = 061206466789ABCD
    sprintf(bDestPinCipherExp, "\xAD\x8B\xB4\xC0\x2E\xA1\xB0\xBE");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", -1);
    printf("[IN ]nMode  = 1\n");
    printf("[IN ]szSrcPan	  =%s\n", szSrcPan);
    printf("[IN ]nSrcPanLen=%d\n",nSrcPanLen);
    printf("[IN ]szDstPan	  =%s\n", szDstPan);
    printf("[IN ]nDstPanLen=%d\n",nDstPanLen);
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 16);
    printf("[IN ]nSrcPinKeyLen=%d\n",nSrcPinKeyLen);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 16);
    printf("[IN ]nDestPinKeyLen=%d\n",nDestPinKeyLen);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98B_DoublePan(-1,1,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDestPinKey,nDestPinKeyLen,bSrcPinCipher,bDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "socket=-1,测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ConvertPinX98B_DoublePan_Test_19(void)
{
    XXX_TEST_START_XXX
    int  nRet, nPanLen;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
    char szSrcPan[19+1];
	int nSrcPanLen;
	char szDstPan[19+1];
	int nDstPanLen;
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
    bufclr(szSrcPan);
	bufclr(szDstPan);
	
    /*plain key = 0123456789ABCDEFFEDCBA9876543210*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nSrcPinKeyLen = strlen(bSrcPinKey);
    /*plain key = FEDCBA98765432100123456789ABCDEF*/
    sprintf(bDestPinKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nDestPinKeyLen = strlen(bDestPinKey);
    sprintf(szPlainPin, "123456");
    sprintf(szSrcPan, "1234567890123456");
	sprintf(szDstPan,"9876543210987654");
    nSrcPanLen = 16;
	nDstPanLen = 16;

    /*pinblock = 06123456FFFFFFFF*/
    /*srcpanblock = 0000789012345678*/
    /*srcfinalblock = 06124CC6EDCBA987*/
    sprintf(bSrcPinCipher, "\x1F\x08\x67\x41\x3F\x39\x1C\x47");
	//dstpanblock = 0000321098765432
	//dstfinalblock = 061206466789ABCD
    sprintf(bDestPinCipherExp, "\xAD\x8B\xB4\xC0\x2E\xA1\xB0\xBE");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", 8);
    printf("[IN ]nMode  = 1\n");
    printf("[IN ]szSrcPan	  =%s\n", szSrcPan);
    printf("[IN ]nSrcPanLen=%d\n",nSrcPanLen);
    printf("[IN ]szDstPan	  =%s\n", szDstPan);
    printf("[IN ]nDstPanLen=%d\n",nDstPanLen);
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 16);
    printf("[IN ]nSrcPinKeyLen=%d\n",nSrcPinKeyLen);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 16);
    printf("[IN ]nDestPinKeyLen=%d\n",nDestPinKeyLen);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98B_DoublePan(8,1,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDestPinKey,nDestPinKeyLen,bSrcPinCipher,bDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "socket=8,测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ConvertPinX98ToIBM3624_Test_01(void)
{
	XXX_TEST_START_XXX
	int nSock = SM_SOCK;
	int nRet;
	char szSrcPan[20];
	int nSrcPanLen;
	char szDstPan[20];
	int nDstPanLen;
	BYTE bSrcPinKey[50];
	int nSrcPinKeyLen;
	BYTE bDstPinKey[50];
	int nDstPinKeyLen;
	BYTE bSrcPinCipher[50];
	char szDestPinCipher[15];
	char szDestPinCipherExp[15];

	bufclr(szSrcPan);
	bufclr(szDstPan);
	bufclr(bSrcPinKey);
	bufclr(bDstPinKey);
	bufclr(bSrcPinCipher);
	bufclr(szDestPinCipher);
	bufclr(szDestPinCipherExp);
	
	sprintf(szDstPan,"1234567890123456");
	nDstPanLen = strlen(szDstPan);
	nSrcPanLen = strlen(szSrcPan);

	//SrcPVK = 1234567890ABCDEF
	sprintf(bSrcPinKey,"\x62\xAB\xF2\xBC\x97\x25\x8E\x6F");
	nSrcPinKeyLen = strlen(bSrcPinKey);
	//DstPVK = FEDCBA0987654321
	sprintf(bDstPinKey,"\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nDstPinKeyLen = strlen(bDstPinKey);
	//PIN = 123456
	sprintf(bSrcPinCipher,"\xA4\x4D\x84\x03\xA3\x81\x64\x1D");
	sprintf(szDestPinCipherExp,"969853");

    XXX_INPUT_XXX
    printf("[IN ]nSock			= %d\n", nSock);
    printf("[IN ]nMode			= 1\n");
    printf("[IN ]nX98Algo		= 1\n");
    printf("[IN ]szSrcPan		= %s\n",szSrcPan);
    printf("[IN ]nSrcPanLen		= %d\n",nSrcPanLen);
    printf("[IN ]szDstPan		= %s\n",szDstPan);
	printf("[IN ]nDstPanLen  	= %d\n",nDstPanLen);
	DspHex("[IN ]bSrcPinKey		= ",bSrcPinKey,8);
	printf("[IN ]nSrcPinKeyLen	= %d\n",nSrcPinKeyLen);
	DspHex("[IN ]bDstPinKey		= ",bDstPinKey,8);
	printf("[IN ]nDstPinKeyLen	= %d\n",nDstPinKeyLen);
	DspHex("[IN ]bSrcPinCipher	= ",bSrcPinCipher,8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
	nRet = SMAPIConvertPinX98ToIBM3624(nSock,1,1,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDstPinKey,nDstPinKeyLen,bSrcPinCipher,szDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=1,nX98Algo=1,pinlen=6,测试未成功");
    XXX_RESULT_XXX
	
    XXX_OUTPUT_XXX
	printf("[OUT]szDestPinCipher	= %s\n",szDestPinCipher);
	printf("[OUT]szDestPinCipherExp = %s\n",szDestPinCipherExp);
    ASSERT_OUT_HEX(szDestPinCipher, szDestPinCipherExp,6);
    XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void ConvertPinX98ToIBM3624_Test_02(void)
{
	XXX_TEST_START_XXX
	int nSock = SM_SOCK;
	int nRet;
	char szSrcPan[20];
	int nSrcPanLen;
	char szDstPan[20];
	int nDstPanLen;
	BYTE bSrcPinKey[50];
	int nSrcPinKeyLen;
	BYTE bDstPinKey[50];
	int nDstPinKeyLen;
	BYTE bSrcPinCipher[50];
	char szDestPinCipher[15];
	char szDestPinCipherExp[15];

	bufclr(szSrcPan);
	bufclr(szDstPan);
	bufclr(bSrcPinKey);
	bufclr(bDstPinKey);
	bufclr(bSrcPinCipher);
	bufclr(szDestPinCipher);
	bufclr(szDestPinCipherExp);
	
	sprintf(szSrcPan,"6543210987654321");
	sprintf(szDstPan,"1234567890123456");
	nDstPanLen = strlen(szDstPan);
	nSrcPanLen = strlen(szSrcPan);

	//SrcPVK = 1234567890ABCDEF
	sprintf(bSrcPinKey,"\x62\xAB\xF2\xBC\x97\x25\x8E\x6F");
	nSrcPinKeyLen = strlen(bSrcPinKey);
	//DstPVK = FEDCBA0987654321
	sprintf(bDstPinKey,"\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nDstPinKeyLen = strlen(bDstPinKey);
	//PlainPIN = 123456
	sprintf(bSrcPinCipher,"\x2F\x5F\x7C\x08\xC7\xFC\xBE\x55");
	sprintf(szDestPinCipherExp,"969853");

    XXX_INPUT_XXX
    printf("[IN ]nSock			= %d\n", nSock);
    printf("[IN ]nMode			= 1\n");
    printf("[IN ]nX98Algo		= 2\n");
    printf("[IN ]szSrcPan		= %s\n",szSrcPan);
    printf("[IN ]nSrcPanLen		= %d\n",nSrcPanLen);
    printf("[IN ]szDstPan		= %s\n",szDstPan);
	printf("[IN ]nDstPanLen  	= %d\n",nDstPanLen);
	DspHex("[IN ]bSrcPinKey		= ",bSrcPinKey,8);
	printf("[IN ]nSrcPinKeyLen	= %d\n",nSrcPinKeyLen);
	DspHex("[IN ]bDstPinKey		= ",bDstPinKey,8);
	printf("[IN ]nDstPinKeyLen	= %d\n",nDstPinKeyLen);
	DspHex("[IN ]bSrcPinCipher	= ",bSrcPinCipher,8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
	nRet = SMAPIConvertPinX98ToIBM3624(nSock,1,2,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDstPinKey,nDstPinKeyLen,bSrcPinCipher,szDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=1,nX98Algo=2,pinlen=6,测试未成功");
    XXX_RESULT_XXX
	
    XXX_OUTPUT_XXX
	printf("[OUT]szDestPinCipher	= %s\n",szDestPinCipher);
	printf("[OUT]szDestPinCipherExp = %s\n",szDestPinCipherExp);
    ASSERT_OUT_HEX(szDestPinCipher, szDestPinCipherExp,6);
    XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void ConvertPinX98ToIBM3624_Test_03(void)
{
	XXX_TEST_START_XXX
	int nSock = SM_SOCK;
	int nRet;
	char szSrcPan[20];
	int nSrcPanLen;
	char szDstPan[20];
	int nDstPanLen;
	BYTE bSrcPinKey[50];
	int nSrcPinKeyLen;
	BYTE bDstPinKey[50];
	int nDstPinKeyLen;
	BYTE bSrcPinCipher[50];
	char szDestPinCipher[15];
	char szDestPinCipherExp[15];

	bufclr(szSrcPan);
	bufclr(szDstPan);
	bufclr(bSrcPinKey);
	bufclr(bDstPinKey);
	bufclr(bSrcPinCipher);
	bufclr(szDestPinCipher);
	bufclr(szDestPinCipherExp);
	
	sprintf(szDstPan,"1234567890123456");
	nDstPanLen = strlen(szDstPan);
	nSrcPanLen = strlen(szSrcPan);

	//SrcPVK = 1234567890ABCDEFFEDCBA0987654321
	sprintf(bSrcPinKey,"\x62\xAB\xF2\xBC\x97\x25\x8E\x6F\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nSrcPinKeyLen = strlen(bSrcPinKey);
	//DstPVK = FEDCBA0987654321
	sprintf(bDstPinKey,"\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nDstPinKeyLen = strlen(bDstPinKey);
	//PIN = 123456
	sprintf(bSrcPinCipher,"\xB7\xC5\x2B\xB3\x16\x18\xD5\x77");
	sprintf(szDestPinCipherExp,"969853");

    XXX_INPUT_XXX
    printf("[IN ]nSock			= %d\n", nSock);
    printf("[IN ]nMode			= 2\n");
    printf("[IN ]nX98Algo		= 1\n");
    printf("[IN ]szSrcPan		= %s\n",szSrcPan);
    printf("[IN ]nSrcPanLen		= %d\n",nSrcPanLen);
    printf("[IN ]szDstPan		= %s\n",szDstPan);
	printf("[IN ]nDstPanLen  	= %d\n",nDstPanLen);
	DspHex("[IN ]bSrcPinKey		= ",bSrcPinKey,16);
	printf("[IN ]nSrcPinKeyLen	= %d\n",nSrcPinKeyLen);
	DspHex("[IN ]bDstPinKey		= ",bDstPinKey,8);
	printf("[IN ]nDstPinKeyLen	= %d\n",nDstPinKeyLen);
	DspHex("[IN ]bSrcPinCipher	= ",bSrcPinCipher,8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
	nRet = SMAPIConvertPinX98ToIBM3624(nSock,2,1,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDstPinKey,nDstPinKeyLen,bSrcPinCipher,szDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=2,nX98Algo=1,pinlen=6,测试未成功");
    XXX_RESULT_XXX
	
    XXX_OUTPUT_XXX
	printf("[OUT]szDestPinCipher	= %s\n",szDestPinCipher);
	printf("[OUT]szDestPinCipherExp = %s\n",szDestPinCipherExp);
    ASSERT_OUT_HEX(szDestPinCipher, szDestPinCipherExp,6);
    XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void ConvertPinX98ToIBM3624_Test_04(void)
{
	XXX_TEST_START_XXX
	int nSock = SM_SOCK;
	int nRet;
	char szSrcPan[20];
	int nSrcPanLen;
	char szDstPan[20];
	int nDstPanLen;
	BYTE bSrcPinKey[50];
	int nSrcPinKeyLen;
	BYTE bDstPinKey[50];
	int nDstPinKeyLen;
	BYTE bSrcPinCipher[50];
	char szDestPinCipher[15];
	char szDestPinCipherExp[15];

	bufclr(szSrcPan);
	bufclr(szDstPan);
	bufclr(bSrcPinKey);
	bufclr(bDstPinKey);
	bufclr(bSrcPinCipher);
	bufclr(szDestPinCipher);
	bufclr(szDestPinCipherExp);
	
	sprintf(szSrcPan,"6543210987654321");
	sprintf(szDstPan,"1234567890123456");
	nDstPanLen = strlen(szDstPan);
	nSrcPanLen = strlen(szSrcPan);

	//SrcPVK = 1234567890ABCDEFFEDCBA0987654321
	sprintf(bSrcPinKey,"\x62\xAB\xF2\xBC\x97\x25\x8E\x6F\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nSrcPinKeyLen = strlen(bSrcPinKey);
	//DstPVK = FEDCBA0987654321
	sprintf(bDstPinKey,"\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nDstPinKeyLen = strlen(bDstPinKey);
	//PlainPIN = 123456
	sprintf(bSrcPinCipher,"\xC4\x6B\x6D\x8B\xCB\xB1\x58\x6C");
	sprintf(szDestPinCipherExp,"969853");

    XXX_INPUT_XXX
    printf("[IN ]nSock			= %d\n", nSock);
    printf("[IN ]nMode			= 2\n");
    printf("[IN ]nX98Algo		= 2\n");
    printf("[IN ]szSrcPan		= %s\n",szSrcPan);
    printf("[IN ]nSrcPanLen		= %d\n",nSrcPanLen);
    printf("[IN ]szDstPan		= %s\n",szDstPan);
	printf("[IN ]nDstPanLen  	= %d\n",nDstPanLen);
	DspHex("[IN ]bSrcPinKey		= ",bSrcPinKey,16);
	printf("[IN ]nSrcPinKeyLen	= %d\n",nSrcPinKeyLen);
	DspHex("[IN ]bDstPinKey		= ",bDstPinKey,8);
	printf("[IN ]nDstPinKeyLen	= %d\n",nDstPinKeyLen);
	DspHex("[IN ]bSrcPinCipher	= ",bSrcPinCipher,8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
	nRet = SMAPIConvertPinX98ToIBM3624(nSock,2,2,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDstPinKey,nDstPinKeyLen,bSrcPinCipher,szDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=2,nX98Algo=2,pinlen=6,测试未成功");
    XXX_RESULT_XXX
	
    XXX_OUTPUT_XXX
	printf("[OUT]szDestPinCipher	= %s\n",szDestPinCipher);
	printf("[OUT]szDestPinCipherExp = %s\n",szDestPinCipherExp);
    ASSERT_OUT_HEX(szDestPinCipher, szDestPinCipherExp,6);
    XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void ConvertPinX98ToIBM3624_Test_05(void)
{
	XXX_TEST_START_XXX
	int nSock = SM_SOCK;
	int nRet;
	char szSrcPan[20];
	int nSrcPanLen;
	char szDstPan[20];
	int nDstPanLen;
	BYTE bSrcPinKey[50];
	int nSrcPinKeyLen;
	BYTE bDstPinKey[50];
	int nDstPinKeyLen;
	BYTE bSrcPinCipher[50];
	char szDestPinCipher[15];
	char szDestPinCipherExp[15];

	bufclr(szSrcPan);
	bufclr(szDstPan);
	bufclr(bSrcPinKey);
	bufclr(bDstPinKey);
	bufclr(bSrcPinCipher);
	bufclr(szDestPinCipher);
	bufclr(szDestPinCipherExp);
	
	sprintf(szDstPan,"1234567890123456");
	nDstPanLen = strlen(szDstPan);
	nSrcPanLen = strlen(szSrcPan);

	//SrcPVK = 1234567890ABCDEFFEDCBA09876543211234567890ABCDEF
	sprintf(bSrcPinKey,"\x62\xAB\xF2\xBC\x97\x25\x8E\x6F\xEB\x43"\
			"\x38\x26\x98\xFD\x83\xCD\x62\xAB\xF2\xBC\x97\x25\x8E\x6F");
	nSrcPinKeyLen = strlen(bSrcPinKey);
	//DstPVK = FEDCBA0987654321
	sprintf(bDstPinKey,"\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nDstPinKeyLen = strlen(bDstPinKey);
	//PIN = 123456
	sprintf(bSrcPinCipher,"\xB7\xC5\x2B\xB3\x16\x18\xD5\x77");
	sprintf(szDestPinCipherExp,"969853");

    XXX_INPUT_XXX
    printf("[IN ]nSock			= %d\n", nSock);
    printf("[IN ]nMode			= 3\n");
    printf("[IN ]nX98Algo		= 1\n");
    printf("[IN ]szSrcPan		= %s\n",szSrcPan);
    printf("[IN ]nSrcPanLen		= %d\n",nSrcPanLen);
    printf("[IN ]szDstPan		= %s\n",szDstPan);
	printf("[IN ]nDstPanLen  	= %d\n",nDstPanLen);
	DspHex("[IN ]bSrcPinKey		= ",bSrcPinKey,24);
	printf("[IN ]nSrcPinKeyLen	= %d\n",nSrcPinKeyLen);
	DspHex("[IN ]bDstPinKey		= ",bDstPinKey,8);
	printf("[IN ]nDstPinKeyLen	= %d\n",nDstPinKeyLen);
	DspHex("[IN ]bSrcPinCipher	= ",bSrcPinCipher,8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
	nRet = SMAPIConvertPinX98ToIBM3624(nSock,3,1,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDstPinKey,nDstPinKeyLen,bSrcPinCipher,szDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=3,nX98Algo=1,pinlen=6,测试未成功");
    XXX_RESULT_XXX
	
    XXX_OUTPUT_XXX
	printf("[OUT]szDestPinCipher	= %s\n",szDestPinCipher);
	printf("[OUT]szDestPinCipherExp = %s\n",szDestPinCipherExp);
    ASSERT_OUT_HEX(szDestPinCipher, szDestPinCipherExp,6);
    XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void ConvertPinX98ToIBM3624_Test_06(void)
{
	XXX_TEST_START_XXX
	int nSock = SM_SOCK;
	int nRet;
	char szSrcPan[20];
	int nSrcPanLen;
	char szDstPan[20];
	int nDstPanLen;
	BYTE bSrcPinKey[50];
	int nSrcPinKeyLen;
	BYTE bDstPinKey[50];
	int nDstPinKeyLen;
	BYTE bSrcPinCipher[50];
	char szDestPinCipher[15];
	char szDestPinCipherExp[15];

	bufclr(szSrcPan);
	bufclr(szDstPan);
	bufclr(bSrcPinKey);
	bufclr(bDstPinKey);
	bufclr(bSrcPinCipher);
	bufclr(szDestPinCipher);
	bufclr(szDestPinCipherExp);
	
	sprintf(szSrcPan,"6543210987654321");
	sprintf(szDstPan,"1234567890123456");
	nDstPanLen = strlen(szDstPan);
	nSrcPanLen = strlen(szSrcPan);

	//SrcPVK = 1234567890ABCDEFFEDCBA09876543211234567890ABCDEF
	sprintf(bSrcPinKey,"\x62\xAB\xF2\xBC\x97\x25\x8E\x6F\xEB\x43"\
			"\x38\x26\x98\xFD\x83\xCD\x62\xAB\xF2\xBC\x97\x25\x8E\x6F");
	nSrcPinKeyLen = strlen(bSrcPinKey);
	//DstPVK = FEDCBA0987654321
	sprintf(bDstPinKey,"\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nDstPinKeyLen = strlen(bDstPinKey);
	//PIN = 123456
	sprintf(bSrcPinCipher,"\xC4\x6B\x6D\x8B\xCB\xB1\x58\x6C");
	sprintf(szDestPinCipherExp,"969853");

    XXX_INPUT_XXX
    printf("[IN ]nSock			= %d\n", nSock);
    printf("[IN ]nMode			= 3\n");
    printf("[IN ]nX98Algo		= 2\n");
    printf("[IN ]szSrcPan		= %s\n",szSrcPan);
    printf("[IN ]nSrcPanLen		= %d\n",nSrcPanLen);
    printf("[IN ]szDstPan		= %s\n",szDstPan);
	printf("[IN ]nDstPanLen  	= %d\n",nDstPanLen);
	DspHex("[IN ]bSrcPinKey		= ",bSrcPinKey,24);
	printf("[IN ]nSrcPinKeyLen	= %d\n",nSrcPinKeyLen);
	DspHex("[IN ]bDstPinKey		= ",bDstPinKey,8);
	printf("[IN ]nDstPinKeyLen	= %d\n",nDstPinKeyLen);
	DspHex("[IN ]bSrcPinCipher	= ",bSrcPinCipher,8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
	nRet = SMAPIConvertPinX98ToIBM3624(nSock,3,2,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDstPinKey,nDstPinKeyLen,bSrcPinCipher,szDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=3,nX98Algo=2,pinlen=6,测试未成功");
    XXX_RESULT_XXX
	
    XXX_OUTPUT_XXX
	printf("[OUT]szDestPinCipher	= %s\n",szDestPinCipher);
	printf("[OUT]szDestPinCipherExp = %s\n",szDestPinCipherExp);
    ASSERT_OUT_HEX(szDestPinCipher, szDestPinCipherExp,6);
    XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void ConvertPinX98ToIBM3624_Test_07(void)
{
	XXX_TEST_START_XXX
	int nSock = SM_SOCK;
	int nRet;
	char szSrcPan[20];
	int nSrcPanLen;
	char szDstPan[20];
	int nDstPanLen;
	BYTE bSrcPinKey[50];
	int nSrcPinKeyLen;
	BYTE bDstPinKey[50];
	int nDstPinKeyLen;
	BYTE bSrcPinCipher[50];
	char szDestPinCipher[15];
	char szDestPinCipherExp[15];

	bufclr(szSrcPan);
	bufclr(szDstPan);
	bufclr(bSrcPinKey);
	bufclr(bDstPinKey);
	bufclr(bSrcPinCipher);
	bufclr(szDestPinCipher);
	bufclr(szDestPinCipherExp);
	
	sprintf(szDstPan,"1234567890123456");
	nDstPanLen = strlen(szDstPan);
	nSrcPanLen = strlen(szSrcPan);

	//SrcPVK = 1234567890ABCDEFFEDCBA0987654321
	sprintf(bSrcPinKey,"\x62\xAB\xF2\xBC\x97\x25\x8E\x6F\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nSrcPinKeyLen = strlen(bSrcPinKey);
	//DstPVK = FEDCBA0987654321
	sprintf(bDstPinKey,"\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nDstPinKeyLen = strlen(bDstPinKey);
	//PIN = 123456
	sprintf(bSrcPinCipher,"\xA7\xC0\x67\xD9\xD2\x41\xE2\xCA\x24\x98\xCE\x0A\xFA\xDB\x2E\xAF");
	//sprintf(bSrcPinCipher,"\xB2\xEF\xD3\xDE\x38\xC8\xE6\x33\xEF\x36\x2C\x04\x77\x7F\x7C\xFA");
	sprintf(szDestPinCipherExp,"969853");

    XXX_INPUT_XXX
    printf("[IN ]nSock			= %d\n", nSock);
    printf("[IN ]nMode			= 4\n");
    printf("[IN ]nX98Algo		= 1\n");
    printf("[IN ]szSrcPan		= %s\n",szSrcPan);
    printf("[IN ]nSrcPanLen		= %d\n",nSrcPanLen);
    printf("[IN ]szDstPan		= %s\n",szDstPan);
	printf("[IN ]nDstPanLen  	= %d\n",nDstPanLen);
	DspHex("[IN ]bSrcPinKey		= ",bSrcPinKey,16);
	printf("[IN ]nSrcPinKeyLen	= %d\n",nSrcPinKeyLen);
	DspHex("[IN ]bDstPinKey		= ",bDstPinKey,8);
	printf("[IN ]nDstPinKeyLen	= %d\n",nDstPinKeyLen);
	DspHex("[IN ]bSrcPinCipher	= ",bSrcPinCipher,16);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
	nRet = SMAPIConvertPinX98ToIBM3624(nSock,4,1,NULL,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDstPinKey,nDstPinKeyLen,bSrcPinCipher,szDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=4,nX98Algo=1,pinlen=6,测试未成功");
    XXX_RESULT_XXX
	
    XXX_OUTPUT_XXX
	printf("[OUT]szDestPinCipher	= %s\n",szDestPinCipher);
	printf("[OUT]szDestPinCipherExp = %s\n",szDestPinCipherExp);
    ASSERT_OUT_HEX(szDestPinCipher, szDestPinCipherExp,6);
    XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void ConvertPinX98ToIBM3624_Test_08(void)
{
	XXX_TEST_START_XXX
	int nSock = SM_SOCK;
	int nRet;
	char szSrcPan[20];
	int nSrcPanLen;
	char szDstPan[20];
	int nDstPanLen;
	BYTE bSrcPinKey[50];
	int nSrcPinKeyLen;
	BYTE bDstPinKey[50];
	int nDstPinKeyLen;
	BYTE bSrcPinCipher[50];
	char szDestPinCipher[15];
	char szDestPinCipherExp[15];

	bufclr(szSrcPan);
	bufclr(szDstPan);
	bufclr(bSrcPinKey);
	bufclr(bDstPinKey);
	bufclr(bSrcPinCipher);
	bufclr(szDestPinCipher);
	bufclr(szDestPinCipherExp);
	
	sprintf(szSrcPan,"6543210987654321");
	sprintf(szDstPan,"1234567890123456");
	nDstPanLen = strlen(szDstPan);
	nSrcPanLen = strlen(szSrcPan);

	//SrcPVK = 1234567890ABCDEFFEDCBA0987654321
	sprintf(bSrcPinKey,"\x62\xAB\xF2\xBC\x97\x25\x8E\x6F\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nSrcPinKeyLen = strlen(bSrcPinKey);
	//DstPVK = FEDCBA0987654321
	sprintf(bDstPinKey,"\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nDstPinKeyLen = strlen(bDstPinKey);
	//PIN = 123456
	sprintf(bSrcPinCipher,"\xB2\xEF\xD3\xDE\x38\xC8\xE6\x33\xEF\x36\x2C\x04\x77\x7F\x7C\xFA");
	//sprintf(bSrcPinCipher,"\xA7\xC0\x67\xD9\xD2\x41\xE2\xCA\x24\x98\xCE\x0A\xFA\xDB\x2E\xAF");
	sprintf(szDestPinCipherExp,"969853");

    XXX_INPUT_XXX
    printf("[IN ]nSock			= %d\n", nSock);
    printf("[IN ]nMode			= 4\n");
    printf("[IN ]nX98Algo		= 2\n");
    printf("[IN ]szSrcPan		= %s\n",szSrcPan);
    printf("[IN ]nSrcPanLen		= %d\n",nSrcPanLen);
    printf("[IN ]szDstPan		= %s\n",szDstPan);
	printf("[IN ]nDstPanLen  	= %d\n",nDstPanLen);
	DspHex("[IN ]bSrcPinKey		= ",bSrcPinKey,16);
	printf("[IN ]nSrcPinKeyLen	= %d\n",nSrcPinKeyLen);
	DspHex("[IN ]bDstPinKey		= ",bDstPinKey,8);
	printf("[IN ]nDstPinKeyLen	= %d\n",nDstPinKeyLen);
	DspHex("[IN ]bSrcPinCipher	= ",bSrcPinCipher,16);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
	nRet = SMAPIConvertPinX98ToIBM3624(nSock,4,2,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDstPinKey,nDstPinKeyLen,bSrcPinCipher,szDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=4,nX98Algo=2,pinlen=6,测试未成功");
    XXX_RESULT_XXX
	
    XXX_OUTPUT_XXX
	printf("[OUT]szDestPinCipher	= %s\n",szDestPinCipher);
	printf("[OUT]szDestPinCipherExp = %s\n",szDestPinCipherExp);
    ASSERT_OUT_HEX(szDestPinCipher, szDestPinCipherExp,6);
    XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void ConvertPinX98ToIBM3624_Test_09(void)
{
	XXX_TEST_START_XXX
	int nSock = SM_SOCK;
	int nRet;
	char szSrcPan[20];
	int nSrcPanLen;
	char szDstPan[20];
	int nDstPanLen;
	BYTE bSrcPinKey[50];
	int nSrcPinKeyLen;
	BYTE bDstPinKey[50];
	int nDstPinKeyLen;
	BYTE bSrcPinCipher[50];
	char szDestPinCipher[15];
	char szDestPinCipherExp[15];

	bufclr(szSrcPan);
	bufclr(szDstPan);
	bufclr(bSrcPinKey);
	bufclr(bDstPinKey);
	bufclr(bSrcPinCipher);
	bufclr(szDestPinCipher);
	bufclr(szDestPinCipherExp);
	
	sprintf(szSrcPan,"6543210987654321");
	sprintf(szDstPan,"1234567890123456");
	nDstPanLen = strlen(szDstPan);
	nSrcPanLen = strlen(szSrcPan);

	//SrcPVK = 1234567890ABCDEFFEDCBA0987654321
	sprintf(bSrcPinKey,"\x62\xAB\xF2\xBC\x97\x25\x8E\x6F\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nSrcPinKeyLen = strlen(bSrcPinKey);
	//DstPVK = FEDCBA0987654321
	sprintf(bDstPinKey,"\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nDstPinKeyLen = strlen(bDstPinKey);
	//PIN = 123456789012
	sprintf(bSrcPinCipher,"\x32\x3E\xC4\x12\x65\x1C\xD0\x8B\xA7\x62\x42\x6E\xD5\xFC\x89\xB9");
	//sprintf(bSrcPinCipher,"\xA7\xC0\x67\xD9\xD2\x41\xE2\xCA\x24\x98\xCE\x0A\xFA\xDB\x2E\xAF");
	sprintf(szDestPinCipherExp,"969853158517");

    XXX_INPUT_XXX
    printf("[IN ]nSock			= %d\n", nSock);
    printf("[IN ]nMode			= 4\n");
    printf("[IN ]nX98Algo		= 2\n");
    printf("[IN ]szSrcPan		= %s\n",szSrcPan);
    printf("[IN ]nSrcPanLen		= %d\n",nSrcPanLen);
    printf("[IN ]szDstPan		= %s\n",szDstPan);
	printf("[IN ]nDstPanLen  	= %d\n",nDstPanLen);
	DspHex("[IN ]bSrcPinKey		= ",bSrcPinKey,16);
	printf("[IN ]nSrcPinKeyLen	= %d\n",nSrcPinKeyLen);
	DspHex("[IN ]bDstPinKey		= ",bDstPinKey,8);
	printf("[IN ]nDstPinKeyLen	= %d\n",nDstPinKeyLen);
	DspHex("[IN ]bSrcPinCipher	= ",bSrcPinCipher,16);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
	nRet = SMAPIConvertPinX98ToIBM3624(nSock,4,2,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDstPinKey,nDstPinKeyLen,bSrcPinCipher,szDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=4,nX98Algo=2,pinlen=12,测试未成功");
    XXX_RESULT_XXX
	
    XXX_OUTPUT_XXX
	printf("[OUT]szDestPinCipher	= %s\n",szDestPinCipher);
	printf("[OUT]szDestPinCipherExp = %s\n",szDestPinCipherExp);
    ASSERT_OUT_HEX(szDestPinCipher, szDestPinCipherExp,12);
    XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void ConvertPinX98ToIBM3624_Test_10(void)
{
	XXX_TEST_START_XXX
	int nSock = SM_SOCK;
	int nRet;
	char szSrcPan[20];
	int nSrcPanLen;
	char szDstPan[20];
	int nDstPanLen;
	BYTE bSrcPinKey[50];
	int nSrcPinKeyLen;
	BYTE bDstPinKey[50];
	int nDstPinKeyLen;
	BYTE bSrcPinCipher[50];
	char szDestPinCipher[15];
	char szDestPinCipherExp[15];

	bufclr(szSrcPan);
	bufclr(szDstPan);
	bufclr(bSrcPinKey);
	bufclr(bDstPinKey);
	bufclr(bSrcPinCipher);
	bufclr(szDestPinCipher);
	bufclr(szDestPinCipherExp);
	
	sprintf(szSrcPan,"6543210987654321");
	sprintf(szDstPan,"1234567890123456");
	nDstPanLen = strlen(szDstPan);
	nSrcPanLen = strlen(szSrcPan);

	//SrcPVK = 1234567890ABCDEFFEDCBA0987654321
	sprintf(bSrcPinKey,"\x62\xAB\xF2\xBC\x97\x25\x8E\x6F\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nSrcPinKeyLen = strlen(bSrcPinKey);
	//DstPVK = FEDCBA0987654321
	sprintf(bDstPinKey,"\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nDstPinKeyLen = strlen(bDstPinKey);
	//PIN = 12345678901
	memcpy(bSrcPinCipher,"\x6F\xC3\x22\x22\x93\xB7\x2C\x00\xBB\x8A\x9C\x51\xF0\xE1\x80\xFA",16);
	//sprintf(bSrcPinCipher,"\xA7\xC0\x67\xD9\xD2\x41\xE2\xCA\x24\x98\xCE\x0A\xFA\xDB\x2E\xAF");
	sprintf(szDestPinCipherExp,"96985315851");

    XXX_INPUT_XXX
    printf("[IN ]nSock			= %d\n", nSock);
    printf("[IN ]nMode			= 4\n");
    printf("[IN ]nX98Algo		= 2\n");
    printf("[IN ]szSrcPan		= %s\n",szSrcPan);
    printf("[IN ]nSrcPanLen		= %d\n",nSrcPanLen);
    printf("[IN ]szDstPan		= %s\n",szDstPan);
	printf("[IN ]nDstPanLen  	= %d\n",nDstPanLen);
	DspHex("[IN ]bSrcPinKey		= ",bSrcPinKey,16);
	printf("[IN ]nSrcPinKeyLen	= %d\n",nSrcPinKeyLen);
	DspHex("[IN ]bDstPinKey		= ",bDstPinKey,8);
	printf("[IN ]nDstPinKeyLen	= %d\n",nDstPinKeyLen);
	DspHex("[IN ]bSrcPinCipher	= ",bSrcPinCipher,16);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
	nRet = SMAPIConvertPinX98ToIBM3624(nSock,4,2,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDstPinKey,nDstPinKeyLen,bSrcPinCipher,szDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=4,nX98Algo=2,pinlen=11,测试未成功");
    XXX_RESULT_XXX
	
    XXX_OUTPUT_XXX
	printf("[OUT]szDestPinCipher	= %s\n",szDestPinCipher);
	printf("[OUT]szDestPinCipherExp = %s\n",szDestPinCipherExp);
    ASSERT_OUT_HEX(szDestPinCipher, szDestPinCipherExp,11);
    XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void ConvertPinX98ToIBM3624_Test_11(void)
{
	XXX_TEST_START_XXX
	int nSock = SM_SOCK;
	int nRet;
	char szSrcPan[20];
	int nSrcPanLen;
	char szDstPan[20];
	int nDstPanLen;
	BYTE bSrcPinKey[50];
	int nSrcPinKeyLen;
	BYTE bDstPinKey[50];
	int nDstPinKeyLen;
	BYTE bSrcPinCipher[50];
	char szDestPinCipher[15];
	char szDestPinCipherExp[15];

	bufclr(szSrcPan);
	bufclr(szDstPan);
	bufclr(bSrcPinKey);
	bufclr(bDstPinKey);
	bufclr(bSrcPinCipher);
	bufclr(szDestPinCipher);
	bufclr(szDestPinCipherExp);
	
	sprintf(szSrcPan,"6543210987654321");
	sprintf(szDstPan,"1234567890123456");
	nDstPanLen = strlen(szDstPan);
	nSrcPanLen = strlen(szSrcPan);

	//SrcPVK = 1234567890ABCDEFFEDCBA0987654321
	sprintf(bSrcPinKey,"\x62\xAB\xF2\xBC\x97\x25\x8E\x6F\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nSrcPinKeyLen = strlen(bSrcPinKey);
	//DstPVK = FEDCBA0987654321
	sprintf(bDstPinKey,"\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nDstPinKeyLen = strlen(bDstPinKey);
	//PIN = 1234
	memcpy(bSrcPinCipher,"\xE8\xB9\xDF\xA4\x04\x4C\xD3\x2B\x0F\xC0\xCE\xFE\xF0\x68\xBC\x3A",16);
	//sprintf(bSrcPinCipher,"\xA7\xC0\x67\xD9\xD2\x41\xE2\xCA\x24\x98\xCE\x0A\xFA\xDB\x2E\xAF");
	sprintf(szDestPinCipherExp,"9698");

    XXX_INPUT_XXX
    printf("[IN ]nSock			= %d\n", nSock);
    printf("[IN ]nMode			= 4\n");
    printf("[IN ]nX98Algo		= 2\n");
    printf("[IN ]szSrcPan		= %s\n",szSrcPan);
    printf("[IN ]nSrcPanLen		= %d\n",nSrcPanLen);
    printf("[IN ]szDstPan		= %s\n",szDstPan);
	printf("[IN ]nDstPanLen  	= %d\n",nDstPanLen);
	DspHex("[IN ]bSrcPinKey		= ",bSrcPinKey,16);
	printf("[IN ]nSrcPinKeyLen	= %d\n",nSrcPinKeyLen);
	DspHex("[IN ]bDstPinKey		= ",bDstPinKey,8);
	printf("[IN ]nDstPinKeyLen	= %d\n",nDstPinKeyLen);
	DspHex("[IN ]bSrcPinCipher	= ",bSrcPinCipher,16);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
	nRet = SMAPIConvertPinX98ToIBM3624(nSock,4,2,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDstPinKey,nDstPinKeyLen,bSrcPinCipher,szDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=4,nX98Algo=2,pinlen=4,测试未成功");
    XXX_RESULT_XXX
	
    XXX_OUTPUT_XXX
	printf("[OUT]szDestPinCipher	= %s\n",szDestPinCipher);
	printf("[OUT]szDestPinCipherExp = %s\n",szDestPinCipherExp);
    ASSERT_OUT_HEX(szDestPinCipher, szDestPinCipherExp,4);
    XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void ConvertPinX98ToIBM3624_Test_12(void)
{
	XXX_TEST_START_XXX
	int nSock = SM_SOCK;
	int nRet;
	char szSrcPan[20];
	int nSrcPanLen;
	char szDstPan[20];
	int nDstPanLen;
	BYTE bSrcPinKey[50];
	int nSrcPinKeyLen;
	BYTE bDstPinKey[50];
	int nDstPinKeyLen;
	BYTE bSrcPinCipher[50];
	char szDestPinCipher[15];
	char szDestPinCipherExp[15];

	bufclr(szSrcPan);
	bufclr(szDstPan);
	bufclr(bSrcPinKey);
	bufclr(bDstPinKey);
	bufclr(bSrcPinCipher);
	bufclr(szDestPinCipher);
	bufclr(szDestPinCipherExp);
	
	sprintf(szSrcPan,"6543210987654321");
	sprintf(szDstPan,"1234567890123456");
	nDstPanLen = strlen(szDstPan);
	nSrcPanLen = strlen(szSrcPan);

	//SrcPVK = 1234567890ABCDEFFEDCBA0987654321
	sprintf(bSrcPinKey,"\x62\xAB\xF2\xBC\x97\x25\x8E\x6F\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nSrcPinKeyLen = strlen(bSrcPinKey);
	//DstPVK = FEDCBA0987654321
	sprintf(bDstPinKey,"\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nDstPinKeyLen = strlen(bDstPinKey);
	//PIN = 1
	memcpy(bSrcPinCipher,"\x7D\x40\x12\x7E\x94\x67\x20\xA7\x4A\x62\x19\xE6\xD3\xCA\xEF\x46",16);
	//sprintf(bSrcPinCipher,"\xA7\xC0\x67\xD9\xD2\x41\xE2\xCA\x24\x98\xCE\x0A\xFA\xDB\x2E\xAF");
	sprintf(szDestPinCipherExp,"9");

    XXX_INPUT_XXX
    printf("[IN ]nSock			= %d\n", nSock);
    printf("[IN ]nMode			= 4\n");
    printf("[IN ]nX98Algo		= 2\n");
    printf("[IN ]szSrcPan		= %s\n",szSrcPan);
    printf("[IN ]nSrcPanLen		= %d\n",nSrcPanLen);
    printf("[IN ]szDstPan		= %s\n",szDstPan);
	printf("[IN ]nDstPanLen  	= %d\n",nDstPanLen);
	DspHex("[IN ]bSrcPinKey		= ",bSrcPinKey,16);
	printf("[IN ]nSrcPinKeyLen	= %d\n",nSrcPinKeyLen);
	DspHex("[IN ]bDstPinKey		= ",bDstPinKey,8);
	printf("[IN ]nDstPinKeyLen	= %d\n",nDstPinKeyLen);
	DspHex("[IN ]bSrcPinCipher	= ",bSrcPinCipher,16);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
	nRet = SMAPIConvertPinX98ToIBM3624(nSock,4,2,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDstPinKey,nDstPinKeyLen,bSrcPinCipher,szDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=4,nX98Algo=2,pinlen=1,测试未成功");
    XXX_RESULT_XXX
	
    XXX_OUTPUT_XXX
	printf("[OUT]szDestPinCipher	= %s\n",szDestPinCipher);
	printf("[OUT]szDestPinCipherExp = %s\n",szDestPinCipherExp);
    ASSERT_OUT_HEX(szDestPinCipher, szDestPinCipherExp,1);
    XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void ConvertPinX98ToIBM3624_Test_13(void)
{
	XXX_TEST_START_XXX
	int nSock = SM_SOCK;
	int nRet;
	char szSrcPan[20];
	int nSrcPanLen;
	char szDstPan[20];
	int nDstPanLen;
	BYTE bSrcPinKey[50];
	int nSrcPinKeyLen;
	BYTE bDstPinKey[50];
	int nDstPinKeyLen;
	BYTE bSrcPinCipher[50];
	char szDestPinCipher[15];
	char szDestPinCipherExp[15];

	bufclr(szSrcPan);
	bufclr(szDstPan);
	bufclr(bSrcPinKey);
	bufclr(bDstPinKey);
	bufclr(bSrcPinCipher);
	bufclr(szDestPinCipher);
	bufclr(szDestPinCipherExp);
	
	sprintf(szSrcPan,"6543210987654321");
	sprintf(szDstPan,"1234567890123456");
	nDstPanLen = strlen(szDstPan);
	nSrcPanLen = strlen(szSrcPan);

	//SrcPVK = 1234567890ABCDEFFEDCBA0987654321
	sprintf(bSrcPinKey,"\x62\xAB\xF2\xBC\x97\x25\x8E\x6F\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nSrcPinKeyLen = strlen(bSrcPinKey);
	//DstPVK = FEDCBA0987654321
	sprintf(bDstPinKey,"\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nDstPinKeyLen = strlen(bDstPinKey);
	//PIN = 123456789012
	sprintf(bSrcPinCipher,"\x70\x1B\xC3\xE1\x7D\x9B\x1E\xB4\x6B\x91\x86\x98\xC4\xE1\x94\xB4");
	//sprintf(bSrcPinCipher,"\xA7\xC0\x67\xD9\xD2\x41\xE2\xCA\x24\x98\xCE\x0A\xFA\xDB\x2E\xAF");
	sprintf(szDestPinCipherExp,"969853158517");

    XXX_INPUT_XXX
    printf("[IN ]nSock			= %d\n", nSock);
    printf("[IN ]nMode			= 4\n");
    printf("[IN ]nX98Algo		= 1\n");
    printf("[IN ]szSrcPan		= %s\n",szSrcPan);
    printf("[IN ]nSrcPanLen		= %d\n",nSrcPanLen);
    printf("[IN ]szDstPan		= %s\n",szDstPan);
	printf("[IN ]nDstPanLen  	= %d\n",nDstPanLen);
	DspHex("[IN ]bSrcPinKey		= ",bSrcPinKey,16);
	printf("[IN ]nSrcPinKeyLen	= %d\n",nSrcPinKeyLen);
	DspHex("[IN ]bDstPinKey		= ",bDstPinKey,8);
	printf("[IN ]nDstPinKeyLen	= %d\n",nDstPinKeyLen);
	DspHex("[IN ]bSrcPinCipher	= ",bSrcPinCipher,16);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
	nRet = SMAPIConvertPinX98ToIBM3624(nSock,4,1,NULL,0,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDstPinKey,nDstPinKeyLen,bSrcPinCipher,szDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=4,nX98Algo=1,pinlen=12,测试未成功");
    XXX_RESULT_XXX
	
    XXX_OUTPUT_XXX
	printf("[OUT]szDestPinCipher	= %s\n",szDestPinCipher);
	printf("[OUT]szDestPinCipherExp = %s\n",szDestPinCipherExp);
    ASSERT_OUT_HEX(szDestPinCipher, szDestPinCipherExp,12);
    XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void ConvertPinX98ToIBM3624_Test_14(void)
{
	XXX_TEST_START_XXX
	int nSock = SM_SOCK;
	int nRet;
	char szSrcPan[20];
	int nSrcPanLen;
	char szDstPan[20];
	int nDstPanLen;
	BYTE bSrcPinKey[50];
	int nSrcPinKeyLen;
	BYTE bDstPinKey[50];
	int nDstPinKeyLen;
	BYTE bSrcPinCipher[50];
	char szDestPinCipher[15];
	char szDestPinCipherExp[15];

	bufclr(szSrcPan);
	bufclr(szDstPan);
	bufclr(bSrcPinKey);
	bufclr(bDstPinKey);
	bufclr(bSrcPinCipher);
	bufclr(szDestPinCipher);
	bufclr(szDestPinCipherExp);
	
	sprintf(szDstPan,"1234567890123456");
	nDstPanLen = strlen(szDstPan);
	nSrcPanLen = strlen(szSrcPan);

	//SrcPVK = 1234567890ABCDEF
	sprintf(bSrcPinKey,"\x62\xAB\xF2\xBC\x97\x25\x8E\x6F");
	nSrcPinKeyLen = strlen(bSrcPinKey);
	//DstPVK = FEDCBA0987654321
	sprintf(bDstPinKey,"\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nDstPinKeyLen = strlen(bDstPinKey);
	//PIN = 123456789012
	sprintf(bSrcPinCipher,"\xED\x43\x17\xD0\xC9\x6C\xDA\xCD");
	sprintf(szDestPinCipherExp,"969853158517");

    XXX_INPUT_XXX
    printf("[IN ]nSock			= %d\n", nSock);
    printf("[IN ]nMode			= 1\n");
    printf("[IN ]nX98Algo		= 1\n");
    printf("[IN ]szSrcPan		= %s\n",szSrcPan);
    printf("[IN ]nSrcPanLen		= %d\n",nSrcPanLen);
    printf("[IN ]szDstPan		= %s\n",szDstPan);
	printf("[IN ]nDstPanLen  	= %d\n",nDstPanLen);
	DspHex("[IN ]bSrcPinKey		= ",bSrcPinKey,8);
	printf("[IN ]nSrcPinKeyLen	= %d\n",nSrcPinKeyLen);
	DspHex("[IN ]bDstPinKey		= ",bDstPinKey,8);
	printf("[IN ]nDstPinKeyLen	= %d\n",nDstPinKeyLen);
	DspHex("[IN ]bSrcPinCipher	= ",bSrcPinCipher,8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
	nRet = SMAPIConvertPinX98ToIBM3624(nSock,1,1,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDstPinKey,nDstPinKeyLen,bSrcPinCipher,szDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=1,nX98Algo=1,pinlen=12,测试未成功");
    XXX_RESULT_XXX
	
    XXX_OUTPUT_XXX
	printf("[OUT]szDestPinCipher	= %s\n",szDestPinCipher);
	printf("[OUT]szDestPinCipherExp = %s\n",szDestPinCipherExp);
    ASSERT_OUT_HEX(szDestPinCipher, szDestPinCipherExp,12);
    XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void ConvertPinX98ToIBM3624_Test_15(void)
{
	XXX_TEST_START_XXX
	int nSock = SM_SOCK;
	int nRet;
	char szSrcPan[20];
	int nSrcPanLen;
	char szDstPan[20];
	int nDstPanLen;
	BYTE bSrcPinKey[50];
	int nSrcPinKeyLen;
	BYTE bDstPinKey[50];
	int nDstPinKeyLen;
	BYTE bSrcPinCipher[50];
	char szDestPinCipher[15];
	char szDestPinCipherExp[15];

	bufclr(szSrcPan);
	bufclr(szDstPan);
	bufclr(bSrcPinKey);
	bufclr(bDstPinKey);
	bufclr(bSrcPinCipher);
	bufclr(szDestPinCipher);
	bufclr(szDestPinCipherExp);
	
	sprintf(szDstPan,"1234567890123456");
	nDstPanLen = strlen(szDstPan);
	nSrcPanLen = strlen(szSrcPan);

	//SrcPVK = 1234567890ABCDEF
	sprintf(bSrcPinKey,"\x62\xAB\xF2\xBC\x97\x25\x8E\x6F");
	nSrcPinKeyLen = strlen(bSrcPinKey);
	//DstPVK = FEDCBA0987654321
	sprintf(bDstPinKey,"\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nDstPinKeyLen = strlen(bDstPinKey);
	//PIN = 12345678901
	sprintf(bSrcPinCipher,"\x57\x0D\x9F\x57\x5C\x66\x15\x3F");
	sprintf(szDestPinCipherExp,"96985315851");

    XXX_INPUT_XXX
    printf("[IN ]nSock			= %d\n", nSock);
    printf("[IN ]nMode			= 1\n");
    printf("[IN ]nX98Algo		= 1\n");
    printf("[IN ]szSrcPan		= %s\n",szSrcPan);
    printf("[IN ]nSrcPanLen		= %d\n",nSrcPanLen);
    printf("[IN ]szDstPan		= %s\n",szDstPan);
	printf("[IN ]nDstPanLen  	= %d\n",nDstPanLen);
	DspHex("[IN ]bSrcPinKey		= ",bSrcPinKey,8);
	printf("[IN ]nSrcPinKeyLen	= %d\n",nSrcPinKeyLen);
	DspHex("[IN ]bDstPinKey		= ",bDstPinKey,8);
	printf("[IN ]nDstPinKeyLen	= %d\n",nDstPinKeyLen);
	DspHex("[IN ]bSrcPinCipher	= ",bSrcPinCipher,8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
	nRet = SMAPIConvertPinX98ToIBM3624(nSock,1,1,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDstPinKey,nDstPinKeyLen,bSrcPinCipher,szDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=1,nX98Algo=1,pinlen=11,测试未成功");
    XXX_RESULT_XXX
	
    XXX_OUTPUT_XXX
	printf("[OUT]szDestPinCipher	= %s\n",szDestPinCipher);
	printf("[OUT]szDestPinCipherExp = %s\n",szDestPinCipherExp);
    ASSERT_OUT_HEX(szDestPinCipher, szDestPinCipherExp,11);
    XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void ConvertPinX98ToIBM3624_Test_16(void)
{
	XXX_TEST_START_XXX
	int nSock = SM_SOCK;
	int nRet;
	char szSrcPan[20];
	int nSrcPanLen;
	char szDstPan[20];
	int nDstPanLen;
	BYTE bSrcPinKey[50];
	int nSrcPinKeyLen;
	BYTE bDstPinKey[50];
	int nDstPinKeyLen;
	BYTE bSrcPinCipher[50];
	char szDestPinCipher[15];
	char szDestPinCipherExp[15];

	bufclr(szSrcPan);
	bufclr(szDstPan);
	bufclr(bSrcPinKey);
	bufclr(bDstPinKey);
	bufclr(bSrcPinCipher);
	bufclr(szDestPinCipher);
	bufclr(szDestPinCipherExp);
	
	sprintf(szSrcPan,"98765432109876543210");
	sprintf(szDstPan,"12345678901234567890");
	nDstPanLen = strlen(szDstPan);
	nSrcPanLen = strlen(szSrcPan);

	//SrcPVK = 1234567890ABCDEFFEDCBA0987654321
	sprintf(bSrcPinKey,"\x62\xAB\xF2\xBC\x97\x25\x8E\x6F\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nSrcPinKeyLen = strlen(bSrcPinKey);
	//DstPVK = FEDCBA0987654321
	sprintf(bDstPinKey,"\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nDstPinKeyLen = strlen(bDstPinKey);
	//PIN = 123456
	sprintf(bSrcPinCipher,"\xD8\x8A\xF3\x8B\x40\x32\xB2\xB0\x5C\xC3\x12\x57\xCD\x3B\x86\xC0");
	//sprintf(bSrcPinCipher,"\xA7\xC0\x67\xD9\xD2\x41\xE2\xCA\x24\x98\xCE\x0A\xFA\xDB\x2E\xAF");
	sprintf(szDestPinCipherExp,"302356");

    XXX_INPUT_XXX
    printf("[IN ]nSock			= %d\n", nSock);
    printf("[IN ]nMode			= 4\n");
    printf("[IN ]nX98Algo		= 2\n");
    printf("[IN ]szSrcPan		= %s\n",szSrcPan);
    printf("[IN ]nSrcPanLen		= %d\n",nSrcPanLen);
    printf("[IN ]szDstPan		= %s\n",szDstPan);
	printf("[IN ]nDstPanLen  	= %d\n",nDstPanLen);
	DspHex("[IN ]bSrcPinKey		= ",bSrcPinKey,16);
	printf("[IN ]nSrcPinKeyLen	= %d\n",nSrcPinKeyLen);
	DspHex("[IN ]bDstPinKey		= ",bDstPinKey,8);
	printf("[IN ]nDstPinKeyLen	= %d\n",nDstPinKeyLen);
	DspHex("[IN ]bSrcPinCipher	= ",bSrcPinCipher,16);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
	nRet = SMAPIConvertPinX98ToIBM3624(nSock,4,2,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDstPinKey,nDstPinKeyLen,bSrcPinCipher,szDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "mode=4,nX98Algo=2,PanLen=20,测试未失败");
    XXX_RESULT_XXX
	
    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void ConvertPinX98ToIBM3624_Test_17(void)
{
	XXX_TEST_START_XXX
	int nSock = SM_SOCK;
	int nRet;
	char szSrcPan[20];
	int nSrcPanLen;
	char szDstPan[20];
	int nDstPanLen;
	BYTE bSrcPinKey[50];
	int nSrcPinKeyLen;
	BYTE bDstPinKey[50];
	int nDstPinKeyLen;
	BYTE bSrcPinCipher[50];
	char szDestPinCipher[15];
	char szDestPinCipherExp[15];

	bufclr(szSrcPan);
	bufclr(szDstPan);
	bufclr(bSrcPinKey);
	bufclr(bDstPinKey);
	bufclr(bSrcPinCipher);
	bufclr(szDestPinCipher);
	bufclr(szDestPinCipherExp);
	
	sprintf(szSrcPan,"2109876543210");
	sprintf(szDstPan,"5678901234567890");
	nDstPanLen = strlen(szDstPan);
	nSrcPanLen = strlen(szSrcPan);

	//SrcPVK = 1234567890ABCDEFFEDCBA0987654321
	sprintf(bSrcPinKey,"\x62\xAB\xF2\xBC\x97\x25\x8E\x6F\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nSrcPinKeyLen = strlen(bSrcPinKey);
	//DstPVK = FEDCBA0987654321
	sprintf(bDstPinKey,"\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nDstPinKeyLen = strlen(bDstPinKey);
	//PIN = 123456
	sprintf(bSrcPinCipher,"\xD8\x8A\xF3\x8B\x40\x32\xB2\xB0\x5C\xC3\x12\x57\xCD\x3B\x86\xC0");
	//sprintf(bSrcPinCipher,"\xA7\xC0\x67\xD9\xD2\x41\xE2\xCA\x24\x98\xCE\x0A\xFA\xDB\x2E\xAF");
	sprintf(szDestPinCipherExp,"302356");

    XXX_INPUT_XXX
    printf("[IN ]nSock			= %d\n", nSock);
    printf("[IN ]nMode			= 4\n");
    printf("[IN ]nX98Algo		= 2\n");
    printf("[IN ]szSrcPan		= %s\n",szSrcPan);
    printf("[IN ]nSrcPanLen		= %d\n",nSrcPanLen);
    printf("[IN ]szDstPan		= %s\n",szDstPan);
	printf("[IN ]nDstPanLen  	= %d\n",nDstPanLen);
	DspHex("[IN ]bSrcPinKey		= ",bSrcPinKey,16);
	printf("[IN ]nSrcPinKeyLen	= %d\n",nSrcPinKeyLen);
	DspHex("[IN ]bDstPinKey		= ",bDstPinKey,8);
	printf("[IN ]nDstPinKeyLen	= %d\n",nDstPinKeyLen);
	DspHex("[IN ]bSrcPinCipher	= ",bSrcPinCipher,16);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
	nRet = SMAPIConvertPinX98ToIBM3624(nSock,4,2,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDstPinKey,nDstPinKeyLen,bSrcPinCipher,szDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=4,nX98Algo=2,SrcPanLen=13,DstPanLen=16,测试未失败");
    XXX_RESULT_XXX
	
    XXX_OUTPUT_XXX
	printf("[OUT]szDestPinCipher	= %s\n",szDestPinCipher);
	printf("[OUT]szDestPinCipherExp = %s\n",szDestPinCipherExp);
    ASSERT_OUT_HEX(szDestPinCipher, szDestPinCipherExp,6);
    XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void ConvertPinX98ToIBM3624_Test_18(void)
{
	XXX_TEST_START_XXX
	int nSock = SM_SOCK;
	int nRet;
	char szSrcPan[20];
	int nSrcPanLen;
	char szDstPan[20];
	int nDstPanLen;
	BYTE bSrcPinKey[50];
	int nSrcPinKeyLen;
	BYTE bDstPinKey[50];
	int nDstPinKeyLen;
	BYTE bSrcPinCipher[50];
	char szDestPinCipher[15];
	char szDestPinCipherExp[15];

	bufclr(szSrcPan);
	bufclr(szDstPan);
	bufclr(bSrcPinKey);
	bufclr(bDstPinKey);
	bufclr(bSrcPinCipher);
	bufclr(szDestPinCipher);
	bufclr(szDestPinCipherExp);
	
	sprintf(szSrcPan,"2109876543210");
	sprintf(szDstPan,"678901234567890");
	nDstPanLen = strlen(szDstPan);
	nSrcPanLen = strlen(szSrcPan);

	//SrcPVK = 1234567890ABCDEFFEDCBA0987654321
	sprintf(bSrcPinKey,"\x62\xAB\xF2\xBC\x97\x25\x8E\x6F\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nSrcPinKeyLen = strlen(bSrcPinKey);
	//DstPVK = FEDCBA0987654321
	sprintf(bDstPinKey,"\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nDstPinKeyLen = strlen(bDstPinKey);
	//PIN = 123456
	sprintf(bSrcPinCipher,"\xD8\x8A\xF3\x8B\x40\x32\xB2\xB0\x5C\xC3\x12\x57\xCD\x3B\x86\xC0");
	//sprintf(bSrcPinCipher,"\xA7\xC0\x67\xD9\xD2\x41\xE2\xCA\x24\x98\xCE\x0A\xFA\xDB\x2E\xAF");

    XXX_INPUT_XXX
    printf("[IN ]nSock			= %d\n", nSock);
    printf("[IN ]nMode			= 4\n");
    printf("[IN ]nX98Algo		= 2\n");
    printf("[IN ]szSrcPan		= %s\n",szSrcPan);
    printf("[IN ]nSrcPanLen		= %d\n",nSrcPanLen);
    printf("[IN ]szDstPan		= %s\n",szDstPan);
	printf("[IN ]nDstPanLen  	= %d\n",nDstPanLen);
	DspHex("[IN ]bSrcPinKey		= ",bSrcPinKey,16);
	printf("[IN ]nSrcPinKeyLen	= %d\n",nSrcPinKeyLen);
	DspHex("[IN ]bDstPinKey		= ",bDstPinKey,8);
	printf("[IN ]nDstPinKeyLen	= %d\n",nDstPinKeyLen);
	DspHex("[IN ]bSrcPinCipher	= ",bSrcPinCipher,16);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
	nRet = SMAPIConvertPinX98ToIBM3624(nSock,4,2,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDstPinKey,nDstPinKeyLen,bSrcPinCipher,szDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "mode=4,nX98Algo=2,SrcPanLen=13,DstPanLen=15,测试未失败");
    XXX_RESULT_XXX
	
    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void ConvertPinX98ToIBM3624_Test_19(void)
{
	XXX_TEST_START_XXX
	int nSock = SM_SOCK;
	int nRet;
	char szSrcPan[20];
	int nSrcPanLen;
	char szDstPan[20];
	int nDstPanLen;
	BYTE bSrcPinKey[50];
	int nSrcPinKeyLen;
	BYTE bDstPinKey[50];
	int nDstPinKeyLen;
	BYTE bSrcPinCipher[50];
	char szDestPinCipher[15];
	char szDestPinCipherExp[15];

	bufclr(szSrcPan);
	bufclr(szDstPan);
	bufclr(bSrcPinKey);
	bufclr(bDstPinKey);
	bufclr(bSrcPinCipher);
	bufclr(szDestPinCipher);
	bufclr(szDestPinCipherExp);
	
	sprintf(szSrcPan,"109876543210");
	sprintf(szDstPan,"5678901234567890");
	nDstPanLen = strlen(szDstPan);
	nSrcPanLen = strlen(szSrcPan);

	//SrcPVK = 1234567890ABCDEFFEDCBA0987654321
	sprintf(bSrcPinKey,"\x62\xAB\xF2\xBC\x97\x25\x8E\x6F\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nSrcPinKeyLen = strlen(bSrcPinKey);
	//DstPVK = FEDCBA0987654321
	sprintf(bDstPinKey,"\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nDstPinKeyLen = strlen(bDstPinKey);
	//PIN = 123456
	sprintf(bSrcPinCipher,"\x9F\x84\x31\xF8\xA2\x47\x30\x74\xB4\x56\x54\x17\xE2\xC4\x61\xBE");

    XXX_INPUT_XXX
    printf("[IN ]nSock			= %d\n", nSock);
    printf("[IN ]nMode			= 4\n");
    printf("[IN ]nX98Algo		= 2\n");
    printf("[IN ]szSrcPan		= %s\n",szSrcPan);
    printf("[IN ]nSrcPanLen		= %d\n",nSrcPanLen);
    printf("[IN ]szDstPan		= %s\n",szDstPan);
	printf("[IN ]nDstPanLen  	= %d\n",nDstPanLen);
	DspHex("[IN ]bSrcPinKey		= ",bSrcPinKey,16);
	printf("[IN ]nSrcPinKeyLen	= %d\n",nSrcPinKeyLen);
	DspHex("[IN ]bDstPinKey		= ",bDstPinKey,8);
	printf("[IN ]nDstPinKeyLen	= %d\n",nDstPinKeyLen);
	DspHex("[IN ]bSrcPinCipher	= ",bSrcPinCipher,16);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
	nRet = SMAPIConvertPinX98ToIBM3624(nSock,4,2,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDstPinKey,nDstPinKeyLen,bSrcPinCipher,szDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "mode=4,nX98Algo=2,SrcPanLen=12,DstPanLen=16,测试未失败");
    XXX_RESULT_XXX
	
    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void ConvertPinX98ToIBM3624_Test_20(void)
{
	XXX_TEST_START_XXX
	int nSock = SM_SOCK;
	int nRet;
	char szSrcPan[20];
	int nSrcPanLen;
	char szDstPan[20];
	int nDstPanLen;
	BYTE bSrcPinKey[50];
	int nSrcPinKeyLen;
	BYTE bDstPinKey[50];
	int nDstPinKeyLen;
	BYTE bSrcPinCipher[50];
	char szDestPinCipher[15];
	char szDestPinCipherExp[15];

	bufclr(szSrcPan);
	bufclr(szDstPan);
	bufclr(bSrcPinKey);
	bufclr(bDstPinKey);
	bufclr(bSrcPinCipher);
	bufclr(szDestPinCipher);
	bufclr(szDestPinCipherExp);
	
	sprintf(szSrcPan,"6abc210987654321");
	sprintf(szDstPan,"1234567890123456");
	nDstPanLen = strlen(szDstPan);
	nSrcPanLen = strlen(szSrcPan);

	//SrcPVK = 1234567890ABCDEFFEDCBA0987654321
	sprintf(bSrcPinKey,"\x62\xAB\xF2\xBC\x97\x25\x8E\x6F\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nSrcPinKeyLen = strlen(bSrcPinKey);
	//DstPVK = FEDCBA0987654321
	sprintf(bDstPinKey,"\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nDstPinKeyLen = strlen(bDstPinKey);
	//PIN = 123456
	sprintf(bSrcPinCipher,"\xB2\xEF\xD3\xDE\x38\xC8\xE6\x33\xEF\x36\x2C\x04\x77\x7F\x7C\xFA");
	//sprintf(bSrcPinCipher,"\xA7\xC0\x67\xD9\xD2\x41\xE2\xCA\x24\x98\xCE\x0A\xFA\xDB\x2E\xAF");
	sprintf(szDestPinCipherExp,"969853");

    XXX_INPUT_XXX
    printf("[IN ]nSock			= %d\n", nSock);
    printf("[IN ]nMode			= 4\n");
    printf("[IN ]nX98Algo		= 2\n");
    printf("[IN ]szSrcPan		= %s\n",szSrcPan);
    printf("[IN ]nSrcPanLen		= %d\n",nSrcPanLen);
    printf("[IN ]szDstPan		= %s\n",szDstPan);
	printf("[IN ]nDstPanLen  	= %d\n",nDstPanLen);
	DspHex("[IN ]bSrcPinKey		= ",bSrcPinKey,16);
	printf("[IN ]nSrcPinKeyLen	= %d\n",nSrcPinKeyLen);
	DspHex("[IN ]bDstPinKey		= ",bDstPinKey,8);
	printf("[IN ]nDstPinKeyLen	= %d\n",nDstPinKeyLen);
	DspHex("[IN ]bSrcPinCipher	= ",bSrcPinCipher,16);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
	nRet = SMAPIConvertPinX98ToIBM3624(nSock,4,2,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDstPinKey,nDstPinKeyLen,bSrcPinCipher,szDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "mode=4,nX98Algo=2,pinlen=6,SrcPan包含未知字符，测试未失败");
    XXX_RESULT_XXX
	
    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void ConvertPinX98ToIBM3624_Test_21(void)
{
	XXX_TEST_START_XXX
	int nSock = SM_SOCK;
	int nRet;
	char szSrcPan[20];
	int nSrcPanLen;
	char szDstPan[20];
	int nDstPanLen;
	BYTE bSrcPinKey[50];
	int nSrcPinKeyLen;
	BYTE bDstPinKey[50];
	int nDstPinKeyLen;
	BYTE bSrcPinCipher[50];
	char szDestPinCipher[15];
	char szDestPinCipherExp[15];

	bufclr(szSrcPan);
	bufclr(szDstPan);
	bufclr(bSrcPinKey);
	bufclr(bDstPinKey);
	bufclr(bSrcPinCipher);
	bufclr(szDestPinCipher);
	bufclr(szDestPinCipherExp);
	
	sprintf(szSrcPan,"6543210987654321");
	sprintf(szDstPan,"123456789012abc6");
	nDstPanLen = strlen(szDstPan);
	nSrcPanLen = strlen(szSrcPan);

	//SrcPVK = 1234567890ABCDEFFEDCBA0987654321
	sprintf(bSrcPinKey,"\x62\xAB\xF2\xBC\x97\x25\x8E\x6F\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nSrcPinKeyLen = strlen(bSrcPinKey);
	//DstPVK = FEDCBA0987654321
	sprintf(bDstPinKey,"\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nDstPinKeyLen = strlen(bDstPinKey);
	//PIN = 123456
	sprintf(bSrcPinCipher,"\xB2\xEF\xD3\xDE\x38\xC8\xE6\x33\xEF\x36\x2C\x04\x77\x7F\x7C\xFA");
	//sprintf(bSrcPinCipher,"\xA7\xC0\x67\xD9\xD2\x41\xE2\xCA\x24\x98\xCE\x0A\xFA\xDB\x2E\xAF");
	sprintf(szDestPinCipherExp,"969853");

    XXX_INPUT_XXX
    printf("[IN ]nSock			= %d\n", nSock);
    printf("[IN ]nMode			= 4\n");
    printf("[IN ]nX98Algo		= 2\n");
    printf("[IN ]szSrcPan		= %s\n",szSrcPan);
    printf("[IN ]nSrcPanLen		= %d\n",nSrcPanLen);
    printf("[IN ]szDstPan		= %s\n",szDstPan);
	printf("[IN ]nDstPanLen  	= %d\n",nDstPanLen);
	DspHex("[IN ]bSrcPinKey		= ",bSrcPinKey,16);
	printf("[IN ]nSrcPinKeyLen	= %d\n",nSrcPinKeyLen);
	DspHex("[IN ]bDstPinKey		= ",bDstPinKey,8);
	printf("[IN ]nDstPinKeyLen	= %d\n",nDstPinKeyLen);
	DspHex("[IN ]bSrcPinCipher	= ",bSrcPinCipher,16);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
	nRet = SMAPIConvertPinX98ToIBM3624(nSock,4,2,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDstPinKey,nDstPinKeyLen,bSrcPinCipher,szDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "mode=4,nX98Algo=2,pinlen=6,DstPan包含未知字符，测试未失败");
    XXX_RESULT_XXX
	
    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void ConvertPinX98ToIBM3624_Test_22(void)
{
	XXX_TEST_START_XXX
	int nSock = -1;
	int nRet;
	char szSrcPan[20];
	int nSrcPanLen;
	char szDstPan[20];
	int nDstPanLen;
	BYTE bSrcPinKey[50];
	int nSrcPinKeyLen;
	BYTE bDstPinKey[50];
	int nDstPinKeyLen;
	BYTE bSrcPinCipher[50];
	char szDestPinCipher[15];
	char szDestPinCipherExp[15];

	bufclr(szSrcPan);
	bufclr(szDstPan);
	bufclr(bSrcPinKey);
	bufclr(bDstPinKey);
	bufclr(bSrcPinCipher);
	bufclr(szDestPinCipher);
	bufclr(szDestPinCipherExp);
	
	sprintf(szSrcPan,"6543210987654321");
	sprintf(szDstPan,"1234567890123456");
	nDstPanLen = strlen(szDstPan);
	nSrcPanLen = strlen(szSrcPan);

	//SrcPVK = 1234567890ABCDEFFEDCBA0987654321
	sprintf(bSrcPinKey,"\x62\xAB\xF2\xBC\x97\x25\x8E\x6F\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nSrcPinKeyLen = strlen(bSrcPinKey);
	//DstPVK = FEDCBA0987654321
	sprintf(bDstPinKey,"\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nDstPinKeyLen = strlen(bDstPinKey);
	//PIN = 123456
	sprintf(bSrcPinCipher,"\xB2\xEF\xD3\xDE\x38\xC8\xE6\x33\xEF\x36\x2C\x04\x77\x7F\x7C\xFA");
	//sprintf(bSrcPinCipher,"\xA7\xC0\x67\xD9\xD2\x41\xE2\xCA\x24\x98\xCE\x0A\xFA\xDB\x2E\xAF");
	sprintf(szDestPinCipherExp,"969853");

    XXX_INPUT_XXX
    printf("[IN ]nSock			= %d\n", nSock);
    printf("[IN ]nMode			= 4\n");
    printf("[IN ]nX98Algo		= 2\n");
    printf("[IN ]szSrcPan		= %s\n",szSrcPan);
    printf("[IN ]nSrcPanLen		= %d\n",nSrcPanLen);
    printf("[IN ]szDstPan		= %s\n",szDstPan);
	printf("[IN ]nDstPanLen  	= %d\n",nDstPanLen);
	DspHex("[IN ]bSrcPinKey		= ",bSrcPinKey,16);
	printf("[IN ]nSrcPinKeyLen	= %d\n",nSrcPinKeyLen);
	DspHex("[IN ]bDstPinKey		= ",bDstPinKey,8);
	printf("[IN ]nDstPinKeyLen	= %d\n",nDstPinKeyLen);
	DspHex("[IN ]bSrcPinCipher	= ",bSrcPinCipher,16);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
	nRet = SMAPIConvertPinX98ToIBM3624(nSock,4,2,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDstPinKey,nDstPinKeyLen,bSrcPinCipher,szDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "socket=[-1]，测试未失败");
    XXX_RESULT_XXX
	
    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void ConvertPinX98ToIBM3624_Test_23(void)
{
	XXX_TEST_START_XXX
	int nSock = 8;
	int nRet;
	char szSrcPan[20];
	int nSrcPanLen;
	char szDstPan[20];
	int nDstPanLen;
	BYTE bSrcPinKey[50];
	int nSrcPinKeyLen;
	BYTE bDstPinKey[50];
	int nDstPinKeyLen;
	BYTE bSrcPinCipher[50];
	char szDestPinCipher[15];
	char szDestPinCipherExp[15];

	bufclr(szSrcPan);
	bufclr(szDstPan);
	bufclr(bSrcPinKey);
	bufclr(bDstPinKey);
	bufclr(bSrcPinCipher);
	bufclr(szDestPinCipher);
	bufclr(szDestPinCipherExp);
	
	sprintf(szSrcPan,"6543210987654321");
	sprintf(szDstPan,"1234567890123456");
	nDstPanLen = strlen(szDstPan);
	nSrcPanLen = strlen(szSrcPan);

	//SrcPVK = 1234567890ABCDEFFEDCBA0987654321
	sprintf(bSrcPinKey,"\x62\xAB\xF2\xBC\x97\x25\x8E\x6F\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nSrcPinKeyLen = strlen(bSrcPinKey);
	//DstPVK = FEDCBA0987654321
	sprintf(bDstPinKey,"\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nDstPinKeyLen = strlen(bDstPinKey);
	//PIN = 123456
	sprintf(bSrcPinCipher,"\xB2\xEF\xD3\xDE\x38\xC8\xE6\x33\xEF\x36\x2C\x04\x77\x7F\x7C\xFA");
	//sprintf(bSrcPinCipher,"\xA7\xC0\x67\xD9\xD2\x41\xE2\xCA\x24\x98\xCE\x0A\xFA\xDB\x2E\xAF");
	sprintf(szDestPinCipherExp,"969853");

    XXX_INPUT_XXX
    printf("[IN ]nSock			= %d\n", nSock);
    printf("[IN ]nMode			= 4\n");
    printf("[IN ]nX98Algo		= 2\n");
    printf("[IN ]szSrcPan		= %s\n",szSrcPan);
    printf("[IN ]nSrcPanLen		= %d\n",nSrcPanLen);
    printf("[IN ]szDstPan		= %s\n",szDstPan);
	printf("[IN ]nDstPanLen  	= %d\n",nDstPanLen);
	DspHex("[IN ]bSrcPinKey		= ",bSrcPinKey,16);
	printf("[IN ]nSrcPinKeyLen	= %d\n",nSrcPinKeyLen);
	DspHex("[IN ]bDstPinKey		= ",bDstPinKey,8);
	printf("[IN ]nDstPinKeyLen	= %d\n",nDstPinKeyLen);
	DspHex("[IN ]bSrcPinCipher	= ",bSrcPinCipher,16);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
	nRet = SMAPIConvertPinX98ToIBM3624(nSock,4,2,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDstPinKey,nDstPinKeyLen,bSrcPinCipher,szDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "socket=[8]，测试未失败");
    XXX_RESULT_XXX
	
    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void ConvertPinX98ToIBM3624_Test_24(void)
{
	XXX_TEST_START_XXX
	int nSock = SM_SOCK;
	int nRet;
	char szSrcPan[20];
	int nSrcPanLen;
	char szDstPan[20];
	int nDstPanLen;
	BYTE bSrcPinKey[50];
	int nSrcPinKeyLen;
	BYTE bDstPinKey[50];
	int nDstPinKeyLen;
	BYTE bSrcPinCipher[50];
	char szDestPinCipher[15];
	char szDestPinCipherExp[15];

	bufclr(szSrcPan);
	bufclr(szDstPan);
	bufclr(bSrcPinKey);
	bufclr(bDstPinKey);
	bufclr(bSrcPinCipher);
	bufclr(szDestPinCipher);
	bufclr(szDestPinCipherExp);
	
	sprintf(szSrcPan,"6543210987654321");
	sprintf(szDstPan,"1234567890123456");
	nDstPanLen = strlen(szDstPan);
	nSrcPanLen = strlen(szSrcPan);

	//SrcPVK = 1234567890ABCDEFFEDCBA0987654321
	sprintf(bSrcPinKey,"\x62\xAB\xF2\xBC\x97\x25\x8E\x6F\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nSrcPinKeyLen = strlen(bSrcPinKey);
	//DstPVK = FEDCBA0987654321
	sprintf(bDstPinKey,"\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nDstPinKeyLen = strlen(bDstPinKey);
	//PIN = 123456
	sprintf(bSrcPinCipher,"\xB2\xEF\xD3\xDE\x38\xC8\xE6\x33\xEF\x36\x2C\x04\x77\x7F\x7C\xFA");
	//sprintf(bSrcPinCipher,"\xA7\xC0\x67\xD9\xD2\x41\xE2\xCA\x24\x98\xCE\x0A\xFA\xDB\x2E\xAF");
	sprintf(szDestPinCipherExp,"969853");

    XXX_INPUT_XXX
    printf("[IN ]nSock			= %d\n", nSock);
    printf("[IN ]nMode			= 5\n");
    printf("[IN ]nX98Algo		= 2\n");
    printf("[IN ]szSrcPan		= %s\n",szSrcPan);
    printf("[IN ]nSrcPanLen		= %d\n",nSrcPanLen);
    printf("[IN ]szDstPan		= %s\n",szDstPan);
	printf("[IN ]nDstPanLen  	= %d\n",nDstPanLen);
	DspHex("[IN ]bSrcPinKey		= ",bSrcPinKey,16);
	printf("[IN ]nSrcPinKeyLen	= %d\n",nSrcPinKeyLen);
	DspHex("[IN ]bDstPinKey		= ",bDstPinKey,8);
	printf("[IN ]nDstPinKeyLen	= %d\n",nDstPinKeyLen);
	DspHex("[IN ]bSrcPinCipher	= ",bSrcPinCipher,16);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
	nRet = SMAPIConvertPinX98ToIBM3624(nSock,5,2,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDstPinKey,nDstPinKeyLen,bSrcPinCipher,szDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "nMode=5，测试未失败");
    XXX_RESULT_XXX
	
    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void ConvertPinX98ToIBM3624_Test_25(void)
{
	XXX_TEST_START_XXX
	int nSock = SM_SOCK;
	int nRet;
	char szSrcPan[20];
	int nSrcPanLen;
	char szDstPan[20];
	int nDstPanLen;
	BYTE bSrcPinKey[50];
	int nSrcPinKeyLen;
	BYTE bDstPinKey[50];
	int nDstPinKeyLen;
	BYTE bSrcPinCipher[50];
	char szDestPinCipher[15];
	char szDestPinCipherExp[15];

	bufclr(szSrcPan);
	bufclr(szDstPan);
	bufclr(bSrcPinKey);
	bufclr(bDstPinKey);
	bufclr(bSrcPinCipher);
	bufclr(szDestPinCipher);
	bufclr(szDestPinCipherExp);
	
	sprintf(szSrcPan,"6543210987654321");
	sprintf(szDstPan,"1234567890123456");
	nDstPanLen = strlen(szDstPan);
	nSrcPanLen = strlen(szSrcPan);

	//SrcPVK = 1234567890ABCDEFFEDCBA0987654321
	sprintf(bSrcPinKey,"\x62\xAB\xF2\xBC\x97\x25\x8E\x6F\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nSrcPinKeyLen = strlen(bSrcPinKey);
	//DstPVK = FEDCBA0987654321
	sprintf(bDstPinKey,"\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nDstPinKeyLen = strlen(bDstPinKey);
	//PIN = 123456
	sprintf(bSrcPinCipher,"\xB2\xEF\xD3\xDE\x38\xC8\xE6\x33\xEF\x36\x2C\x04\x77\x7F\x7C\xFA");
	//sprintf(bSrcPinCipher,"\xA7\xC0\x67\xD9\xD2\x41\xE2\xCA\x24\x98\xCE\x0A\xFA\xDB\x2E\xAF");
	sprintf(szDestPinCipherExp,"969853");

    XXX_INPUT_XXX
    printf("[IN ]nSock			= %d\n", nSock);
    printf("[IN ]nMode			= 0\n");
    printf("[IN ]nX98Algo		= 2\n");
    printf("[IN ]szSrcPan		= %s\n",szSrcPan);
    printf("[IN ]nSrcPanLen		= %d\n",nSrcPanLen);
    printf("[IN ]szDstPan		= %s\n",szDstPan);
	printf("[IN ]nDstPanLen  	= %d\n",nDstPanLen);
	DspHex("[IN ]bSrcPinKey		= ",bSrcPinKey,16);
	printf("[IN ]nSrcPinKeyLen	= %d\n",nSrcPinKeyLen);
	DspHex("[IN ]bDstPinKey		= ",bDstPinKey,8);
	printf("[IN ]nDstPinKeyLen	= %d\n",nDstPinKeyLen);
	DspHex("[IN ]bSrcPinCipher	= ",bSrcPinCipher,16);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
	nRet = SMAPIConvertPinX98ToIBM3624(nSock,0,2,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDstPinKey,nDstPinKeyLen,bSrcPinCipher,szDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "nMode=0，测试未失败");
    XXX_RESULT_XXX
	
    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void ConvertPinX98ToIBM3624_Test_26(void)
{
	XXX_TEST_START_XXX
	int nSock = SM_SOCK;
	int nRet;
	char szSrcPan[20];
	int nSrcPanLen;
	char szDstPan[20];
	int nDstPanLen;
	BYTE bSrcPinKey[50];
	int nSrcPinKeyLen;
	BYTE bDstPinKey[50];
	int nDstPinKeyLen;
	BYTE bSrcPinCipher[50];
	char szDestPinCipher[15];
	char szDestPinCipherExp[15];

	bufclr(szSrcPan);
	bufclr(szDstPan);
	bufclr(bSrcPinKey);
	bufclr(bDstPinKey);
	bufclr(bSrcPinCipher);
	bufclr(szDestPinCipher);
	bufclr(szDestPinCipherExp);
	
	sprintf(szSrcPan,"6543210987654321");
	sprintf(szDstPan,"1234567890123456");
	nDstPanLen = strlen(szDstPan);
	nSrcPanLen = strlen(szSrcPan);

	//SrcPVK = 1234567890ABCDEFFEDCBA0987654321
	sprintf(bSrcPinKey,"\x62\xAB\xF2\xBC\x97\x25\x8E\x6F\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nSrcPinKeyLen = strlen(bSrcPinKey);
	//DstPVK = FEDCBA0987654321
	sprintf(bDstPinKey,"\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nDstPinKeyLen = strlen(bDstPinKey);
	//PIN = 123456
	sprintf(bSrcPinCipher,"\xB2\xEF\xD3\xDE\x38\xC8\xE6\x33\xEF\x36\x2C\x04\x77\x7F\x7C\xFA");
	//sprintf(bSrcPinCipher,"\xA7\xC0\x67\xD9\xD2\x41\xE2\xCA\x24\x98\xCE\x0A\xFA\xDB\x2E\xAF");
	sprintf(szDestPinCipherExp,"969853");

    XXX_INPUT_XXX
    printf("[IN ]nSock			= %d\n", nSock);
    printf("[IN ]nMode			= 4\n");
    printf("[IN ]nX98Algo		= 3\n");
    printf("[IN ]szSrcPan		= %s\n",szSrcPan);
    printf("[IN ]nSrcPanLen		= %d\n",nSrcPanLen);
    printf("[IN ]szDstPan		= %s\n",szDstPan);
	printf("[IN ]nDstPanLen  	= %d\n",nDstPanLen);
	DspHex("[IN ]bSrcPinKey		= ",bSrcPinKey,16);
	printf("[IN ]nSrcPinKeyLen	= %d\n",nSrcPinKeyLen);
	DspHex("[IN ]bDstPinKey		= ",bDstPinKey,8);
	printf("[IN ]nDstPinKeyLen	= %d\n",nDstPinKeyLen);
	DspHex("[IN ]bSrcPinCipher	= ",bSrcPinCipher,16);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
	nRet = SMAPIConvertPinX98ToIBM3624(nSock,4,3,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDstPinKey,nDstPinKeyLen,bSrcPinCipher,szDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "nX98Algo=3，测试未失败");
    XXX_RESULT_XXX
	
    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void ConvertPinX98ToIBM3624_Test_27(void)
{
	XXX_TEST_START_XXX
	int nSock = SM_SOCK;
	int nRet;
	char szSrcPan[20];
	int nSrcPanLen;
	char szDstPan[20];
	int nDstPanLen;
	BYTE bSrcPinKey[50];
	int nSrcPinKeyLen;
	BYTE bDstPinKey[50];
	int nDstPinKeyLen;
	BYTE bSrcPinCipher[50];
	char szDestPinCipher[15];
	char szDestPinCipherExp[15];

	bufclr(szSrcPan);
	bufclr(szDstPan);
	bufclr(bSrcPinKey);
	bufclr(bDstPinKey);
	bufclr(bSrcPinCipher);
	bufclr(szDestPinCipher);
	bufclr(szDestPinCipherExp);
	
	sprintf(szSrcPan,"6543210987654321");
	sprintf(szDstPan,"1234567890123456");
	nDstPanLen = strlen(szDstPan);
	nSrcPanLen = strlen(szSrcPan);

	//SrcPVK = 1234567890ABCDEFFEDCBA0987654321
	sprintf(bSrcPinKey,"\x62\xAB\xF2\xBC\x97\x25\x8E\x6F\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nSrcPinKeyLen = strlen(bSrcPinKey);
	//DstPVK = FEDCBA0987654321
	sprintf(bDstPinKey,"\xEB\x43\x38\x26\x98\xFD\x83\xCD");
	nDstPinKeyLen = strlen(bDstPinKey);
	//PIN = 123456
	sprintf(bSrcPinCipher,"\xB2\xEF\xD3\xDE\x38\xC8\xE6\x33\xEF\x36\x2C\x04\x77\x7F\x7C\xFA");
	//sprintf(bSrcPinCipher,"\xA7\xC0\x67\xD9\xD2\x41\xE2\xCA\x24\x98\xCE\x0A\xFA\xDB\x2E\xAF");
	sprintf(szDestPinCipherExp,"969853");

    XXX_INPUT_XXX
    printf("[IN ]nSock			= %d\n", nSock);
    printf("[IN ]nMode			= 4\n");
    printf("[IN ]nX98Algo		= 0\n");
    printf("[IN ]szSrcPan		= %s\n",szSrcPan);
    printf("[IN ]nSrcPanLen		= %d\n",nSrcPanLen);
    printf("[IN ]szDstPan		= %s\n",szDstPan);
	printf("[IN ]nDstPanLen  	= %d\n",nDstPanLen);
	DspHex("[IN ]bSrcPinKey		= ",bSrcPinKey,16);
	printf("[IN ]nSrcPinKeyLen	= %d\n",nSrcPinKeyLen);
	DspHex("[IN ]bDstPinKey		= ",bDstPinKey,8);
	printf("[IN ]nDstPinKeyLen	= %d\n",nDstPinKeyLen);
	DspHex("[IN ]bSrcPinCipher	= ",bSrcPinCipher,16);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
	nRet = SMAPIConvertPinX98ToIBM3624(nSock,4,0,szSrcPan,nSrcPanLen,szDstPan,\
			nDstPanLen,bSrcPinKey,nSrcPinKeyLen,bDstPinKey,nDstPinKeyLen,bSrcPinCipher,szDestPinCipher);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "nX98Algo=0，测试未失败");
    XXX_RESULT_XXX
	
    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

/**
  zhaomx  2017-04-18 SM2 私钥去掉后面8字节
*/
void Sm2SKTransInto_Test_01(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nEcMark;
	int  nPadMode;
	BYTE bSK[2400];
	int  nSKLen;
	BYTE bKeyByPK[260];
	int  nKeyByPKLen;
	BYTE bKeyByHMK[2056];
	int  nKeyByHMKLen;
	BYTE bKeyByHMKExp[260];
	int  nKeyByHMKLenExp;

	bufclr(bSK);
	bufclr(bKeyByHMK);
	bufclr(bKeyByPK);
	nKeyByPKLen = 0;
	bufclr(bKeyByHMKExp);

	nEcMark = 17;
	nPadMode = 0;
	/* PK = 04695BC3452B4DF79EBA188AC61C51A33A243F497A4D76D272F3771827BD80A944E1DA925A4853860EE0D883F3A2F43AA8F265C95F60A9102A7495551034D6C021 */
	/* SK = 7BAD1BC2D566F4AC0F93E830E2E9A1E756C063E94FBDEABF68A29DD720B44B30 */
	/* SKByHMK = C3E09939138691AA609031AADA1231495D23D89AA32D7B3E4C4D10D4631308FD6BCB2CCA658BFD78 */
	/* Key = 0123456789ABCDEFFEDCBA9876543210 */
	/* KeyByPK = 893173F4DDD695C466F8280251FE097E887C5CC4EC3E86EB101CA4A66BD5A8D54FE9280137C999CB0C9057A272723B1C6308F6FB0890549F65B1A470BF85607A19E2CE8F74298F29D0B3A6B624D5254807024B2449EC52AED4B6AC2B42186C73B38E848D5819ABFD8075A4D4A16502E5 */
	/* KeyByHMK = A2C0B0F8F7F5EE21FB5C6AEBE714E53A */
        //zhaomx  6BCB2CCA658BFD78 
	memcpy(bSK,
			"\xC3\xE0\x99\x39\x13\x86\x91\xAA\x60\x90\x31\xAA\xDA\x12\x31\x49"
			"\x5D\x23\xD8\x9A\xA3\x2D\x7B\x3E\x4C\x4D\x10\xD4\x63\x13\x08\xFD"
                        "\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78" 
			, 40);
	nSKLen = 40;

	memcpy(bKeyByPK,
			"\x89\x31\x73\xF4\xDD\xD6\x95\xC4\x66\xF8\x28\x02\x51\xFE\x09\x7E" \
			"\x88\x7C\x5C\xC4\xEC\x3E\x86\xEB\x10\x1C\xA4\xA6\x6B\xD5\xA8\xD5" \
			"\x4F\xE9\x28\x01\x37\xC9\x99\xCB\x0C\x90\x57\xA2\x72\x72\x3B\x1C" \
			"\x63\x08\xF6\xFB\x08\x90\x54\x9F\x65\xB1\xA4\x70\xBF\x85\x60\x7A" \
			"\x19\xE2\xCE\x8F\x74\x29\x8F\x29\xD0\xB3\xA6\xB6\x24\xD5\x25\x48" \
			"\x07\x02\x4B\x24\x49\xEC\x52\xAE\xD4\xB6\xAC\x2B\x42\x18\x6C\x73" \
			"\xB3\x8E\x84\x8D\x58\x19\xAB\xFD\x80\x75\xA4\xD4\xA1\x65\x02\xE5" \
			, 112);
	nKeyByPKLen = 112;

	memcpy(bKeyByHMKExp,
			"\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
			, 16);
	nKeyByHMKLenExp = 16;

	XXX_INPUT_XXX
		printf("[IN ]nSock = %d\n", nSock);
	printf("[IN ]nEcMark = %d\n", nEcMark);
	printf("[IN ]nPadMode = %d\n", nPadMode);
	DspHex("[IN ]bSK =", bSK, nSKLen);
	printf("[IN ]nPKLen = %d\n", nSKLen);
	DspHex("[IN ]bKeyByPK =", bKeyByPK, nKeyByPKLen);
	printf("[IN ]nKeyByPKLen = %d\n", nKeyByPKLen);
	XXX_INPUT_XXX

		/* Call Test Target Function Start */
		nRet = SMAPISm2SKTransInto(nSock, nEcMark, nPadMode, bSK, nSKLen, bKeyByPK, \
				nKeyByPKLen, bKeyByHMK, &nKeyByHMKLen);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
		ASSERT_RESULT(nRet, 0, "SM2私钥转加密，无填充，测试未成功");
	XXX_RESULT_XXX

		XXX_OUTPUT_XXX
		DspHex("[OUT]bKeyByHMK    =", bKeyByHMK, nKeyByHMKLen);
	DspHex("[OUT]bKeyByHMKExp =", bKeyByHMKExp, nKeyByHMKLenExp);
	ASSERT_OUT_HEX(bKeyByHMK, bKeyByHMKExp, nKeyByHMKLenExp);
	ASSERT_OUT(nKeyByHMKLen, nKeyByHMKLenExp);
	XXX_OUTPUT_XXX

		XXX_TEST_END_XXX
}

void TransKeyDesToSm4_Test_01(void)
{
	XXX_TEST_START_XXX
		int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bDesKey[24];
	int  nDesKeyLen;
	BYTE bKeyUnderDes[16];
	BYTE bSm4Key[16];
	BYTE bKeyUnderSm4[16];
	BYTE bKeyUnderSm4Exp[16];

	bufclr(bDesKey);
	bufclr(bKeyUnderDes);
	bufclr(bSm4Key);
	bufclr(bKeyUnderSm4);
	bufclr(bKeyUnderSm4Exp);

	nAlgo = 1;
	/* Key = 0123456789ABCDEFFEDCBA9876543210 */
	/* DESK = 72C7E64D5350FD59 */
	/* SM4K = 1AAE084D3316D8E1943E081C3E897D47 */
	/* DESKByHMK = C3827BE853B6BFB8 */
	/* SM4KByHMK = F0F2D67016869403B35D28E3FE7BD638 */
	/* KeyByDES = 3A418967A22CC08FD2B77E60128F692E */
	/* KeyBySM4 = 44A43336F55AAFF948EC19A31E983723 */

	memcpy(bDesKey,
			"\xC3\x82\x7B\xE8\x53\xB6\xBF\xB8" \
			, 8);
	nDesKeyLen = 8;

	memcpy(bKeyUnderDes,
			"\x3A\x41\x89\x67\xA2\x2C\xC0\x8F\xD2\xB7\x7E\x60\x12\x8F\x69\x2E" \
			, 16);

	memcpy(bSm4Key,
			"\xF0\xF2\xD6\x70\x16\x86\x94\x03\xB3\x5D\x28\xE3\xFE\x7B\xD6\x38" \
			, 16);

	memcpy(bKeyUnderSm4Exp,
			"\x44\xA4\x33\x36\xF5\x5A\xAF\xF9\x48\xEC\x19\xA3\x1E\x98\x37\x23" \
			, 16);

	XXX_INPUT_XXX
		printf("[IN ]nSock = %d\n", nSock);
	printf("[IN ]nAlgo = %d\n", nAlgo);
	DspHex("[IN ]bDesKey =", bDesKey, nDesKeyLen);
	DspHex("[IN ]bSm4Key =", bSm4Key, 16);
	DspHex("[IN ]bKeyUnderDes =", bKeyUnderDes, 16);
	XXX_INPUT_XXX

		/* Call Test Target Function Start */
		nRet = SMAPITransKeyDesToSm4(nSock, nAlgo, bDesKey, bSm4Key, bKeyUnderDes, \
				bKeyUnderSm4);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
		ASSERT_RESULT(nRet, 0, "DES到SM4密钥转加密，ALGO=1，测试未成功");
	XXX_RESULT_XXX

		XXX_OUTPUT_XXX
		DspHex("[OUT]bKeyUnderSm4    =", bKeyUnderSm4, 16);
	DspHex("[OUT]bKeyUnderSm4Exp =", bKeyUnderSm4Exp, 16);
	ASSERT_OUT_HEX(bKeyUnderSm4, bKeyUnderSm4Exp, 16);
	XXX_OUTPUT_XXX

		XXX_TEST_END_XXX
}

void TransKeyDesToSm4_Test_02(void)
{
	XXX_TEST_START_XXX
		int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bDesKey[24];
	int  nDesKeyLen;
	BYTE bKeyUnderDes[16];
	BYTE bSm4Key[16];
	BYTE bKeyUnderSm4[16];
	BYTE bKeyUnderSm4Exp[16];

	bufclr(bDesKey);
	bufclr(bKeyUnderDes);
	bufclr(bSm4Key);
	bufclr(bKeyUnderSm4);
	bufclr(bKeyUnderSm4Exp);

	nAlgo = 2;
	/* Key = 0123456789ABCDEFFEDCBA9876543210 */
	/* DESK = 72C7E64D5350FD5961E9E79E1A8A099F */
	/* SM4K = 1AAE084D3316D8E1943E081C3E897D47 */
	/* DESKByHMK = C3827BE853B6BFB81D73D8EDCA93F6AC */
	/* SM4KByHMK = F0F2D67016869403B35D28E3FE7BD638 */
	/* KeyByDES = B7540BCCFF0F44FEBA3952E73B01B78C */
	/* KeyBySM4 = 44A43336F55AAFF948EC19A31E983723 */

	memcpy(bDesKey,
			"\xC3\x82\x7B\xE8\x53\xB6\xBF\xB8\x1D\x73\xD8\xED\xCA\x93\xF6\xAC" \
			, 16);
	nDesKeyLen = 16;

	memcpy(bKeyUnderDes,
			"\xB7\x54\x0B\xCC\xFF\x0F\x44\xFE\xBA\x39\x52\xE7\x3B\x01\xB7\x8C" \
			, 16);

	memcpy(bSm4Key,
			"\xF0\xF2\xD6\x70\x16\x86\x94\x03\xB3\x5D\x28\xE3\xFE\x7B\xD6\x38" \
			, 16);

	memcpy(bKeyUnderSm4Exp,
			"\x44\xA4\x33\x36\xF5\x5A\xAF\xF9\x48\xEC\x19\xA3\x1E\x98\x37\x23" \
			, 16);

	XXX_INPUT_XXX
		printf("[IN ]nSock = %d\n", nSock);
	printf("[IN ]nAlgo = %d\n", nAlgo);
	DspHex("[IN ]bDesKey =", bDesKey, nDesKeyLen);
	DspHex("[IN ]bSm4Key =", bSm4Key, 16);
	DspHex("[IN ]bKeyUnderDes =", bKeyUnderDes, 16);
	XXX_INPUT_XXX

		/* Call Test Target Function Start */
	nRet = SMAPITransKeyDesToSm4(nSock, nAlgo, bDesKey, bSm4Key, bKeyUnderDes, \
				bKeyUnderSm4);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
		ASSERT_RESULT(nRet, 0, "DES到SM4密钥转加密，ALGO=2，测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
		DspHex("[OUT]bKeyUnderSm4    =", bKeyUnderSm4, 16);
		DspHex("[OUT]bKeyUnderSm4Exp =", bKeyUnderSm4Exp, 16);
		ASSERT_OUT_HEX(bKeyUnderSm4, bKeyUnderSm4Exp, 16);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void TransKeyDesToSm4_Test_03(void)
{
	XXX_TEST_START_XXX
		int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bDesKey[24];
	int  nDesKeyLen;
	BYTE bKeyUnderDes[16];
	BYTE bSm4Key[16];
	BYTE bKeyUnderSm4[16];
	BYTE bKeyUnderSm4Exp[16];

	bufclr(bDesKey);
	bufclr(bKeyUnderDes);
	bufclr(bSm4Key);
	bufclr(bKeyUnderSm4);
	bufclr(bKeyUnderSm4Exp);

	nAlgo = 3;
	/* Key = 0123456789ABCDEFFEDCBA9876543210 */
	/* DESK = 72C7E64D5350FD5961E9E79E1A8A099F50A1CF897BEB07BA */
	/* SM4K = 1AAE084D3316D8E1943E081C3E897D47 */
	/* DESKByHMK = C3827BE853B6BFB81D73D8EDCA93F6ACFC5CDC212AE4165E */
	/* SM4KByHMK = F0F2D67016869403B35D28E3FE7BD638 */
	/* KeyByDES = 48C87F8BCF878B8D550A998AD614CCB2 */
	/* KeyBySM4 = 44A43336F55AAFF948EC19A31E983723 */

	memcpy(bDesKey,
			"\xC3\x82\x7B\xE8\x53\xB6\xBF\xB8\x1D\x73\xD8\xED\xCA\x93\xF6\xAC" \
			"\xFC\x5C\xDC\x21\x2A\xE4\x16\x5E" \
			, 24);
	nDesKeyLen = 24;

	memcpy(bKeyUnderDes,
			"\x48\xC8\x7F\x8B\xCF\x87\x8B\x8D\x55\x0A\x99\x8A\xD6\x14\xCC\xB2" \
			, 16);

	memcpy(bSm4Key,
			"\xF0\xF2\xD6\x70\x16\x86\x94\x03\xB3\x5D\x28\xE3\xFE\x7B\xD6\x38" \
			, 16);

	memcpy(bKeyUnderSm4Exp,
			"\x44\xA4\x33\x36\xF5\x5A\xAF\xF9\x48\xEC\x19\xA3\x1E\x98\x37\x23" \
			, 16);

	XXX_INPUT_XXX
		printf("[IN ]nSock = %d\n", nSock);
	printf("[IN ]nAlgo = %d\n", nAlgo);
	DspHex("[IN ]bDesKey =", bDesKey, nDesKeyLen);
	DspHex("[IN ]bSm4Key =", bSm4Key, 16);
	DspHex("[IN ]bKeyUnderDes =", bKeyUnderDes, 16);
	XXX_INPUT_XXX

		/* Call Test Target Function Start */
	nRet = SMAPITransKeyDesToSm4(nSock, nAlgo, bDesKey, bSm4Key, bKeyUnderDes, \
				bKeyUnderSm4);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
		ASSERT_RESULT(nRet, 0, "DES到SM4密钥转加密，ALGO=3，测试未成功");
	XXX_RESULT_XXX

		XXX_OUTPUT_XXX
		DspHex("[OUT]bKeyUnderSm4    =", bKeyUnderSm4, 16);
	DspHex("[OUT]bKeyUnderSm4Exp =", bKeyUnderSm4Exp, 16);
	ASSERT_OUT_HEX(bKeyUnderSm4, bKeyUnderSm4Exp, 16);
	XXX_OUTPUT_XXX

		XXX_TEST_END_XXX
}

void TransKeyDesToSm4_Test_04(void)
{
	XXX_TEST_START_XXX
		int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bDesKey[24];
	int  nDesKeyLen;
	BYTE bKeyUnderDes[16];
	BYTE bSm4Key[16];
	BYTE bKeyUnderSm4[16];
	BYTE bKeyUnderSm4Exp[16];

	bufclr(bDesKey);
	bufclr(bKeyUnderDes);
	bufclr(bSm4Key);
	bufclr(bKeyUnderSm4);
	bufclr(bKeyUnderSm4Exp);

	nAlgo = 4;
	/* Key = 0123456789ABCDEFFEDCBA9876543210 */
	/* DESK = 72C7E64D5350FD5961E9E79E1A8A099F50A1CF897BEB07BA */
	/* SM4K = 1AAE084D3316D8E1943E081C3E897D47 */
	/* DESKByHMK = C3827BE853B6BFB81D73D8EDCA93F6ACFC5CDC212AE4165E */
	/* SM4KByHMK = F0F2D67016869403B35D28E3FE7BD638 */
	/* KeyByDES = 48C87F8BCF878B8D550A998AD614CCB2 */
	/* KeyBySM4 = 44A43336F55AAFF948EC19A31E983723 */

	memcpy(bDesKey,
			"\xC3\x82\x7B\xE8\x53\xB6\xBF\xB8\x1D\x73\xD8\xED\xCA\x93\xF6\xAC" \
			"\xFC\x5C\xDC\x21\x2A\xE4\x16\x5E" \
			, 24);
	nDesKeyLen = 24;

	memcpy(bKeyUnderDes,
			"\x48\xC8\x7F\x8B\xCF\x87\x8B\x8D\x55\x0A\x99\x8A\xD6\x14\xCC\xB2" \
			, 16);

	memcpy(bSm4Key,
			"\xF0\xF2\xD6\x70\x16\x86\x94\x03\xB3\x5D\x28\xE3\xFE\x7B\xD6\x38" \
			, 16);

	memcpy(bKeyUnderSm4Exp,
			"\x44\xA4\x33\x36\xF5\x5A\xAF\xF9\x48\xEC\x19\xA3\x1E\x98\x37\x23" \
			, 16);

	XXX_INPUT_XXX
		printf("[IN ]nSock = %d\n", nSock);
	printf("[IN ]nAlgo = %d\n", nAlgo);
	DspHex("[IN ]bDesKey =", bDesKey, nDesKeyLen);
	DspHex("[IN ]bSm4Key =", bSm4Key, 16);
	DspHex("[IN ]bKeyUnderDes =", bKeyUnderDes, 16);
	XXX_INPUT_XXX

		/* Call Test Target Function Start */
		nRet = SMAPITransKeyDesToSm4(nSock, nAlgo, bDesKey, bSm4Key, bKeyUnderDes, \
				bKeyUnderSm4);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
		ASSERT_RESULT(nRet, 1, "DES到SM4密钥转加密，ALGO=4，测试未成功");
	XXX_RESULT_XXX

		XXX_OUTPUT_XXX
		XXX_OUTPUT_NONE_XXX
		XXX_OUTPUT_XXX

		XXX_TEST_END_XXX
}

void TransKeySm4ToDes_Test_01(void)
{
	XXX_TEST_START_XXX
		int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bDesKey[24];
	int  nDesKeyLen;
	BYTE bKeyUnderDes[16];
	BYTE bSm4Key[16];
	BYTE bKeyUnderSm4[16];
	BYTE bKeyUnderDesExp[16];

	bufclr(bDesKey);
	bufclr(bKeyUnderDes);
	bufclr(bSm4Key);
	bufclr(bKeyUnderSm4);
	bufclr(bKeyUnderDesExp);

	nAlgo = 1;
	/* Key = 0123456789ABCDEFFEDCBA9876543210 */
	/* DESK = 72C7E64D5350FD59 */
	/* SM4K = 1AAE084D3316D8E1943E081C3E897D47 */
	/* DESKByHMK = C3827BE853B6BFB8 */
	/* SM4KByHMK = F0F2D67016869403B35D28E3FE7BD638 */
	/* KeyByDES = 3A418967A22CC08FD2B77E60128F692E */
	/* KeyBySM4 = 44A43336F55AAFF948EC19A31E983723 */

	memcpy(bDesKey,
			"\xC3\x82\x7B\xE8\x53\xB6\xBF\xB8" \
			, 8);
	nDesKeyLen = 8;

	memcpy(bKeyUnderSm4,
			"\x44\xA4\x33\x36\xF5\x5A\xAF\xF9\x48\xEC\x19\xA3\x1E\x98\x37\x23" \
			, 16);

	memcpy(bSm4Key,
			"\xF0\xF2\xD6\x70\x16\x86\x94\x03\xB3\x5D\x28\xE3\xFE\x7B\xD6\x38" \
			, 16);

	memcpy(bKeyUnderDesExp,
			"\x3A\x41\x89\x67\xA2\x2C\xC0\x8F\xD2\xB7\x7E\x60\x12\x8F\x69\x2E" \
			, 16);

	XXX_INPUT_XXX
		printf("[IN ]nSock = %d\n", nSock);
	printf("[IN ]nAlgo = %d\n", nAlgo);
	DspHex("[IN ]bDesKey =", bDesKey, nDesKeyLen);
	DspHex("[IN ]bSm4Key =", bSm4Key, 16);
	DspHex("[IN ]bKeyUnderSm4 =", bKeyUnderSm4, 16);
	XXX_INPUT_XXX

		/* Call Test Target Function Start */
   	nRet = SMAPITransKeySm4ToDes(nSock, nAlgo, bSm4Key, bDesKey, bKeyUnderSm4, \
				bKeyUnderDes);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
		ASSERT_RESULT(nRet, 0, "DES到SM4密钥转加密，ALGO=1，测试未成功");
	XXX_RESULT_XXX

		XXX_OUTPUT_XXX
		DspHex("[OUT]bKeyUnderDes    =", bKeyUnderDes, 16);
	DspHex("[OUT]bKeyUnderDesExp =", bKeyUnderDesExp, 16);
	ASSERT_OUT_HEX(bKeyUnderDes, bKeyUnderDesExp, 16);
	XXX_OUTPUT_XXX

		XXX_TEST_END_XXX
}

void TransKeySm4ToDes_Test_02(void)
{
	XXX_TEST_START_XXX
		int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bDesKey[24];
	int  nDesKeyLen;
	BYTE bKeyUnderDes[16];
	BYTE bSm4Key[16];
	BYTE bKeyUnderSm4[16];
	BYTE bKeyUnderDesExp[16];

	bufclr(bDesKey);
	bufclr(bKeyUnderDes);
	bufclr(bSm4Key);
	bufclr(bKeyUnderSm4);
	bufclr(bKeyUnderDesExp);

	nAlgo = 2;
	/* Key = 0123456789ABCDEFFEDCBA9876543210 */
	/* DESK = 72C7E64D5350FD5961E9E79E1A8A099F */
	/* SM4K = 1AAE084D3316D8E1943E081C3E897D47 */
	/* DESKByHMK = C3827BE853B6BFB81D73D8EDCA93F6AC */
	/* SM4KByHMK = F0F2D67016869403B35D28E3FE7BD638 */
	/* KeyByDES = B7540BCCFF0F44FEBA3952E73B01B78C */
	/* KeyBySM4 = 44A43336F55AAFF948EC19A31E983723 */

	memcpy(bDesKey,
			"\xC3\x82\x7B\xE8\x53\xB6\xBF\xB8\x1D\x73\xD8\xED\xCA\x93\xF6\xAC" \
			, 16);
	nDesKeyLen = 16;

	memcpy(bKeyUnderSm4,
			"\x44\xA4\x33\x36\xF5\x5A\xAF\xF9\x48\xEC\x19\xA3\x1E\x98\x37\x23" \
			, 16);

	memcpy(bSm4Key,
			"\xF0\xF2\xD6\x70\x16\x86\x94\x03\xB3\x5D\x28\xE3\xFE\x7B\xD6\x38" \
			, 16);

	memcpy(bKeyUnderDesExp,
			"\xB7\x54\x0B\xCC\xFF\x0F\x44\xFE\xBA\x39\x52\xE7\x3B\x01\xB7\x8C" \
			, 16);

	XXX_INPUT_XXX
		printf("[IN ]nSock = %d\n", nSock);
	printf("[IN ]nAlgo = %d\n", nAlgo);
	DspHex("[IN ]bDesKey =", bDesKey, nDesKeyLen);
	DspHex("[IN ]bSm4Key =", bSm4Key, 16);
	DspHex("[IN ]bKeyUnderSm4 =", bKeyUnderSm4, 16);
	XXX_INPUT_XXX

		/* Call Test Target Function Start */
		nRet = SMAPITransKeySm4ToDes(nSock, nAlgo, bSm4Key, bDesKey, bKeyUnderSm4, \
				bKeyUnderDes);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
		ASSERT_RESULT(nRet, 0, "DES到SM4密钥转加密，ALGO=2，测试未成功");
	XXX_RESULT_XXX

		XXX_OUTPUT_XXX
		DspHex("[OUT]bKeyUnderDes    =", bKeyUnderDes, 16);
	DspHex("[OUT]bKeyUnderDesExp =", bKeyUnderDesExp, 16);
	ASSERT_OUT_HEX(bKeyUnderDes, bKeyUnderDesExp, 16);
	XXX_OUTPUT_XXX

		XXX_TEST_END_XXX
}

void TransKeySm4ToDes_Test_03(void)
{
	XXX_TEST_START_XXX
		int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bDesKey[24];
	int  nDesKeyLen;
	BYTE bKeyUnderDes[16];
	BYTE bSm4Key[16];
	BYTE bKeyUnderSm4[16];
	BYTE bKeyUnderDesExp[16];

	bufclr(bDesKey);
	bufclr(bKeyUnderDes);
	bufclr(bSm4Key);
	bufclr(bKeyUnderSm4);
	bufclr(bKeyUnderDesExp);

	nAlgo = 3;
	/* Key = 0123456789ABCDEFFEDCBA9876543210 */
	/* DESK = 72C7E64D5350FD5961E9E79E1A8A099F50A1CF897BEB07BA */
	/* SM4K = 1AAE084D3316D8E1943E081C3E897D47 */
	/* DESKByHMK = C3827BE853B6BFB81D73D8EDCA93F6ACFC5CDC212AE4165E */
	/* SM4KByHMK = F0F2D67016869403B35D28E3FE7BD638 */
	/* KeyByDES = 48C87F8BCF878B8D550A998AD614CCB2 */
	/* KeyBySM4 = 44A43336F55AAFF948EC19A31E983723 */

	memcpy(bDesKey,
			"\xC3\x82\x7B\xE8\x53\xB6\xBF\xB8\x1D\x73\xD8\xED\xCA\x93\xF6\xAC" \
			"\xFC\x5C\xDC\x21\x2A\xE4\x16\x5E" \
			, 24);
	nDesKeyLen = 24;

	memcpy(bKeyUnderSm4,
			"\x44\xA4\x33\x36\xF5\x5A\xAF\xF9\x48\xEC\x19\xA3\x1E\x98\x37\x23" \
			, 16);

	memcpy(bSm4Key,
			"\xF0\xF2\xD6\x70\x16\x86\x94\x03\xB3\x5D\x28\xE3\xFE\x7B\xD6\x38" \
			, 16);

	memcpy(bKeyUnderDesExp,
			"\x48\xC8\x7F\x8B\xCF\x87\x8B\x8D\x55\x0A\x99\x8A\xD6\x14\xCC\xB2" \
			, 16);

	XXX_INPUT_XXX
		printf("[IN ]nSock = %d\n", nSock);
	printf("[IN ]nAlgo = %d\n", nAlgo);
	DspHex("[IN ]bDesKey =", bDesKey, nDesKeyLen);
	DspHex("[IN ]bSm4Key =", bSm4Key, 16);
	DspHex("[IN ]bKeyUnderSm4 =", bKeyUnderSm4, 16);
	XXX_INPUT_XXX

		/* Call Test Target Function Start */
		nRet = SMAPITransKeySm4ToDes(nSock, nAlgo, bSm4Key, bDesKey, bKeyUnderSm4, \
				bKeyUnderDes);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
		ASSERT_RESULT(nRet, 0, "DES到SM4密钥转加密，ALGO=3，测试未成功");
	XXX_RESULT_XXX

		XXX_OUTPUT_XXX
		DspHex("[OUT]bKeyUnderDes    =", bKeyUnderDes, 16);
	DspHex("[OUT]bKeyUnderDesExp =", bKeyUnderDesExp, 16);
	ASSERT_OUT_HEX(bKeyUnderDes, bKeyUnderDesExp, 16);
	XXX_OUTPUT_XXX

		XXX_TEST_END_XXX
}

void TransKeySm4ToDes_Test_04(void)
{
	XXX_TEST_START_XXX
		int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bDesKey[24];
	int  nDesKeyLen;
	BYTE bKeyUnderDes[16];
	BYTE bSm4Key[16];
	BYTE bKeyUnderSm4[16];
	BYTE bKeyUnderDesExp[16];

	bufclr(bDesKey);
	bufclr(bKeyUnderDes);
	bufclr(bSm4Key);
	bufclr(bKeyUnderSm4);
	bufclr(bKeyUnderDesExp);

	nAlgo = 4;
	/* Key = 0123456789ABCDEFFEDCBA9876543210 */
	/* DESK = 72C7E64D5350FD5961E9E79E1A8A099F50A1CF897BEB07BA */
	/* SM4K = 1AAE084D3316D8E1943E081C3E897D47 */
	/* DESKByHMK = C3827BE853B6BFB81D73D8EDCA93F6ACFC5CDC212AE4165E */
	/* SM4KByHMK = F0F2D67016869403B35D28E3FE7BD638 */
	/* KeyByDES = 48C87F8BCF878B8D550A998AD614CCB2 */
	/* KeyBySM4 = 44A43336F55AAFF948EC19A31E983723 */

	memcpy(bDesKey,
			"\xC3\x82\x7B\xE8\x53\xB6\xBF\xB8\x1D\x73\xD8\xED\xCA\x93\xF6\xAC" \
			"\xFC\x5C\xDC\x21\x2A\xE4\x16\x5E" \
			, 24);
	nDesKeyLen = 24;

	memcpy(bKeyUnderSm4,
			"\x44\xA4\x33\x36\xF5\x5A\xAF\xF9\x48\xEC\x19\xA3\x1E\x98\x37\x23" \
			, 16);

	memcpy(bSm4Key,
			"\xF0\xF2\xD6\x70\x16\x86\x94\x03\xB3\x5D\x28\xE3\xFE\x7B\xD6\x38" \
			, 16);

	memcpy(bKeyUnderDesExp,
			"\x48\xC8\x7F\x8B\xCF\x87\x8B\x8D\x55\x0A\x99\x8A\xD6\x14\xCC\xB2" \
			, 16);

	XXX_INPUT_XXX
		printf("[IN ]nSock = %d\n", nSock);
	printf("[IN ]nAlgo = %d\n", nAlgo);
	DspHex("[IN ]bDesKey =", bDesKey, nDesKeyLen);
	DspHex("[IN ]bSm4Key =", bSm4Key, 16);
	DspHex("[IN ]bKeyUnderSm4 =", bKeyUnderSm4, 16);
	XXX_INPUT_XXX

		/* Call Test Target Function Start */
		nRet = SMAPITransKeySm4ToDes(nSock, nAlgo, bSm4Key, bDesKey, bKeyUnderSm4, \
				bKeyUnderDes);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
		ASSERT_RESULT(nRet, 1, "DES到SM4密钥转加密，ALGO=4，测试未成功");
	XXX_RESULT_XXX

		XXX_OUTPUT_XXX
		XXX_OUTPUT_NONE_XXX
		XXX_OUTPUT_XXX

		XXX_TEST_END_XXX
}

void DisreteSubKeyExt1_Test_01(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	unsigned char  bMasterKey[32];
	unsigned char  bFactor[32];
	unsigned char  bSubKey[32];
	unsigned char  szCheckValue[16];
	unsigned char  bSubKeyExp[32];
	unsigned char  szCheckValueExp[16];

	bufclr(bMasterKey);
	bufclr(bFactor);
	bufclr(bSubKey);
	bufclr(szCheckValue);

	/* B308 EAC4 7CDC 158A 5BC2 2045 86C2 6DAD */
	memcpy(bMasterKey,
			"\xE7\x38\x93\xDA\x28\x2F\x5B\x1D\x11\x0F\x59\xF5\x00\x2C\x10\x2D"
			, 16);
	memcpy(bFactor,
			"\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x41\x42\x43\x44\x45\x46"
			, 16);
	/*6F30 B253 DD50 2BED 64C6 AF7F 718B 2DAD*/
	memcpy(bSubKeyExp,
			"\x7A\xCC\x21\xDA\x48\x78\x38\x9F\xF5\xC5\x87\x8F\xE3\xE0\xC9\x82"
			, 16);
	/* FA1F 4996 F621 6C61 */
	memcpy(szCheckValueExp,"\x46\x41\x31\x46\x34\x39\x39\x36", 8);

	XXX_INPUT_XXX
	printf("[IN ]nSock          = %d\n", nSock);
	DspHex("[IN ]bMasterKey     =", bMasterKey, 16);
	DspHex("[IN ]bFactor    =", bFactor, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPIDisreteSubKeyExt1(nSock,bMasterKey, bFactor, \
			bSubKey, szCheckValue);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "离散测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	ASSERT_OUT_HEX(bSubKey, bSubKeyExp, 16);
	ASSERT_OUT_HEX(szCheckValue, szCheckValueExp, 8);
	XXX_OUTPUT_XXX
/*
	DspHex("[RESULT ]expected subkey    =", bSubKeyExp, 16);
	DspHex("[RESULT ]disreted subkey =", bSubKey, 16);
	DspHex("[RESULT ]expected checkvalue    =", szCheckValueExp, 8);
	DspHex("[RESULT]disreted checkvalue =", szCheckValue, 8);
*/
	XXX_TEST_END_XXX
}

void DisreteSubKeyExt1_Test_02(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = -1;

	unsigned char  bMasterKey[32];
	unsigned char  bFactor[32];
	unsigned char  bSubKey[32];
	unsigned char  szCheckValue[16];
	unsigned char  bSubKeyExp[32];
	unsigned char  szCheckValueExp[16];

	bufclr(bMasterKey);
	bufclr(bFactor);
	bufclr(bSubKey);
	bufclr(szCheckValue);

	/* F431 623E 4997 89C8 C2F1 F725 AD7F 8949 */
	memcpy(bMasterKey,
			"\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
			, 16);
	memcpy(bFactor,
			"\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x41\x42\x43\x44\x45\x46"
			, 16);
	/*695A 6C7B 4E4D 894E 0374 AA96 D3A8 1BD0*/
	memcpy(bSubKeyExp,
			"\x92\xD5\xC5\x49\xC7\xB4\x11\xBD\x45\x07\x7A\x24\x9E\xA9\x59\x2F"
			, 16);
	/* 09F1 C278 E411 C078 */
	memcpy(szCheckValueExp,"\x36\x33\x33\x37\x35\x36\x30\x30", 8);

	XXX_INPUT_XXX
	printf("[IN ]nSock          = %d\n", nSock);
	DspHex("[IN ]bMasterKey     =", bMasterKey, 16);
	DspHex("[IN ]bFactor    =", bFactor, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPIDisreteSubKeyExt1(nSock,bMasterKey, bFactor, \
			bSubKey, szCheckValue);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 1, "socket=[-1],离散测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void DisreteSubKeyExt1_Test_03(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = 8;

	unsigned char  bMasterKey[32];
	unsigned char  bFactor[32];
	unsigned char  bSubKey[32];
	unsigned char  szCheckValue[16];
	unsigned char  bSubKeyExp[32];
	unsigned char  szCheckValueExp[16];

	bufclr(bMasterKey);
	bufclr(bFactor);
	bufclr(bSubKey);
	bufclr(szCheckValue);

	/* F431 623E 4997 89C8 C2F1 F725 AD7F 8949 */
	memcpy(bMasterKey,
			"\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
			, 16);
	memcpy(bFactor,
			"\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x41\x42\x43\x44\x45\x46"
			, 16);
	/*695A 6C7B 4E4D 894E 0374 AA96 D3A8 1BD0*/
	memcpy(bSubKeyExp,
			"\x92\xD5\xC5\x49\xC7\xB4\x11\xBD\x45\x07\x7A\x24\x9E\xA9\x59\x2F"
			, 16);
	/* 09F1 C278 E411 C078 */
	memcpy(szCheckValueExp,"\x36\x33\x33\x37\x35\x36\x30\x30", 8);

	XXX_INPUT_XXX
	printf("[IN ]nSock          = %d\n", nSock);
	DspHex("[IN ]bMasterKey     =", bMasterKey, 16);
	DspHex("[IN ]bFactor    =", bFactor, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPIDisreteSubKeyExt1(nSock,bMasterKey, bFactor, \
			bSubKey, szCheckValue);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 1, "socket=[8],离散测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void DisreteSubKeyExt1_Test_04(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	unsigned char  bMasterKey[32];
	unsigned char  bFactor[32];
	unsigned char  bSubKey[32];
	unsigned char  szCheckValue[16];
	unsigned char  bSubKeyExp[32];
	unsigned char  szCheckValueExp[16];

	bufclr(bMasterKey);
	bufclr(bFactor);
	bufclr(bSubKey);
	bufclr(szCheckValue);

	memcpy(bMasterKey,
			"\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB"
			, 15);
	memcpy(bFactor,
			"\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x41\x42\x43\x44\x45\x46"
			, 16);
	/*695A 6C7B 4E4D 894E 0374 AA96 D3A8 1BD0*/
	memcpy(bSubKeyExp,
			"\x92\xD5\xC5\x49\xC7\xB4\x11\xBD\x45\x07\x7A\x24\x9E\xA9\x59\x2F"
			, 16);
	/* 09F1 C278 E411 C078 */
	memcpy(szCheckValueExp,"\x36\x33\x33\x37\x35\x36\x30\x30", 8);

	XXX_INPUT_XXX
	printf("[IN ]nSock          = %d\n", nSock);
	DspHex("[IN ]bMasterKey     =", bMasterKey, 15);
	DspHex("[IN ]bFactor    =", bFactor, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPIDisreteSubKeyExt1(nSock,bMasterKey, bFactor, \
			bSubKey, szCheckValue);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 1, "MasterKeyLen=15,离散测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void DisreteSubKeyExt1_Test_05(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	unsigned char  bMasterKey[32];
	unsigned char  bFactor[32];
	unsigned char  bSubKey[32];
	unsigned char  szCheckValue[16];
	unsigned char  bSubKeyExp[32];
	unsigned char  szCheckValueExp[16];

	bufclr(bMasterKey);
	bufclr(bFactor);
	bufclr(bSubKey);
	bufclr(szCheckValue);

	memcpy(bMasterKey,
			"\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
			, 16);
	memcpy(bFactor,
			"\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x41\x42\x43\x44\x45"
			, 15);
	/*695A 6C7B 4E4D 894E 0374 AA96 D3A8 1BD0*/
	memcpy(bSubKeyExp,
			"\x92\xD5\xC5\x49\xC7\xB4\x11\xBD\x45\x07\x7A\x24\x9E\xA9\x59\x2F"
			, 16);
	/* 09F1 C278 E411 C078 */
	memcpy(szCheckValueExp,"\x36\x33\x33\x37\x35\x36\x30\x30", 8);

	XXX_INPUT_XXX
	printf("[IN ]nSock          = %d\n", nSock);
	DspHex("[IN ]bMasterKey     =", bMasterKey, 16);
	DspHex("[IN ]bFactor    =", bFactor, 15);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPIDisreteSubKeyExt1(nSock,bMasterKey, bFactor, \
			bSubKey, szCheckValue);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 1, "FactorLen=15,离散测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void DisreteSubKeyExt1_Test_06(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	unsigned char  bMasterKey[32];
	unsigned char  bFactor[32];
	unsigned char  bSubKey[32];
	unsigned char  szCheckValue[16];
	unsigned char  bSubKeyExp[32];
	unsigned char  szCheckValueExp[16];

	bufclr(bMasterKey);
	bufclr(bFactor);
	bufclr(bSubKey);
	bufclr(szCheckValue);

	memcpy(bMasterKey,
			"\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4\xAB"
			, 17);
	memcpy(bFactor,
			"\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x41\x42\x43\x44\x45\x46"
			, 16);
	/*695A 6C7B 4E4D 894E 0374 AA96 D3A8 1BD0*/
	memcpy(bSubKeyExp,
			"\x92\xD5\xC5\x49\xC7\xB4\x11\xBD\x45\x07\x7A\x24\x9E\xA9\x59\x2F"
			, 16);
	/* 09F1 C278 E411 C078 */
	memcpy(szCheckValueExp,"\x36\x33\x33\x37\x35\x36\x30\x30", 8);

	XXX_INPUT_XXX
	printf("[IN ]nSock          = %d\n", nSock);
	DspHex("[IN ]bMasterKey     =", bMasterKey, 17);
	DspHex("[IN ]bFactor    =", bFactor, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPIDisreteSubKeyExt1(nSock,bMasterKey, bFactor, \
			bSubKey, szCheckValue);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 1, "MasterKeyLen=17,离散测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void DisreteSubKeyExt2_Test_01(void)
{
	XXX_TEST_START_XXX
		int  nRet;
	int  nSock = SM_SOCK;

	unsigned char  bKek[32];
	unsigned char  bMasterKey[32];
	unsigned char  bFactor[32];
	unsigned char  bSubKey[32];
	unsigned char  szCheckValue[16];
	unsigned char  bSubKeyExp[32];
	unsigned char  szCheckValueExp[16];

	bufclr(bKek);
	bufclr(bMasterKey);
	bufclr(bFactor);
	bufclr(bSubKey);
	bufclr(szCheckValue);

	/* 7F61 1F06 87B0 F7F8 22B1 D6FB DD7B 11A4 */
	memcpy(bKek,
			"\x47\xAC\x4D\xB5\xC6\x93\x69\xFC\xC1\x71\x84\x92\x69\x15\x92\x44"
			, 16);
	/* B308 EAC4 7CDC 158A 5BC2 2045 86C2 6DAD */
	memcpy(bMasterKey,
			"\xE7\x38\x93\xDA\x28\x2F\x5B\x1D\x11\x0F\x59\xF5\x00\x2C\x10\x2D"
			, 16);
	memcpy(bFactor,
			"\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x41\x42\x43\x44\x45\x46"
			, 16);
	/*6F30 B253 DD50 2BED 64C6 AF7F 718B 2DAD*/
	memcpy(bSubKeyExp,
			"\x77\x78\x21\x8C\x91\xA2\xA2\xC8\x50\xD7\xB4\x37\x44\xAF\x93\x30"
			, 16);
	/* FA1F 4996 */
	memcpy(szCheckValueExp,"\xFA\x1F\x49\x96", 8);

	XXX_INPUT_XXX
		printf("[IN ]nSock          = %d\n", nSock);
	DspHex("[IN ]bKey     =", bKek, 16);
	DspHex("[IN ]bMasterKey     =", bMasterKey, 16);
	DspHex("[IN ]bFactor    =", bFactor, 16);
	XXX_INPUT_XXX

		/* Call Test Target Function Start */
		nRet = SMAPIDisreteSubKeyExt2(nSock, bKek, bMasterKey, bFactor, \
				bSubKey, szCheckValue);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
		ASSERT_RESULT(nRet, 0, "离散测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
		ASSERT_OUT_HEX(bSubKey, bSubKeyExp, 16);
	ASSERT_OUT_HEX(szCheckValue, szCheckValueExp, 8);
	XXX_OUTPUT_XXX
	/*
	   DspHex("[RESULT ]expected subkey    =", bSubKeyExp, 16);
	   DspHex("[RESULT ]disreted subkey =", bSubKey, 16);
	   DspHex("[RESULT ]expected checkvalue    =", szCheckValueExp, 8);
	   DspHex("[RESULT]disreted checkvalue =", szCheckValue, 8);
	 */
	XXX_TEST_END_XXX
}


/*DES -> DES*/
void ConvertPinX98B_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet, nPanLen;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
    char szPan[19+1];
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
    bufclr(szPan);
	
    /*plain key = 0123456789ABCDEF*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nSrcPinKeyLen = strlen(bSrcPinKey);
    /*plain key = FEDCBA9876543210*/
    sprintf(bDestPinKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nDestPinKeyLen = strlen(bDestPinKey);
	
    sprintf(szPlainPin, "123456");

    sprintf(szPan, "1234567890123456");
    nPanLen = 16;

    /*pin block = 06123456FFFFFFFF*/
    /*pan block = 0000456789012345*/
   /*final block = 0612713176FEDCBA*/
    sprintf(bSrcPinCipher, "\x68\x67\x90\xAC\x2D\x5B\x2F\xFD");
    sprintf(bDestPinCipherExp, "\x9E\xA7\x6B\xA2\x26\x29\xFC\x01");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 1\n");
    printf("[IN ]szPlainPin	  =%s\n", szPlainPin);
    printf("[IN ]szPan	  =%s\n", szPan);
    printf("[IN ]nPanLen=%d\n",nPanLen);
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 8);
    printf("[IN ]nSrcPinKeyLen=%d\n",nSrcPinKeyLen);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 8);
    printf("[IN ]nDestPinKeyLen=%d\n",nDestPinKeyLen);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98B(nSock, 1, szPan, nPanLen, bSrcPinKey, 8, bDestPinKey, 8, bSrcPinCipher, bDestPinCipher);
    /* Call Test Target Function End */
    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=1,des->des, pinlen=6,测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]nRet = %d\n", nRet);
    DspHex("[OUT]bDestPinCipher  =", bDestPinCipher, 8);
    DspHex("[OUT]bDestPinCipherExp     =", bDestPinCipherExp, 8);
    ASSERT_OUT_HEX(bDestPinCipher, bDestPinCipherExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

/*DES -> SM4*/
void ConvertPinX98B_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet, nPanLen;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
    char szPan[19+1];
	
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
    bufclr(szPan);

    /*plain key = 0123456789ABCDEF*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nSrcPinKeyLen = strlen(bSrcPinKey);	
    /*plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bDestPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nDestPinKeyLen = strlen(bDestPinKey);
	
    sprintf(szPlainPin, "123456");
    
    sprintf(szPan, "1234567890123456");
    nPanLen = 16;

     /*pin block = 06123456FFFFFFFF*/
     /*pan block = 0000456789012345*/
    /*final block = 0612713176FEDCBA*/
    sprintf(bSrcPinCipher, "\x68\x67\x90\xAC\x2D\x5B\x2F\xFD");
    /*pin block = 06123456FFFFFFFFFFFFFFFFFFFFFFFF*/
    /*pan block = 00000000000000000000456789012345*/
    /*final block = 06123456FFFFFFFFFFFFBA9876FEDCBA*/
    sprintf(bDestPinCipherExp, "\x17\xF4\xE8\xF0\x85\x67\x91\xEF\xFD\x6A\x5F\xCE\xB2\x1A\x62\x3F");

    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 2\n");
    printf("[IN ]szPlainPin    =%s\n", szPlainPin);
    printf("[IN ]szPan    =%s\n", szPan);
    printf("[IN ]nPanLen=%d\n",nPanLen);
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 8);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 16);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */	
    nRet = SMAPIConvertPinX98B(nSock, 2, szPan, nPanLen, bSrcPinKey, 8, bDestPinKey, 16, bSrcPinCipher, bDestPinCipher);
    /* Call Test Target Function End */
    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=2,des->sm4, pinlen=6,测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX    
    printf("[OUT]nRet  = %d\n", nRet);
    DspHex("[OUT]bDestPinCipher  =", bDestPinCipher, 16);
    DspHex("[OUT]bDestPinCipherExp     =", bDestPinCipherExp, 16);
    ASSERT_OUT_HEX(bDestPinCipher, bDestPinCipherExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

/*SM4 ->DES*/
void ConvertPinX98B_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet, nPanLen;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
    char szPan[19+1];
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
    bufclr(szPan);

    /*plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nSrcPinKeyLen = strlen(bSrcPinKey);
    /*plain key = 0123456789ABCDEF*/
    sprintf(bDestPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nDestPinKeyLen= strlen(bDestPinKey);

    sprintf(szPlainPin, "123456");

      sprintf(szPan, "1234567890123456");
      nPanLen = 16;

    /*pin block = 06123456FFFFFFFFFFFFFFFFFFFFFFFF*/
     /*pin block = 00000000000000000000456789012345*/
    /*final block = 06123456FFFFFFFFFFFFBA9876FEDCBA*/	
    sprintf(bSrcPinCipher, "\x17\xF4\xE8\xF0\x85\x67\x91\xEF\xFD\x6A\x5F\xCE\xB2\x1A\x62\x3F");
     /*pin block = 06123456FFFFFFFF*/
     /*pan block = 0000456789012345*/
    /*final block = 0612713176FEDCBA*/
    sprintf(bDestPinCipherExp, "\x68\x67\x90\xAC\x2D\x5B\x2F\xFD");

    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 3\n");
    printf("[IN ]szPlainPin    =%s\n", szPlainPin);
    printf("[IN ]szPan    =%s\n", szPan);
    printf("[IN ]nPanLen=%d\n",nPanLen);
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 16);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 8);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 16);	
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98B(nSock, 3, szPan, nPanLen, bSrcPinKey, 16, bDestPinKey, 8, bSrcPinCipher, bDestPinCipher);
    /* Call Test Target Function End */
    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=3,sm4->des, pinlen=6,测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX    
    printf("[OUT]nRet  = %d\n", nRet);
    DspHex("[OUT]bDestPinCipher  =", bDestPinCipher, 8);
    DspHex("[OUT]bDestPinCipherExp     =", bDestPinCipherExp, 8);
    ASSERT_OUT_HEX(bDestPinCipher, bDestPinCipherExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

/*SM4 ->SM4*/
void ConvertPinX98B_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet, nPanLen;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
    char szPan[19+1];
	
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);

    /*plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nSrcPinKeyLen = strlen(bSrcPinKey);
    /*plain key = FEDCBA98765432100123456789ABCEDF*/
    sprintf(bDestPinKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A\x68\x75\x8D\x83\x92\x51\x56\x58");
    nDestPinKeyLen= strlen(bDestPinKey);

    sprintf(szPlainPin, "123456");

      sprintf(szPan, "1234567890123456");
      nPanLen = 16;

    /*pin block = 06123456FFFFFFFFFFFFFFFFFFFFFFFF*/
     /*pin block = 00000000000000000000456789012345*/
    /*final block = 06123456FFFFFFFFFFFFBA9876FEDCBA*/
    sprintf(bSrcPinCipher, "\x17\xF4\xE8\xF0\x85\x67\x91\xEF\xFD\x6A\x5F\xCE\xB2\x1A\x62\x3F");
    sprintf(bDestPinCipherExp, "\xAF\xC8\x2C\x33\xAE\x3F\xEE\x2F\xD5\xC9\x14\x17\x4B\x0E\x91\xA1");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 4\n");
    printf("[IN ]szPlainPin    =%s\n", szPlainPin);
    printf("[IN ]szPan    =%s\n", szPan);
    printf("[IN ]nPanLen=%d\n",nPanLen);
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 16);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 16);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 16);	
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98B(nSock, 4, szPan, nPanLen, bSrcPinKey, 16, bDestPinKey, 16, bSrcPinCipher, bDestPinCipher);
    /* Call Test Target Function End */
    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=4,sm4->sm4, pinlen=6, 测试未成功");
    XXX_RESULT_XXX
		
    XXX_OUTPUT_XXX    
    printf("[OUT]nRet  = %d\n", nRet);
    DspHex("[OUT]bDestPinCipher  =", bDestPinCipher, 16);
    DspHex("[OUT]bDestPinCipherExp     =", bDestPinCipherExp, 16);
    ASSERT_OUT_HEX(bDestPinCipher, bDestPinCipherExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

/*DES -> DES*/
void ConvertPinX98B_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet, nPanLen;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
    char szPan[19+1];
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
    bufclr(szPan);
	
    /*plain key = 0123456789ABCDEF*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nSrcPinKeyLen = strlen(bSrcPinKey);
    /*plain key = FEDCBA9876543210*/
    sprintf(bDestPinKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nDestPinKeyLen = strlen(bDestPinKey);
	
    sprintf(szPlainPin, "123456789012");

    sprintf(szPan, "1234567890123456");
    nPanLen = 16;
    /*    sprintf(szPan, "456789012345");
    nPanLen = 12;*/

    /*pin block = 0C123456789012FF*/
    /*pan block = 0000456789012345*/
   /*final block = 0C127131F19131BA*/
    sprintf(bSrcPinCipher, "\x35\x4B\xB4\x49\x39\xFC\x38\xB4");
    sprintf(bDestPinCipherExp, "\xD5\x48\x54\x4C\x5E\xC9\x71\x75");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 1\n");
    printf("[IN ]szPlainPin	  =%s\n", szPlainPin);
    printf("[IN ]szPan	  =%s\n", szPan);
    printf("[IN ]nPanLen=%d\n",nPanLen);
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 8);
    printf("[IN ]nSrcPinKeyLen=%d\n",nSrcPinKeyLen);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 8);
    printf("[IN ]nDestPinKeyLen=%d\n",nDestPinKeyLen);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98B(nSock, 1, szPan, nPanLen, bSrcPinKey, 8, bDestPinKey, 8, bSrcPinCipher, bDestPinCipher);
    /* Call Test Target Function End */
    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=1,des->des, pinlen=12,测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]nRet = %d\n", nRet);
    DspHex("[OUT]bDestPinCipher  =", bDestPinCipher, 8);
    DspHex("[OUT]bDestPinCipherExp     =", bDestPinCipherExp, 8);
    ASSERT_OUT_HEX(bDestPinCipher, bDestPinCipherExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

/*DES -> SM4*/
void ConvertPinX98B_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet, nPanLen;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
    char szPan[19+1];
	
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
    bufclr(szPan);

    /*plain key = 0123456789ABCDEF*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nSrcPinKeyLen = strlen(bSrcPinKey);	
    /*plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bDestPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nDestPinKeyLen = strlen(bDestPinKey);
	
    sprintf(szPlainPin, "123456789012");
    
    sprintf(szPan, "1234567890123456");
    nPanLen = 16;

     /*pin block = 0C123456789012FF*/
     /*pan block = 0000456789012345*/
    /*final block = 0C127131F19131BA*/
    sprintf(bSrcPinCipher, "\x35\x4B\xB4\x49\x39\xFC\x38\xB4");
    /*pin block = 0C123456789012FFFFFFFFFFFFFFFFFF*/
    /*pan block = 00000000000000000000456789012345*/
    /*final block = 0C123456789012FFFFFFBA9876FEDCBA*/
    sprintf(bDestPinCipherExp, "\x2E\x7C\x3B\xF8\x68\x86\xCF\xA2\xF1\x29\xBE\x9E\xE5\x5C\xA7\xBF");

    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 2\n");
    printf("[IN ]szPlainPin    =%s\n", szPlainPin);
    printf("[IN ]szPan    =%s\n", szPan);
    printf("[IN ]nPanLen=%d\n",nPanLen);
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 8);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 16);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */	
    nRet = SMAPIConvertPinX98B(nSock, 2, szPan, nPanLen, bSrcPinKey, 8, bDestPinKey, 16, bSrcPinCipher, bDestPinCipher);
    /* Call Test Target Function End */
    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=2,des->sm4, pinlen=12,测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX    
    printf("[OUT]nRet  = %d\n", nRet);
    DspHex("[OUT]bDestPinCipher  =", bDestPinCipher, 16);
    DspHex("[OUT]bDestPinCipherExp     =", bDestPinCipherExp, 16);
    ASSERT_OUT_HEX(bDestPinCipher, bDestPinCipherExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

/*SM4 ->DES*/
void ConvertPinX98B_Test_07(void)
{
    XXX_TEST_START_XXX
    int  nRet, nPanLen;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
    char szPan[19+1];
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
    bufclr(szPan);

    /*plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nSrcPinKeyLen = strlen(bSrcPinKey);
    /*plain key = 0123456789ABCDEF*/
    sprintf(bDestPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nDestPinKeyLen= strlen(bDestPinKey);

    sprintf(szPlainPin, "123456789012");

      sprintf(szPan, "1234567890123456");
      nPanLen = 16;

    /*pin block = 0C123456789012FFFFFFFFFFFFFFFFFF*/
     /*pin block = 00000000000000000000456789012345*/
    /*final block = 0C123456789012FFFFFFBA9876FEDCBA*/	
    sprintf(bSrcPinCipher, "\x2E\x7C\x3B\xF8\x68\x86\xCF\xA2\xF1\x29\xBE\x9E\xE5\x5C\xA7\xBF");
     /*pin block = 0C123456789012FF*/
     /*pan block = 0000456789012345*/
    /*final block = 0C127131F19131BA*/
    sprintf(bDestPinCipherExp, "\x35\x4B\xB4\x49\x39\xFC\x38\xB4");

    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 3\n");
    printf("[IN ]szPlainPin    =%s\n", szPlainPin);
    printf("[IN ]szPan    =%s\n", szPan);
    printf("[IN ]nPanLen=%d\n",nPanLen);
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 16);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 8);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 16);	
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98B(nSock, 3, szPan, nPanLen, bSrcPinKey, 16, bDestPinKey, 8, bSrcPinCipher, bDestPinCipher);
    /* Call Test Target Function End */
    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=3,sm4->des, pinlen=12,测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX    
    printf("[OUT]nRet  = %d\n", nRet);
    DspHex("[OUT]bDestPinCipher  =", bDestPinCipher, 8);
    DspHex("[OUT]bDestPinCipherExp     =", bDestPinCipherExp, 8);
    ASSERT_OUT_HEX(bDestPinCipher, bDestPinCipherExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

/*SM4 ->SM4*/
void ConvertPinX98B_Test_08(void)
{
    XXX_TEST_START_XXX
    int  nRet, nPanLen;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
    char szPan[19+1];
	
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);

    /*plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nSrcPinKeyLen = strlen(bSrcPinKey);
    /*plain key = FEDCBA98765432100123456789ABCEDF*/
    sprintf(bDestPinKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A\x68\x75\x8D\x83\x92\x51\x56\x58");
    nDestPinKeyLen= strlen(bDestPinKey);

    sprintf(szPlainPin, "123456789012");

      sprintf(szPan, "1234567890123456");
      nPanLen = 16;

    /*pin block = 0C123456789012FFFFFFFFFFFFFFFFFF*/
     /*pin block = 00000000000000000000456789012345*/
    /*final block = 0C123456789012FFFFFFBA9876FEDCBA*/
    sprintf(bSrcPinCipher, "\x2E\x7C\x3B\xF8\x68\x86\xCF\xA2\xF1\x29\xBE\x9E\xE5\x5C\xA7\xBF");
    sprintf(bDestPinCipherExp, "\xD6\xB7\xE2\xB2\x30\xEC\x9A\x69\xF9\xBA\xBB\x8F\x05\xAA\x69\xF8");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 4\n");
    printf("[IN ]szPlainPin    =%s\n", szPlainPin);
    printf("[IN ]szPan    =%s\n", szPan);
    printf("[IN ]nPanLen=%d\n",nPanLen);
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 16);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 16);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 16);	
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98B(nSock, 4, szPan, nPanLen, bSrcPinKey, 16, bDestPinKey, 16, bSrcPinCipher, bDestPinCipher);
    /* Call Test Target Function End */
    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=4,sm4->sm4, pinlen=12, 测试未成功");
    XXX_RESULT_XXX
		
    XXX_OUTPUT_XXX   
    printf("[OUT]nRet  = %d\n", nRet);
    DspHex("[OUT]bDestPinCipher  =", bDestPinCipher, 16);
    DspHex("[OUT]bDestPinCipherExp     =", bDestPinCipherExp, 16);
    ASSERT_OUT_HEX(bDestPinCipher, bDestPinCipherExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ConvertPinX98B_Test_09(void)
{
    XXX_TEST_START_XXX
    int  nRet, nPanLen;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
    char szPan[19+1];
	
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
    bufclr(szPan);

    /*plain key = 0123456789ABCDEF*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nSrcPinKeyLen = strlen(bSrcPinKey);	
    /*plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bDestPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nDestPinKeyLen = strlen(bDestPinKey);
	
    sprintf(szPlainPin, "123");
    
    sprintf(szPan, "1234567890123456");
    nPanLen = 16;

     /*pin block = 03123FFFFFFFFFFF*/
     /*pan block = 0000456789012345*/
    /*final block = 03127A9876FEDCBA*/
    sprintf(bSrcPinCipher, "\x7A\x03\x51\xAC\xDA\x86\xF5\x73");
    /*pin block = 03123FFFFFFFFFFFFFFFFFFFFFFFFFFF*/
    /*pan block = 00000000000000000000456789012345*/
    /*final block = 03123FFFFFFFFFFFFFFFBA9876FEDCBA*/
    sprintf(bDestPinCipherExp, "\x45\x58\x67\xB6\xAF\x1C\x51\x2F\xA8\x52\xFD\xEC\x7E\xFE\x7C\xA4");

    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 2\n");
    printf("[IN ]szPlainPin    =%s\n", szPlainPin);
    printf("[IN ]szPan    =%s\n", szPan);
    printf("[IN ]nPanLen=%d\n",nPanLen);
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 8);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 16);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */	
    nRet = SMAPIConvertPinX98B(nSock, 2, szPan, nPanLen, bSrcPinKey, 8, bDestPinKey, 16, bSrcPinCipher, bDestPinCipher);
    /* Call Test Target Function End */
    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=2,des->sm4, pinlen=3,测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX    
    printf("[OUT]nRet  = %d\n", nRet);
    DspHex("[OUT]bDestPinCipher  =", bDestPinCipher, 16);
    DspHex("[OUT]bDestPinCipherExp     =", bDestPinCipherExp, 16);
    ASSERT_OUT_HEX(bDestPinCipher, bDestPinCipherExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

/*PIK = NULL*/
void ConvertPinX98B_Test_10(void)
{
    XXX_TEST_START_XXX
    int  nRet, nPanLen;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
    char szPan[19+1];
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
    bufclr(szPan);
	
    /*plain key = 0123456789ABCDEF*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nSrcPinKeyLen = strlen(bSrcPinKey);
    /*plain key = FEDCBA9876543210*/
    sprintf(bDestPinKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nDestPinKeyLen = strlen(bDestPinKey);
	
    sprintf(szPlainPin, "123456");
  
    sprintf(szPan, "1234567890123456");
    nPanLen = 16;

    /*pin block = 06123456FFFFFFFF*/
    /*pan block = 0000456789012345*/
   /*final block = 0612713176FEDCBA*/
    sprintf(bSrcPinCipher, "\x68\x67\x90\xAC\x2D\x5B\x2F\xFD");
    sprintf(bDestPinCipherExp, "\x9E\xA7\x6B\xA2\x26\x29\xFC\x01");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 1\n");
    printf("[IN ]szPlainPin	  =%s\n", szPlainPin);
    printf("[IN ]szPan	  =%s\n", szPan);
    printf("[IN ]nPanLen=%d\n",nPanLen);
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 8);
    printf("[IN ]nSrcPinKeyLen=%d\n",nSrcPinKeyLen);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 8);
    printf("[IN ]nDestPinKeyLen=%d\n",nDestPinKeyLen);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98B(nSock, 1, szPan, nPanLen, NULL, 8, bDestPinKey, 8, bSrcPinCipher, bDestPinCipher);
    /* Call Test Target Function End */
    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "mode=1, null指针,测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

/*PAN=NULL*/
void ConvertPinX98B_Test_11(void)
{
    XXX_TEST_START_XXX
    int  nRet, nPanLen;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
    char szPan[19+1];
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
    bufclr(szPan);
	
    /*plain key = 0123456789ABCDEF*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nSrcPinKeyLen = strlen(bSrcPinKey);
    /*plain key = FEDCBA9876543210*/
    sprintf(bDestPinKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nDestPinKeyLen = strlen(bDestPinKey);
	
    sprintf(szPlainPin, "123456");

    sprintf(szPan, "1234567890123456");
    nPanLen = 16;

    /*pin block = 06123456FFFFFFFF*/
    /*pan block = 0000456789012345*/
   /*final block = 0612713176FEDCBA*/
    sprintf(bSrcPinCipher, "\x68\x67\x90\xAC\x2D\x5B\x2F\xFD");
    sprintf(bDestPinCipherExp, "\x9E\xA7\x6B\xA2\x26\x29\xFC\x01");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 1\n");
    printf("[IN ]szPlainPin	  =%s\n", szPlainPin);
    printf("[IN ]szPan	  =%s\n", szPan);
    printf("[IN ]nPanLen=%d\n",nPanLen);
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 8);
    printf("[IN ]nSrcPinKeyLen=%d\n",nSrcPinKeyLen);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 8);
    printf("[IN ]nDestPinKeyLen=%d\n",nDestPinKeyLen);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98B(nSock, 1, NULL, nPanLen, bSrcPinKey, 8, bDestPinKey, 8, bSrcPinCipher, bDestPinCipher);
    /* Call Test Target Function End */
    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "mode=1, PAN号=null,测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ConvertPinX98B_Test_12(void)
{
    XXX_TEST_START_XXX
    int  nRet, nPanLen;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
    char szPan[19+1];
	
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
    bufclr(szPan);

    /*plain key = 0123456789ABCDEF*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nSrcPinKeyLen = strlen(bSrcPinKey);	
    /*plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bDestPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nDestPinKeyLen = strlen(bDestPinKey);
	
    sprintf(szPlainPin, "123456");
    
    sprintf(szPan, "1234567890123456");
    nPanLen = 16;

     /*pin block = 06123456FFFFFFFF*/
     /*pan block = 0000456789012345*/
    /*final block = 0612713176FEDCBA*/
    sprintf(bSrcPinCipher, "\x68\x67\x90\xAC\x2D\x5B\x2F\xFD");
    /*pin block = 06123456FFFFFFFFFFFFFFFFFFFFFFFF*/
    /*pan block = 00000000000000000000456789012345*/
    /*final block = 06123456FFFFFFFFFFFFBA9876FEDCBA*/
    sprintf(bDestPinCipherExp, "\x17\xF4\xE8\xF0\x85\x67\x91\xEF\xFD\x6A\x5F\xCE\xB2\x1A\x62\x3F");

    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 2\n");
    printf("[IN ]szPlainPin    =%s\n", szPlainPin);
    printf("[IN ]szPan    =%s\n", szPan);
    printf("[IN ]nPanLen=%d\n",nPanLen);
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 8);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 16);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */	
    nRet = SMAPIConvertPinX98B(nSock, 2, szPan, nPanLen, bSrcPinKey, 8, bDestPinKey, 16, NULL, bDestPinCipher);
    /* Call Test Target Function End */
    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "mode=2,des->sm4, bSrcPinCipher= null,测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX    
    XXX_OUTPUT_NONE_XXX    
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}


/*PAN=NULL*/
void ConvertPinX98B_Test_13(void)
{
    XXX_TEST_START_XXX
    int  nRet, nPanLen;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
    char szPan[19+1];
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
    bufclr(szPan);
	
    /*plain key = 0123456789ABCDEF*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nSrcPinKeyLen = strlen(bSrcPinKey);
    /*plain key = FEDCBA9876543210*/
    sprintf(bDestPinKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nDestPinKeyLen = strlen(bDestPinKey);
	
    sprintf(szPlainPin, "123456");

    sprintf(szPan, "1234567890123456");
    nPanLen = 16;

    /*pin block = 06123456FFFFFFFF*/
    /*pan block = 0000456789012345*/
   /*final block = 0612713176FEDCBA*/
    sprintf(bSrcPinCipher, "\x68\x67\x90\xAC\x2D\x5B\x2F\xFD");
    sprintf(bDestPinCipherExp, "\x9E\xA7\x6B\xA2\x26\x29\xFC\x01");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 1\n");
    printf("[IN ]szPlainPin	  =%s\n", szPlainPin);
    printf("[IN ]szPan	  =%s\n", szPan);
    printf("[IN ]nPanLen=%d\n",nPanLen);
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 8);
    printf("[IN ]nSrcPinKeyLen=%d\n",nSrcPinKeyLen);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 8);
    printf("[IN ]nDestPinKeyLen=%d\n",nDestPinKeyLen);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98B(nSock, 1, "", nPanLen, bSrcPinKey, 8, bDestPinKey, 8, bSrcPinCipher, bDestPinCipher);
    /* Call Test Target Function End */
    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "mode=1, PAN号="",测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ConvertPinX98B_Test_14(void)
{
    XXX_TEST_START_XXX
    int  nRet, nPanLen;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
    char szPan[19+1];
	
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
    bufclr(szPan);

    /*plain key = 0123456789ABCDEF*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nSrcPinKeyLen = strlen(bSrcPinKey);	
    /*plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bDestPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nDestPinKeyLen = strlen(bDestPinKey);
	
    sprintf(szPlainPin, "123456");
    
    sprintf(szPan, "1234567890123456789");
    nPanLen = 19;

     /*pin block = 06123456FFFFFFFF*/
     /*pan block = 0000789012345678*/
    /*final block = 06124CC6EDCBA987*/
    sprintf(bSrcPinCipher, "\x5B\xFA\x35\xEC\x97\x27\x47\x15");
    /*pin block = 06123456FFFFFFFFFFFFFFFFFFFFFFFF*/
    /*pan block = 00000000000000000000789012345678*/
    /*final block = 06123456FFFFFFFFFFFF876FEDCBA987*/
    sprintf(bDestPinCipherExp, "\xE3\xD1\x93\xFE\xA6\xAD\x24\x1F\x43\x9E\x21\x8F\x60\x11\x64\x7D");

    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 2\n");
    printf("[IN ]szPlainPin    =%s\n", szPlainPin);
    printf("[IN ]szPan    =%s\n", szPan);
    printf("[IN ]nPanLen=%d\n",nPanLen);
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 8);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 16);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */	
    nRet = SMAPIConvertPinX98B(nSock, 2, szPan, nPanLen, bSrcPinKey, 8, bDestPinKey, 16, bSrcPinCipher, bDestPinCipher);
    /* Call Test Target Function End */
    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "mode=2,des->sm4, 19位PAN号,测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX    
    printf("[OUT]nRet  = %d\n", nRet);
    DspHex("[OUT]bDestPinCipher  =", bDestPinCipher, 16);
    DspHex("[OUT]bDestPinCipherExp     =", bDestPinCipherExp, 16);
    ASSERT_OUT_HEX(bDestPinCipher, bDestPinCipherExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ConvertPinX98B_Test_15(void)
{
    XXX_TEST_START_XXX
    int  nRet, nPanLen;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
    char szPan[19+1];
	
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
    bufclr(szPan);

    /*plain key = 0123456789ABCDEF*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nSrcPinKeyLen = strlen(bSrcPinKey);	
    /*plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bDestPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nDestPinKeyLen = strlen(bDestPinKey);
	
    sprintf(szPlainPin, "123456");
    
    sprintf(szPan, "12345678901234567890");
    nPanLen = 20;

     /*pin block = 06123456FFFFFFFF*/
     /*pan block = 0000789012345678*/
    /*final block = 06124CC6EDCBA987*/
    sprintf(bSrcPinCipher, "\x5B\xFA\x35\xEC\x97\x27\x47\x15");
    /*pin block = 06123456FFFFFFFFFFFFFFFFFFFFFFFF*/
    /*pan block = 00000000000000000000789012345678*/
    /*final block = 06123456FFFFFFFFFFFF876FEDCBA987*/
    sprintf(bDestPinCipherExp, "\xE3\xD1\x93\xFE\xA6\xAD\x24\x1F\x43\x9E\x21\x8F\x60\x11\x64\x7D");

    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 2\n");
    printf("[IN ]szPlainPin    =%s\n", szPlainPin);
    printf("[IN ]szPan    =%s\n", szPan);
    printf("[IN ]nPanLen=%d\n",nPanLen);
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 8);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 16);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */	
    nRet = SMAPIConvertPinX98B(nSock, 2, szPan, nPanLen, bSrcPinKey, 8, bDestPinKey, 16, bSrcPinCipher, bDestPinCipher);
    /* Call Test Target Function End */
    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "mode=2,des->sm4, 20位PAN号,测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX    
    XXX_OUTPUT_NONE_XXX    
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ConvertPinX98B_Test_16(void)
{
    XXX_TEST_START_XXX
    int  nRet, nPanLen;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
    char szPan[19+1];
	
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
    bufclr(szPan);

    /*plain key = 0123456789ABCDEF*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nSrcPinKeyLen = strlen(bSrcPinKey);	
    /*plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bDestPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nDestPinKeyLen = strlen(bDestPinKey);
	
    sprintf(szPlainPin, "123456");
    
    sprintf(szPan, "			ConvertPinX98B_Test_15();");
    nPanLen = 16;

     /*pin block = 06123456FFFFFFFF*/
     /*pan block = 0000456789012345*/
    /*final block = 0612713176FEDCBA*/
    sprintf(bSrcPinCipher, "\x68\x67\x90\xAC\x2D\x5B\x2F\xFD");
    /*pin block = 06123456FFFFFFFFFFFFFFFFFFFFFFFF*/
    /*pan block = 00000000000000000000456789012345*/
    /*final block = 06123456FFFFFFFFFFFFBA9876FEDCBA*/
    sprintf(bDestPinCipherExp, "\x17\xF4\xE8\xF0\x85\x67\x91\xEF\xFD\x6A\x5F\xCE\xB2\x1A\x62\x3F");

    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 2\n");
    printf("[IN ]szPlainPin    =%s\n", szPlainPin);
    printf("[IN ]szPan    =%s\n", szPan);
    printf("[IN ]nPanLen=%d\n",nPanLen);
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 8);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 16);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */	
    nRet = SMAPIConvertPinX98B(nSock, 2, szPan, nPanLen, bSrcPinKey, 8, bDestPinKey, 16, bSrcPinCipher, bDestPinCipher);
    /* Call Test Target Function End */
    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "mode=2,des->sm4, 无效账号-账号中含有非数字字符,测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX    
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ConvertPinX98B_Test_17(void)
{
    XXX_TEST_START_XXX
    int  nRet, nPanLen;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
    char szPan[19+1];
	
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
    bufclr(szPan);

    /*plain key = 0123456789ABCDEF*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nSrcPinKeyLen = strlen(bSrcPinKey);	
    /*plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bDestPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nDestPinKeyLen = strlen(bDestPinKey);
	
    sprintf(szPlainPin, "123456");
    
    sprintf(szPan, "abc4567890123456");
    nPanLen = 16;

     /*pin block = 06123456FFFFFFFF*/
     /*pan block = 0000456789012345*/
    /*final block = 0612713176FEDCBA*/
    sprintf(bSrcPinCipher, "\x68\x67\x90\xAC\x2D\x5B\x2F\xFD");
    /*pin block = 06123456FFFFFFFFFFFFFFFFFFFFFFFF*/
    /*pan block = 00000000000000000000456789012345*/
    /*final block = 06123456FFFFFFFFFFFFBA9876FEDCBA*/
    sprintf(bDestPinCipherExp, "\x17\xF4\xE8\xF0\x85\x67\x91\xEF\xFD\x6A\x5F\xCE\xB2\x1A\x62\x3F");

    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 2\n");
    printf("[IN ]szPlainPin    =%s\n", szPlainPin);
    printf("[IN ]szPan    =%s\n", szPan);
    printf("[IN ]nPanLen=%d\n",nPanLen);
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 8);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 16);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */	
    nRet = SMAPIConvertPinX98B(nSock, 2, szPan, nPanLen, bSrcPinKey, 8, bDestPinKey, 16, bSrcPinCipher, bDestPinCipher);
    /* Call Test Target Function End */
    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "mode=2,des->sm4, 无效账号-账号中含有非数字字符,测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX    
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

/*mode = 5*/
void ConvertPinX98B_Test_18(void)
{
    XXX_TEST_START_XXX
    int  nRet, nPanLen;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
    char szPan[19+1];
  
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
    bufclr(szPan);
	
    /*plain key = 0123456789ABCDEF*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nSrcPinKeyLen = strlen(bSrcPinKey);
    /*plain key = FEDCBA9876543210*/
    sprintf(bDestPinKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nDestPinKeyLen = strlen(bDestPinKey);
	
    sprintf(szPlainPin, "123456");

    sprintf(szPan, "1234567890123456");
    nPanLen = 16;

    /*pin block = 06123456FFFFFFFF*/
    /*pan block = 0000456789012345*/
   /*final block = 0612713176FEDCBA*/
    sprintf(bSrcPinCipher, "\x68\x67\x90\xAC\x2D\x5B\x2F\xFD");
    sprintf(bDestPinCipherExp, "\x9E\xA7\x6B\xA2\x26\x29\xFC\x01");
	
    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 1\n");
    printf("[IN ]szPlainPin	  =%s\n", szPlainPin);
    printf("[IN ]szPan	  =%s\n", szPan);
    printf("[IN ]nPanLen=%d\n",nPanLen);
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 8);
    printf("[IN ]nSrcPinKeyLen=%d\n",nSrcPinKeyLen);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 8);
    printf("[IN ]nDestPinKeyLen=%d\n",nDestPinKeyLen);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */
    nRet = SMAPIConvertPinX98B(nSock, 5, szPan, nPanLen, bSrcPinKey, 8, bDestPinKey, 8, bSrcPinCipher, bDestPinCipher);
    /* Call Test Target Function End */
    XXX_RESULT_XXX
     ASSERT_RESULT(nRet, 1, "mode=5,异常模式,测试未成功");
     XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ConvertPinX98B_Test_19(void)
{
    XXX_TEST_START_XXX
    int  nRet, nPanLen;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
    char szPan[19+1];
	
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
    bufclr(szPan);

    /*plain key = 0123456789ABCDEF*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nSrcPinKeyLen = strlen(bSrcPinKey);	
    /*plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bDestPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nDestPinKeyLen = strlen(bDestPinKey);
	
    sprintf(szPlainPin, "123456");
    
    sprintf(szPan, "1234567890123456");
    nPanLen = 16;

     /*pin block = 06123456FFFFFFFF*/
     /*pan block = 0000456789012345*/
    /*final block = 0612713176FEDCBA*/
    sprintf(bSrcPinCipher, "\x68\x67\x90\xAC\x2D\x5B\x2F\xFD");
    /*pin block = 06123456FFFFFFFFFFFFFFFFFFFFFFFF*/
    /*pan block = 00000000000000000000456789012345*/
    /*final block = 06123456FFFFFFFFFFFFBA9876FEDCBA*/
    sprintf(bDestPinCipherExp, "\x17\xF4\xE8\xF0\x85\x67\x91\xEF\xFD\x6A\x5F\xCE\xB2\x1A\x62\x3F");

    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 2\n");
    printf("[IN ]szPlainPin    =%s\n", szPlainPin);
    printf("[IN ]szPan    =%s\n", szPan);
    printf("[IN ]nPanLen=%d\n",nPanLen);
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 8);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 16);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */	
    nRet = SMAPIConvertPinX98B(-1, 2, szPan, nPanLen, bSrcPinKey, 8, bDestPinKey, 16, bSrcPinCipher, bDestPinCipher);
    /* Call Test Target Function End */
    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "mode=2,des->sm4, 无效socket[-1],测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ConvertPinX98B_Test_20(void)
{
    XXX_TEST_START_XXX
    int  nRet, nPanLen;
    int  nSock = SM_SOCK;

    int nSrcPinKeyLen=0;
    int nDestPinKeyLen=0;	
    BYTE bSrcPinKey[16+1];
    BYTE bDestPinKey[16+1];
    BYTE bSrcPinCipher[16+1];
    BYTE bDestPinCipher[16+1];
    BYTE bDestPinCipherExp[16 +1];
    char szPlainPin[16];
    char szPan[19+1];
	
    bufclr(bSrcPinKey);
    bufclr(bDestPinKey);
    bufclr(bSrcPinCipher);
    bufclr(bDestPinCipher);
    bufclr(bDestPinCipherExp);
    bufclr(szPlainPin);
    bufclr(szPan);

    /*plain key = 0123456789ABCDEF*/
    sprintf(bSrcPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");
    nSrcPinKeyLen = strlen(bSrcPinKey);	
    /*plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bDestPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");
    nDestPinKeyLen = strlen(bDestPinKey);
	
    sprintf(szPlainPin, "123456");
    
    sprintf(szPan, "1234567890123456");
    nPanLen = 16;

     /*pin block = 06123456FFFFFFFF*/
     /*pan block = 0000456789012345*/
    /*final block = 0612713176FEDCBA*/
    sprintf(bSrcPinCipher, "\x68\x67\x90\xAC\x2D\x5B\x2F\xFD");
    /*pin block = 06123456FFFFFFFFFFFFFFFFFFFFFFFF*/
    /*pan block = 00000000000000000000456789012345*/
    /*final block = 06123456FFFFFFFFFFFFBA9876FEDCBA*/
    sprintf(bDestPinCipherExp, "\x17\xF4\xE8\xF0\x85\x67\x91\xEF\xFD\x6A\x5F\xCE\xB2\x1A\x62\x3F");

    XXX_INPUT_XXX
    printf("[IN ]nSock	  = %d\n", nSock);
    printf("[IN ]nMode  = 2\n");
    printf("[IN ]szPlainPin    =%s\n", szPlainPin);
    printf("[IN ]szPan    =%s\n", szPan);
    printf("[IN ]nPanLen=%d\n",nPanLen);
    DspHex("[IN ]bSrcPinKey	  =", bSrcPinKey, 8);
    DspHex("[IN ]bDestPinKey	  =", bDestPinKey, 16);
    DspHex("[IN ]bSrcPinCipher	  =", bSrcPinCipher, 8);	
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX
		
    /* Call Test Target Function Start */	
    nRet = SMAPIConvertPinX98B(80, 2, szPan, nPanLen, bSrcPinKey, 8, bDestPinKey, 16, bSrcPinCipher, bDestPinCipher);
    /* Call Test Target Function End */
    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "mode=2,des->sm4, 无效socket[80],测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX   
    XXX_OUTPUT_NONE_XXX   
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyOutOf_GM_Test_01(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bKEK[32];
	BYTE bKeyUnderLMK[32];
	int  nKeyLen;
	BYTE bKeyUnderKEK[32];
	BYTE bKeyUnderKEKExp[32];

	bufclr(bKEK);
	bufclr(bKeyUnderLMK);
	bufclr(bKeyUnderKEK);
	bufclr(bKeyUnderKEKExp);

	nAlgo = 1;
	/* 0123 4567 89AB CDEF */
	memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
	nKeyLen = 8;
	/* 1023 3245 5467 7689 */
	memcpy(bKeyUnderLMK, "\x34\xF4\xFE\x76\x33\xA8\x03\x5F", 8);
	memcpy(bKeyUnderKEKExp, "\xED\x91\x88\x2F\xB6\xAF\xBD\xAF", 8);

	XXX_INPUT_XXX
	printf("[IN ]nSock        = %d\n", nSock);
	printf("[IN ]nAlgo        = %d\n", nAlgo);
	DspHex("[IN ]bKEK         =", bKEK, 8);
	printf("[IN ]nKeyLen      = %d\n", nKeyLen);
	DspHex("[IN ]bKeyUnderLMK =", bKeyUnderLMK, 8);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPITranslateKeyOutOf_GM(nSock, nAlgo, bKEK, bKeyUnderLMK, \
			nKeyLen, bKeyUnderKEK);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "Algo=1，DataLen=8测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[OUT]bKeyUnderKEK    =", bKeyUnderKEK, 8);
	DspHex("[OUT]bKeyUnderKEKExp =", bKeyUnderKEKExp, 8);
	ASSERT_OUT_HEX(bKeyUnderKEK, bKeyUnderKEKExp, 8);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void TranslateKeyOutOf_GM_Test_02(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bKEK[32];
	BYTE bKeyUnderLMK[32];
	int  nKeyLen;
	BYTE bKeyUnderKEK[32];
	BYTE bKeyUnderKEKExp[32];

	bufclr(bKEK);
	bufclr(bKeyUnderLMK);
	bufclr(bKeyUnderKEK);
	bufclr(bKeyUnderKEKExp);

	nAlgo = 2;
	/* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
	memcpy(bKEK,
			"\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
			16);
	nKeyLen = 8;
	/* 1023 3245 5467 7689 */
	memcpy(bKeyUnderLMK, "\x34\xF4\xFE\x76\x33\xA8\x03\x5F", 8);
	memcpy(bKeyUnderKEKExp, "\xF1\x6C\x5A\xA6\x4E\x30\xFC\x15", 8);

	XXX_INPUT_XXX
	printf("[IN ]nSock        = %d\n", nSock);
	printf("[IN ]nAlgo        = %d\n", nAlgo);
	DspHex("[IN ]bKEK         =", bKEK, 16);
	printf("[IN ]nKeyLen      = %d\n", nKeyLen);
	DspHex("[IN ]bKeyUnderLMK =", bKeyUnderLMK, 8);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPITranslateKeyOutOf_GM(nSock, nAlgo, bKEK, bKeyUnderLMK, \
			nKeyLen, bKeyUnderKEK);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "Algo=2，DataLen=8测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[OUT]bKeyUnderKEK    =", bKeyUnderKEK, 8);
	DspHex("[OUT]bKeyUnderKEKExp =", bKeyUnderKEKExp, 8);
	ASSERT_OUT_HEX(bKeyUnderKEK, bKeyUnderKEKExp, 8);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void TranslateKeyOutOf_GM_Test_03(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bKEK[32];
	BYTE bKeyUnderLMK[32];
	int  nKeyLen;
	BYTE bKeyUnderKEK[32];
	BYTE bKeyUnderKEKExp[32];

	bufclr(bKEK);
	bufclr(bKeyUnderLMK);
	bufclr(bKeyUnderKEK);
	bufclr(bKeyUnderKEKExp);

	nAlgo = 3;
	/* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8796 A5B4 C3D2 E1F0 */
	memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
			"\x59\x99\xC3\x06\xAB\x84\x01\xB2",\
			24);
	nKeyLen = 8;
	/* 1023 3245 5467 7689 */
	memcpy(bKeyUnderLMK, "\x34\xF4\xFE\x76\x33\xA8\x03\x5F", 8);
	memcpy(bKeyUnderKEKExp, "\xE3\x6B\x3F\x4B\x69\xD7\xA2\xBB", 8);

	XXX_INPUT_XXX
	printf("[IN ]nSock        = %d\n", nSock);
	printf("[IN ]nAlgo        = %d\n", nAlgo);
	DspHex("[IN ]bKEK         =", bKEK, 24);
	printf("[IN ]nKeyLen      = %d\n", nKeyLen);
	DspHex("[IN ]bKeyUnderLMK =", bKeyUnderLMK, 8);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPITranslateKeyOutOf_GM(nSock, nAlgo, bKEK, bKeyUnderLMK, \
			nKeyLen, bKeyUnderKEK);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "Algo=3，DataLen=8测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[OUT]bKeyUnderKEK    =", bKeyUnderKEK, 8);
	DspHex("[OUT]bKeyUnderKEKExp =", bKeyUnderKEKExp, 8);
	ASSERT_OUT_HEX(bKeyUnderKEK, bKeyUnderKEKExp, 8);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void TranslateKeyOutOf_GM_Test_04(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bKEK[32];
	BYTE bKeyUnderLMK[32];
	int  nKeyLen;
	BYTE bKeyUnderKEK[32];
	BYTE bKeyUnderKEKExp[32];

	bufclr(bKEK);
	bufclr(bKeyUnderLMK);
	bufclr(bKeyUnderKEK);
	bufclr(bKeyUnderKEKExp);

	nAlgo = 4;
	/* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
	memcpy(bKEK,
			"\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
			16);
	nKeyLen = 16;
	/* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
	memcpy(bKeyUnderLMK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A", 16);
	memcpy(bKeyUnderKEKExp, "\x68\x1E\xDF\x34\xD2\x06\x96\x5E\x86\xB3\xE9\x4F\x53\x6E\x42\x46", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock        = %d\n", nSock);
	printf("[IN ]nAlgo        = %d\n", nAlgo);
	DspHex("[IN ]bKEK         =", bKEK, 16);
	printf("[IN ]nKeyLen      = %d\n", nKeyLen);
	DspHex("[IN ]bKeyUnderLMK =", bKeyUnderLMK, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPITranslateKeyOutOf_GM(nSock, nAlgo, bKEK, bKeyUnderLMK, \
			nKeyLen, bKeyUnderKEK);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "Algo=4，DataLen=16测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[OUT]bKeyUnderKEK    =", bKeyUnderKEK, 16);
	DspHex("[OUT]bKeyUnderKEKExp =", bKeyUnderKEKExp, 16);
	ASSERT_OUT_HEX(bKeyUnderKEK, bKeyUnderKEKExp, 16);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void TranslateKeyOutOf_GM_Test_05(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bKEK[32];
	BYTE bKeyUnderLMK[32];
	int  nKeyLen;
	BYTE bKeyUnderKEK[32];
	BYTE bKeyUnderKEKExp[32];

	bufclr(bKEK);
	bufclr(bKeyUnderLMK);
	bufclr(bKeyUnderKEK);
	bufclr(bKeyUnderKEKExp);

	nAlgo = 1;
	/* 0123 4567 89AB CDEF */
	memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
	nKeyLen = 16;
	/* 1122 3344 5566 7788 99AA BBCC DDEE FF00 */
	memcpy(bKeyUnderLMK, "\x91\x21\x98\xF1\x03\x6B\xBA\x33" \
			"\x8C\x35\x9E\x9E\xE5\xA5\x72\x0D",\
			16);
	memcpy(bKeyUnderKEKExp, "\xB4\xCC\x3F\xD9\xD8\xD9\x52\x14" \
			"\x15\x79\x65\x7C\x43\x26\x3E\x1E",\
			16);

	XXX_INPUT_XXX
	printf("[IN ]nSock        = %d\n", nSock);
	printf("[IN ]nAlgo        = %d\n", nAlgo);
	DspHex("[IN ]bKEK         =", bKEK, 8);
	printf("[IN ]nKeyLen      = %d\n", nKeyLen);
	DspHex("[IN ]bKeyUnderLMK =", bKeyUnderLMK, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPITranslateKeyOutOf_GM(nSock, nAlgo, bKEK, bKeyUnderLMK, \
			nKeyLen, bKeyUnderKEK);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "Algo=1，DataLen=16测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[OUT]bKeyUnderKEK    =", bKeyUnderKEK, 16);
	DspHex("[OUT]bKeyUnderKEKExp =", bKeyUnderKEKExp, 16);
	ASSERT_OUT_HEX(bKeyUnderKEK, bKeyUnderKEKExp, 16);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void TranslateKeyOutOf_GM_Test_06(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bKEK[32];
	BYTE bKeyUnderLMK[32];
	int  nKeyLen;
	BYTE bKeyUnderKEK[32];
	BYTE bKeyUnderKEKExp[32];

	bufclr(bKEK);
	bufclr(bKeyUnderLMK);
	bufclr(bKeyUnderKEK);
	bufclr(bKeyUnderKEKExp);

	nAlgo = 2;
	/* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
	memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
			16);
	nKeyLen = 16;
	/* 1023 3245 5467 7689 98AB BACD DCEF FE01 */
	memcpy(bKeyUnderLMK, 
			"\x34\xF4\xFE\x76\x33\xA8\x03\x5F" \
			"\x25\x25\x12\x2F\x72\xE8\x35\x01" \
			, 16);
	memcpy(bKeyUnderKEKExp,
			"\xF1\x6C\x5A\xA6\x4E\x30\xFC\x15" \
			"\x81\x25\x8F\xE4\xB8\xB2\xB5\x4F" \
			, 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock        = %d\n", nSock);
	printf("[IN ]nAlgo        = %d\n", nAlgo);
	DspHex("[IN ]bKEK         =", bKEK, 16);
	printf("[IN ]nKeyLen      = %d\n", nKeyLen);
	DspHex("[IN ]bKeyUnderLMK =", bKeyUnderLMK, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPITranslateKeyOutOf_GM(nSock, nAlgo, bKEK, bKeyUnderLMK, \
			nKeyLen, bKeyUnderKEK);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "Algo=2，DataLen=16测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[OUT]bKeyUnderKEK    =", bKeyUnderKEK, 16);
	DspHex("[OUT]bKeyUnderKEKExp =", bKeyUnderKEKExp, 16);
	ASSERT_OUT_HEX(bKeyUnderKEK, bKeyUnderKEKExp, 16);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void TranslateKeyOutOf_GM_Test_07(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bKEK[32];
	BYTE bKeyUnderLMK[32];
	int  nKeyLen;
	BYTE bKeyUnderKEK[32];
	BYTE bKeyUnderKEKExp[32];

	bufclr(bKEK);
	bufclr(bKeyUnderLMK);
	bufclr(bKeyUnderKEK);
	bufclr(bKeyUnderKEKExp);

	nAlgo = 3;
	/* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8796 A5B4 C3D2 E1F0 */
	memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
			"\x59\x99\xC3\x06\xAB\x84\x01\xB2",\
			24);
	nKeyLen = 16;
	/* 1023 3245 5467 7689 98AB BACD DCEF FE01 */
	memcpy(bKeyUnderLMK, 
			"\x34\xF4\xFE\x76\x33\xA8\x03\x5F" \
			"\x25\x25\x12\x2F\x72\xE8\x35\x01" \
			, 16);
	memcpy(bKeyUnderKEKExp,
			"\xE3\x6B\x3F\x4B\x69\xD7\xA2\xBB" \
			"\x3B\x31\x80\x3D\x25\x79\x93\x09" \
			, 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock        = %d\n", nSock);
	printf("[IN ]nAlgo        = %d\n", nAlgo);
	DspHex("[IN ]bKEK         =", bKEK, 24);
	printf("[IN ]nKeyLen      = %d\n", nKeyLen);
	DspHex("[IN ]bKeyUnderLMK =", bKeyUnderLMK, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPITranslateKeyOutOf_GM(nSock, nAlgo, bKEK, bKeyUnderLMK, \
			nKeyLen, bKeyUnderKEK);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "Algo=3，DataLen=16测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[OUT]bKeyUnderKEK    =", bKeyUnderKEK, 16);
	DspHex("[OUT]bKeyUnderKEKExp =", bKeyUnderKEKExp, 16);
	ASSERT_OUT_HEX(bKeyUnderKEK, bKeyUnderKEKExp, 16);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void TranslateKeyOutOf_GM_Test_08(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bKEK[32];
	BYTE bKeyUnderLMK[32];
	int  nKeyLen;
	BYTE bKeyUnderKEK[32];
	BYTE bKeyUnderKEKExp[32];

	bufclr(bKEK);
	bufclr(bKeyUnderLMK);
	bufclr(bKeyUnderKEK);
	bufclr(bKeyUnderKEKExp);

	nAlgo = 1;
	/* 0123 4567 89AB CDEF */
	memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
	nKeyLen = 24;
	/* 1122 3344 5566 7788 99AA BBCC DDEE FF00 048C 159D 26AE 37BF */
	memcpy(bKeyUnderLMK, "\x91\x21\x98\xF1\x03\x6B\xBA\x33" \
			"\x8C\x35\x9E\x9E\xE5\xA5\x72\x0D" \
			"\xF3\x16\x51\xBB\xA0\x53\x71\xCB",\
			24);
	memcpy(bKeyUnderKEKExp, "\xB4\xCC\x3F\xD9\xD8\xD9\x52\x14" \
			"\x15\x79\x65\x7C\x43\x26\x3E\x1E" \
			"\x42\x7E\x63\xF4\x1F\xDF\x69\xE7",\
			24);

	XXX_INPUT_XXX
	printf("[IN ]nSock        = %d\n", nSock);
	printf("[IN ]nAlgo        = %d\n", nAlgo);
	DspHex("[IN ]bKEK         =", bKEK, 8);
	printf("[IN ]nKeyLen      = %d\n", nKeyLen);
	DspHex("[IN ]bKeyUnderLMK =", bKeyUnderLMK, 24);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPITranslateKeyOutOf_GM(nSock, nAlgo, bKEK, bKeyUnderLMK, \
			nKeyLen, bKeyUnderKEK);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "Algo=1，DataLen=24测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[OUT]bKeyUnderKEK    =", bKeyUnderKEK, 24);
	DspHex("[OUT]bKeyUnderKEKExp =", bKeyUnderKEKExp, 24);
	ASSERT_OUT_HEX(bKeyUnderKEK, bKeyUnderKEKExp, 24);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void TranslateKeyOutOf_GM_Test_09(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bKEK[32];
	BYTE bKeyUnderLMK[32];
	int  nKeyLen;
	BYTE bKeyUnderKEK[32];
	BYTE bKeyUnderKEKExp[32];

	bufclr(bKEK);
	bufclr(bKeyUnderLMK);
	bufclr(bKeyUnderKEK);
	bufclr(bKeyUnderKEKExp);

	nAlgo = 2;
	/* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
	memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
			16);
	nKeyLen = 24;
	/* 1122 3344 5566 7788 99AA BBCC DDEE FF00 048C 159D 26AE 37BF */
	memcpy(bKeyUnderLMK, "\x91\x21\x98\xF1\x03\x6B\xBA\x33" \
			"\x8C\x35\x9E\x9E\xE5\xA5\x72\x0D" \
			"\xF3\x16\x51\xBB\xA0\x53\x71\xCB",\
			24);
	memcpy(bKeyUnderKEKExp, "\x3E\xB3\xB7\x25\x76\xBB\xBE\x83" \
			"\x56\x01\x10\x4F\x2D\xF9\x44\x05" \
			"\x56\x29\x2B\xFE\xB2\x42\x1B\xEF",\
			24);

	XXX_INPUT_XXX
	printf("[IN ]nSock        = %d\n", nSock);
	printf("[IN ]nAlgo        = %d\n", nAlgo);
	DspHex("[IN ]bKEK         =", bKEK, 16);
	printf("[IN ]nKeyLen      = %d\n", nKeyLen);
	DspHex("[IN ]bKeyUnderLMK =", bKeyUnderLMK, 24);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPITranslateKeyOutOf_GM(nSock, nAlgo, bKEK, bKeyUnderLMK, \
			nKeyLen, bKeyUnderKEK);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "Algo=2，DataLen=24测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[OUT]bKeyUnderKEK    =", bKeyUnderKEK, 24);
	DspHex("[OUT]bKeyUnderKEKExp =", bKeyUnderKEKExp, 24);
	ASSERT_OUT_HEX(bKeyUnderKEK, bKeyUnderKEKExp, 24);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void TranslateKeyOutOf_GM_Test_10(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bKEK[32];
	BYTE bKeyUnderLMK[32];
	int  nKeyLen;
	BYTE bKeyUnderKEK[32];
	BYTE bKeyUnderKEKExp[32];

	bufclr(bKEK);
	bufclr(bKeyUnderLMK);
	bufclr(bKeyUnderKEK);
	bufclr(bKeyUnderKEKExp);

	nAlgo = 3;
	/* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8796 A5B4 C3D2 E1F0 */
	memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
			"\x59\x99\xC3\x06\xAB\x84\x01\xB2",\
			24);
	nKeyLen = 24;
	/* 1023 3245 5467 7689 98AB BACD DCEF FE01 048C 159D 26AE 37BF */
	memcpy(bKeyUnderLMK,
			"\x34\xF4\xFE\x76\x33\xA8\x03\x5F" \
			"\x25\x25\x12\x2F\x72\xE8\x35\x01" \
			"\xF3\x16\x51\xBB\xA0\x53\x71\xCB" \
			, 24);
	memcpy(bKeyUnderKEKExp, 
			"\xE3\x6B\x3F\x4B\x69\xD7\xA2\xBB" \
			"\x3B\x31\x80\x3D\x25\x79\x93\x09" \
			"\x7F\xCB\xE4\x66\x2B\x30\x92\x3B" \
			, 24);

	XXX_INPUT_XXX
	printf("[IN ]nSock        = %d\n", nSock);
	printf("[IN ]nAlgo        = %d\n", nAlgo);
	DspHex("[IN ]bKEK         =", bKEK, 24);
	printf("[IN ]nKeyLen      = %d\n", nKeyLen);
	DspHex("[IN ]bKeyUnderLMK =", bKeyUnderLMK, 24);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPITranslateKeyOutOf_GM(nSock, nAlgo, bKEK, bKeyUnderLMK, \
			nKeyLen, bKeyUnderKEK);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "Algo=3，DataLen=24测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[OUT]bKeyUnderKEK    =", bKeyUnderKEK, 24);
	DspHex("[OUT]bKeyUnderKEKExp =", bKeyUnderKEKExp, 24);
	ASSERT_OUT_HEX(bKeyUnderKEK, bKeyUnderKEKExp, 24);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void TranslateKeyOutOf_GM_Test_11(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bKEK[32];
	BYTE bKeyUnderLMK[32];
	int  nKeyLen;
	BYTE bKeyUnderKEK[32];
	BYTE bKeyUnderKEKExp[32];

	bufclr(bKEK);
	bufclr(bKeyUnderLMK);
	bufclr(bKeyUnderKEK);
	bufclr(bKeyUnderKEKExp);

	nSock = -1;
	nAlgo = 4;
	/* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
	memcpy(bKEK,
			"\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
			16);
	nKeyLen = 16;
	/* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
	memcpy(bKeyUnderLMK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock        = %d\n", nSock);
	printf("[IN ]nAlgo        = %d\n", nAlgo);
	DspHex("[IN ]bKEK         =", bKEK, 16);
	printf("[IN ]nKeyLen      = %d\n", nKeyLen);
	DspHex("[IN ]bKeyUnderLMK =", bKeyUnderLMK, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPITranslateKeyOutOf_GM(nSock, nAlgo, bKEK, bKeyUnderLMK, \
			nKeyLen, bKeyUnderKEK);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 3, "无效Socket ID[-1]测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	nSock = SM_SOCK;

	XXX_TEST_END_XXX
}

void TranslateKeyOutOf_GM_Test_12(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bKEK[32];
	BYTE bKeyUnderLMK[32];
	int  nKeyLen;
	BYTE bKeyUnderKEK[32];
	BYTE bKeyUnderKEKExp[32];

	bufclr(bKEK);
	bufclr(bKeyUnderLMK);
	bufclr(bKeyUnderKEK);
	bufclr(bKeyUnderKEKExp);

	nSock = 8;
	nAlgo = 4;
	/* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
	memcpy(bKEK,
			"\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
			16);
	nKeyLen = 16;
	/* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
	memcpy(bKeyUnderLMK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock        = %d\n", nSock);
	printf("[IN ]nAlgo        = %d\n", nAlgo);
	DspHex("[IN ]bKEK         =", bKEK, 16);
	printf("[IN ]nKeyLen      = %d\n", nKeyLen);
	DspHex("[IN ]bKeyUnderLMK =", bKeyUnderLMK, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPITranslateKeyOutOf_GM(nSock, nAlgo, bKEK, bKeyUnderLMK, \
			nKeyLen, bKeyUnderKEK);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 3, "无效Socket ID[8]测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	nSock = SM_SOCK;

	XXX_TEST_END_XXX
}

void TranslateKeyOutOf_GM_Test_13(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bKEK[32];
	BYTE bKeyUnderLMK[32];
	int  nKeyLen;
	BYTE bKeyUnderKEK[32];
	BYTE bKeyUnderKEKExp[32];

	bufclr(bKEK);
	bufclr(bKeyUnderLMK);
	bufclr(bKeyUnderKEK);
	bufclr(bKeyUnderKEKExp);

	nAlgo = 0;
	/* 0123 4567 89AB CDEF */
	memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
	nKeyLen = 8;
	/* 1122 3344 5566 7788 */
	memcpy(bKeyUnderLMK, "\x91\x21\x98\xF1\x03\x6B\xBA\x33", 8);

	XXX_INPUT_XXX
	printf("[IN ]nSock        = %d\n", nSock);
	printf("[IN ]nAlgo        = %d\n", nAlgo);
	DspHex("[IN ]bKEK         =", bKEK, 8);
	printf("[IN ]nKeyLen      = %d\n", nKeyLen);
	DspHex("[IN ]bKeyUnderLMK =", bKeyUnderLMK, 8);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPITranslateKeyOutOf_GM(nSock, nAlgo, bKEK, bKeyUnderLMK, \
			nKeyLen, bKeyUnderKEK);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 1, "无效算法类型[0]测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void TranslateKeyOutOf_GM_Test_14(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bKEK[32];
	BYTE bKeyUnderLMK[32];
	int  nKeyLen;
	BYTE bKeyUnderKEK[32];
	BYTE bKeyUnderKEKExp[32];

	bufclr(bKEK);
	bufclr(bKeyUnderLMK);
	bufclr(bKeyUnderKEK);
	bufclr(bKeyUnderKEKExp);

	nAlgo = 5;
	/* 0123 4567 89AB CDEF */
	memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
	nKeyLen = 8;
	/* 1122 3344 5566 7788 */
	memcpy(bKeyUnderLMK, "\x91\x21\x98\xF1\x03\x6B\xBA\x33", 8);

	XXX_INPUT_XXX
	printf("[IN ]nSock        = %d\n", nSock);
	printf("[IN ]nAlgo        = %d\n", nAlgo);
	DspHex("[IN ]bKEK         =", bKEK, 8);
	printf("[IN ]nKeyLen      = %d\n", nKeyLen);
	DspHex("[IN ]bKeyUnderLMK =", bKeyUnderLMK, 8);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPITranslateKeyOutOf_GM(nSock, nAlgo, bKEK, bKeyUnderLMK, \
			nKeyLen, bKeyUnderKEK);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 1, "无效算法类型[5]测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void TranslateKeyOutOf_GM_Test_15(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bKEK[32];
	BYTE bKeyUnderLMK[32];
	int  nKeyLen;
	BYTE bKeyUnderKEK[32];
	BYTE bKeyUnderKEKExp[32];

	bufclr(bKEK);
	bufclr(bKeyUnderLMK);
	bufclr(bKeyUnderKEK);
	bufclr(bKeyUnderKEKExp);

	nAlgo = 4;
	/* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
	memcpy(bKEK,
			"\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
			16);
	nKeyLen = 0;
	/* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
	memcpy(bKeyUnderLMK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock        = %d\n", nSock);
	printf("[IN ]nAlgo        = %d\n", nAlgo);
	DspHex("[IN ]bKEK         =", bKEK, 16);
	printf("[IN ]nKeyLen      = %d\n", nKeyLen);
	DspHex("[IN ]bKeyUnderLMK =", bKeyUnderLMK, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPITranslateKeyOutOf_GM(nSock, nAlgo, bKEK, bKeyUnderLMK, \
			nKeyLen, bKeyUnderKEK);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 1, "无效数据长度[0]测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void TranslateKeyOutOf_GM_Test_16(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bKEK[32];
	BYTE bKeyUnderLMK[32];
	int  nKeyLen;
	BYTE bKeyUnderKEK[32];
	BYTE bKeyUnderKEKExp[32];

	bufclr(bKEK);
	bufclr(bKeyUnderLMK);
	bufclr(bKeyUnderKEK);
	bufclr(bKeyUnderKEKExp);

	nAlgo = 4;
	/* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
	memcpy(bKEK,
			"\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
			16);
	nKeyLen = 15;
	/* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
	memcpy(bKeyUnderLMK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock        = %d\n", nSock);
	printf("[IN ]nAlgo        = %d\n", nAlgo);
	DspHex("[IN ]bKEK         =", bKEK, 16);
	printf("[IN ]nKeyLen      = %d\n", nKeyLen);
	DspHex("[IN ]bKeyUnderLMK =", bKeyUnderLMK, 15);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPITranslateKeyOutOf_GM(nSock, nAlgo, bKEK, bKeyUnderLMK, \
			nKeyLen, bKeyUnderKEK);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 1, "无效数据长度[15]测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void TranslateKeyOutOf_GM_Test_17(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bKEK[32];
	BYTE bKeyUnderLMK[32];
	int  nKeyLen;
	BYTE bKeyUnderKEK[32];
	BYTE bKeyUnderKEKExp[32];

	bufclr(bKEK);
	bufclr(bKeyUnderLMK);
	bufclr(bKeyUnderKEK);
	bufclr(bKeyUnderKEKExp);

	nAlgo = 4;
	/* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
	memcpy(bKEK,
			"\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
			16);
	nKeyLen = 24;
	/* 0123 4567 89AB CDEF FEDC BA98 7654 3210 0123 4567 89AB CDEF */
	memcpy(bKeyUnderLMK,"\xA2\xC0\xB0\xF8\xF7\xF5\xEE"\
			"\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A\xA2"\
			"\xC0\xB0\xF8\xF7\xF5\xEE\x21",24);

	XXX_INPUT_XXX
	printf("[IN ]nSock        = %d\n", nSock);
	printf("[IN ]nAlgo        = %d\n", nAlgo);
	DspHex("[IN ]bKEK         =", bKEK, 16);
	printf("[IN ]nKeyLen      = %d\n", nKeyLen);
	DspHex("[IN ]bKeyUnderLMK =", bKeyUnderLMK, 24);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPITranslateKeyOutOf_GM(nSock, nAlgo, bKEK, bKeyUnderLMK, \
			nKeyLen, bKeyUnderKEK);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 1, "无效数据长度[24]测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void TranslateKeyOutOf_GM_Test_18(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bKEK[32];
	BYTE bKeyUnderLMK[32];
	int  nKeyLen;
	BYTE bKeyUnderKEK[32];
	BYTE bKeyUnderKEKExp[32];

	bufclr(bKEK);
	bufclr(bKeyUnderLMK);
	bufclr(bKeyUnderKEK);
	bufclr(bKeyUnderKEKExp);

	nAlgo = 4;
	/* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
	memcpy(bKEK,
			"\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
			16);
	nKeyLen = 8;
	/* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
	memcpy(bKeyUnderLMK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock        = %d\n", nSock);
	printf("[IN ]nAlgo        = %d\n", nAlgo);
	DspHex("[IN ]bKEK         =", bKEK, 16);
	printf("[IN ]nKeyLen      = %d\n", nKeyLen);
	DspHex("[IN ]bKeyUnderLMK =", bKeyUnderLMK, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPITranslateKeyOutOf_GM(nSock, nAlgo, bKEK, bKeyUnderLMK, \
			nKeyLen, bKeyUnderKEK);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 1, "无效数据长度[8]测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void TranslateKeyOutOf_GM_Test_19(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bKEK[32];
	BYTE bKeyUnderLMK[32];
	int  nKeyLen;
	BYTE bKeyUnderKEK[32];
	BYTE bKeyUnderKEKExp[32];

	bufclr(bKEK);
	bufclr(bKeyUnderLMK);
	bufclr(bKeyUnderKEK);
	bufclr(bKeyUnderKEKExp);

	nAlgo = 4;
	/* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
	memcpy(bKEK,
			"\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
			16);
	nKeyLen = 32;
	/* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
	memcpy(bKeyUnderLMK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE" \
			"\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
			"\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A" \
			"\xEB\xE7\x14\xE5\x3A", 32);

	XXX_INPUT_XXX
	printf("[IN ]nSock        = %d\n", nSock);
	printf("[IN ]nAlgo        = %d\n", nAlgo);
	DspHex("[IN ]bKEK         =", bKEK, 16);
	printf("[IN ]nKeyLen      = %d\n", nKeyLen);
	DspHex("[IN ]bKeyUnderLMK =", bKeyUnderLMK, 32);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPITranslateKeyOutOf_GM(nSock, nAlgo, bKEK, bKeyUnderLMK, \
			nKeyLen, bKeyUnderKEK);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 1, "无效数据长度[32]测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}


void EncryptPinX98A_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "1234");
    sprintf(bCryptPinExp, "\xF0\x05\xB8\xAE\x32\x43\x6B\x80");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98A(nSock, nAlgo, bPinKey, szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "4位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptPin  =", bCryptPin, 8);
    DspHex("[OUT]expect     =", bCryptPinExp, 8);
    ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98A_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "12345");
    sprintf(bCryptPinExp, "\xBB\x0D\x3B\x5C\x9C\x5E\x47\x4D");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98A(nSock, nAlgo, bPinKey, szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "5位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptPin  =", bCryptPin, 8);
    DspHex("[OUT]expect     =", bCryptPinExp, 8);
    ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98A_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "123456");
    sprintf(bCryptPinExp, "\x43\xE9\x45\x58\x8E\xD5\x66\xD9");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98A(nSock, nAlgo, bPinKey, szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "6位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptPin  =", bCryptPin, 8);
    DspHex("[OUT]expect     =", bCryptPinExp, 8);
    ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98A_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "1234567");
    sprintf(bCryptPinExp, "\x57\xC3\xC3\x82\x6F\xD7\x24\xE0");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98A(nSock, nAlgo, bPinKey, szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "7位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptPin  =", bCryptPin, 8);
    DspHex("[OUT]expect     =", bCryptPinExp, 8);
    ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98A_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "12345678");
    sprintf(bCryptPinExp, "\xDC\x09\x04\xC0\x8A\xDA\x7B\x7E");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98A(nSock, nAlgo, bPinKey, szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "8位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptPin  =", bCryptPin, 8);
    DspHex("[OUT]expect     =", bCryptPinExp, 8);
    ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98A_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "123456789");
    sprintf(bCryptPinExp, "\xEA\x30\xC7\x69\xEC\x6D\x5C\x04");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98A(nSock, nAlgo, bPinKey, szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "9位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptPin  =", bCryptPin, 8);
    DspHex("[OUT]expect     =", bCryptPinExp, 8);
    ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98A_Test_07(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "1234567890");
    sprintf(bCryptPinExp, "\xA1\x76\xC3\x3D\x92\xA7\xA7\xBB");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98A(nSock, nAlgo, bPinKey, szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "10位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptPin  =", bCryptPin, 8);
    DspHex("[OUT]expect     =", bCryptPinExp, 8);
    ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98A_Test_08(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "12345678901");
    sprintf(bCryptPinExp, "\x18\xFD\x54\x3A\x70\x02\x4D\xBB");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98A(nSock, nAlgo, bPinKey, szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "11位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptPin  =", bCryptPin, 8);
    DspHex("[OUT]expect     =", bCryptPinExp, 8);
    ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98A_Test_09(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "123456789012");
    sprintf(bCryptPinExp, "\x1C\x26\x79\x07\x9C\x6F\xE3\x91");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98A(nSock, nAlgo, bPinKey, szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "12位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptPin  =", bCryptPin, 8);
    DspHex("[OUT]expect     =", bCryptPinExp, 8);
    ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98A_Test_10(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "123");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98A(nSock, nAlgo, bPinKey, szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "3位PIN测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98A_Test_11(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "1234567890123");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98A(nSock, nAlgo, bPinKey, szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "13位PIN测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98A_Test_12(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 1;
    /* plain key = 0123456789ABCDEF */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");

    sprintf(szPlainPin, "123456");
    sprintf(bCryptPinExp, "\x2F\x2B\x15\xB0\xF0\x9A\xD4\xD1");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 8);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98A(nSock, nAlgo, bPinKey, szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "单倍长密钥测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptPin  =", bCryptPin, 8);
    DspHex("[OUT]expect     =", bCryptPinExp, 8);
    ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98A_Test_13(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 3;
    /* plain key = 0123456789ABCDEFFEDCBA98765432108796A5B4C3D2E1F0 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                     "\x59\x99\xC3\x06\xAB\x84\x01\xB2");

    sprintf(szPlainPin, "123456");
    sprintf(bCryptPinExp, "\x59\x92\xA5\x8F\x5E\x1A\x77\x52");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 24);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98A(nSock, nAlgo, bPinKey, szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "三倍长密钥测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptPin  =", bCryptPin, 8);
    DspHex("[OUT]expect     =", bCryptPinExp, 8);
    ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98A_Test_14(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "123az!");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 24);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98A(nSock, nAlgo, bPinKey, szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 6, "无效密码-密码中含有非数字字符测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98A_Test_15(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "123abc");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 24);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98A(nSock, nAlgo, bPinKey, szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 6, "无效密码-密码中含有非数字字符测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98A_Test_16(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nSock = -1;
    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "123456");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 24);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98A(nSock, nAlgo, bPinKey, szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void EncryptPinX98A_Test_17(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nSock = 8;
    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "123456");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 24);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98A(nSock, nAlgo, bPinKey, szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[8]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void EncryptPinX98A_Test_18(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 0;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "123456");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98A(nSock, nAlgo, bPinKey, szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效算法类型[0]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98A_Test_19(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 4;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "123456");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98A(nSock, nAlgo, bPinKey, szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效算法类型[4]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98B_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];
    char szPan[24];
    int  nPanLen;

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPan);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "1234");
    sprintf(szPan, "1234567890123456");
    nPanLen = 16;
    memcpy(bCryptPinExp, "\xE5\x63\x9C\xBC\x7E\xC0\xB4\xCA", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "4位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptPin  =", bCryptPin, 8);
    DspHex("[OUT]expect     =", bCryptPinExp, 8);
    ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98B_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];
    char szPan[24];
    int  nPanLen;

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPan);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "12345");
    sprintf(szPan, "1234567890123456");
    nPanLen = 16;
    memcpy(bCryptPinExp, "\xCA\xFC\x93\x1F\x5E\x86\xC8\xF9", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "5位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptPin  =", bCryptPin, 8);
    DspHex("[OUT]expect     =", bCryptPinExp, 8);
    ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98B_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];
    char szPan[24];
    int  nPanLen;

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPan);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "123456");
    sprintf(szPan, "1234567890123456");
    nPanLen = 16;
    memcpy(bCryptPinExp, "\x79\x3A\xE1\xFC\xD3\x06\x49\x68", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "6位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptPin  =", bCryptPin, 8);
    DspHex("[OUT]expect     =", bCryptPinExp, 8);
    ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98B_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];
    char szPan[24];
    int  nPanLen;

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPan);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "1234567");
    sprintf(szPan, "1234567890123456");
    nPanLen = 16;
    memcpy(bCryptPinExp, "\xE5\xE2\xF6\x85\x88\x69\x40\x94", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "7位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptPin  =", bCryptPin, 8);
    DspHex("[OUT]expect     =", bCryptPinExp, 8);
    ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98B_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];
    char szPan[24];
    int  nPanLen;

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPan);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "12345678");
    sprintf(szPan, "1234567890123456");
    nPanLen = 16;
    memcpy(bCryptPinExp, "\x51\xFD\x77\xE4\x96\xD4\x18\xE1", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "8位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptPin  =", bCryptPin, 8);
    DspHex("[OUT]expect     =", bCryptPinExp, 8);
    ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98B_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];
    char szPan[24];
    int  nPanLen;

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPan);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "123456789");
    sprintf(szPan, "1234567890123456");
    nPanLen = 16;
    memcpy(bCryptPinExp, "\x06\x04\x4D\x82\x02\x7E\xEE\xEF", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "9位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptPin  =", bCryptPin, 8);
    DspHex("[OUT]expect     =", bCryptPinExp, 8);
    ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98B_Test_07(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];
    char szPan[24];
    int  nPanLen;

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPan);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "1234567890");
    sprintf(szPan, "1234567890123456");
    nPanLen = 16;
    memcpy(bCryptPinExp, "\xC2\x50\x00\xAD\x16\xEF\x76\x3B", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "10位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptPin  =", bCryptPin, 8);
    DspHex("[OUT]expect     =", bCryptPinExp, 8);
    ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98B_Test_08(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];
    char szPan[24];
    int  nPanLen;

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPan);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "12345678901");
    sprintf(szPan, "1234567890123456");
    nPanLen = 16;
    memcpy(bCryptPinExp, "\xB4\xAA\x17\xD0\x03\x92\x14\xDA", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "11位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptPin  =", bCryptPin, 8);
    DspHex("[OUT]expect     =", bCryptPinExp, 8);
    ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98B_Test_09(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];
    char szPan[24];
    int  nPanLen;

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPan);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "123456789012");
    sprintf(szPan, "1234567890123456");
    nPanLen = 16;
    memcpy(bCryptPinExp, "\xD4\x0C\xFB\x50\x16\xFB\xC1\x18", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "12位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptPin  =", bCryptPin, 8);
    DspHex("[OUT]expect     =", bCryptPinExp, 8);
    ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98B_Test_10(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];
    char szPan[24];
    int  nPanLen;

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPan);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "123");
    sprintf(szPan, "1234567890123456");
    nPanLen = 16;

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "3位PIN测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98B_Test_11(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];
    char szPan[24];
    int  nPanLen;

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPan);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "1234567890123");
    sprintf(szPan, "1234567890123456");
    nPanLen = 16;

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "13位PIN测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98B_Test_12(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];
    char szPan[24];
    int  nPanLen;

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPan);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 1;
    /* plain key = 0123456789ABCDEF */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");

    sprintf(szPlainPin, "123456");
    sprintf(szPan, "1234567890123456");
    nPanLen = 16;
    memcpy(bCryptPinExp, "\x68\x67\x90\xAC\x2D\x5B\x2F\xFD", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 8);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "单倍长密钥测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptPin  =", bCryptPin, 8);
    DspHex("[OUT]expect     =", bCryptPinExp, 8);
    ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98B_Test_13(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];
    char szPan[24];
    int  nPanLen;

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPan);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 3;
    /* plain key = 0123456789ABCDEFFEDCBA98765432108796A5B4C3D2E1F0 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                     "\x59\x99\xC3\x06\xAB\x84\x01\xB2");

    sprintf(szPlainPin, "123456");
    sprintf(szPan, "1234567890123456");
    nPanLen = 16;
    memcpy(bCryptPinExp, "\x6C\x88\xF0\xE4\xCD\x99\xB8\xA4", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 24);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "三倍长密钥测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptPin  =", bCryptPin, 8);
    DspHex("[OUT]expect     =", bCryptPinExp, 8);
    ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98B_Test_14(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];
    char szPan[24];
    int  nPanLen;

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPan);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "123az!");
    sprintf(szPan, "1234567890123456");
    nPanLen = 16;

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 24);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 6, "无效密码-密码中含有非数字字符测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98B_Test_15(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];
    char szPan[24];
    int  nPanLen;

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPan);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "123abc");
    sprintf(szPan, "1234567890123456");
    nPanLen = 16;

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 24);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 6, "无效密码-密码中含有非数字字符测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98B_Test_16(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];
    char szPan[24];
    int  nPanLen;

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPan);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nSock = -1;
    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "123456");
    sprintf(szPan, "1234567890123456");
    nPanLen = 16;

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 24);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void EncryptPinX98B_Test_17(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];
    char szPan[24];
    int  nPanLen;

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPan);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nSock = 8;
    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "123456");
    sprintf(szPan, "1234567890123456");
    nPanLen = 16;

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 24);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[8]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void EncryptPinX98B_Test_18(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];
    char szPan[24];
    int  nPanLen;

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPan);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "123456");
    sprintf(szPan, "1234567890123");
    nPanLen = 13;
    memcpy(bCryptPinExp, "\x2A\x08\x4C\x60\x49\x73\xD4\xAE", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "13位PAN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptPin  =", bCryptPin, 8);
    DspHex("[OUT]expect     =", bCryptPinExp, 8);
    ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98B_Test_19(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];
    char szPan[24];
    int  nPanLen;

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPan);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "123456");
    sprintf(szPan, "12345678901234");
    nPanLen = 14;
    memcpy(bCryptPinExp, "\xB9\x1D\x02\x0C\x87\x1D\xFF\xC1", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "14位PAN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptPin  =", bCryptPin, 8);
    DspHex("[OUT]expect     =", bCryptPinExp, 8);
    ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98B_Test_20(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];
    char szPan[24];
    int  nPanLen;

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPan);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "123456");
    sprintf(szPan, "123456789012345");
    nPanLen = 15;
    memcpy(bCryptPinExp, "\x22\xC2\x22\x68\x52\x3C\x48\xA4", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "15位PAN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptPin  =", bCryptPin, 8);
    DspHex("[OUT]expect     =", bCryptPinExp, 8);
    ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98B_Test_21(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];
    char szPan[24];
    int  nPanLen;

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPan);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "123456");
    sprintf(szPan, "12345678901234567");
    nPanLen = 17;
    memcpy(bCryptPinExp, "\x84\x61\x5C\x0F\xB7\x61\x52\x8E", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "17位PAN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptPin  =", bCryptPin, 8);
    DspHex("[OUT]expect     =", bCryptPinExp, 8);
    ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98B_Test_22(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];
    char szPan[24];
    int  nPanLen;

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPan);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "123456");
    sprintf(szPan, "123456789012345678");
    nPanLen = 18;
    memcpy(bCryptPinExp, "\xDE\xCD\x0A\xF6\x38\xE0\x47\x4B", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "18位PAN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptPin  =", bCryptPin, 8);
    DspHex("[OUT]expect     =", bCryptPinExp, 8);
    ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98B_Test_23(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];
    char szPan[24];
    int  nPanLen;

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPan);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "123456789012");
    sprintf(szPan, "1234567890123456789");
    nPanLen = 19;
    memcpy(bCryptPinExp, "\xE1\xF8\x26\x1A\x56\xD0\xBB\x1D", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "12位PIN19位PAN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptPin  =", bCryptPin, 8);
    DspHex("[OUT]expect     =", bCryptPinExp, 8);
    ASSERT_OUT_HEX(bCryptPin, bCryptPinExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98B_Test_24(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];
    char szPan[24];
    int  nPanLen;

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPan);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "123456");
    sprintf(szPan, "123456789012");
    nPanLen = 12;

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "12位PAN测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98B_Test_25(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];
    char szPan[24];
    int  nPanLen;

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPan);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "123456");
    sprintf(szPan, "12345678901234567890");
    nPanLen = 20;

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "20位PAN测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98B_Test_26(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];
    char szPan[24];
    int  nPanLen;

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPan);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "123456");
    sprintf(szPan, "1234567az!123456");
    nPanLen = 16;

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效账号-账号中含有非数字字符测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    DspHex("[OUT]bCryptPin  =", bCryptPin, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98B_Test_27(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];
    char szPan[24];
    int  nPanLen;

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPan);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "123456");
    sprintf(szPan, "abc4567890123456");
    nPanLen = 16;

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效账号-账号中含有非数字字符测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    DspHex("[OUT]bCryptPin  =", bCryptPin, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98B_Test_28(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];
    char szPan[24];
    int  nPanLen;

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPan);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "123456");
    sprintf(szPan, "1234567890123ABC");
    nPanLen = 16;

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效账号-账号中含有非数字字符测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    DspHex("[OUT]bCryptPin  =", bCryptPin, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98B_Test_29(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];
    char szPan[24];
    int  nPanLen;

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPan);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 0;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "123456");
    sprintf(szPan, "1234567890123456");
    nPanLen = 16;

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效算法类型[0]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptPinX98B_Test_30(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    BYTE bCryptPinExp[8];
    char szPan[24];
    int  nPanLen;

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPan);
    bufclr(bCryptPin);
    bufclr(bCryptPinExp);

    nAlgo = 4;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPlainPin, "123456");
    sprintf(szPan, "1234567890123456");
    nPanLen = 16;

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    printf("[IN ]szPlainPin = %s\n", szPlainPin);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               szPlainPin, bCryptPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效算法类型[4]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98A_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(szPlainPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(bCryptPin, "\xF0\x05\xB8\xAE\x32\x43\x6B\x80");
    sprintf(szPlainPinExp, "1234");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98A(nSock, nAlgo, bPinKey, bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "4位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szPlainPin = %s\n", szPlainPin);
    printf("[OUT]expect     = %s\n", szPlainPinExp);
    ASSERT_OUT_HEX(szPlainPin, szPlainPinExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98A_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(szPlainPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(bCryptPin, "\xBB\x0D\x3B\x5C\x9C\x5E\x47\x4D");
    sprintf(szPlainPinExp, "12345");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98A(nSock, nAlgo, bPinKey, bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "5位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szPlainPin = %s\n", szPlainPin);
    printf("[OUT]expect     = %s\n", szPlainPinExp);
    ASSERT_OUT_HEX(szPlainPin, szPlainPinExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98A_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(szPlainPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(bCryptPin, "\x43\xE9\x45\x58\x8E\xD5\x66\xD9");
    sprintf(szPlainPinExp, "123456");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98A(nSock, nAlgo, bPinKey, bCryptPin, szPlainPin);
	/* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "6位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szPlainPin = %s\n", szPlainPin);
    printf("[OUT]expect     = %s\n", szPlainPinExp);
    ASSERT_OUT_HEX(szPlainPin, szPlainPinExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98A_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(szPlainPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(bCryptPin, "\x57\xC3\xC3\x82\x6F\xD7\x24\xE0");
    sprintf(szPlainPinExp, "1234567");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98A(nSock, nAlgo, bPinKey, bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "7位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szPlainPin = %s\n", szPlainPin);
    printf("[OUT]expect     = %s\n", szPlainPinExp);
    ASSERT_OUT_HEX(szPlainPin, szPlainPinExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98A_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(szPlainPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(bCryptPin, "\xDC\x09\x04\xC0\x8A\xDA\x7B\x7E");
    sprintf(szPlainPinExp, "12345678");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98A(nSock, nAlgo, bPinKey, bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "8位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szPlainPin = %s\n", szPlainPin);
    printf("[OUT]expect     = %s\n", szPlainPinExp);
    ASSERT_OUT_HEX(szPlainPin, szPlainPinExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98A_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(szPlainPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(bCryptPin, "\xEA\x30\xC7\x69\xEC\x6D\x5C\x04");
    sprintf(szPlainPinExp, "123456789");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98A(nSock, nAlgo, bPinKey, bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "9位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szPlainPin = %s\n", szPlainPin);
    printf("[OUT]expect     = %s\n", szPlainPinExp);
    ASSERT_OUT_HEX(szPlainPin, szPlainPinExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98A_Test_07(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(szPlainPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(bCryptPin, "\xA1\x76\xC3\x3D\x92\xA7\xA7\xBB");
    sprintf(szPlainPinExp, "1234567890");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98A(nSock, nAlgo, bPinKey, bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "10位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szPlainPin = %s\n", szPlainPin);
    printf("[OUT]expect     = %s\n", szPlainPinExp);
    ASSERT_OUT_HEX(szPlainPin, szPlainPinExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98A_Test_08(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(szPlainPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(bCryptPin, "\x18\xFD\x54\x3A\x70\x02\x4D\xBB");
    sprintf(szPlainPinExp, "12345678901");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98A(nSock, nAlgo, bPinKey, bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "11位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szPlainPin = %s\n", szPlainPin);
    printf("[OUT]expect     = %s\n", szPlainPinExp);
    ASSERT_OUT_HEX(szPlainPin, szPlainPinExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98A_Test_09(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(szPlainPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(bCryptPin, "\x1C\x26\x79\x07\x9C\x6F\xE3\x91");
    sprintf(szPlainPinExp, "123456789012");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98A(nSock, nAlgo, bPinKey, bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "12位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szPlainPin = %s\n", szPlainPin);
    printf("[OUT]expect     = %s\n", szPlainPinExp);
    ASSERT_OUT_HEX(szPlainPin, szPlainPinExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98A_Test_10(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(szPlainPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(bCryptPin, "\xA2\xAF\x2D\x2E\x31\xEC\x62\x4D");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98A(nSock, nAlgo, bPinKey, bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 6, "3位PIN测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98A_Test_11(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(szPlainPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(bCryptPin, "\xAE\x26\xE7\x82\x64\xCF\x27\xCE");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98A(nSock, nAlgo, bPinKey, bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 6, "13位PIN测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98A_Test_12(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(szPlainPinExp);

    nAlgo = 1;
    /* plain key = 0123456789ABCDEF */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");

    sprintf(bCryptPin, "\x2F\x2B\x15\xB0\xF0\x9A\xD4\xD1");
    sprintf(szPlainPinExp, "123456");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 8);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98A(nSock, nAlgo, bPinKey, bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "单倍长密钥测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szPlainPin = %s\n", szPlainPin);
    printf("[OUT]expect     = %s\n", szPlainPinExp);
    ASSERT_OUT_HEX(szPlainPin, szPlainPinExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98A_Test_13(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(szPlainPinExp);

    nAlgo = 3;
    /* plain key = 0123456789ABCDEFFEDCBA98765432108796A5B4C3D2E1F0 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                     "\x59\x99\xC3\x06\xAB\x84\x01\xB2");

    sprintf(bCryptPin, "\x59\x92\xA5\x8F\x5E\x1A\x77\x52");
    sprintf(szPlainPinExp, "123456");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 24);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98A(nSock, nAlgo, bPinKey, bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "三倍长密钥测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szPlainPin = %s\n", szPlainPin);
    printf("[OUT]expect     = %s\n", szPlainPinExp);
    ASSERT_OUT_HEX(szPlainPin, szPlainPinExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98A_Test_14(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(szPlainPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    memset(bCryptPin, 0x00, 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 24);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98A(nSock, nAlgo, bPinKey, bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 6, "无效密文(0x00)测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98A_Test_15(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(szPlainPinExp);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    memset(bCryptPin, 0xFF, 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 24);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98A(nSock, nAlgo, bPinKey, bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 6, "无效密文(0xFF)测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98A_Test_16(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(szPlainPinExp);

    nSock = -1;
    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(bCryptPin, "\x43\xE9\x45\x58\x8E\xD5\x66\xD9");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 24);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98A(nSock, nAlgo, bPinKey, bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void DecryptPinX98A_Test_17(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(szPlainPinExp);

    nSock = 8;
    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(bCryptPin, "\x43\xE9\x45\x58\x8E\xD5\x66\xD9");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 24);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98A(nSock, nAlgo, bPinKey, bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[8]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void DecryptPinX98A_Test_18(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(szPlainPinExp);

    nAlgo = 0;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(bCryptPin, "\x43\xE9\x45\x58\x8E\xD5\x66\xD9");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98A(nSock, nAlgo, bPinKey, bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效算法类型[0]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98A_Test_19(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];

    bufclr(szPlainPin);
    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(szPlainPinExp);

    nAlgo = 4;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(bCryptPin, "\x43\xE9\x45\x58\x8E\xD5\x66\xD9");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98A(nSock, nAlgo, bPinKey, bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效算法类型[4]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98B_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];
    char szPan[24];
    int  nPanLen;

    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(bCryptPin);
    bufclr(szPlainPinExp);
    bufclr(szPan);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPan, "1234567890123456");
    nPanLen = 16;
    memcpy(bCryptPin, "\xE5\x63\x9C\xBC\x7E\xC0\xB4\xCA", 8);
    sprintf(szPlainPinExp, "1234");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "4位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szPlainPin = %s\n", szPlainPin);
    printf("[OUT]expect     = %s\n", szPlainPinExp);
    ASSERT_OUT_HEX(szPlainPin, szPlainPinExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98B_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];
    char szPan[24];
    int  nPanLen;

    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(bCryptPin);
    bufclr(szPlainPinExp);
    bufclr(szPan);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPan, "1234567890123456");
    nPanLen = 16;
    memcpy(bCryptPin, "\xCA\xFC\x93\x1F\x5E\x86\xC8\xF9", 8);
    sprintf(szPlainPinExp, "12345");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "5位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szPlainPin = %s\n", szPlainPin);
    printf("[OUT]expect     = %s\n", szPlainPinExp);
    ASSERT_OUT_HEX(szPlainPin, szPlainPinExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98B_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];
    char szPan[24];
    int  nPanLen;

    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(bCryptPin);
    bufclr(szPlainPinExp);
    bufclr(szPan);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPan, "1234567890123456");
    nPanLen = 16;
    memcpy(bCryptPin, "\x79\x3A\xE1\xFC\xD3\x06\x49\x68", 8);
    sprintf(szPlainPinExp, "123456");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "6位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szPlainPin = %s\n", szPlainPin);
    printf("[OUT]expect     = %s\n", szPlainPinExp);
    ASSERT_OUT_HEX(szPlainPin, szPlainPinExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98B_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];
    char szPan[24];
    int  nPanLen;

    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(bCryptPin);
    bufclr(szPlainPinExp);
    bufclr(szPan);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPan, "1234567890123456");
    nPanLen = 16;
    memcpy(bCryptPin, "\xE5\xE2\xF6\x85\x88\x69\x40\x94", 8);
    sprintf(szPlainPinExp, "1234567");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "7位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szPlainPin = %s\n", szPlainPin);
    printf("[OUT]expect     = %s\n", szPlainPinExp);
    ASSERT_OUT_HEX(szPlainPin, szPlainPinExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98B_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];
    char szPan[24];
    int  nPanLen;

    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(bCryptPin);
    bufclr(szPlainPinExp);
    bufclr(szPan);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPan, "1234567890123456");
    nPanLen = 16;
    memcpy(bCryptPin, "\x51\xFD\x77\xE4\x96\xD4\x18\xE1", 8);
    sprintf(szPlainPinExp, "12345678");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "8位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szPlainPin = %s\n", szPlainPin);
    printf("[OUT]expect     = %s\n", szPlainPinExp);
    ASSERT_OUT_HEX(szPlainPin, szPlainPinExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98B_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];
    char szPan[24];
    int  nPanLen;

    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(bCryptPin);
    bufclr(szPlainPinExp);
    bufclr(szPan);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPan, "1234567890123456");
    nPanLen = 16;
    memcpy(bCryptPin, "\x06\x04\x4D\x82\x02\x7E\xEE\xEF", 8);
    sprintf(szPlainPinExp, "123456789");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "9位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szPlainPin = %s\n", szPlainPin);
    printf("[OUT]expect     = %s\n", szPlainPinExp);
    ASSERT_OUT_HEX(szPlainPin, szPlainPinExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98B_Test_07(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];
    char szPan[24];
    int  nPanLen;

    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(bCryptPin);
    bufclr(szPlainPinExp);
    bufclr(szPan);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPan, "1234567890123456");
    nPanLen = 16;
    memcpy(bCryptPin, "\xC2\x50\x00\xAD\x16\xEF\x76\x3B", 8);
    sprintf(szPlainPinExp, "1234567890");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "10位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szPlainPin = %s\n", szPlainPin);
    printf("[OUT]expect     = %s\n", szPlainPinExp);
    ASSERT_OUT_HEX(szPlainPin, szPlainPinExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98B_Test_08(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];
    char szPan[24];
    int  nPanLen;

    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(bCryptPin);
    bufclr(szPlainPinExp);
    bufclr(szPan);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPan, "1234567890123456");
    nPanLen = 16;
    memcpy(bCryptPin, "\xB4\xAA\x17\xD0\x03\x92\x14\xDA", 8);
    sprintf(szPlainPinExp, "12345678901");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "11位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szPlainPin = %s\n", szPlainPin);
    printf("[OUT]expect     = %s\n", szPlainPinExp);
    ASSERT_OUT_HEX(szPlainPin, szPlainPinExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98B_Test_09(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];
    char szPan[24];
    int  nPanLen;

    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(bCryptPin);
    bufclr(szPlainPinExp);
    bufclr(szPan);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPan, "1234567890123456");
    nPanLen = 16;
    memcpy(bCryptPin, "\xD4\x0C\xFB\x50\x16\xFB\xC1\x18", 8);
    sprintf(szPlainPinExp, "123456789012");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "12位PIN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szPlainPin = %s\n", szPlainPin);
    printf("[OUT]expect     = %s\n", szPlainPinExp);
    ASSERT_OUT_HEX(szPlainPin, szPlainPinExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98B_Test_10(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];
    char szPan[24];
    int  nPanLen;

    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(bCryptPin);
    bufclr(szPlainPinExp);
    bufclr(szPan);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPan, "1234567890123456");
    nPanLen = 16;
    memcpy(bCryptPin, "\xEA\x39\x38\xF4\x8F\x9F\x73\xEA", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "3位PIN测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98B_Test_11(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];
    char szPan[24];
    int  nPanLen;

    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(bCryptPin);
    bufclr(szPlainPinExp);
    bufclr(szPan);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPan, "1234567890123456");
    nPanLen = 16;
    memcpy(bCryptPin, "\x1D\xDF\x6B\xBA\x81\xDB\x1C\xC9", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "13位PIN测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    printf("[OUT]szPlainPin = %s\n", szPlainPin);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98B_Test_12(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];
    char szPan[24];
    int  nPanLen;

    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(bCryptPin);
    bufclr(szPlainPinExp);
    bufclr(szPan);

    nAlgo = 1;
    /* plain key = 0123456789ABCDEF */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21");

    sprintf(szPan, "1234567890123456");
    nPanLen = 16;
    memcpy(bCryptPin, "\x68\x67\x90\xAC\x2D\x5B\x2F\xFD", 8);
    sprintf(szPlainPinExp, "123456");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 8);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "单倍长密钥测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szPlainPin = %s\n", szPlainPin);
    printf("[OUT]expect     = %s\n", szPlainPinExp);
    ASSERT_OUT_HEX(szPlainPin, szPlainPinExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98B_Test_13(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];
    char szPan[24];
    int  nPanLen;

    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(bCryptPin);
    bufclr(szPlainPinExp);
    bufclr(szPan);

    nAlgo = 3;
    /* plain key = 0123456789ABCDEFFEDCBA98765432108796A5B4C3D2E1F0 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                     "\x59\x99\xC3\x06\xAB\x84\x01\xB2");

    sprintf(szPan, "1234567890123456");
    nPanLen = 16;
    memcpy(bCryptPin, "\x6C\x88\xF0\xE4\xCD\x99\xB8\xA4", 8);
    sprintf(szPlainPinExp, "123456");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 24);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "三倍长密钥测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szPlainPin = %s\n", szPlainPin);
    printf("[OUT]expect     = %s\n", szPlainPinExp);
    ASSERT_OUT_HEX(szPlainPin, szPlainPinExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98B_Test_14(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];
    char szPan[24];
    int  nPanLen;

    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(bCryptPin);
    bufclr(szPlainPinExp);
    bufclr(szPan);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPan, "1234567890123456");
    nPanLen = 16;
    memset(bCryptPin, 0x00, 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 24);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 6, "无效密文[0x00]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98B_Test_15(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];
    char szPan[24];
    int  nPanLen;

    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(bCryptPin);
    bufclr(szPlainPinExp);
    bufclr(szPan);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPan, "1234567890123456");
    nPanLen = 16;
    memset(bCryptPin, 0xFF, 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 24);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 6, "无效密文[0xFF]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98B_Test_16(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];
    char szPan[24];
    int  nPanLen;

    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(bCryptPin);
    bufclr(szPlainPinExp);
    bufclr(szPan);

    nSock = -1;
    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPan, "1234567890123456");
    nPanLen = 16;
    memcpy(bCryptPin, "\x6C\x88\xF0\xE4\xCD\x99\xB8\xA4", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 24);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void DecryptPinX98B_Test_17(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];
    char szPan[24];
    int  nPanLen;

    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(bCryptPin);
    bufclr(szPlainPinExp);
    bufclr(szPan);

    nSock = 8;
    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPan, "1234567890123456");
    nPanLen = 16;
    memcpy(bCryptPin, "\x6C\x88\xF0\xE4\xCD\x99\xB8\xA4", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 24);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[8]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void DecryptPinX98B_Test_18(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];
    char szPan[24];
    int  nPanLen;

    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(bCryptPin);
    bufclr(szPlainPinExp);
    bufclr(szPan);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPan, "1234567890123");
    nPanLen = 13;
    memcpy(bCryptPin, "\x2A\x08\x4C\x60\x49\x73\xD4\xAE", 8);
    sprintf(szPlainPinExp, "123456");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "13位PAN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szPlainPin = %s\n", szPlainPin);
    printf("[OUT]expect     = %s\n", szPlainPinExp);
    ASSERT_OUT_HEX(szPlainPin, szPlainPinExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98B_Test_19(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];
    char szPan[24];
    int  nPanLen;

    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(bCryptPin);
    bufclr(szPlainPinExp);
    bufclr(szPan);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPan, "12345678901234");
    nPanLen = 14;
    memcpy(bCryptPin, "\xB9\x1D\x02\x0C\x87\x1D\xFF\xC1", 8);
    sprintf(szPlainPinExp, "123456");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "14位PAN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szPlainPin = %s\n", szPlainPin);
    printf("[OUT]expect     = %s\n", szPlainPinExp);
    ASSERT_OUT_HEX(szPlainPin, szPlainPinExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98B_Test_20(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];
    char szPan[24];
    int  nPanLen;

    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(bCryptPin);
    bufclr(szPlainPinExp);
    bufclr(szPan);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPan, "123456789012345");
    nPanLen = 15;
    memcpy(bCryptPin, "\x22\xC2\x22\x68\x52\x3C\x48\xA4", 8);
    sprintf(szPlainPinExp, "123456");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "15位PAN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szPlainPin = %s\n", szPlainPin);
    printf("[OUT]expect     = %s\n", szPlainPinExp);
    ASSERT_OUT_HEX(szPlainPin, szPlainPinExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98B_Test_21(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];
    char szPan[24];
    int  nPanLen;

    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(bCryptPin);
    bufclr(szPlainPinExp);
    bufclr(szPan);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPan, "12345678901234567");
    nPanLen = 17;
    memcpy(bCryptPin, "\x84\x61\x5C\x0F\xB7\x61\x52\x8E", 8);
    sprintf(szPlainPinExp, "123456");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "17位PAN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szPlainPin = %s\n", szPlainPin);
    printf("[OUT]expect     = %s\n", szPlainPinExp);
    ASSERT_OUT_HEX(szPlainPin, szPlainPinExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98B_Test_22(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];
    char szPan[24];
    int  nPanLen;

    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(bCryptPin);
    bufclr(szPlainPinExp);
    bufclr(szPan);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPan, "123456789012345678");
    nPanLen = 18;
    memcpy(bCryptPin, "\xDE\xCD\x0A\xF6\x38\xE0\x47\x4B", 8);
    sprintf(szPlainPinExp, "123456");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "18位PAN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szPlainPin = %s\n", szPlainPin);
    printf("[OUT]expect     = %s\n", szPlainPinExp);
    ASSERT_OUT_HEX(szPlainPin, szPlainPinExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98B_Test_23(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];
    char szPan[24];
    int  nPanLen;

    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(bCryptPin);
    bufclr(szPlainPinExp);
    bufclr(szPan);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPan, "1234567890123456789");
    nPanLen = 19;
    memcpy(bCryptPin, "\xE1\xF8\x26\x1A\x56\xD0\xBB\x1D", 8);
    sprintf(szPlainPinExp, "123456789012");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "12位PIN19位PAN测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szPlainPin = %s\n", szPlainPin);
    printf("[OUT]expect     = %s\n", szPlainPinExp);
    ASSERT_OUT_HEX(szPlainPin, szPlainPinExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98B_Test_24(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];
    char szPan[24];
    int  nPanLen;

    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(bCryptPin);
    bufclr(szPlainPinExp);
    bufclr(szPan);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPan, "123456789012");
    nPanLen = 12;
    memcpy(bCryptPin, "\xD9\xE6\x0B\xED\xBE\xDA\xB0\x15", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "12位PAN测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98B_Test_25(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];
    char szPan[24];
    int  nPanLen;

    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(bCryptPin);
    bufclr(szPlainPinExp);
    bufclr(szPan);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPan, "12345678901234567890");
    nPanLen = 20;
    memcpy(bCryptPin, "\xFA\xFC\x32\x01\xAC\xFF\x4A\x24", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "20位PAN测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98B_Test_26(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];
    char szPan[24];
    int  nPanLen;

    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(bCryptPin);
    bufclr(szPlainPinExp);
    bufclr(szPan);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPan, "1234567az!123456");
    nPanLen = 16;
    memcpy(bCryptPin, "\x79\x5F\x97\x78\x55\xC1\xF5\x92", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效账号-账号中含有非数字字符测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    printf("[OUT]szPlainPin = %s\n", szPlainPin);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98B_Test_27(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];
    char szPan[24];
    int  nPanLen;

    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(bCryptPin);
    bufclr(szPlainPinExp);
    bufclr(szPan);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPan, "abc4567890123456");
    nPanLen = 16;
    memcpy(bCryptPin, "\x79\x3A\xE1\xFC\xD3\x06\x49\x68", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效账号-账号中含有非数字字符测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    printf("[OUT]szPlainPin = %s\n", szPlainPin);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98B_Test_28(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];
    char szPan[24];
    int  nPanLen;

    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(bCryptPin);
    bufclr(szPlainPinExp);
    bufclr(szPan);

    nAlgo = 2;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPan, "1234567890123ABC");
    nPanLen = 16;
    memcpy(bCryptPin, "\x9C\x4A\xB5\x2F\xD0\x01\xF5\xD2", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效账号-账号中含有非数字字符测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    printf("[OUT]szPlainPin = %s\n", szPlainPin);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98B_Test_29(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];
    char szPan[24];
    int  nPanLen;

    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(bCryptPin);
    bufclr(szPlainPinExp);
    bufclr(szPan);

    nAlgo = 0;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPan, "1234567890123456");
    nPanLen = 16;
    memcpy(bCryptPin, "\x79\x3A\xE1\xFC\xD3\x06\x49\x68", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效算法类型[0]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptPinX98B_Test_30(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bPinKey[32];
    char szPlainPin[16];
    BYTE bCryptPin[8];
    char szPlainPinExp[16];
    char szPan[24];
    int  nPanLen;

    bufclr(bPinKey);
    bufclr(szPlainPin);
    bufclr(bCryptPin);
    bufclr(szPlainPinExp);
    bufclr(szPan);

    nAlgo = 4;
    /* plain key = 0123456789ABCDEFFEDCBA9876543210 */
    sprintf(bPinKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                     "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A");

    sprintf(szPan, "1234567890123456");
    nPanLen = 16;
    memcpy(bCryptPin, "\x79\x3A\xE1\xFC\xD3\x06\x49\x68", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nAlgo      = %d\n", nAlgo);
    printf("[IN ]szPan      = %s\n", szPan);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]bPinKey    =", bPinKey, 16);
    DspHex("[IN ]bCryptPin  =", bCryptPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptPinX98B(nSock, nAlgo, szPan, nPanLen, bPinKey, \
                               bCryptPin, szPlainPin);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效算法类型[4]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalcMAC_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo;
    BYTE bMacKey[32];
    int  nMakLen;
    BYTE bMsgBuf[2056];
    int  nMsgLen;
    BYTE bMAC[8];
    BYTE bMACExp[8];

    bufclr(bMacKey);
    bufclr(bMsgBuf);
    bufclr(bMAC);
    bufclr(bMACExp);

    nAlgo = 1;
    nMakLen = 8;
    nMsgLen = 8;
    memset(bMsgBuf, 0x2C, 8);
    bMsgBuf[0] = 0x2B;
    bMsgBuf[7] = 0x3F;
    memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memcpy(bMACExp, "\xE6\xAB\x82\xB3\xFF\xBC\xC0\xFD", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nAlgo   = %d\n", nAlgo);
    printf("[IN ]nMakLen = %d\n", nMakLen);
    DspHex("[IN ]bMacKey =", bMacKey, 8);
    printf("[IN ]nMsgLen = %d\n", nMsgLen);
    DspHex("[IN ]bMsgBuf =", bMsgBuf, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalcMac(nSock, nAlgo, bMacKey, nMakLen, \
                        bMsgBuf, nMsgLen, bMAC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "Algo=1,MsgLen=8测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[IN ]bMAC    =", bMAC, 8);
    DspHex("[IN ]bMACExp =", bMACExp, 8);
    ASSERT_OUT_HEX(bMAC, bMACExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalcMAC_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo;
    BYTE bMacKey[32];
    int  nMakLen;
    BYTE bMsgBuf[2056];
    int  nMsgLen;
    BYTE bMAC[8];
    BYTE bMACExp[8];

    bufclr(bMacKey);
    bufclr(bMsgBuf);
    bufclr(bMAC);
    bufclr(bMACExp);

    nAlgo = 2;
    nMakLen = 8;
    nMsgLen = 8;
    memset(bMsgBuf, 0x2C, 8);
    bMsgBuf[0] = 0x2B;
    bMsgBuf[7] = 0x3F;
    memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memcpy(bMACExp, "\xE6\xAB\x82\xB3\xFF\xBC\xC0\xFD", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nAlgo   = %d\n", nAlgo);
    printf("[IN ]nMakLen = %d\n", nMakLen);
    DspHex("[IN ]bMacKey =", bMacKey, 8);
    printf("[IN ]nMsgLen = %d\n", nMsgLen);
    DspHex("[IN ]bMsgBuf =", bMsgBuf, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalcMac(nSock, nAlgo, bMacKey, nMakLen, \
                        bMsgBuf, nMsgLen, bMAC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "Algo=2,MsgLen=8测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[IN ]bMAC    =", bMAC, 8);
    DspHex("[IN ]bMACExp =", bMACExp, 8);
    ASSERT_OUT_HEX(bMAC, bMACExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalcMAC_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo;
    BYTE bMacKey[32];
    int  nMakLen;
    BYTE bMsgBuf[2056];
    int  nMsgLen;
    BYTE bMAC[8];
    BYTE bMACExp[8];

    bufclr(bMacKey);
    bufclr(bMsgBuf);
    bufclr(bMAC);
    bufclr(bMACExp);

    nAlgo = 3;
    nMakLen = 16;
    nMsgLen = 8;
    memset(bMsgBuf, 0x2C, 8);
    bMsgBuf[0] = 0x2B;
    bMsgBuf[7] = 0x3F;
    memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                    "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
                    16);
    memcpy(bMACExp, "\xD6\x6B\x65\xFE\x05\xEC\x11\xE8", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nAlgo   = %d\n", nAlgo);
    printf("[IN ]nMakLen = %d\n", nMakLen);
    DspHex("[IN ]bMacKey =", bMacKey, 16);
    printf("[IN ]nMsgLen = %d\n", nMsgLen);
    DspHex("[IN ]bMsgBuf =", bMsgBuf, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalcMac(nSock, nAlgo, bMacKey, nMakLen, \
                        bMsgBuf, nMsgLen, bMAC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "Algo=3,MsgLen=8测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[IN ]bMAC    =", bMAC, 8);
    DspHex("[IN ]bMACExp =", bMACExp, 8);
    ASSERT_OUT_HEX(bMAC, bMACExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalcMAC_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo;
    BYTE bMacKey[32];
    int  nMakLen;
    BYTE bMsgBuf[2056];
    int  nMsgLen;
    BYTE bMAC[8];
    BYTE bMACExp[8];

    bufclr(bMacKey);
    bufclr(bMsgBuf);
    bufclr(bMAC);
    bufclr(bMACExp);

    nAlgo = 1;
    nMakLen = 8;
    nMsgLen = 2048;
    memset(bMsgBuf, 0x2C, 2048);
    bMsgBuf[0] = 0x2B;
    bMsgBuf[2047] = 0x3F;
    memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memcpy(bMACExp, "\xA0\x20\x7B\x55\x7C\xFE\x2D\xFE", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nAlgo   = %d\n", nAlgo);
    printf("[IN ]nMakLen = %d\n", nMakLen);
    DspHex("[IN ]bMacKey =", bMacKey, 8);
    printf("[IN ]nMsgLen = %d\n", nMsgLen);
    DspHex("[IN ]bMsgBuf =", bMsgBuf, 2048);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalcMac(nSock, nAlgo, bMacKey, nMakLen, \
                        bMsgBuf, nMsgLen, bMAC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "Algo=1,MsgLen=2048测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[IN ]bMAC    =", bMAC, 8);
    DspHex("[IN ]bMACExp =", bMACExp, 8);
    ASSERT_OUT_HEX(bMAC, bMACExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalcMAC_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo;
    BYTE bMacKey[32];
    int  nMakLen;
    BYTE bMsgBuf[2056];
    int  nMsgLen;
    BYTE bMAC[8];
    BYTE bMACExp[8];

    bufclr(bMacKey);
    bufclr(bMsgBuf);
    bufclr(bMAC);
    bufclr(bMACExp);

    nAlgo = 2;
    nMakLen = 8;
    nMsgLen = 2048;
    memset(bMsgBuf, 0x2C, 2048);
    bMsgBuf[0] = 0x2B;
    bMsgBuf[2047] = 0x3F;
    memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memcpy(bMACExp, "\x5E\x8C\xFC\x5E\x43\x5F\x5E\x65", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nAlgo   = %d\n", nAlgo);
    printf("[IN ]nMakLen = %d\n", nMakLen);
    DspHex("[IN ]bMacKey =", bMacKey, 8);
    printf("[IN ]nMsgLen = %d\n", nMsgLen);
    DspHex("[IN ]bMsgBuf =", bMsgBuf, 2048);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalcMac(nSock, nAlgo, bMacKey, nMakLen, \
                        bMsgBuf, nMsgLen, bMAC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "Algo=2,MsgLen=2048测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[IN ]bMAC    =", bMAC, 8);
    DspHex("[IN ]bMACExp =", bMACExp, 8);
    ASSERT_OUT_HEX(bMAC, bMACExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalcMAC_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo;
    BYTE bMacKey[32];
    int  nMakLen;
    BYTE bMsgBuf[2056];
    int  nMsgLen;
    BYTE bMAC[8];
    BYTE bMACExp[8];

    bufclr(bMacKey);
    bufclr(bMsgBuf);
    bufclr(bMAC);
    bufclr(bMACExp);

    nAlgo = 3;
    nMakLen = 16;
    nMsgLen = 2048;
    memset(bMsgBuf, 0x2C, 2048);
    bMsgBuf[0] = 0x2B;
    bMsgBuf[2047] = 0x3F;
    memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                    "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
                    16);
    memcpy(bMACExp, "\x13\xE4\xEF\x64\x67\xD6\xE3\xE3", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nAlgo   = %d\n", nAlgo);
    printf("[IN ]nMakLen = %d\n", nMakLen);
    DspHex("[IN ]bMacKey =", bMacKey, 16);
    printf("[IN ]nMsgLen = %d\n", nMsgLen);
    DspHex("[IN ]bMsgBuf =", bMsgBuf, 2048);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalcMac(nSock, nAlgo, bMacKey, nMakLen, \
                        bMsgBuf, nMsgLen, bMAC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "Algo=3,MsgLen=2048测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[IN ]bMAC    =", bMAC, 8);
    DspHex("[IN ]bMACExp =", bMACExp, 8);
    ASSERT_OUT_HEX(bMAC, bMACExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalcMAC_Test_07(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo;
    BYTE bMacKey[32];
    int  nMakLen;
    BYTE bMsgBuf[2056];
    int  nMsgLen;
    BYTE bMAC[8];
    BYTE bMACExp[8];

    bufclr(bMacKey);
    bufclr(bMsgBuf);
    bufclr(bMAC);
    bufclr(bMACExp);

    nSock = -1;
    nAlgo = 1;
    nMakLen = 8;
    nMsgLen = 8;
    memset(bMsgBuf, 0x2C, 8);
    bMsgBuf[0] = 0x2B;
    bMsgBuf[7] = 0x3F;
    memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nAlgo   = %d\n", nAlgo);
    printf("[IN ]nMakLen = %d\n", nMakLen);
    DspHex("[IN ]bMacKey =", bMacKey, 8);
    printf("[IN ]nMsgLen = %d\n", nMsgLen);
    DspHex("[IN ]bMsgBuf =", bMsgBuf, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalcMac(nSock, nAlgo, bMacKey, nMakLen, \
                        bMsgBuf, nMsgLen, bMAC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void CalcMAC_Test_08(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo;
    BYTE bMacKey[32];
    int  nMakLen;
    BYTE bMsgBuf[2056];
    int  nMsgLen;
    BYTE bMAC[8];
    BYTE bMACExp[8];

    bufclr(bMacKey);
    bufclr(bMsgBuf);
    bufclr(bMAC);
    bufclr(bMACExp);

    nSock = 8;
    nAlgo = 1;
    nMakLen = 8;
    nMsgLen = 8;
    memset(bMsgBuf, 0x2C, 8);
    bMsgBuf[0] = 0x2B;
    bMsgBuf[7] = 0x3F;
    memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nAlgo   = %d\n", nAlgo);
    printf("[IN ]nMakLen = %d\n", nMakLen);
    DspHex("[IN ]bMacKey =", bMacKey, 8);
    printf("[IN ]nMsgLen = %d\n", nMsgLen);
    DspHex("[IN ]bMsgBuf =", bMsgBuf, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalcMac(nSock, nAlgo, bMacKey, nMakLen, \
                        bMsgBuf, nMsgLen, bMAC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[8]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void CalcMAC_Test_09(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo;
    BYTE bMacKey[32];
    int  nMakLen;
    BYTE bMsgBuf[2056];
    int  nMsgLen;
    BYTE bMAC[8];
    BYTE bMACExp[8];

    bufclr(bMacKey);
    bufclr(bMsgBuf);
    bufclr(bMAC);
    bufclr(bMACExp);

    nAlgo = 0;
    nMakLen = 8;
    nMsgLen = 8;
    memset(bMsgBuf, 0x2C, 8);
    bMsgBuf[0] = 0x2B;
    bMsgBuf[7] = 0x3F;
    memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nAlgo   = %d\n", nAlgo);
    printf("[IN ]nMakLen = %d\n", nMakLen);
    DspHex("[IN ]bMacKey =", bMacKey, 8);
    printf("[IN ]nMsgLen = %d\n", nMsgLen);
    DspHex("[IN ]bMsgBuf =", bMsgBuf, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalcMac(nSock, nAlgo, bMacKey, nMakLen, \
                        bMsgBuf, nMsgLen, bMAC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效算法类型[0]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalcMAC_Test_10(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo;
    BYTE bMacKey[32];
    int  nMakLen;
    BYTE bMsgBuf[2056];
    int  nMsgLen;
    BYTE bMAC[8];
    BYTE bMACExp[8];

    bufclr(bMacKey);
    bufclr(bMsgBuf);
    bufclr(bMAC);
    bufclr(bMACExp);

    nAlgo = 4;
    nMakLen = 8;
    nMsgLen = 8;
    memset(bMsgBuf, 0x2C, 8);
    bMsgBuf[0] = 0x2B;
    bMsgBuf[7] = 0x3F;
    memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nAlgo   = %d\n", nAlgo);
    printf("[IN ]nMakLen = %d\n", nMakLen);
    DspHex("[IN ]bMacKey =", bMacKey, 8);
    printf("[IN ]nMsgLen = %d\n", nMsgLen);
    DspHex("[IN ]bMsgBuf =", bMsgBuf, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalcMac(nSock, nAlgo, bMacKey, nMakLen, \
                        bMsgBuf, nMsgLen, bMAC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效算法类型[4]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalcMAC_Test_11(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo;
    BYTE bMacKey[32];
    int  nMakLen;
    BYTE bMsgBuf[2056];
    int  nMsgLen;
    BYTE bMAC[8];
    BYTE bMACExp[8];

    bufclr(bMacKey);
    bufclr(bMsgBuf);
    bufclr(bMAC);
    bufclr(bMACExp);

    nAlgo = 1;
    nMakLen = 0;
    nMsgLen = 8;
    memset(bMsgBuf, 0x2C, 8);
    bMsgBuf[0] = 0x2B;
    bMsgBuf[7] = 0x3F;

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nAlgo   = %d\n", nAlgo);
    printf("[IN ]nMakLen = %d\n", nMakLen);
    DspHex("[IN ]bMacKey =", bMacKey, 16);
    printf("[IN ]nMsgLen = %d\n", nMsgLen);
    DspHex("[IN ]bMsgBuf =", bMsgBuf, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalcMac(nSock, nAlgo, bMacKey, nMakLen, \
                        bMsgBuf, nMsgLen, bMAC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效密钥长度[0]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalcMAC_Test_12(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo;
    BYTE bMacKey[32];
    int  nMakLen;
    BYTE bMsgBuf[2056];
    int  nMsgLen;
    BYTE bMAC[8];
    BYTE bMACExp[8];

    bufclr(bMacKey);
    bufclr(bMsgBuf);
    bufclr(bMAC);
    bufclr(bMACExp);

    nAlgo = 3;
    nMakLen = 24;
    nMsgLen = 8;
    memset(bMsgBuf, 0x2C, 8);
    bMsgBuf[0] = 0x2B;
    bMsgBuf[7] = 0x3F;
    memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                    "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                    "\x59\x99\xC3\x06\xAB\x84\x01\xB2",\
                    24);

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nAlgo   = %d\n", nAlgo);
    printf("[IN ]nMakLen = %d\n", nMakLen);
    DspHex("[IN ]bMacKey =", bMacKey, 24);
    printf("[IN ]nMsgLen = %d\n", nMsgLen);
    DspHex("[IN ]bMsgBuf =", bMsgBuf, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalcMac(nSock, nAlgo, bMacKey, nMakLen, \
                        bMsgBuf, nMsgLen, bMAC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效密钥长度[24]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalcMAC_Test_13(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo;
    BYTE bMacKey[32];
    int  nMakLen;
    BYTE bMsgBuf[2056];
    int  nMsgLen;
    BYTE bMAC[8];
    BYTE bMACExp[8];

    bufclr(bMacKey);
    bufclr(bMsgBuf);
    bufclr(bMAC);
    bufclr(bMACExp);

    nAlgo = 1;
    nMakLen = 8;
    nMsgLen = 8;
    memcpy(bMsgBuf, "\x2B\x2C\x2C\x2C\x00\x2C\x2C\x3F", 8);
    memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memcpy(bMACExp, "\x75\x41\x15\x3D\x92\x52\x07\xA1", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nAlgo   = %d\n", nAlgo);
    printf("[IN ]nMakLen = %d\n", nMakLen);
    DspHex("[IN ]bMacKey =", bMacKey, 8);
    printf("[IN ]nMsgLen = %d\n", nMsgLen);
    DspHex("[IN ]bMsgBuf =", bMsgBuf, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalcMac(nSock, nAlgo, bMacKey, nMakLen, \
                        bMsgBuf, nMsgLen, bMAC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "消息是由两条字符串拼接而成，中间含'\\0'测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[IN ]bMAC    =", bMAC, 8);
    DspHex("[IN ]bMACExp =", bMACExp, 8);
    ASSERT_OUT_HEX(bMAC, bMACExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalcMAC_Test_14(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo;
    BYTE bMacKey[32];
    int  nMakLen;
    BYTE bMsgBuf[2056];
    int  nMsgLen;
    BYTE bMAC[8];
    BYTE bMACExp[8];

    bufclr(bMacKey);
    bufclr(bMsgBuf);
    bufclr(bMAC);
    bufclr(bMACExp);

    nAlgo = 1;
    nMakLen = 8;
    nMsgLen = 15;
    memset(bMsgBuf, 0x2C, 15);
    bMsgBuf[0] = 0x2B;
    bMsgBuf[14] = 0x3F;
    memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memcpy(bMACExp, "\x7C\x1A\xFC\x12\xEB\x34\xE8\xBF", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nAlgo   = %d\n", nAlgo);
    printf("[IN ]nMakLen = %d\n", nMakLen);
    DspHex("[IN ]bMacKey =", bMacKey, 8);
    printf("[IN ]nMsgLen = %d\n", nMsgLen);
    DspHex("[IN ]bMsgBuf =", bMsgBuf, 16);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalcMac(nSock, nAlgo, bMacKey, nMakLen, \
                        bMsgBuf, nMsgLen, bMAC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "消息长度不是8的倍数测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[IN ]bMAC    =", bMAC, 8);
    DspHex("[IN ]bMACExp =", bMACExp, 8);
    ASSERT_OUT_HEX(bMAC, bMACExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalcMAC_Test_15(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo;
    BYTE bMacKey[32];
    int  nMakLen;
    BYTE bMsgBuf[2056];
    int  nMsgLen;
    BYTE bMAC[8];
    BYTE bMACExp[8];

    bufclr(bMacKey);
    bufclr(bMsgBuf);
    bufclr(bMAC);
    bufclr(bMACExp);

    nAlgo = 1;
    nMakLen = 8;
    nMsgLen = 9;
    memset(bMsgBuf, 0x2C, 9);
    bMsgBuf[0] = 0x2B;
    bMsgBuf[8] = 0x3F;
    memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memcpy(bMACExp, "\xD3\x18\x88\x24\x72\xC1\xB9\x1E", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nAlgo   = %d\n", nAlgo);
    printf("[IN ]nMakLen = %d\n", nMakLen);
    DspHex("[IN ]bMacKey =", bMacKey, 8);
    printf("[IN ]nMsgLen = %d\n", nMsgLen);
    DspHex("[IN ]bMsgBuf =", bMsgBuf, 16);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalcMac(nSock, nAlgo, bMacKey, nMakLen, \
                        bMsgBuf, nMsgLen, bMAC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "消息长度不是8的倍数测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[IN ]bMAC    =", bMAC, 8);
    DspHex("[IN ]bMACExp =", bMACExp, 8);
    ASSERT_OUT_HEX(bMAC, bMACExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalcMAC_Test_16(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo;
    BYTE bMacKey[32];
    int  nMakLen;
    BYTE bMsgBuf[2056];
    int  nMsgLen;
    BYTE bMAC[8];
    BYTE bMACExp[8];

    bufclr(bMacKey);
    bufclr(bMsgBuf);
    bufclr(bMAC);
    bufclr(bMACExp);

    nAlgo = 1;
    nMakLen = 8;
    nMsgLen = 8;
    memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memcpy(bMACExp, "\xD5\xD4\x4F\xF7\x20\x68\x3D\x0D", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nAlgo   = %d\n", nAlgo);
    printf("[IN ]nMakLen = %d\n", nMakLen);
    DspHex("[IN ]bMacKey =", bMacKey, 8);
    printf("[IN ]nMsgLen = %d\n", nMsgLen);
    DspHex("[IN ]bMsgBuf =", bMsgBuf, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalcMac(nSock, nAlgo, bMacKey, nMakLen, \
                        bMsgBuf, nMsgLen, bMAC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "algo=1空消息测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[IN ]bMAC    =", bMAC, 8);
    DspHex("[IN ]bMACExp =", bMACExp, 8);
    ASSERT_OUT_HEX(bMAC, bMACExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalcMAC_Test_17(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo;
    BYTE bMacKey[32];
    int  nMakLen;
    BYTE bMsgBuf[2056];
    int  nMsgLen;
    BYTE bMAC[8];
    BYTE bMACExp[8];

    bufclr(bMacKey);
    bufclr(bMsgBuf);
    bufclr(bMAC);
    bufclr(bMACExp);

    nAlgo = 1;
    nMakLen = 8;
    nMsgLen = 0;
    memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nAlgo   = %d\n", nAlgo);
    printf("[IN ]nMakLen = %d\n", nMakLen);
    DspHex("[IN ]bMacKey =", bMacKey, 8);
    printf("[IN ]nMsgLen = %d\n", nMsgLen);
    DspHex("[IN ]bMsgBuf =", bMsgBuf, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalcMac(nSock, nAlgo, bMacKey, nMakLen, \
                        bMsgBuf, nMsgLen, bMAC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效消息长度[0]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalcMAC_Test_18(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo;
    BYTE bMacKey[32];
    int  nMakLen;
    BYTE bMsgBuf[2056];
    int  nMsgLen;
    BYTE bMAC[8];
    BYTE bMACExp[8];

    bufclr(bMacKey);
    bufclr(bMsgBuf);
    bufclr(bMAC);
    bufclr(bMACExp);

    nAlgo = 1;
    nMakLen = 8;
    nMsgLen = 2056;
    memset(bMsgBuf, 0x2C, 2056);
    bMsgBuf[0] = 0x2B;
    bMsgBuf[2055] = 0x3F;
    memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nAlgo   = %d\n", nAlgo);
    printf("[IN ]nMakLen = %d\n", nMakLen);
    DspHex("[IN ]bMacKey =", bMacKey, 8);
    printf("[IN ]nMsgLen = %d\n", nMsgLen);
    DspHex("[IN ]bMsgBuf =", bMsgBuf, 2056);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalcMac(nSock, nAlgo, bMacKey, nMakLen, \
                        bMsgBuf, nMsgLen, bMAC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效消息长度[2056]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalcMAC_Test_19(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo;
    BYTE bMacKey[32];
    int  nMakLen;
    BYTE bMsgBuf[2056];
    int  nMsgLen;
    BYTE bMAC[8];
    BYTE bMACExp[8];

    bufclr(bMacKey);
    bufclr(bMsgBuf);
    bufclr(bMAC);
    bufclr(bMACExp);

    nAlgo = 1;
    nMakLen = 8;
    nMsgLen = 7;
    memset(bMsgBuf, 0x2C, 7);
    bMsgBuf[0] = 0x2B;
    bMsgBuf[6] = 0x3F;
    memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nAlgo   = %d\n", nAlgo);
    printf("[IN ]nMakLen = %d\n", nMakLen);
    DspHex("[IN ]bMacKey =", bMacKey, 8);
    printf("[IN ]nMsgLen = %d\n", nMsgLen);
    DspHex("[IN ]bMsgBuf =", bMsgBuf, 7);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalcMac(nSock, nAlgo, bMacKey, nMakLen, \
                        bMsgBuf, nMsgLen, bMAC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效消息长度[7]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalcMAC_Test_20(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo;
    BYTE bMacKey[32];
    int  nMakLen;
    BYTE bMsgBuf[2056];
    int  nMsgLen;
    BYTE bMAC[8];
    BYTE bMACExp[8];

    bufclr(bMacKey);
    bufclr(bMsgBuf);
    bufclr(bMAC);
    bufclr(bMACExp);

    nAlgo = 1;
    nMakLen = 8;
    nMsgLen = 2049;
    memset(bMsgBuf, 0x2C, 2049);
    bMsgBuf[0] = 0x2B;
    bMsgBuf[2048] = 0x3F;
    memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nAlgo   = %d\n", nAlgo);
    printf("[IN ]nMakLen = %d\n", nMakLen);
    DspHex("[IN ]bMacKey =", bMacKey, 8);
    printf("[IN ]nMsgLen = %d\n", nMsgLen);
    DspHex("[IN ]bMsgBuf =", bMsgBuf, 2049);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalcMac(nSock, nAlgo, bMacKey, nMakLen, \
                        bMsgBuf, nMsgLen, bMAC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效消息长度[2049]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalcMAC_Test_21(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo;
    BYTE bMacKey[32];
    int  nMakLen;
    BYTE bMsgBuf[2056];
    int  nMsgLen;
    BYTE bMAC[8];
    BYTE bMACExp[8];

    bufclr(bMacKey);
    bufclr(bMsgBuf);
    bufclr(bMAC);
    bufclr(bMACExp);

    nAlgo = 2;
    nMakLen = 8;
    nMsgLen = 8;
    memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memcpy(bMACExp, "\xD5\xD4\x4F\xF7\x20\x68\x3D\x0D", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nAlgo   = %d\n", nAlgo);
    printf("[IN ]nMakLen = %d\n", nMakLen);
    DspHex("[IN ]bMacKey =", bMacKey, 8);
    printf("[IN ]nMsgLen = %d\n", nMsgLen);
    DspHex("[IN ]bMsgBuf =", bMsgBuf, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalcMac(nSock, nAlgo, bMacKey, nMakLen, \
                        bMsgBuf, nMsgLen, bMAC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "algo=2空消息测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[IN ]bMAC    =", bMAC, 8);
    DspHex("[IN ]bMACExp =", bMACExp, 8);
    ASSERT_OUT_HEX(bMAC, bMACExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalcMAC_Test_22(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo;
    BYTE bMacKey[32];
    int  nMakLen;
    BYTE bMsgBuf[2056];
    int  nMsgLen;
    BYTE bMAC[8];
    BYTE bMACExp[8];

    bufclr(bMacKey);
    bufclr(bMsgBuf);
    bufclr(bMAC);
    bufclr(bMACExp);

    nAlgo = 3;
    nMakLen = 16;
    nMsgLen = 8;
    memcpy(bMacKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                    "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
                    16);
    memcpy(bMACExp, "\x08\xD7\xB4\xFB\x62\x9D\x08\x85", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nAlgo   = %d\n", nAlgo);
    printf("[IN ]nMakLen = %d\n", nMakLen);
    DspHex("[IN ]bMacKey =", bMacKey, 16);
    printf("[IN ]nMsgLen = %d\n", nMsgLen);
    DspHex("[IN ]bMsgBuf =", bMsgBuf, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalcMac(nSock, nAlgo, bMacKey, nMakLen, \
                        bMsgBuf, nMsgLen, bMAC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "algo=3空消息测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[IN ]bMAC    =", bMAC, 8);
    DspHex("[IN ]bMACExp =", bMACExp, 8);
    ASSERT_OUT_HEX(bMAC, bMACExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateBlock_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo1;
    BYTE bKey1[32];
    int  nAlgo2;
    BYTE bKey2[32];
    BYTE bSrcBlock[16];
    BYTE bDestBlock[16];
    BYTE bDestBlockExp[16];

    nAlgo1 = 1;
    bufclr(bKey1);
    nAlgo2 = 1;
    bufclr(bKey2);
    bufclr(bSrcBlock);
    bufclr(bDestBlock);
    bufclr(bDestBlockExp);

    /* 1010 1010 1010 1010 */
    memcpy(bKey1, "\x67\xE3\x7D\xDE\xF4\x91\xEB\x77", 8);
    /* 2323 2323 2323 2323 */
    memcpy(bKey2, "\x78\xF8\xEF\x49\xFE\x38\x40\x09", 8);

    /* 0123 4567 89AB CDEF */
    memcpy(bSrcBlock, "\x8A\x5A\xE1\xF8\x1A\xB8\xF2\xDD", 8);
    memcpy(bDestBlockExp, "\x11\x54\x02\x98\x4D\xD7\xE5\x3E", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nAlgo1    = %d\n", nAlgo1);
    DspHex("[IN ]bKey1     =", bKey1, 8);
    printf("[IN ]nAlgo2    = %d\n", nAlgo2);
    DspHex("[IN ]bKey2     =", bKey2, 8);
    DspHex("[IN ]bSrcBlock =", bSrcBlock, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateBlock(nSock, nAlgo1, bKey1, nAlgo2, bKey2, \
                               bSrcBlock, bDestBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "Algo1=1，Algo2=1测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bDestBlock    =", bDestBlock, 8);
    DspHex("[OUT]bDestBlockExp =", bDestBlockExp, 8);
    ASSERT_OUT_HEX(bDestBlock, bDestBlockExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateBlock_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo1;
    BYTE bKey1[32];
    int  nAlgo2;
    BYTE bKey2[32];
    BYTE bSrcBlock[16];
    BYTE bDestBlock[16];
    BYTE bDestBlockExp[16];

    nAlgo1 = 2;
    bufclr(bKey1);
    nAlgo2 = 2;
    bufclr(bKey2);
    bufclr(bSrcBlock);
    bufclr(bDestBlock);
    bufclr(bDestBlockExp);

    /* 1010 1010 1010 1010 3232 3232 3232 3232 */
    memcpy(bKey1, "\x67\xE3\x7D\xDE\xF4\x91\xEB\x77" \
                  "\xAC\x73\x7F\x70\xC0\xF4\xAE\x84",\
                  16);
    /* 2323 2323 2323 2323 4545 4545 4545 4545 */
    memcpy(bKey2, "\x78\xF8\xEF\x49\xFE\x38\x40\x09" \
                  "\x1C\xCC\x05\x13\x84\x64\xCB\x1C",\
                  16);

    /* 0123 4567 89AB CDEF */
    memcpy(bSrcBlock, "\xAF\xD5\xBF\x31\x9C\x4C\xA6\xA7", 8);
    memcpy(bDestBlockExp, "\x82\x23\x0B\x0D\x51\x92\x3F\x86", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nAlgo1    = %d\n", nAlgo1);
    DspHex("[IN ]bKey1     =", bKey1, 16);
    printf("[IN ]nAlgo2    = %d\n", nAlgo2);
    DspHex("[IN ]bKey2     =", bKey2, 16);
    DspHex("[IN ]bSrcBlock =", bSrcBlock, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateBlock(nSock, nAlgo1, bKey1, nAlgo2, bKey2, \
                               bSrcBlock, bDestBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "Algo1=2，Algo2=2测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bDestBlock    =", bDestBlock, 8);
    DspHex("[OUT]bDestBlockExp =", bDestBlockExp, 8);
    ASSERT_OUT_HEX(bDestBlock, bDestBlockExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateBlock_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo1;
    BYTE bKey1[32];
    int  nAlgo2;
    BYTE bKey2[32];
    BYTE bSrcBlock[16];
    BYTE bDestBlock[16];
    BYTE bDestBlockExp[16];

    nAlgo1 = 3;
    bufclr(bKey1);
    nAlgo2 = 3;
    bufclr(bKey2);
    bufclr(bSrcBlock);
    bufclr(bDestBlock);
    bufclr(bDestBlockExp);

    /* 1010 1010 1010 1010 3232 3232 3232 3232 5454 5454 5454 5454 */
    memcpy(bKey1, "\x67\xE3\x7D\xDE\xF4\x91\xEB\x77" \
                  "\xAC\x73\x7F\x70\xC0\xF4\xAE\x84" \
                  "\xF7\xE5\x65\x88\x38\x2A\x4B\x2D",\
                  24);
    /* 2323 2323 2323 2323 4545 4545 4545 4545 6767 6767 6767 6767 */
    memcpy(bKey2, "\x78\xF8\xEF\x49\xFE\x38\x40\x09" \
                  "\x1C\xCC\x05\x13\x84\x64\xCB\x1C" \
                  "\x68\x2D\xB4\x54\xFC\x7B\xB4\x5D",\
                  24);

    /* 0123 4567 89AB CDEF */
    memcpy(bSrcBlock, "\xD5\x80\x24\x76\x2B\x18\x45\x06", 8);
    memcpy(bDestBlockExp, "\x76\xC7\xB8\xD0\xD6\x90\x7E\x7D", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nAlgo1    = %d\n", nAlgo1);
    DspHex("[IN ]bKey1     =", bKey1, 24);
    printf("[IN ]nAlgo2    = %d\n", nAlgo2);
    DspHex("[IN ]bKey2     =", bKey2, 24);
    DspHex("[IN ]bSrcBlock =", bSrcBlock, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateBlock(nSock, nAlgo1, bKey1, nAlgo2, bKey2, \
                               bSrcBlock, bDestBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "Algo1=3，Algo2=3测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bDestBlock    =", bDestBlock, 8);
    DspHex("[OUT]bDestBlockExp =", bDestBlockExp, 8);
    ASSERT_OUT_HEX(bDestBlock, bDestBlockExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateBlock_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo1;
    BYTE bKey1[32];
    int  nAlgo2;
    BYTE bKey2[32];
    BYTE bSrcBlock[16];
    BYTE bDestBlock[16];
    BYTE bDestBlockExp[16];

    nAlgo1 = 1;
    bufclr(bKey1);
    nAlgo2 = 2;
    bufclr(bKey2);
    bufclr(bSrcBlock);
    bufclr(bDestBlock);
    bufclr(bDestBlockExp);

    /* 1010 1010 1010 1010 */
    memcpy(bKey1, "\x67\xE3\x7D\xDE\xF4\x91\xEB\x77", 8);
    /* 2323 2323 2323 2323 4545 4545 4545 4545 */
    memcpy(bKey2, "\x78\xF8\xEF\x49\xFE\x38\x40\x09" \
                  "\x1C\xCC\x05\x13\x84\x64\xCB\x1C",\
                  16);

    /* 0123 4567 89AB CDEF */
    memcpy(bSrcBlock, "\x8A\x5A\xE1\xF8\x1A\xB8\xF2\xDD", 8);
    memcpy(bDestBlockExp, "\x82\x23\x0B\x0D\x51\x92\x3F\x86", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nAlgo1    = %d\n", nAlgo1);
    DspHex("[IN ]bKey1     =", bKey1, 8);
    printf("[IN ]nAlgo2    = %d\n", nAlgo2);
    DspHex("[IN ]bKey2     =", bKey2, 16);
    DspHex("[IN ]bSrcBlock =", bSrcBlock, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateBlock(nSock, nAlgo1, bKey1, nAlgo2, bKey2, \
                               bSrcBlock, bDestBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "Algo1=1，Algo2=2测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bDestBlock    =", bDestBlock, 8);
    DspHex("[OUT]bDestBlockExp =", bDestBlockExp, 8);
    ASSERT_OUT_HEX(bDestBlock, bDestBlockExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateBlock_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo1;
    BYTE bKey1[32];
    int  nAlgo2;
    BYTE bKey2[32];
    BYTE bSrcBlock[16];
    BYTE bDestBlock[16];
    BYTE bDestBlockExp[16];

    nAlgo1 = 1;
    bufclr(bKey1);
    nAlgo2 = 3;
    bufclr(bKey2);
    bufclr(bSrcBlock);
    bufclr(bDestBlock);
    bufclr(bDestBlockExp);

    /* 1010 1010 1010 1010 */
    memcpy(bKey1, "\x67\xE3\x7D\xDE\xF4\x91\xEB\x77", 8);
    /* 2323 2323 2323 2323 4545 4545 4545 4545 6767 6767 6767 6767 */
    memcpy(bKey2, "\x78\xF8\xEF\x49\xFE\x38\x40\x09" \
                  "\x1C\xCC\x05\x13\x84\x64\xCB\x1C" \
                  "\x68\x2D\xB4\x54\xFC\x7B\xB4\x5D",\
                  24);

    /* 0123 4567 89AB CDEF */
    memcpy(bSrcBlock, "\x8A\x5A\xE1\xF8\x1A\xB8\xF2\xDD", 8);
    memcpy(bDestBlockExp, "\x76\xC7\xB8\xD0\xD6\x90\x7E\x7D", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nAlgo1    = %d\n", nAlgo1);
    DspHex("[IN ]bKey1     =", bKey1, 8);
    printf("[IN ]nAlgo2    = %d\n", nAlgo2);
    DspHex("[IN ]bKey2     =", bKey2, 24);
    DspHex("[IN ]bSrcBlock =", bSrcBlock, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateBlock(nSock, nAlgo1, bKey1, nAlgo2, bKey2, \
                               bSrcBlock, bDestBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "Algo1=1，Algo2=3测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bDestBlock    =", bDestBlock, 8);
    DspHex("[OUT]bDestBlockExp =", bDestBlockExp, 8);
    ASSERT_OUT_HEX(bDestBlock, bDestBlockExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateBlock_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo1;
    BYTE bKey1[32];
    int  nAlgo2;
    BYTE bKey2[32];
    BYTE bSrcBlock[16];
    BYTE bDestBlock[16];
    BYTE bDestBlockExp[16];

    nAlgo1 = 2;
    bufclr(bKey1);
    nAlgo2 = 1;
    bufclr(bKey2);
    bufclr(bSrcBlock);
    bufclr(bDestBlock);
    bufclr(bDestBlockExp);

    /* 1010 1010 1010 1010 3232 3232 3232 3232 */
    memcpy(bKey1, "\x67\xE3\x7D\xDE\xF4\x91\xEB\x77" \
                  "\xAC\x73\x7F\x70\xC0\xF4\xAE\x84",\
                  16);
    /* 2323 2323 2323 2323 */
    memcpy(bKey2, "\x78\xF8\xEF\x49\xFE\x38\x40\x09", 8);

    /* 0123 4567 89AB CDEF */
    memcpy(bSrcBlock, "\xAF\xD5\xBF\x31\x9C\x4C\xA6\xA7", 8);
    memcpy(bDestBlockExp, "\x11\x54\x02\x98\x4D\xD7\xE5\x3E", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nAlgo1    = %d\n", nAlgo1);
    DspHex("[IN ]bKey1     =", bKey1, 16);
    printf("[IN ]nAlgo2    = %d\n", nAlgo2);
    DspHex("[IN ]bKey2     =", bKey2, 8);
    DspHex("[IN ]bSrcBlock =", bSrcBlock, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateBlock(nSock, nAlgo1, bKey1, nAlgo2, bKey2, \
                               bSrcBlock, bDestBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "Algo1=2，Algo2=1测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bDestBlock    =", bDestBlock, 8);
    DspHex("[OUT]bDestBlockExp =", bDestBlockExp, 8);
    ASSERT_OUT_HEX(bDestBlock, bDestBlockExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateBlock_Test_07(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo1;
    BYTE bKey1[32];
    int  nAlgo2;
    BYTE bKey2[32];
    BYTE bSrcBlock[16];
    BYTE bDestBlock[16];
    BYTE bDestBlockExp[16];

    nAlgo1 = 2;
    bufclr(bKey1);
    nAlgo2 = 3;
    bufclr(bKey2);
    bufclr(bSrcBlock);
    bufclr(bDestBlock);
    bufclr(bDestBlockExp);

    /* 1010 1010 1010 1010 3232 3232 3232 3232 */
    memcpy(bKey1, "\x67\xE3\x7D\xDE\xF4\x91\xEB\x77" \
                  "\xAC\x73\x7F\x70\xC0\xF4\xAE\x84",\
                  16);
    /* 2323 2323 2323 2323 4545 4545 4545 4545 6767 6767 6767 6767 */
    memcpy(bKey2, "\x78\xF8\xEF\x49\xFE\x38\x40\x09" \
                  "\x1C\xCC\x05\x13\x84\x64\xCB\x1C" \
                  "\x68\x2D\xB4\x54\xFC\x7B\xB4\x5D",\
                  24);

    /* 0123 4567 89AB CDEF */
    memcpy(bSrcBlock, "\xAF\xD5\xBF\x31\x9C\x4C\xA6\xA7", 8);
    memcpy(bDestBlockExp, "\x76\xC7\xB8\xD0\xD6\x90\x7E\x7D", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nAlgo1    = %d\n", nAlgo1);
    DspHex("[IN ]bKey1     =", bKey1, 16);
    printf("[IN ]nAlgo2    = %d\n", nAlgo2);
    DspHex("[IN ]bKey2     =", bKey2, 24);
    DspHex("[IN ]bSrcBlock =", bSrcBlock, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateBlock(nSock, nAlgo1, bKey1, nAlgo2, bKey2, \
                               bSrcBlock, bDestBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "Algo1=2，Algo2=3测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bDestBlock    =", bDestBlock, 8);
    DspHex("[OUT]bDestBlockExp =", bDestBlockExp, 8);
    ASSERT_OUT_HEX(bDestBlock, bDestBlockExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateBlock_Test_08(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo1;
    BYTE bKey1[32];
    int  nAlgo2;
    BYTE bKey2[32];
    BYTE bSrcBlock[16];
    BYTE bDestBlock[16];
    BYTE bDestBlockExp[16];

    nAlgo1 = 3;
    bufclr(bKey1);
    nAlgo2 = 1;
    bufclr(bKey2);
    bufclr(bSrcBlock);
    bufclr(bDestBlock);
    bufclr(bDestBlockExp);

    /* 1010 1010 1010 1010 3232 3232 3232 3232 5454 5454 5454 5454 */
    memcpy(bKey1, "\x67\xE3\x7D\xDE\xF4\x91\xEB\x77" \
                  "\xAC\x73\x7F\x70\xC0\xF4\xAE\x84" \
                  "\xF7\xE5\x65\x88\x38\x2A\x4B\x2D",\
                  24);
    /* 2323 2323 2323 2323 */
    memcpy(bKey2, "\x78\xF8\xEF\x49\xFE\x38\x40\x09", 8);

    /* 0123 4567 89AB CDEF */
    memcpy(bSrcBlock, "\xD5\x80\x24\x76\x2B\x18\x45\x06", 8);
    memcpy(bDestBlockExp, "\x11\x54\x02\x98\x4D\xD7\xE5\x3E", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nAlgo1    = %d\n", nAlgo1);
    DspHex("[IN ]bKey1     =", bKey1, 24);
    printf("[IN ]nAlgo2    = %d\n", nAlgo2);
    DspHex("[IN ]bKey2     =", bKey2, 8);
    DspHex("[IN ]bSrcBlock =", bSrcBlock, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateBlock(nSock, nAlgo1, bKey1, nAlgo2, bKey2, \
                               bSrcBlock, bDestBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "Algo1=3，Algo2=1测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bDestBlock    =", bDestBlock, 8);
    DspHex("[OUT]bDestBlockExp =", bDestBlockExp, 8);
    ASSERT_OUT_HEX(bDestBlock, bDestBlockExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateBlock_Test_09(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo1;
    BYTE bKey1[32];
    int  nAlgo2;
    BYTE bKey2[32];
    BYTE bSrcBlock[16];
    BYTE bDestBlock[16];
    BYTE bDestBlockExp[16];

    nAlgo1 = 3;
    bufclr(bKey1);
    nAlgo2 = 2;
    bufclr(bKey2);
    bufclr(bSrcBlock);
    bufclr(bDestBlock);
    bufclr(bDestBlockExp);

    /* 1010 1010 1010 1010 3232 3232 3232 3232 5454 5454 5454 5454 */
    memcpy(bKey1, "\x67\xE3\x7D\xDE\xF4\x91\xEB\x77" \
                  "\xAC\x73\x7F\x70\xC0\xF4\xAE\x84" \
                  "\xF7\xE5\x65\x88\x38\x2A\x4B\x2D",\
                  24);
    /* 2323 2323 2323 2323 4545 4545 4545 4545 */
    memcpy(bKey2, "\x78\xF8\xEF\x49\xFE\x38\x40\x09" \
                  "\x1C\xCC\x05\x13\x84\x64\xCB\x1C",\
                  16);

    /* 0123 4567 89AB CDEF */
    memcpy(bSrcBlock, "\xD5\x80\x24\x76\x2B\x18\x45\x06", 8);
    memcpy(bDestBlockExp, "\x82\x23\x0B\x0D\x51\x92\x3F\x86", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nAlgo1    = %d\n", nAlgo1);
    DspHex("[IN ]bKey1     =", bKey1, 24);
    printf("[IN ]nAlgo2    = %d\n", nAlgo2);
    DspHex("[IN ]bKey2     =", bKey2, 16);
    DspHex("[IN ]bSrcBlock =", bSrcBlock, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateBlock(nSock, nAlgo1, bKey1, nAlgo2, bKey2, \
                               bSrcBlock, bDestBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "Algo1=3，Algo2=2测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bDestBlock    =", bDestBlock, 8);
    DspHex("[OUT]bDestBlockExp =", bDestBlockExp, 8);
    ASSERT_OUT_HEX(bDestBlock, bDestBlockExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateBlock_Test_10(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo1;
    BYTE bKey1[32];
    int  nAlgo2;
    BYTE bKey2[32];
    BYTE bSrcBlock[16];
    BYTE bDestBlock[16];
    BYTE bDestBlockExp[16];

    nSock = -1;
    nAlgo1 = 1;
    bufclr(bKey1);
    nAlgo2 = 1;
    bufclr(bKey2);
    bufclr(bSrcBlock);
    bufclr(bDestBlock);
    bufclr(bDestBlockExp);

    /* 1010 1010 1010 1010 */
    memcpy(bKey1, "\x67\xE3\x7D\xDE\xF4\x91\xEB\x77", 8);
    /* 2323 2323 2323 2323 */
    memcpy(bKey2, "\x78\xF8\xEF\x49\xFE\x38\x40\x09", 8);

    /* 0123 4567 89AB CDEF */
    memcpy(bSrcBlock, "\x8A\x5A\xE1\xF8\x1A\xB8\xF2\xDD", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nAlgo1    = %d\n", nAlgo1);
    DspHex("[IN ]bKey1     =", bKey1, 8);
    printf("[IN ]nAlgo2    = %d\n", nAlgo2);
    DspHex("[IN ]bKey2     =", bKey2, 8);
    DspHex("[IN ]bSrcBlock =", bSrcBlock, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateBlock(nSock, nAlgo1, bKey1, nAlgo2, bKey2, \
                               bSrcBlock, bDestBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void TranslateBlock_Test_11(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo1;
    BYTE bKey1[32];
    int  nAlgo2;
    BYTE bKey2[32];
    BYTE bSrcBlock[16];
    BYTE bDestBlock[16];
    BYTE bDestBlockExp[16];

    nSock = 8;
    nAlgo1 = 1;
    bufclr(bKey1);
    nAlgo2 = 1;
    bufclr(bKey2);
    bufclr(bSrcBlock);
    bufclr(bDestBlock);
    bufclr(bDestBlockExp);

    /* 1010 1010 1010 1010 */
    memcpy(bKey1, "\x67\xE3\x7D\xDE\xF4\x91\xEB\x77", 8);
    /* 2323 2323 2323 2323 */
    memcpy(bKey2, "\x78\xF8\xEF\x49\xFE\x38\x40\x09", 8);

    /* 0123 4567 89AB CDEF */
    memcpy(bSrcBlock, "\x8A\x5A\xE1\xF8\x1A\xB8\xF2\xDD", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nAlgo1    = %d\n", nAlgo1);
    DspHex("[IN ]bKey1     =", bKey1, 8);
    printf("[IN ]nAlgo2    = %d\n", nAlgo2);
    DspHex("[IN ]bKey2     =", bKey2, 8);
    DspHex("[IN ]bSrcBlock =", bSrcBlock, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateBlock(nSock, nAlgo1, bKey1, nAlgo2, bKey2, \
                               bSrcBlock, bDestBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[8]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void TranslateBlock_Test_12(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo1;
    BYTE bKey1[32];
    int  nAlgo2;
    BYTE bKey2[32];
    BYTE bSrcBlock[16];
    BYTE bDestBlock[16];
    BYTE bDestBlockExp[16];

    nAlgo1 = 0;
    bufclr(bKey1);
    nAlgo2 = 1;
    bufclr(bKey2);
    bufclr(bSrcBlock);
    bufclr(bDestBlock);
    bufclr(bDestBlockExp);

    /* 1010 1010 1010 1010 */
    memcpy(bKey1, "\x67\xE3\x7D\xDE\xF4\x91\xEB\x77", 8);
    /* 2323 2323 2323 2323 */
    memcpy(bKey2, "\x78\xF8\xEF\x49\xFE\x38\x40\x09", 8);

    /* 0123 4567 89AB CDEF */
    memcpy(bSrcBlock, "\x8A\x5A\xE1\xF8\x1A\xB8\xF2\xDD", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nAlgo1    = %d\n", nAlgo1);
    DspHex("[IN ]bKey1     =", bKey1, 8);
    printf("[IN ]nAlgo2    = %d\n", nAlgo2);
    DspHex("[IN ]bKey2     =", bKey2, 8);
    DspHex("[IN ]bSrcBlock =", bSrcBlock, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateBlock(nSock, nAlgo1, bKey1, nAlgo2, bKey2, \
                               bSrcBlock, bDestBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效算法1[0]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateBlock_Test_13(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo1;
    BYTE bKey1[32];
    int  nAlgo2;
    BYTE bKey2[32];
    BYTE bSrcBlock[16];
    BYTE bDestBlock[16];
    BYTE bDestBlockExp[16];

    nAlgo1 = 4;
    bufclr(bKey1);
    nAlgo2 = 1;
    bufclr(bKey2);
    bufclr(bSrcBlock);
    bufclr(bDestBlock);
    bufclr(bDestBlockExp);

    /* 1010 1010 1010 1010 */
    memcpy(bKey1, "\x67\xE3\x7D\xDE\xF4\x91\xEB\x77", 8);
    /* 2323 2323 2323 2323 */
    memcpy(bKey2, "\x78\xF8\xEF\x49\xFE\x38\x40\x09", 8);

    /* 0123 4567 89AB CDEF */
    memcpy(bSrcBlock, "\x8A\x5A\xE1\xF8\x1A\xB8\xF2\xDD", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nAlgo1    = %d\n", nAlgo1);
    DspHex("[IN ]bKey1     =", bKey1, 8);
    printf("[IN ]nAlgo2    = %d\n", nAlgo2);
    DspHex("[IN ]bKey2     =", bKey2, 8);
    DspHex("[IN ]bSrcBlock =", bSrcBlock, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateBlock(nSock, nAlgo1, bKey1, nAlgo2, bKey2, \
                               bSrcBlock, bDestBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效算法1[4]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateBlock_Test_14(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo1;
    BYTE bKey1[32];
    int  nAlgo2;
    BYTE bKey2[32];
    BYTE bSrcBlock[16];
    BYTE bDestBlock[16];
    BYTE bDestBlockExp[16];

    nAlgo1 = 1;
    bufclr(bKey1);
    nAlgo2 = 0;
    bufclr(bKey2);
    bufclr(bSrcBlock);
    bufclr(bDestBlock);
    bufclr(bDestBlockExp);

    /* 1010 1010 1010 1010 */
    memcpy(bKey1, "\x67\xE3\x7D\xDE\xF4\x91\xEB\x77", 8);
    /* 2323 2323 2323 2323 */
    memcpy(bKey2, "\x78\xF8\xEF\x49\xFE\x38\x40\x09", 8);

    /* 0123 4567 89AB CDEF */
    memcpy(bSrcBlock, "\x8A\x5A\xE1\xF8\x1A\xB8\xF2\xDD", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nAlgo1    = %d\n", nAlgo1);
    DspHex("[IN ]bKey1     =", bKey1, 8);
    printf("[IN ]nAlgo2    = %d\n", nAlgo2);
    DspHex("[IN ]bKey2     =", bKey2, 8);
    DspHex("[IN ]bSrcBlock =", bSrcBlock, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateBlock(nSock, nAlgo1, bKey1, nAlgo2, bKey2, \
                               bSrcBlock, bDestBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效算法2[0]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateBlock_Test_15(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo1;
    BYTE bKey1[32];
    int  nAlgo2;
    BYTE bKey2[32];
    BYTE bSrcBlock[16];
    BYTE bDestBlock[16];
    BYTE bDestBlockExp[16];

    nAlgo1 = 1;
    bufclr(bKey1);
    nAlgo2 = 4;
    bufclr(bKey2);
    bufclr(bSrcBlock);
    bufclr(bDestBlock);
    bufclr(bDestBlockExp);

    /* 1010 1010 1010 1010 */
    memcpy(bKey1, "\x67\xE3\x7D\xDE\xF4\x91\xEB\x77", 8);
    /* 2323 2323 2323 2323 */
    memcpy(bKey2, "\x78\xF8\xEF\x49\xFE\x38\x40\x09", 8);

    /* 0123 4567 89AB CDEF */
    memcpy(bSrcBlock, "\x8A\x5A\xE1\xF8\x1A\xB8\xF2\xDD", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nAlgo1    = %d\n", nAlgo1);
    DspHex("[IN ]bKey1     =", bKey1, 8);
    printf("[IN ]nAlgo2    = %d\n", nAlgo2);
    DspHex("[IN ]bKey2     =", bKey2, 8);
    DspHex("[IN ]bSrcBlock =", bSrcBlock, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateBlock(nSock, nAlgo1, bKey1, nAlgo2, bKey2, \
                               bSrcBlock, bDestBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效算法2[4]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateBlock_Test_16(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo1;
    BYTE bKey1[32];
    int  nAlgo2;
    BYTE bKey2[32];
    BYTE bSrcBlock[16];
    BYTE bDestBlock[16];
    BYTE bDestBlockExp[16];

    nAlgo1 = 1;
    bufclr(bKey1);
    nAlgo2 = 1;
    bufclr(bKey2);
    bufclr(bSrcBlock);
    bufclr(bDestBlock);
    bufclr(bDestBlockExp);

    /* 0101 0101 0101 0101 */
    memcpy(bKey1, "\x7E\xAB\x74\x3A\x23\x64\x7B\xE6", 8);
    /* FEFE FEFE FEFE FEFE */
    memcpy(bKey2, "\x6B\xAC\x93\xCC\x3A\x9E\x9A\x13", 8);

    /* 0123 4567 89AB CDEF */
    memcpy(bSrcBlock, "\x61\x7B\x3A\x0C\xE8\xF0\x71\x00", 8);
    memcpy(bDestBlockExp, "\x6D\xCE\x0D\xC9\x00\x65\x56\xA3", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nAlgo1    = %d\n", nAlgo1);
    DspHex("[IN ]bKey1     =", bKey1, 8);
    printf("[IN ]nAlgo2    = %d\n", nAlgo2);
    DspHex("[IN ]bKey2     =", bKey2, 8);
    DspHex("[IN ]bSrcBlock =", bSrcBlock, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateBlock(nSock, nAlgo1, bKey1, nAlgo2, bKey2, \
                               bSrcBlock, bDestBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, \
        "空密钥，密钥1明文=0000 0000 0000 0000，密钥2明文=FFFF FFFF FFFF FFFF，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bDestBlock    =", bDestBlock, 8);
    DspHex("[OUT]bDestBlockExp =", bDestBlockExp, 8);
    ASSERT_OUT_HEX(bDestBlock, bDestBlockExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateBlock_Test_17(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo1;
    BYTE bKey1[32];
    int  nAlgo2;
    BYTE bKey2[32];
    BYTE bSrcBlock[16];
    BYTE bDestBlock[16];
    BYTE bDestBlockExp[16];

    nAlgo1 = 1;
    bufclr(bKey1);
    nAlgo2 = 1;
    bufclr(bKey2);
    bufclr(bSrcBlock);
    bufclr(bDestBlock);
    bufclr(bDestBlockExp);

    /* 1F1F 1F1F 0E0E 0E0E */
    memcpy(bKey1, "\x75\x1F\x0E\xFB\x47\x83\x90\x5A", 8);
    /* E0E0 E0E0 F1F1 F1F1 */
    memcpy(bKey2, "\xE0\x7B\x5A\xBE\x55\xB5\x67\xDB", 8);

    /* 0123 4567 89AB CDEF */
    memcpy(bSrcBlock, "\xDB\x95\x86\x05\xF8\xC8\xC6\x06", 8);
    memcpy(bDestBlockExp, "\xEE\x60\x0B\xC0\x6F\xC9\xEF\x23", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nAlgo1    = %d\n", nAlgo1);
    DspHex("[IN ]bKey1     =", bKey1, 8);
    printf("[IN ]nAlgo2    = %d\n", nAlgo2);
    DspHex("[IN ]bKey2     =", bKey2, 8);
    DspHex("[IN ]bSrcBlock =", bSrcBlock, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateBlock(nSock, nAlgo1, bKey1, nAlgo2, bKey2, \
                               bSrcBlock, bDestBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, \
        "弱密钥，密钥1明文=1F1F 1F1F 0E0E 0E0E，密钥2明文=E0E0 E0E0 F1F1 F1F1，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bDestBlock    =", bDestBlock, 8);
    DspHex("[OUT]bDestBlockExp =", bDestBlockExp, 8);
    ASSERT_OUT_HEX(bDestBlock, bDestBlockExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateBlock_Test_18(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo1;
    BYTE bKey1[32];
    int  nAlgo2;
    BYTE bKey2[32];
    BYTE bSrcBlock[16];
    BYTE bDestBlock[16];
    BYTE bDestBlockExp[16];

    nAlgo1 = 1;
    bufclr(bKey1);
    nAlgo2 = 1;
    bufclr(bKey2);
    bufclr(bSrcBlock);
    bufclr(bDestBlock);
    bufclr(bDestBlockExp);

    /* 1010 1010 1010 1010 */
    memcpy(bKey1, "\x67\xE3\x7D\xDE\xF4\x91\xEB\x77", 8);
    /* 2323 2323 2323 2323 */
    memcpy(bKey2, "\x78\xF8\xEF\x49\xFE\x38\x40\x09", 8);

    /* F7F6 3CD1 2A86 05F1 */
    memcpy(bSrcBlock, "\x00\x00\x00\x00\x00\x00\x00\x00", 8);
    memcpy(bDestBlockExp, "\x11\x73\xA3\x55\xA2\x8B\x6B\x6E", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nAlgo1    = %d\n", nAlgo1);
    DspHex("[IN ]bKey1     =", bKey1, 8);
    printf("[IN ]nAlgo2    = %d\n", nAlgo2);
    DspHex("[IN ]bKey2     =", bKey2, 8);
    DspHex("[IN ]bSrcBlock =", bSrcBlock, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateBlock(nSock, nAlgo1, bKey1, nAlgo2, bKey2, \
                               bSrcBlock, bDestBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密文数据长度为0，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bDestBlock    =", bDestBlock, 8);
    DspHex("[OUT]bDestBlockExp =", bDestBlockExp, 8);
    ASSERT_OUT_HEX(bDestBlock, bDestBlockExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateBlock_Test_19(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo1;
    BYTE bKey1[32];
    int  nAlgo2;
    BYTE bKey2[32];
    BYTE bSrcBlock[16];
    BYTE bDestBlock[16];
    BYTE bDestBlockExp[16];

    nAlgo1 = 1;
    bufclr(bKey1);
    nAlgo2 = 1;
    bufclr(bKey2);
    bufclr(bSrcBlock);
    bufclr(bDestBlock);
    bufclr(bDestBlockExp);

    /* 1010 1010 1010 1010 */
    memcpy(bKey1, "\x67\xE3\x7D\xDE\xF4\x91\xEB\x77", 8);
    /* 2323 2323 2323 2323 */
    memcpy(bKey2, "\x78\xF8\xEF\x49\xFE\x38\x40\x09", 8);

    /* 47A4 6E88 9A4D 0181 */
    memcpy(bSrcBlock, "\x01\x23\x45\x67\x89\xAB\xCD\x00", 8);
    memcpy(bDestBlockExp, "\x0A\x4B\x82\x55\x3B\x10\x68\xC5", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nAlgo1    = %d\n", nAlgo1);
    DspHex("[IN ]bKey1     =", bKey1, 8);
    printf("[IN ]nAlgo2    = %d\n", nAlgo2);
    DspHex("[IN ]bKey2     =", bKey2, 8);
    DspHex("[IN ]bSrcBlock =", bSrcBlock, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateBlock(nSock, nAlgo1, bKey1, nAlgo2, bKey2, \
                               bSrcBlock, bDestBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密文数据长度为7，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bDestBlock    =", bDestBlock, 8);
    DspHex("[OUT]bDestBlockExp =", bDestBlockExp, 8);
    ASSERT_OUT_HEX(bDestBlock, bDestBlockExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateBlock_Test_20(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo1;
    BYTE bKey1[32];
    int  nAlgo2;
    BYTE bKey2[32];
    BYTE bSrcBlock[16];
    BYTE bDestBlock[16];
    BYTE bDestBlockExp[16];

    nAlgo1 = 1;
    bufclr(bKey1);
    nAlgo2 = 1;
    bufclr(bKey2);
    bufclr(bSrcBlock);
    bufclr(bDestBlock);
    bufclr(bDestBlockExp);

    /* 1010 1010 1010 1010 */
    memcpy(bKey1, "\x67\xE3\x7D\xDE\xF4\x91\xEB\x77", 8);
    /* 2323 2323 2323 2323 */
    memcpy(bKey2, "\x78\xF8\xEF\x49\xFE\x38\x40\x09", 8);

    /* 47A4 6E88 9A4D 0181 */
    memcpy(bSrcBlock, "\x01\x23\x45\x67\x89\xAB\xCD\xEF\xFE", 9);
    memcpy(bDestBlockExp, "\xDF\x79\x7B\xE3\xA9\xE0\x0F\x3B", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nAlgo1    = %d\n", nAlgo1);
    DspHex("[IN ]bKey1     =", bKey1, 8);
    printf("[IN ]nAlgo2    = %d\n", nAlgo2);
    DspHex("[IN ]bKey2     =", bKey2, 8);
    DspHex("[IN ]bSrcBlock =", bSrcBlock, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateBlock(nSock, nAlgo1, bKey1, nAlgo2, bKey2, \
                               bSrcBlock, bDestBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密文数据长度为9，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bDestBlock    =", bDestBlock, 8);
    DspHex("[OUT]bDestBlockExp =", bDestBlockExp, 8);
    ASSERT_OUT_HEX(bDestBlock, bDestBlockExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyOutOf_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderLMK[32];
    int  nKeyLen;
    BYTE bKeyUnderKEK[32];
    BYTE bKeyUnderKEKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderKEKExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    nKeyLen = 8;
    /* 1023 3245 5467 7689 */
    memcpy(bKeyUnderLMK, "\x34\xF4\xFE\x76\x33\xA8\x03\x5F", 8);
    memcpy(bKeyUnderKEKExp, "\xED\x91\x88\x2F\xB6\xAF\xBD\xAF", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderLMK =", bKeyUnderLMK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyOutOf(nSock, nAlgo, bKEK, bKeyUnderLMK, \
                                  nKeyLen, bKeyUnderKEK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "Algo=1，DataLen=8测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKeyUnderKEK    =", bKeyUnderKEK, 8);
    DspHex("[OUT]bKeyUnderKEKExp =", bKeyUnderKEKExp, 8);
    ASSERT_OUT_HEX(bKeyUnderKEK, bKeyUnderKEKExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyOutOf_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderLMK[32];
    int  nKeyLen;
    BYTE bKeyUnderKEK[32];
    BYTE bKeyUnderKEKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderKEKExp);

    nAlgo = 2;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKEK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
           "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
                 16);
    nKeyLen = 8;
    /* 1023 3245 5467 7689 */
    memcpy(bKeyUnderLMK, "\x34\xF4\xFE\x76\x33\xA8\x03\x5F", 8);
    memcpy(bKeyUnderKEKExp, "\xF1\x6C\x5A\xA6\x4E\x30\xFC\x15", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 16);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderLMK =", bKeyUnderLMK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyOutOf(nSock, nAlgo, bKEK, bKeyUnderLMK, \
                                  nKeyLen, bKeyUnderKEK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "Algo=1，DataLen=16测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKeyUnderKEK    =", bKeyUnderKEK, 8);
    DspHex("[OUT]bKeyUnderKEKExp =", bKeyUnderKEKExp, 8);
    ASSERT_OUT_HEX(bKeyUnderKEK, bKeyUnderKEKExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyOutOf_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderLMK[32];
    int  nKeyLen;
    BYTE bKeyUnderKEK[32];
    BYTE bKeyUnderKEKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderKEKExp);

    nAlgo = 3;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8796 A5B4 C3D2 E1F0 */
    memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\x59\x99\xC3\x06\xAB\x84\x01\xB2",\
                 24);
    nKeyLen = 8;
    /* 1023 3245 5467 7689 */
    memcpy(bKeyUnderLMK, "\x34\xF4\xFE\x76\x33\xA8\x03\x5F", 8);
    memcpy(bKeyUnderKEKExp, "\xE3\x6B\x3F\x4B\x69\xD7\xA2\xBB", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 24);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderLMK =", bKeyUnderLMK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyOutOf(nSock, nAlgo, bKEK, bKeyUnderLMK, \
                                  nKeyLen, bKeyUnderKEK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "Algo=1，DataLen=24测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKeyUnderKEK    =", bKeyUnderKEK, 8);
    DspHex("[OUT]bKeyUnderKEKExp =", bKeyUnderKEKExp, 8);
    ASSERT_OUT_HEX(bKeyUnderKEK, bKeyUnderKEKExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyOutOf_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderLMK[32];
    int  nKeyLen;
    BYTE bKeyUnderKEK[32];
    BYTE bKeyUnderKEKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderKEKExp);

    nAlgo = 2;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
                 16);
    nKeyLen = 16;
    /* 1023 3245 5467 7689 98AB BACD DCEF FE01 */
    memcpy(bKeyUnderLMK, 
           "\x34\xF4\xFE\x76\x33\xA8\x03\x5F" \
           "\x25\x25\x12\x2F\x72\xE8\x35\x01" \
           , 16);
    memcpy(bKeyUnderKEKExp,
           "\xF1\x6C\x5A\xA6\x4E\x30\xFC\x15" \
           "\x81\x25\x8F\xE4\xB8\xB2\xB5\x4F" \
           , 16);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 16);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderLMK =", bKeyUnderLMK, 16);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyOutOf(nSock, nAlgo, bKEK, bKeyUnderLMK, \
                                  nKeyLen, bKeyUnderKEK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "Algo=2，DataLen=16测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKeyUnderKEK    =", bKeyUnderKEK, 16);
    DspHex("[OUT]bKeyUnderKEKExp =", bKeyUnderKEKExp, 16);
    ASSERT_OUT_HEX(bKeyUnderKEK, bKeyUnderKEKExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyOutOf_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderLMK[32];
    int  nKeyLen;
    BYTE bKeyUnderKEK[32];
    BYTE bKeyUnderKEKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderKEKExp);

    nAlgo = 3;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8796 A5B4 C3D2 E1F0 */
    memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\x59\x99\xC3\x06\xAB\x84\x01\xB2",\
                 24);
    nKeyLen = 16;
    /* 1023 3245 5467 7689 98AB BACD DCEF FE01 */
    memcpy(bKeyUnderLMK, 
           "\x34\xF4\xFE\x76\x33\xA8\x03\x5F" \
           "\x25\x25\x12\x2F\x72\xE8\x35\x01" \
           , 16);
    memcpy(bKeyUnderKEKExp,
           "\xE3\x6B\x3F\x4B\x69\xD7\xA2\xBB" \
           "\x3B\x31\x80\x3D\x25\x79\x93\x09" \
           , 16);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 24);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderLMK =", bKeyUnderLMK, 16);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyOutOf(nSock, nAlgo, bKEK, bKeyUnderLMK, \
                                  nKeyLen, bKeyUnderKEK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "Algo=3，DataLen=16测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKeyUnderKEK    =", bKeyUnderKEK, 16);
    DspHex("[OUT]bKeyUnderKEKExp =", bKeyUnderKEKExp, 16);
    ASSERT_OUT_HEX(bKeyUnderKEK, bKeyUnderKEKExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyOutOf_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderLMK[32];
    int  nKeyLen;
    BYTE bKeyUnderKEK[32];
    BYTE bKeyUnderKEKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderKEKExp);

    nAlgo = 3;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8796 A5B4 C3D2 E1F0 */
    memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\x59\x99\xC3\x06\xAB\x84\x01\xB2",\
                 24);
    nKeyLen = 24;
    /* 1023 3245 5467 7689 98AB BACD DCEF FE01 048C 159D 26AE 37BF */
    memcpy(bKeyUnderLMK,
           "\x34\xF4\xFE\x76\x33\xA8\x03\x5F" \
           "\x25\x25\x12\x2F\x72\xE8\x35\x01" \
           "\xF3\x16\x51\xBB\xA0\x53\x71\xCB" \
           , 24);
    memcpy(bKeyUnderKEKExp, 
           "\xE3\x6B\x3F\x4B\x69\xD7\xA2\xBB" \
           "\x3B\x31\x80\x3D\x25\x79\x93\x09" \
           "\x7F\xCB\xE4\x66\x2B\x30\x92\x3B" \
           , 24);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 24);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderLMK =", bKeyUnderLMK, 24);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyOutOf(nSock, nAlgo, bKEK, bKeyUnderLMK, \
                                  nKeyLen, bKeyUnderKEK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "Algo=3，DataLen=24测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKeyUnderKEK    =", bKeyUnderKEK, 24);
    DspHex("[OUT]bKeyUnderKEKExp =", bKeyUnderKEKExp, 24);
    ASSERT_OUT_HEX(bKeyUnderKEK, bKeyUnderKEKExp, 24);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyOutOf_Test_07(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderLMK[32];
    int  nKeyLen;
    BYTE bKeyUnderKEK[32];
    BYTE bKeyUnderKEKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderKEKExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    nKeyLen = 16;
    /* 1122 3344 5566 7788 99AA BBCC DDEE FF00 */
    memcpy(bKeyUnderLMK, "\x91\x21\x98\xF1\x03\x6B\xBA\x33" \
                         "\x8C\x35\x9E\x9E\xE5\xA5\x72\x0D",\
                         16);
    memcpy(bKeyUnderKEKExp, "\xB4\xCC\x3F\xD9\xD8\xD9\x52\x14" \
                            "\x15\x79\x65\x7C\x43\x26\x3E\x1E",\
                            16);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderLMK =", bKeyUnderLMK, 16);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyOutOf(nSock, nAlgo, bKEK, bKeyUnderLMK, \
                                  nKeyLen, bKeyUnderKEK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "Algo=1，DataLen=16测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKeyUnderKEK    =", bKeyUnderKEK, 16);
    DspHex("[OUT]bKeyUnderKEKExp =", bKeyUnderKEKExp, 16);
    ASSERT_OUT_HEX(bKeyUnderKEK, bKeyUnderKEKExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyOutOf_Test_08(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderLMK[32];
    int  nKeyLen;
    BYTE bKeyUnderKEK[32];
    BYTE bKeyUnderKEKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderKEKExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    nKeyLen = 24;
    /* 1122 3344 5566 7788 99AA BBCC DDEE FF00 048C 159D 26AE 37BF */
    memcpy(bKeyUnderLMK, "\x91\x21\x98\xF1\x03\x6B\xBA\x33" \
                         "\x8C\x35\x9E\x9E\xE5\xA5\x72\x0D" \
                         "\xF3\x16\x51\xBB\xA0\x53\x71\xCB",\
                         24);
    memcpy(bKeyUnderKEKExp, "\xB4\xCC\x3F\xD9\xD8\xD9\x52\x14" \
                            "\x15\x79\x65\x7C\x43\x26\x3E\x1E" \
                            "\x42\x7E\x63\xF4\x1F\xDF\x69\xE7",\
                            24);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderLMK =", bKeyUnderLMK, 24);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyOutOf(nSock, nAlgo, bKEK, bKeyUnderLMK, \
                                  nKeyLen, bKeyUnderKEK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "Algo=1，DataLen=24测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKeyUnderKEK    =", bKeyUnderKEK, 24);
    DspHex("[OUT]bKeyUnderKEKExp =", bKeyUnderKEKExp, 24);
    ASSERT_OUT_HEX(bKeyUnderKEK, bKeyUnderKEKExp, 24);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyOutOf_Test_09(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderLMK[32];
    int  nKeyLen;
    BYTE bKeyUnderKEK[32];
    BYTE bKeyUnderKEKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderKEKExp);

    nAlgo = 2;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
                 16);
    nKeyLen = 24;
    /* 1122 3344 5566 7788 99AA BBCC DDEE FF00 048C 159D 26AE 37BF */
    memcpy(bKeyUnderLMK, "\x91\x21\x98\xF1\x03\x6B\xBA\x33" \
                         "\x8C\x35\x9E\x9E\xE5\xA5\x72\x0D" \
                         "\xF3\x16\x51\xBB\xA0\x53\x71\xCB",\
                         24);
    memcpy(bKeyUnderKEKExp, "\x3E\xB3\xB7\x25\x76\xBB\xBE\x83" \
                            "\x56\x01\x10\x4F\x2D\xF9\x44\x05" \
                            "\x56\x29\x2B\xFE\xB2\x42\x1B\xEF",\
                            24);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 16);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderLMK =", bKeyUnderLMK, 24);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyOutOf(nSock, nAlgo, bKEK, bKeyUnderLMK, \
                                  nKeyLen, bKeyUnderKEK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "Algo=2，DataLen=24测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKeyUnderKEK    =", bKeyUnderKEK, 24);
    DspHex("[OUT]bKeyUnderKEKExp =", bKeyUnderKEKExp, 24);
    ASSERT_OUT_HEX(bKeyUnderKEK, bKeyUnderKEKExp, 24);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyOutOf_Test_10(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderLMK[32];
    int  nKeyLen;
    BYTE bKeyUnderKEK[32];
    BYTE bKeyUnderKEKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderKEKExp);

    nSock = -1;
    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    nKeyLen = 8;
    /* 1122 3344 5566 7788 */
    memcpy(bKeyUnderLMK, "\x91\x21\x98\xF1\x03\x6B\xBA\x33", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderLMK =", bKeyUnderLMK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyOutOf(nSock, nAlgo, bKEK, bKeyUnderLMK, \
                                  nKeyLen, bKeyUnderKEK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void TranslateKeyOutOf_Test_11(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderLMK[32];
    int  nKeyLen;
    BYTE bKeyUnderKEK[32];
    BYTE bKeyUnderKEKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderKEKExp);

    nSock = 8;
    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    nKeyLen = 8;
    /* 1122 3344 5566 7788 */
    memcpy(bKeyUnderLMK, "\x91\x21\x98\xF1\x03\x6B\xBA\x33", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderLMK =", bKeyUnderLMK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyOutOf(nSock, nAlgo, bKEK, bKeyUnderLMK, \
                                  nKeyLen, bKeyUnderKEK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[8]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void TranslateKeyOutOf_Test_12(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderLMK[32];
    int  nKeyLen;
    BYTE bKeyUnderKEK[32];
    BYTE bKeyUnderKEKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderKEKExp);

    nAlgo = 0;
    /* 0123 4567 89AB CDEF */
    memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    nKeyLen = 8;
    /* 1122 3344 5566 7788 */
    memcpy(bKeyUnderLMK, "\x91\x21\x98\xF1\x03\x6B\xBA\x33", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderLMK =", bKeyUnderLMK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyOutOf(nSock, nAlgo, bKEK, bKeyUnderLMK, \
                                  nKeyLen, bKeyUnderKEK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效算法类型[0]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyOutOf_Test_13(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderLMK[32];
    int  nKeyLen;
    BYTE bKeyUnderKEK[32];
    BYTE bKeyUnderKEKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderKEKExp);

    nAlgo = 4;
    /* 0123 4567 89AB CDEF */
    memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    nKeyLen = 8;
    /* 1122 3344 5566 7788 */
    memcpy(bKeyUnderLMK, "\x91\x21\x98\xF1\x03\x6B\xBA\x33", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderLMK =", bKeyUnderLMK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyOutOf(nSock, nAlgo, bKEK, bKeyUnderLMK, \
                                  nKeyLen, bKeyUnderKEK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效算法类型[4]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyOutOf_Test_14(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderLMK[32];
    int  nKeyLen;
    BYTE bKeyUnderKEK[32];
    BYTE bKeyUnderKEKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderKEKExp);

    nAlgo = 1;
    /* 0101 0101 0101 0101 */
    memcpy(bKEK, "\x7E\xAB\x74\x3A\x23\x64\x7B\xE6", 8);
    nKeyLen = 8;
    /* 1122 3344 5566 7788 */
    memcpy(bKeyUnderLMK, "\x91\x21\x98\xF1\x03\x6B\xBA\x33", 8);
    memcpy(bKeyUnderKEKExp, "\xCD\x72\xDF\xC6\xE6\xD0\x40\xA4", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderLMK =", bKeyUnderLMK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyOutOf(nSock, nAlgo, bKEK, bKeyUnderLMK, \
                                  nKeyLen, bKeyUnderKEK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "空密钥，KEK明文=0000 0000 0000 0000，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKeyUnderKEK    =", bKeyUnderKEK, 8);
    DspHex("[OUT]bKeyUnderKEKExp =", bKeyUnderKEKExp, 8);
    ASSERT_OUT_HEX(bKeyUnderKEK, bKeyUnderKEKExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyOutOf_Test_15(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderLMK[32];
    int  nKeyLen;
    BYTE bKeyUnderKEK[32];
    BYTE bKeyUnderKEKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderKEKExp);

    nAlgo = 1;
    /* 1F1F 1F1F 0E0E 0E0E */
    memcpy(bKEK, "\x75\x1F\x0E\xFB\x47\x83\x90\x5A", 8);
    nKeyLen = 8;
    /* 1122 3344 5566 7788 */
    memcpy(bKeyUnderLMK, "\x91\x21\x98\xF1\x03\x6B\xBA\x33", 8);
    memcpy(bKeyUnderKEKExp, "\x21\x6F\x20\xD6\x56\xBC\xBA\x0B", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderLMK =", bKeyUnderLMK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyOutOf(nSock, nAlgo, bKEK, bKeyUnderLMK, \
                                  nKeyLen, bKeyUnderKEK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "弱密钥，KEK明文=1F1F 1F1F 0E0E 0E0E，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKeyUnderKEK    =", bKeyUnderKEK, 8);
    DspHex("[OUT]bKeyUnderKEKExp =", bKeyUnderKEKExp, 8);
    ASSERT_OUT_HEX(bKeyUnderKEK, bKeyUnderKEKExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyOutOf_Test_16(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderLMK[32];
    int  nKeyLen;
    BYTE bKeyUnderKEK[32];
    BYTE bKeyUnderKEKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderKEKExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    nKeyLen = 8;
    /* 0101 0101 0101 0101 */
    memcpy(bKeyUnderLMK, "\x7E\xAB\x74\x3A\x23\x64\x7B\xE6", 8);
    memcpy(bKeyUnderKEKExp, "\xB4\xFD\x23\x16\x47\xA5\xBE\xC0", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderLMK =", bKeyUnderLMK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyOutOf(nSock, nAlgo, bKEK, bKeyUnderLMK, \
                                  nKeyLen, bKeyUnderKEK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "空密钥，密钥明文=0000 0000 0000 0000，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKeyUnderKEK    =", bKeyUnderKEK, 8);
    DspHex("[OUT]bKeyUnderKEKExp =", bKeyUnderKEKExp, 8);
    ASSERT_OUT_HEX(bKeyUnderKEK, bKeyUnderKEKExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyOutOf_Test_17(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderLMK[32];
    int  nKeyLen;
    BYTE bKeyUnderKEK[32];
    BYTE bKeyUnderKEKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderKEKExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    nKeyLen = 8;
    /* 1F1F 1F1F 0E0E 0E0E */
    memcpy(bKeyUnderLMK, "\x75\x1F\x0E\xFB\x47\x83\x90\x5A", 8);
    memcpy(bKeyUnderKEKExp, "\x81\x04\x38\x89\x53\x63\xF2\x95", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderLMK =", bKeyUnderLMK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyOutOf(nSock, nAlgo, bKEK, bKeyUnderLMK, \
                                  nKeyLen, bKeyUnderKEK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "弱密钥，密钥明文=1F1F 1F1F 0E0E 0E0E，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKeyUnderKEK    =", bKeyUnderKEK, 8);
    DspHex("[OUT]bKeyUnderKEKExp =", bKeyUnderKEKExp, 8);
    ASSERT_OUT_HEX(bKeyUnderKEK, bKeyUnderKEKExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyOutOf_Test_18(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderLMK[32];
    int  nKeyLen;
    BYTE bKeyUnderKEK[32];
    BYTE bKeyUnderKEKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderKEKExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    nKeyLen = 0;
    /* 1122 3344 5566 7788 */
    memcpy(bKeyUnderLMK, "\x91\x21\x98\xF1\x03\x6B\xBA\x33", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderLMK =", bKeyUnderLMK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyOutOf(nSock, nAlgo, bKEK, bKeyUnderLMK, \
                                  nKeyLen, bKeyUnderKEK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效数据长度[0]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyOutOf_Test_19(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderLMK[32];
    int  nKeyLen;
    BYTE bKeyUnderKEK[32];
    BYTE bKeyUnderKEKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderKEKExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    nKeyLen = 7;
    /* 1122 3344 5566 7788 */
    memcpy(bKeyUnderLMK, "\x91\x21\x98\xF1\x03\x6B\xBA\x33", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderLMK =", bKeyUnderLMK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyOutOf(nSock, nAlgo, bKEK, bKeyUnderLMK, \
                                  nKeyLen, bKeyUnderKEK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效数据长度[7]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyOutOf_Test_20(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderLMK[32];
    int  nKeyLen;
    BYTE bKeyUnderKEK[32];
    BYTE bKeyUnderKEKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderKEKExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    nKeyLen = 20;
    /* 1122 3344 5566 7788 */
    memcpy(bKeyUnderLMK, "\x91\x21\x98\xF1\x03\x6B\xBA\x33", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderLMK =", bKeyUnderLMK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyOutOf(nSock, nAlgo, bKEK, bKeyUnderLMK, \
                                  nKeyLen, bKeyUnderKEK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效数据长度[20]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyOutOf_Test_21(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderLMK[32];
    int  nKeyLen;
    BYTE bKeyUnderKEK[32];
    BYTE bKeyUnderKEKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderKEKExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    nKeyLen = 25;
    /* 1122 3344 5566 7788 */
    memcpy(bKeyUnderLMK, "\x91\x21\x98\xF1\x03\x6B\xBA\x33", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderLMK =", bKeyUnderLMK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyOutOf(nSock, nAlgo, bKEK, bKeyUnderLMK, \
                                  nKeyLen, bKeyUnderKEK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效数据长度[25]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyInTo_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderKEK[32];
    int  nKeyLen;
    BYTE bKeyUnderLMK[32];
    BYTE bKeyUnderLMKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderLMKExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    nKeyLen = 8;
    /* 1023 3245 5467 7689 */
    memcpy(bKeyUnderKEK, "\xED\x91\x88\x2F\xB6\xAF\xBD\xAF", 8);
    memcpy(bKeyUnderLMKExp, "\x34\xF4\xFE\x76\x33\xA8\x03\x5F", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderLMK =", bKeyUnderKEK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyInTo(nSock, nAlgo, bKEK, bKeyUnderKEK, \
                                  nKeyLen, bKeyUnderLMK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "Algo=1，DataLen=8测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKeyUnderKEK    =", bKeyUnderLMK, 8);
    DspHex("[OUT]bKeyUnderKEKExp =", bKeyUnderLMKExp, 8);
    ASSERT_OUT_HEX(bKeyUnderLMK, bKeyUnderLMKExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyInTo_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderKEK[32];
    int  nKeyLen;
    BYTE bKeyUnderLMK[32];
    BYTE bKeyUnderLMKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderLMKExp);

    nAlgo = 2;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
                 16);
    nKeyLen = 8;
    /* 1023 3245 5467 7689 */
    memcpy(bKeyUnderKEK, "\xF1\x6C\x5A\xA6\x4E\x30\xFC\x15", 8);
    memcpy(bKeyUnderLMKExp, "\x34\xF4\xFE\x76\x33\xA8\x03\x5F", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 16);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderKEK =", bKeyUnderKEK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyInTo(nSock, nAlgo, bKEK, bKeyUnderKEK, \
                                  nKeyLen, bKeyUnderLMK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "Algo=2，DataLen=8测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKeyUnderLMK    =", bKeyUnderLMK, 8);
    DspHex("[OUT]bKeyUnderLMKExp =", bKeyUnderLMKExp, 8);
    ASSERT_OUT_HEX(bKeyUnderLMK, bKeyUnderLMKExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyInTo_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderKEK[32];
    int  nKeyLen;
    BYTE bKeyUnderLMK[32];
    BYTE bKeyUnderLMKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderLMKExp);

    nAlgo = 3;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8796 A5B4 C3D2 E1F0 */
    memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\x59\x99\xC3\x06\xAB\x84\x01\xB2",\
                 24);
    nKeyLen = 8;
    /* 1023 3245 5467 7689 */
    memcpy(bKeyUnderKEK, "\xE3\x6B\x3F\x4B\x69\xD7\xA2\xBB", 8);
    memcpy(bKeyUnderLMKExp, "\x34\xF4\xFE\x76\x33\xA8\x03\x5F", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 24);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderKEK =", bKeyUnderKEK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyInTo(nSock, nAlgo, bKEK, bKeyUnderKEK, \
                                  nKeyLen, bKeyUnderLMK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "Algo=3，DataLen=8测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKeyUnderLMK    =", bKeyUnderLMK, 8);
    DspHex("[OUT]bKeyUnderLMKExp =", bKeyUnderLMKExp, 8);
    ASSERT_OUT_HEX(bKeyUnderLMK, bKeyUnderLMKExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyInTo_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderKEK[32];
    int  nKeyLen;
    BYTE bKeyUnderLMK[32];
    BYTE bKeyUnderLMKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderLMKExp);

    nAlgo = 2;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
                 16);
    nKeyLen = 16;
    /* 1023 3245 5467 7689 98AB BACD DCEF FE01 */
    memcpy(bKeyUnderKEK, 
           "\xF1\x6C\x5A\xA6\x4E\x30\xFC\x15" \
           "\x81\x25\x8F\xE4\xB8\xB2\xB5\x4F" \
           , 16);
    memcpy(bKeyUnderLMKExp, 
           "\x34\xF4\xFE\x76\x33\xA8\x03\x5F" \
           "\x25\x25\x12\x2F\x72\xE8\x35\x01" \
           , 16);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 16);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderKEK =", bKeyUnderKEK, 16);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyInTo(nSock, nAlgo, bKEK, bKeyUnderKEK, \
                                  nKeyLen, bKeyUnderLMK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "Algo=2，DataLen=16测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKeyUnderLMK    =", bKeyUnderLMK, 16);
    DspHex("[OUT]bKeyUnderLMKExp =", bKeyUnderLMKExp, 16);
    ASSERT_OUT_HEX(bKeyUnderLMK, bKeyUnderLMKExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyInTo_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderKEK[32];
    int  nKeyLen;
    BYTE bKeyUnderLMK[32];
    BYTE bKeyUnderLMKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderLMKExp);

    nAlgo = 3;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8796 A5B4 C3D2 E1F0 */
    memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\x59\x99\xC3\x06\xAB\x84\x01\xB2",\
                 24);
    nKeyLen = 16;
    /* 1023 3245 5467 7689 98AB BACD DCEF FE01 */
    memcpy(bKeyUnderKEK, 
           "\xE3\x6B\x3F\x4B\x69\xD7\xA2\xBB" \
           "\x3B\x31\x80\x3D\x25\x79\x93\x09" \
           , 16);
    memcpy(bKeyUnderLMKExp, 
           "\x34\xF4\xFE\x76\x33\xA8\x03\x5F" \
           "\x25\x25\x12\x2F\x72\xE8\x35\x01" \
           , 16);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 24);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderKEK =", bKeyUnderKEK, 16);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyInTo(nSock, nAlgo, bKEK, bKeyUnderKEK, \
                                  nKeyLen, bKeyUnderLMK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "Algo=3，DataLen=16测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKeyUnderLMK    =", bKeyUnderLMK, 16);
    DspHex("[OUT]bKeyUnderLMKExp =", bKeyUnderLMKExp, 16);
    ASSERT_OUT_HEX(bKeyUnderLMK, bKeyUnderLMKExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyInTo_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderKEK[32];
    int  nKeyLen;
    BYTE bKeyUnderLMK[32];
    BYTE bKeyUnderLMKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderLMKExp);

    nAlgo = 3;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8796 A5B4 C3D2 E1F0 */
    memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\x59\x99\xC3\x06\xAB\x84\x01\xB2",\
                 24);
    nKeyLen = 24;
    /* 1023 3245 5467 7689 98AB BACD DCEF FE01 048C 159D 26AE 37BF */
    memcpy(bKeyUnderKEK, 
           "\xE3\x6B\x3F\x4B\x69\xD7\xA2\xBB" \
           "\x3B\x31\x80\x3D\x25\x79\x93\x09" \
           "\x7F\xCB\xE4\x66\x2B\x30\x92\x3B" \
           , 24);
    memcpy(bKeyUnderLMKExp, 
           "\x34\xF4\xFE\x76\x33\xA8\x03\x5F" \
           "\x25\x25\x12\x2F\x72\xE8\x35\x01" \
           "\xF3\x16\x51\xBB\xA0\x53\x71\xCB" \
           , 24);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 24);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderKEK =", bKeyUnderKEK, 24);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyInTo(nSock, nAlgo, bKEK, bKeyUnderKEK, \
                                  nKeyLen, bKeyUnderLMK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "Algo=3，DataLen=24测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKeyUnderLMK    =", bKeyUnderLMK, 24);
    DspHex("[OUT]bKeyUnderLMKExp =", bKeyUnderLMKExp, 24);
    ASSERT_OUT_HEX(bKeyUnderLMK, bKeyUnderLMKExp, 24);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyInTo_Test_07(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderKEK[32];
    int  nKeyLen;
    BYTE bKeyUnderLMK[32];
    BYTE bKeyUnderLMKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderLMKExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    nKeyLen = 16;
    /* 1122 3344 5566 7788 99AA BBCC DDEE FF00 */
    memcpy(bKeyUnderKEK, "\xB4\xCC\x3F\xD9\xD8\xD9\x52\x14" \
                            "\x15\x79\x65\x7C\x43\x26\x3E\x1E",\
                            16);
    memcpy(bKeyUnderLMKExp, "\x91\x21\x98\xF1\x03\x6B\xBA\x33" \
                         "\x8C\x35\x9E\x9E\xE5\xA5\x72\x0D",\
                         16);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderKEK =", bKeyUnderKEK, 16);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyInTo(nSock, nAlgo, bKEK, bKeyUnderKEK, \
                                  nKeyLen, bKeyUnderLMK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "Algo=1，DataLen=16测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKeyUnderLMK    =", bKeyUnderLMK, 16);
    DspHex("[OUT]bKeyUnderLMKExp =", bKeyUnderLMKExp, 16);
    ASSERT_OUT_HEX(bKeyUnderLMK, bKeyUnderLMKExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyInTo_Test_08(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderKEK[32];
    int  nKeyLen;
    BYTE bKeyUnderLMK[32];
    BYTE bKeyUnderLMKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderLMKExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    nKeyLen = 24;
    /* 1122 3344 5566 7788 99AA BBCC DDEE FF00 048C 159D 26AE 37BF */
    memcpy(bKeyUnderKEK, "\xB4\xCC\x3F\xD9\xD8\xD9\x52\x14" \
                            "\x15\x79\x65\x7C\x43\x26\x3E\x1E" \
                            "\x42\x7E\x63\xF4\x1F\xDF\x69\xE7",\
                            24);
    memcpy(bKeyUnderLMKExp, "\x91\x21\x98\xF1\x03\x6B\xBA\x33" \
                         "\x8C\x35\x9E\x9E\xE5\xA5\x72\x0D" \
                         "\xF3\x16\x51\xBB\xA0\x53\x71\xCB",\
                         24);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderKEK =", bKeyUnderKEK, 24);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyInTo(nSock, nAlgo, bKEK, bKeyUnderKEK, \
                                  nKeyLen, bKeyUnderLMK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "Algo=1，DataLen=24测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKeyUnderLMK    =", bKeyUnderLMK, 24);
    DspHex("[OUT]bKeyUnderLMKExp =", bKeyUnderLMKExp, 24);
    ASSERT_OUT_HEX(bKeyUnderLMK, bKeyUnderLMKExp, 24);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyInTo_Test_09(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderKEK[32];
    int  nKeyLen;
    BYTE bKeyUnderLMK[32];
    BYTE bKeyUnderLMKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderLMKExp);

    nAlgo = 2;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
                 16);
    nKeyLen = 24;
    /* 1122 3344 5566 7788 99AA BBCC DDEE FF00 048C 159D 26AE 37BF */
    memcpy(bKeyUnderKEK, "\x3E\xB3\xB7\x25\x76\xBB\xBE\x83" \
                            "\x56\x01\x10\x4F\x2D\xF9\x44\x05" \
                            "\x56\x29\x2B\xFE\xB2\x42\x1B\xEF",\
                            24);
    memcpy(bKeyUnderLMKExp, "\x91\x21\x98\xF1\x03\x6B\xBA\x33" \
                         "\x8C\x35\x9E\x9E\xE5\xA5\x72\x0D" \
                         "\xF3\x16\x51\xBB\xA0\x53\x71\xCB",\
                         24);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 16);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderKEK =", bKeyUnderKEK, 24);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyInTo(nSock, nAlgo, bKEK, bKeyUnderKEK, \
                                  nKeyLen, bKeyUnderLMK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "Algo=2，DataLen=24测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKeyUnderLMK    =", bKeyUnderLMK, 24);
    DspHex("[OUT]bKeyUnderLMKExp =", bKeyUnderLMKExp, 24);
    ASSERT_OUT_HEX(bKeyUnderLMK, bKeyUnderLMKExp, 24);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyInTo_Test_10(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderKEK[32];
    int  nKeyLen;
    BYTE bKeyUnderLMK[32];
    BYTE bKeyUnderLMKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderLMKExp);

    nSock = -1;
    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    nKeyLen = 8;
    /* 1122 3344 5566 7788 */
    memcpy(bKeyUnderKEK, "\xB4\xCC\x3F\xD9\xD8\xD9\x52\x14", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderKEK =", bKeyUnderKEK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyInTo(nSock, nAlgo, bKEK, bKeyUnderKEK, \
                                  nKeyLen, bKeyUnderLMK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void TranslateKeyInTo_Test_11(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderKEK[32];
    int  nKeyLen;
    BYTE bKeyUnderLMK[32];
    BYTE bKeyUnderLMKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderLMKExp);

    nSock = 8;
    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    nKeyLen = 8;
    /* 1122 3344 5566 7788 */
    memcpy(bKeyUnderKEK, "\xB4\xCC\x3F\xD9\xD8\xD9\x52\x14", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderKEK =", bKeyUnderKEK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyInTo(nSock, nAlgo, bKEK, bKeyUnderKEK, \
                                  nKeyLen, bKeyUnderLMK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[8]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void TranslateKeyInTo_Test_12(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderKEK[32];
    int  nKeyLen;
    BYTE bKeyUnderLMK[32];
    BYTE bKeyUnderLMKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderLMKExp);

    nAlgo = 0;
    /* 0123 4567 89AB CDEF */
    memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    nKeyLen = 8;
    /* 1122 3344 5566 7788 */
    memcpy(bKeyUnderKEK, "\xB4\xCC\x3F\xD9\xD8\xD9\x52\x14", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderKEK =", bKeyUnderKEK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyInTo(nSock, nAlgo, bKEK, bKeyUnderKEK, \
                                  nKeyLen, bKeyUnderLMK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效算法类型[0]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyInTo_Test_13(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderKEK[32];
    int  nKeyLen;
    BYTE bKeyUnderLMK[32];
    BYTE bKeyUnderLMKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderLMKExp);

    nAlgo = 4;
    /* 0123 4567 89AB CDEF */
    memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    nKeyLen = 8;
    /* 1122 3344 5566 7788 */
    memcpy(bKeyUnderKEK, "\xB4\xCC\x3F\xD9\xD8\xD9\x52\x14", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderKEK =", bKeyUnderKEK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyInTo(nSock, nAlgo, bKEK, bKeyUnderKEK, \
                                  nKeyLen, bKeyUnderLMK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效算法类型[4]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyInTo_Test_14(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderKEK[32];
    int  nKeyLen;
    BYTE bKeyUnderLMK[32];
    BYTE bKeyUnderLMKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderLMKExp);

    nAlgo = 1;
    /* 0101 0101 0101 0101 */
    memcpy(bKEK, "\x7E\xAB\x74\x3A\x23\x64\x7B\xE6", 8);
    nKeyLen = 8;
    /* 1122 3344 5566 7788 */
    memcpy(bKeyUnderKEK, "\xCD\x72\xDF\xC6\xE6\xD0\x40\xA4", 8);
    memcpy(bKeyUnderLMKExp, "\x91\x21\x98\xF1\x03\x6B\xBA\x33", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderKEK =", bKeyUnderKEK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyInTo(nSock, nAlgo, bKEK, bKeyUnderKEK, \
                                  nKeyLen, bKeyUnderLMK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "空密钥，KEK明文=0000 0000 0000 0000，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKeyUnderLMK    =", bKeyUnderLMK, 8);
    DspHex("[OUT]bKeyUnderLMKExp =", bKeyUnderLMKExp, 8);
    ASSERT_OUT_HEX(bKeyUnderLMK, bKeyUnderLMKExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyInTo_Test_15(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderKEK[32];
    int  nKeyLen;
    BYTE bKeyUnderLMK[32];
    BYTE bKeyUnderLMKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderLMKExp);

    nAlgo = 1;
    /* 1F1F 1F1F 0E0E 0E0E */
    memcpy(bKEK, "\x75\x1F\x0E\xFB\x47\x83\x90\x5A", 8);
    nKeyLen = 8;
    /* 1122 3344 5566 7788 */
    memcpy(bKeyUnderKEK, "\x21\x6F\x20\xD6\x56\xBC\xBA\x0B", 8);
    memcpy(bKeyUnderLMKExp, "\x91\x21\x98\xF1\x03\x6B\xBA\x33", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderKEK =", bKeyUnderKEK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyInTo(nSock, nAlgo, bKEK, bKeyUnderKEK, \
                                  nKeyLen, bKeyUnderLMK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "弱密钥，KEK明文=1F1F 1F1F 0E0E 0E0E，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKeyUnderLMK    =", bKeyUnderLMK, 8);
    DspHex("[OUT]bKeyUnderLMKExp =", bKeyUnderLMKExp, 8);
    ASSERT_OUT_HEX(bKeyUnderLMK, bKeyUnderLMKExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyInTo_Test_16(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderKEK[32];
    int  nKeyLen;
    BYTE bKeyUnderLMK[32];
    BYTE bKeyUnderLMKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderLMKExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    nKeyLen = 8;
    /* 0101 0101 0101 0101 */
    memcpy(bKeyUnderKEK, "\xB4\xFD\x23\x16\x47\xA5\xBE\xC0", 8);
    memcpy(bKeyUnderLMKExp, "\x7E\xAB\x74\x3A\x23\x64\x7B\xE6", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderKEK =", bKeyUnderKEK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyInTo(nSock, nAlgo, bKEK, bKeyUnderKEK, \
                                  nKeyLen, bKeyUnderLMK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "空密钥，密钥明文=0000 0000 0000 0000，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKeyUnderLMK    =", bKeyUnderLMK, 8);
    DspHex("[OUT]bKeyUnderLMKExp =", bKeyUnderLMKExp, 8);
    ASSERT_OUT_HEX(bKeyUnderLMK, bKeyUnderLMKExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyInTo_Test_17(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderKEK[32];
    int  nKeyLen;
    BYTE bKeyUnderLMK[32];
    BYTE bKeyUnderLMKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderLMKExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    nKeyLen = 8;
    /* 14AA D7F4 DBB4 E094 */
    memcpy(bKeyUnderKEK, "\x00\x00\x00\x00\x00\x00\x00\x00", 8);
    memcpy(bKeyUnderLMKExp, "\xE2\x10\x0A\xCB\x57\x23\xD1\x37", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderKEK =", bKeyUnderKEK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyInTo(nSock, nAlgo, bKEK, bKeyUnderKEK, \
                                  nKeyLen, bKeyUnderLMK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "空密钥，密钥密文=0000 0000 0000 0000，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKeyUnderLMK    =", bKeyUnderLMK, 8);
    DspHex("[OUT]bKeyUnderLMKExp =", bKeyUnderLMKExp, 8);
    ASSERT_OUT_HEX(bKeyUnderLMK, bKeyUnderLMKExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyInTo_Test_18(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderKEK[32];
    int  nKeyLen;
    BYTE bKeyUnderLMK[32];
    BYTE bKeyUnderLMKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderLMKExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    nKeyLen = 8;
    /* 1F1F 1F1F 0E0E 0E0E */
    memcpy(bKeyUnderKEK, "\x81\x04\x38\x89\x53\x63\xF2\x95", 8);
    memcpy(bKeyUnderLMKExp, "\x75\x1F\x0E\xFB\x47\x83\x90\x5A", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderKEK =", bKeyUnderKEK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyInTo(nSock, nAlgo, bKEK, bKeyUnderKEK, \
                                  nKeyLen, bKeyUnderLMK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "弱密钥，密钥明文=1F1F 1F1F 0E0E 0E0E，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKeyUnderLMK    =", bKeyUnderLMK, 8);
    DspHex("[OUT]bKeyUnderLMKExp =", bKeyUnderLMKExp, 8);
    ASSERT_OUT_HEX(bKeyUnderLMK, bKeyUnderLMKExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyInTo_Test_19(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderKEK[32];
    int  nKeyLen;
    BYTE bKeyUnderLMK[32];
    BYTE bKeyUnderLMKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderLMKExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    nKeyLen = 0;
    /* 1122 3344 5566 7788 */
    memcpy(bKeyUnderKEK, "\xB4\xCC\x3F\xD9\xD8\xD9\x52\x14", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderKEK =", bKeyUnderKEK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyInTo(nSock, nAlgo, bKEK, bKeyUnderKEK, \
                                  nKeyLen, bKeyUnderLMK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效数据长度[0]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyInTo_Test_20(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderKEK[32];
    int  nKeyLen;
    BYTE bKeyUnderLMK[32];
    BYTE bKeyUnderLMKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderLMKExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    nKeyLen = 7;
    /* 1122 3344 5566 7788 */
    memcpy(bKeyUnderKEK, "\xB4\xCC\x3F\xD9\xD8\xD9\x52\x14", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderKEK =", bKeyUnderKEK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyInTo(nSock, nAlgo, bKEK, bKeyUnderKEK, \
                                  nKeyLen, bKeyUnderLMK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效数据长度[7]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyInTo_Test_21(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderKEK[32];
    int  nKeyLen;
    BYTE bKeyUnderLMK[32];
    BYTE bKeyUnderLMKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderLMKExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    nKeyLen = 20;
    /* 1122 3344 5566 7788 */
    memcpy(bKeyUnderKEK, "\xB4\xCC\x3F\xD9\xD8\xD9\x52\x14", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderKEK =", bKeyUnderKEK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyInTo(nSock, nAlgo, bKEK, bKeyUnderKEK, \
                                  nKeyLen, bKeyUnderLMK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效数据长度[20]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyInTo_Test_22(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bKEK[32];
    BYTE bKeyUnderKEK[32];
    int  nKeyLen;
    BYTE bKeyUnderLMK[32];
    BYTE bKeyUnderLMKExp[32];

    bufclr(bKEK);
    bufclr(bKeyUnderKEK);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderLMKExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    nKeyLen = 25;
    /* 1122 3344 5566 7788 */
    memcpy(bKeyUnderKEK, "\xB4\xCC\x3F\xD9\xD8\xD9\x52\x14", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nAlgo        = %d\n", nAlgo);
    DspHex("[IN ]bKEK         =", bKEK, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]bKeyUnderKEK =", bKeyUnderKEK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITranslateKeyInTo(nSock, nAlgo, bKEK, bKeyUnderKEK, \
                                  nKeyLen, bKeyUnderLMK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效数据长度[25]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TranslateKeyInTo_GM_Test_01(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bKEK[32];
	BYTE bKeyUnderKEK[32];
	int  nKeyLen;
	BYTE bKeyUnderLMK[32];
	BYTE bKeyUnderLMKExp[32];

	bufclr(bKEK);
	bufclr(bKeyUnderLMK);
	bufclr(bKeyUnderKEK);
	bufclr(bKeyUnderLMKExp);

	nAlgo = 1;
	/* 0123 4567 89AB CDEF */
	memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
	nKeyLen = 8;
	/* 1023 3245 5467 7689 */
	memcpy(bKeyUnderKEK, "\xED\x91\x88\x2F\xB6\xAF\xBD\xAF", 8);
	memcpy(bKeyUnderLMKExp, "\x34\xF4\xFE\x76\x33\xA8\x03\x5F", 8);

	XXX_INPUT_XXX
	printf("[IN ]nSock        = %d\n", nSock);
	printf("[IN ]nAlgo        = %d\n", nAlgo);
	DspHex("[IN ]bKEK         =", bKEK, 8);
	printf("[IN ]nKeyLen      = %d\n", nKeyLen);
	DspHex("[IN ]bKeyUnderLMK =", bKeyUnderKEK, 8);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPITranslateKeyInTo_GM(nSock, nAlgo, bKEK, bKeyUnderKEK, \
			nKeyLen, bKeyUnderLMK);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "Algo=1，DataLen=8测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[OUT]bKeyUnderKEK    =", bKeyUnderLMK, 8);
	DspHex("[OUT]bKeyUnderKEKExp =", bKeyUnderLMKExp, 8);
	ASSERT_OUT_HEX(bKeyUnderLMK, bKeyUnderLMKExp, 8);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void TranslateKeyInTo_GM_Test_02(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bKEK[32];
	BYTE bKeyUnderKEK[32];
	int  nKeyLen;
	BYTE bKeyUnderLMK[32];
	BYTE bKeyUnderLMKExp[32];

	bufclr(bKEK);
	bufclr(bKeyUnderKEK);
	bufclr(bKeyUnderLMK);
	bufclr(bKeyUnderLMKExp);

	nAlgo = 2;
	/* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
	memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
			16);
	nKeyLen = 8;
	/* 1023 3245 5467 7689 */
	memcpy(bKeyUnderKEK, "\xF1\x6C\x5A\xA6\x4E\x30\xFC\x15", 8);
	memcpy(bKeyUnderLMKExp, "\x34\xF4\xFE\x76\x33\xA8\x03\x5F", 8);

	XXX_INPUT_XXX
	printf("[IN ]nSock        = %d\n", nSock);
	printf("[IN ]nAlgo        = %d\n", nAlgo);
	DspHex("[IN ]bKEK         =", bKEK, 16);
	printf("[IN ]nKeyLen      = %d\n", nKeyLen);
	DspHex("[IN ]bKeyUnderKEK =", bKeyUnderKEK, 8);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPITranslateKeyInTo_GM(nSock, nAlgo, bKEK, bKeyUnderKEK, \
			nKeyLen, bKeyUnderLMK);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "Algo=2，DataLen=8测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[OUT]bKeyUnderLMK    =", bKeyUnderLMK, 8);
	DspHex("[OUT]bKeyUnderLMKExp =", bKeyUnderLMKExp, 8);
	ASSERT_OUT_HEX(bKeyUnderLMK, bKeyUnderLMKExp, 8);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void TranslateKeyInTo_GM_Test_03(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bKEK[32];
	BYTE bKeyUnderKEK[32];
	int  nKeyLen;
	BYTE bKeyUnderLMK[32];
	BYTE bKeyUnderLMKExp[32];

	bufclr(bKEK);
	bufclr(bKeyUnderKEK);
	bufclr(bKeyUnderLMK);
	bufclr(bKeyUnderLMKExp);

	nAlgo = 3;
	/* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8796 A5B4 C3D2 E1F0 */
	memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
			"\x59\x99\xC3\x06\xAB\x84\x01\xB2",\
			24);
	nKeyLen = 8;
	/* 1023 3245 5467 7689 */
	memcpy(bKeyUnderKEK, "\xE3\x6B\x3F\x4B\x69\xD7\xA2\xBB", 8);
	memcpy(bKeyUnderLMKExp, "\x34\xF4\xFE\x76\x33\xA8\x03\x5F", 8);

	XXX_INPUT_XXX
	printf("[IN ]nSock        = %d\n", nSock);
	printf("[IN ]nAlgo        = %d\n", nAlgo);
	DspHex("[IN ]bKEK         =", bKEK, 24);
	printf("[IN ]nKeyLen      = %d\n", nKeyLen);
	DspHex("[IN ]bKeyUnderKEK =", bKeyUnderKEK, 8);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPITranslateKeyInTo_GM(nSock, nAlgo, bKEK, bKeyUnderKEK, \
			nKeyLen, bKeyUnderLMK);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "Algo=3，DataLen=8测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[OUT]bKeyUnderLMK    =", bKeyUnderLMK, 8);
	DspHex("[OUT]bKeyUnderLMKExp =", bKeyUnderLMKExp, 8);
	ASSERT_OUT_HEX(bKeyUnderLMK, bKeyUnderLMKExp, 8);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void TranslateKeyInTo_GM_Test_04(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bKEK[32];
	BYTE bKeyUnderKEK[32];
	int  nKeyLen;
	BYTE bKeyUnderLMK[32];
	BYTE bKeyUnderLMKExp[32];

	bufclr(bKEK);
	bufclr(bKeyUnderKEK);
	bufclr(bKeyUnderLMK);
	bufclr(bKeyUnderLMKExp);

	nAlgo = 4;
	/* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
	memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
			16);
	nKeyLen = 16;
	/* 1122 3344 5566 7788 99AA BBCC DDEE FF00*/
	memcpy(bKeyUnderKEK, "\xD8\xB1\x62\x84\x56\x1B\xC1\x81\x3F\xA2\x2C\x7F\x63\xE0\xFA\x23", 16);
	memcpy(bKeyUnderLMKExp, "\x91\x21\x98\xF1\x03\x6B\xBA\x33\x8C\x35\x9E\x9E\xE5\xA5\x72\x0D", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock        = %d\n", nSock);
	printf("[IN ]nAlgo        = %d\n", nAlgo);
	DspHex("[IN ]bKEK         =", bKEK, 16);
	printf("[IN ]nKeyLen      = %d\n", nKeyLen);
	DspHex("[IN ]bKeyUnderKEK =", bKeyUnderKEK, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPITranslateKeyInTo_GM(nSock, nAlgo, bKEK, bKeyUnderKEK, \
			nKeyLen, bKeyUnderLMK);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "Algo=4，DataLen=16测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[OUT]bKeyUnderLMK    =", bKeyUnderLMK, 16);
	DspHex("[OUT]bKeyUnderLMKExp =", bKeyUnderLMKExp, 16);
	ASSERT_OUT_HEX(bKeyUnderLMK, bKeyUnderLMKExp, 16);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void TranslateKeyInTo_GM_Test_05(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bKEK[32];
	BYTE bKeyUnderKEK[32];
	int  nKeyLen;
	BYTE bKeyUnderLMK[32];
	BYTE bKeyUnderLMKExp[32];

	bufclr(bKEK);
	bufclr(bKeyUnderKEK);
	bufclr(bKeyUnderLMK);
	bufclr(bKeyUnderLMKExp);

	nAlgo = 1;
	/* 0123 4567 89AB CDEF */
	memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
	nKeyLen = 16;
	/* 1122 3344 5566 7788 99AA BBCC DDEE FF00 */
	memcpy(bKeyUnderKEK, "\xB4\xCC\x3F\xD9\xD8\xD9\x52\x14" \
			"\x15\x79\x65\x7C\x43\x26\x3E\x1E",\
			16);
	memcpy(bKeyUnderLMKExp, "\x91\x21\x98\xF1\x03\x6B\xBA\x33" \
			"\x8C\x35\x9E\x9E\xE5\xA5\x72\x0D",\
			16);

	XXX_INPUT_XXX
	printf("[IN ]nSock        = %d\n", nSock);
	printf("[IN ]nAlgo        = %d\n", nAlgo);
	DspHex("[IN ]bKEK         =", bKEK, 8);
	printf("[IN ]nKeyLen      = %d\n", nKeyLen);
	DspHex("[IN ]bKeyUnderKEK =", bKeyUnderKEK, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPITranslateKeyInTo(nSock, nAlgo, bKEK, bKeyUnderKEK, \
			nKeyLen, bKeyUnderLMK);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "Algo=1，DataLen=16测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[OUT]bKeyUnderLMK    =", bKeyUnderLMK, 16);
	DspHex("[OUT]bKeyUnderLMKExp =", bKeyUnderLMKExp, 16);
	ASSERT_OUT_HEX(bKeyUnderLMK, bKeyUnderLMKExp, 16);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void TranslateKeyInTo_GM_Test_06(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bKEK[32];
	BYTE bKeyUnderKEK[32];
	int  nKeyLen;
	BYTE bKeyUnderLMK[32];
	BYTE bKeyUnderLMKExp[32];

	bufclr(bKEK);
	bufclr(bKeyUnderKEK);
	bufclr(bKeyUnderLMK);
	bufclr(bKeyUnderLMKExp);

	nAlgo = 2;
	/* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
	memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
			16);
	nKeyLen = 16;
	/* 1023 3245 5467 7689 98AB BACD DCEF FE01 */
	memcpy(bKeyUnderKEK, 
			"\xF1\x6C\x5A\xA6\x4E\x30\xFC\x15" \
			"\x81\x25\x8F\xE4\xB8\xB2\xB5\x4F" \
			, 16);
	memcpy(bKeyUnderLMKExp, 
			"\x34\xF4\xFE\x76\x33\xA8\x03\x5F" \
			"\x25\x25\x12\x2F\x72\xE8\x35\x01" \
			, 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock        = %d\n", nSock);
	printf("[IN ]nAlgo        = %d\n", nAlgo);
	DspHex("[IN ]bKEK         =", bKEK, 16);
	printf("[IN ]nKeyLen      = %d\n", nKeyLen);
	DspHex("[IN ]bKeyUnderKEK =", bKeyUnderKEK, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPITranslateKeyInTo_GM(nSock, nAlgo, bKEK, bKeyUnderKEK, \
			nKeyLen, bKeyUnderLMK);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "Algo=2，DataLen=16测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[OUT]bKeyUnderLMK    =", bKeyUnderLMK, 16);
	DspHex("[OUT]bKeyUnderLMKExp =", bKeyUnderLMKExp, 16);
	ASSERT_OUT_HEX(bKeyUnderLMK, bKeyUnderLMKExp, 16);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void TranslateKeyInTo_GM_Test_07(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bKEK[32];
	BYTE bKeyUnderKEK[32];
	int  nKeyLen;
	BYTE bKeyUnderLMK[32];
	BYTE bKeyUnderLMKExp[32];

	bufclr(bKEK);
	bufclr(bKeyUnderKEK);
	bufclr(bKeyUnderLMK);
	bufclr(bKeyUnderLMKExp);

	nAlgo = 3;
	/* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8796 A5B4 C3D2 E1F0 */
	memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
			"\x59\x99\xC3\x06\xAB\x84\x01\xB2",\
			24);
	nKeyLen = 16;
	/* 1023 3245 5467 7689 98AB BACD DCEF FE01 */
	memcpy(bKeyUnderKEK, 
			"\xE3\x6B\x3F\x4B\x69\xD7\xA2\xBB" \
			"\x3B\x31\x80\x3D\x25\x79\x93\x09" \
			, 16);
	memcpy(bKeyUnderLMKExp, 
			"\x34\xF4\xFE\x76\x33\xA8\x03\x5F" \
			"\x25\x25\x12\x2F\x72\xE8\x35\x01" \
			, 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock        = %d\n", nSock);
	printf("[IN ]nAlgo        = %d\n", nAlgo);
	DspHex("[IN ]bKEK         =", bKEK, 24);
	printf("[IN ]nKeyLen      = %d\n", nKeyLen);
	DspHex("[IN ]bKeyUnderKEK =", bKeyUnderKEK, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPITranslateKeyInTo_GM(nSock, nAlgo, bKEK, bKeyUnderKEK, \
			nKeyLen, bKeyUnderLMK);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "Algo=3，DataLen=16测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[OUT]bKeyUnderLMK    =", bKeyUnderLMK, 16);
	DspHex("[OUT]bKeyUnderLMKExp =", bKeyUnderLMKExp, 16);
	ASSERT_OUT_HEX(bKeyUnderLMK, bKeyUnderLMKExp, 16);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void TranslateKeyInTo_GM_Test_08(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bKEK[32];
	BYTE bKeyUnderKEK[32];
	int  nKeyLen;
	BYTE bKeyUnderLMK[32];
	BYTE bKeyUnderLMKExp[32];

	bufclr(bKEK);
	bufclr(bKeyUnderKEK);
	bufclr(bKeyUnderLMK);
	bufclr(bKeyUnderLMKExp);

	nAlgo = 1;
	/* 0123 4567 89AB CDEF */
	memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
	nKeyLen = 24;
	/* 1122 3344 5566 7788 99AA BBCC DDEE FF00 048C 159D 26AE 37BF */
	memcpy(bKeyUnderKEK, "\xB4\xCC\x3F\xD9\xD8\xD9\x52\x14" \
			"\x15\x79\x65\x7C\x43\x26\x3E\x1E" \
			"\x42\x7E\x63\xF4\x1F\xDF\x69\xE7",\
			24);
	memcpy(bKeyUnderLMKExp, "\x91\x21\x98\xF1\x03\x6B\xBA\x33" \
			"\x8C\x35\x9E\x9E\xE5\xA5\x72\x0D" \
			"\xF3\x16\x51\xBB\xA0\x53\x71\xCB",\
			24);

	XXX_INPUT_XXX
	printf("[IN ]nSock        = %d\n", nSock);
	printf("[IN ]nAlgo        = %d\n", nAlgo);
	DspHex("[IN ]bKEK         =", bKEK, 8);
	printf("[IN ]nKeyLen      = %d\n", nKeyLen);
	DspHex("[IN ]bKeyUnderKEK =", bKeyUnderKEK, 24);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPITranslateKeyInTo_GM(nSock, nAlgo, bKEK, bKeyUnderKEK, \
			nKeyLen, bKeyUnderLMK);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "Algo=1，DataLen=24测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[OUT]bKeyUnderLMK    =", bKeyUnderLMK, 24);
	DspHex("[OUT]bKeyUnderLMKExp =", bKeyUnderLMKExp, 24);
	ASSERT_OUT_HEX(bKeyUnderLMK, bKeyUnderLMKExp, 24);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void TranslateKeyInTo_GM_Test_09(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bKEK[32];
	BYTE bKeyUnderKEK[32];
	int  nKeyLen;
	BYTE bKeyUnderLMK[32];
	BYTE bKeyUnderLMKExp[32];

	bufclr(bKEK);
	bufclr(bKeyUnderKEK);
	bufclr(bKeyUnderLMK);
	bufclr(bKeyUnderLMKExp);

	nAlgo = 2;
	/* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
	memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
			16);
	nKeyLen = 24;
	/* 1122 3344 5566 7788 99AA BBCC DDEE FF00 048C 159D 26AE 37BF */
	memcpy(bKeyUnderKEK, "\x3E\xB3\xB7\x25\x76\xBB\xBE\x83" \
			"\x56\x01\x10\x4F\x2D\xF9\x44\x05" \
			"\x56\x29\x2B\xFE\xB2\x42\x1B\xEF",\
			24);
	memcpy(bKeyUnderLMKExp, "\x91\x21\x98\xF1\x03\x6B\xBA\x33" \
			"\x8C\x35\x9E\x9E\xE5\xA5\x72\x0D" \
			"\xF3\x16\x51\xBB\xA0\x53\x71\xCB",\
			24);

	XXX_INPUT_XXX
	printf("[IN ]nSock        = %d\n", nSock);
	printf("[IN ]nAlgo        = %d\n", nAlgo);
	DspHex("[IN ]bKEK         =", bKEK, 16);
	printf("[IN ]nKeyLen      = %d\n", nKeyLen);
	DspHex("[IN ]bKeyUnderKEK =", bKeyUnderKEK, 24);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPITranslateKeyInTo_GM(nSock, nAlgo, bKEK, bKeyUnderKEK, \
			nKeyLen, bKeyUnderLMK);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "Algo=2，DataLen=24测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[OUT]bKeyUnderLMK    =", bKeyUnderLMK, 24);
	DspHex("[OUT]bKeyUnderLMKExp =", bKeyUnderLMKExp, 24);
	ASSERT_OUT_HEX(bKeyUnderLMK, bKeyUnderLMKExp, 24);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void TranslateKeyInTo_GM_Test_10(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bKEK[32];
	BYTE bKeyUnderKEK[32];
	int  nKeyLen;
	BYTE bKeyUnderLMK[32];
	BYTE bKeyUnderLMKExp[32];

	bufclr(bKEK);
	bufclr(bKeyUnderKEK);
	bufclr(bKeyUnderLMK);
	bufclr(bKeyUnderLMKExp);

	nAlgo = 3;
	/* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8796 A5B4 C3D2 E1F0 */
	memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
			"\x59\x99\xC3\x06\xAB\x84\x01\xB2",\
			24);
	nKeyLen = 24;
	/* 1023 3245 5467 7689 98AB BACD DCEF FE01 048C 159D 26AE 37BF */
	memcpy(bKeyUnderKEK, 
			"\xE3\x6B\x3F\x4B\x69\xD7\xA2\xBB" \
			"\x3B\x31\x80\x3D\x25\x79\x93\x09" \
			"\x7F\xCB\xE4\x66\x2B\x30\x92\x3B" \
			, 24);
	memcpy(bKeyUnderLMKExp, 
			"\x34\xF4\xFE\x76\x33\xA8\x03\x5F" \
			"\x25\x25\x12\x2F\x72\xE8\x35\x01" \
			"\xF3\x16\x51\xBB\xA0\x53\x71\xCB" \
			, 24);

	XXX_INPUT_XXX
	printf("[IN ]nSock        = %d\n", nSock);
	printf("[IN ]nAlgo        = %d\n", nAlgo);
	DspHex("[IN ]bKEK         =", bKEK, 24);
	printf("[IN ]nKeyLen      = %d\n", nKeyLen);
	DspHex("[IN ]bKeyUnderKEK =", bKeyUnderKEK, 24);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPITranslateKeyInTo_GM(nSock, nAlgo, bKEK, bKeyUnderKEK, \
			nKeyLen, bKeyUnderLMK);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "Algo=3，DataLen=24测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[OUT]bKeyUnderLMK    =", bKeyUnderLMK, 24);
	DspHex("[OUT]bKeyUnderLMKExp =", bKeyUnderLMKExp, 24);
	ASSERT_OUT_HEX(bKeyUnderLMK, bKeyUnderLMKExp, 24);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void TranslateKeyInTo_GM_Test_11(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = -1;

	int  nAlgo;
	BYTE bKEK[32];
	BYTE bKeyUnderKEK[32];
	int  nKeyLen;
	BYTE bKeyUnderLMK[32];
	BYTE bKeyUnderLMKExp[32];

	bufclr(bKEK);
	bufclr(bKeyUnderKEK);
	bufclr(bKeyUnderLMK);
	bufclr(bKeyUnderLMKExp);

	nAlgo = 4;
	/* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
	memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
			16);
	nKeyLen = 16;
	/* 1122 3344 5566 7788 99AA BBCC DDEE FF00*/
	memcpy(bKeyUnderKEK, "\xD8\xB1\x62\x84\x56\x1B\xC1\x81\x3F\xA2\x2C\x7F\x63\xE0\xFA\x23", 16);
	memcpy(bKeyUnderLMKExp, "\x91\x21\x98\xF1\x03\x6B\xBA\x33\x8C\x35\x9E\x9E\xE5\xA5\x72\x0D", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock        = %d\n", nSock);
	printf("[IN ]nAlgo        = %d\n", nAlgo);
	DspHex("[IN ]bKEK         =", bKEK, 16);
	printf("[IN ]nKeyLen      = %d\n", nKeyLen);
	DspHex("[IN ]bKeyUnderKEK =", bKeyUnderKEK, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPITranslateKeyInTo_GM(nSock, nAlgo, bKEK, bKeyUnderKEK, \
			nKeyLen, bKeyUnderLMK);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 3, "无效Socket ID[-1]测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void TranslateKeyInTo_GM_Test_12(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = 8;

	int  nAlgo;
	BYTE bKEK[32];
	BYTE bKeyUnderKEK[32];
	int  nKeyLen;
	BYTE bKeyUnderLMK[32];
	BYTE bKeyUnderLMKExp[32];

	bufclr(bKEK);
	bufclr(bKeyUnderKEK);
	bufclr(bKeyUnderLMK);
	bufclr(bKeyUnderLMKExp);

	nAlgo = 4;
	/* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
	memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
			16);
	nKeyLen = 16;
	/* 1122 3344 5566 7788 99AA BBCC DDEE FF00*/
	memcpy(bKeyUnderKEK, "\xD8\xB1\x62\x84\x56\x1B\xC1\x81\x3F\xA2\x2C\x7F\x63\xE0\xFA\x23", 16);
	memcpy(bKeyUnderLMKExp, "\x91\x21\x98\xF1\x03\x6B\xBA\x33\x8C\x35\x9E\x9E\xE5\xA5\x72\x0D", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock        = %d\n", nSock);
	printf("[IN ]nAlgo        = %d\n", nAlgo);
	DspHex("[IN ]bKEK         =", bKEK, 16);
	printf("[IN ]nKeyLen      = %d\n", nKeyLen);
	DspHex("[IN ]bKeyUnderKEK =", bKeyUnderKEK, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPITranslateKeyInTo_GM(nSock, nAlgo, bKEK, bKeyUnderKEK, \
			nKeyLen, bKeyUnderLMK);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 3, "无效Socket ID[8]测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void TranslateKeyInTo_GM_Test_13(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bKEK[32];
	BYTE bKeyUnderKEK[32];
	int  nKeyLen;
	BYTE bKeyUnderLMK[32];
	BYTE bKeyUnderLMKExp[32];

	bufclr(bKEK);
	bufclr(bKeyUnderKEK);
	bufclr(bKeyUnderLMK);
	bufclr(bKeyUnderLMKExp);
	nAlgo = 0;
	/* 0123 4567 89AB CDEF */
	memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
	nKeyLen = 8;
	/* 1122 3344 5566 7788 */
	memcpy(bKeyUnderKEK, "\xB4\xCC\x3F\xD9\xD8\xD9\x52\x14", 8);

	XXX_INPUT_XXX
	printf("[IN ]nSock        = %d\n", nSock);
	printf("[IN ]nAlgo        = %d\n", nAlgo);
	DspHex("[IN ]bKEK         =", bKEK, 8);
	printf("[IN ]nKeyLen      = %d\n", nKeyLen);
	DspHex("[IN ]bKeyUnderKEK =", bKeyUnderKEK, 8);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPITranslateKeyInTo_GM(nSock, nAlgo, bKEK, bKeyUnderKEK, \
			nKeyLen, bKeyUnderLMK);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 1, "无效算法类型[0]测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void TranslateKeyInTo_GM_Test_14(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bKEK[32];
	BYTE bKeyUnderKEK[32];
	int  nKeyLen;
	BYTE bKeyUnderLMK[32];
	BYTE bKeyUnderLMKExp[32];

	bufclr(bKEK);
	bufclr(bKeyUnderKEK);
	bufclr(bKeyUnderLMK);
	bufclr(bKeyUnderLMKExp);
	nAlgo = 5;
	/* 0123 4567 89AB CDEF */
	memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
	nKeyLen = 8;
	/* 1122 3344 5566 7788 */
	memcpy(bKeyUnderKEK, "\xB4\xCC\x3F\xD9\xD8\xD9\x52\x14", 8);

	XXX_INPUT_XXX
	printf("[IN ]nSock        = %d\n", nSock);
	printf("[IN ]nAlgo        = %d\n", nAlgo);
	DspHex("[IN ]bKEK         =", bKEK, 8);
	printf("[IN ]nKeyLen      = %d\n", nKeyLen);
	DspHex("[IN ]bKeyUnderKEK =", bKeyUnderKEK, 8);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPITranslateKeyInTo_GM(nSock, nAlgo, bKEK, bKeyUnderKEK, \
			nKeyLen, bKeyUnderLMK);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 1, "无效算法类型[5]测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void TranslateKeyInTo_GM_Test_15(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bKEK[32];
	BYTE bKeyUnderKEK[32];
	int  nKeyLen;
	BYTE bKeyUnderLMK[32];
	BYTE bKeyUnderLMKExp[32];

	bufclr(bKEK);
	bufclr(bKeyUnderKEK);
	bufclr(bKeyUnderLMK);
	bufclr(bKeyUnderLMKExp);

	nAlgo = 4;
	/* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
	memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
			16);
	nKeyLen = 0;
	/* 1122 3344 5566 7788 99AA BBCC DDEE FF00*/
	memcpy(bKeyUnderKEK, "\xD8\xB1\x62\x84\x56\x1B\xC1\x81\x3F\xA2\x2C\x7F\x63\xE0\xFA\x23", 16);
	memcpy(bKeyUnderLMKExp, "\x91\x21\x98\xF1\x03\x6B\xBA\x33\x8C\x35\x9E\x9E\xE5\xA5\x72\x0D", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock        = %d\n", nSock);
	printf("[IN ]nAlgo        = %d\n", nAlgo);
	DspHex("[IN ]bKEK         =", bKEK, 16);
	printf("[IN ]nKeyLen      = %d\n", nKeyLen);
	DspHex("[IN ]bKeyUnderKEK =", bKeyUnderKEK, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPITranslateKeyInTo_GM(nSock, nAlgo, bKEK, bKeyUnderKEK, \
			nKeyLen, bKeyUnderLMK);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 1, "无效数据长度[0]测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void TranslateKeyInTo_GM_Test_16(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bKEK[32];
	BYTE bKeyUnderKEK[32];
	int  nKeyLen;
	BYTE bKeyUnderLMK[32];
	BYTE bKeyUnderLMKExp[32];

	bufclr(bKEK);
	bufclr(bKeyUnderKEK);
	bufclr(bKeyUnderLMK);
	bufclr(bKeyUnderLMKExp);

	nAlgo = 4;
	/* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
	memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
			16);
	nKeyLen = 8;
	/* 1122 3344 5566 7788 99AA BBCC DDEE FF00*/
	memcpy(bKeyUnderKEK, "\xD8\xB1\x62\x84\x56\x1B\xC1\x81\x3F\xA2\x2C\x7F\x63\xE0\xFA\x23", 16);
	memcpy(bKeyUnderLMKExp, "\x91\x21\x98\xF1\x03\x6B\xBA\x33\x8C\x35\x9E\x9E\xE5\xA5\x72\x0D", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock        = %d\n", nSock);
	printf("[IN ]nAlgo        = %d\n", nAlgo);
	DspHex("[IN ]bKEK         =", bKEK, 16);
	printf("[IN ]nKeyLen      = %d\n", nKeyLen);
	DspHex("[IN ]bKeyUnderKEK =", bKeyUnderKEK, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPITranslateKeyInTo_GM(nSock, nAlgo, bKEK, bKeyUnderKEK, \
			nKeyLen, bKeyUnderLMK);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 1, "无效数据长度[8]测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void TranslateKeyInTo_GM_Test_17(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bKEK[32];
	BYTE bKeyUnderKEK[32];
	int  nKeyLen;
	BYTE bKeyUnderLMK[32];
	BYTE bKeyUnderLMKExp[32];

	bufclr(bKEK);
	bufclr(bKeyUnderKEK);
	bufclr(bKeyUnderLMK);
	bufclr(bKeyUnderLMKExp);

	nAlgo = 4;
	/* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
	memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
			16);
	nKeyLen = 24;
	/* 1122 3344 5566 7788 99AA BBCC DDEE FF00*/
	memcpy(bKeyUnderKEK, "\xD8\xB1\x62\x84\x56\x1B\xC1\x81\x3F\xA2\x2C\x7F\x63\xE0\xFA\x23", 16);
	memcpy(bKeyUnderLMKExp, "\x91\x21\x98\xF1\x03\x6B\xBA\x33\x8C\x35\x9E\x9E\xE5\xA5\x72\x0D", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock        = %d\n", nSock);
	printf("[IN ]nAlgo        = %d\n", nAlgo);
	DspHex("[IN ]bKEK         =", bKEK, 16);
	printf("[IN ]nKeyLen      = %d\n", nKeyLen);
	DspHex("[IN ]bKeyUnderKEK =", bKeyUnderKEK, 24);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPITranslateKeyInTo_GM(nSock, nAlgo, bKEK, bKeyUnderKEK, \
			nKeyLen, bKeyUnderLMK);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 1, "无效数据长度[24]测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void TranslateKeyInTo_GM_Test_18(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bKEK[32];
	BYTE bKeyUnderKEK[32];
	int  nKeyLen;
	BYTE bKeyUnderLMK[32];
	BYTE bKeyUnderLMKExp[32];

	bufclr(bKEK);
	bufclr(bKeyUnderKEK);
	bufclr(bKeyUnderLMK);
	bufclr(bKeyUnderLMKExp);

	nAlgo = 4;
	/* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
	memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
			"\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
			16);
	nKeyLen = 32;
	/* 1122 3344 5566 7788 99AA BBCC DDEE FF00*/
	memcpy(bKeyUnderKEK, "\xD8\xB1\x62\x84\x56\x1B\xC1\x81\x3F\xA2\x2C\x7F\x63\xE0\xFA\x23", 16);
	memcpy(bKeyUnderLMKExp, "\x91\x21\x98\xF1\x03\x6B\xBA\x33\x8C\x35\x9E\x9E\xE5\xA5\x72\x0D", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock        = %d\n", nSock);
	printf("[IN ]nAlgo        = %d\n", nAlgo);
	DspHex("[IN ]bKEK         =", bKEK, 16);
	printf("[IN ]nKeyLen      = %d\n", nKeyLen);
	DspHex("[IN ]bKeyUnderKEK =", bKeyUnderKEK, 32);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPITranslateKeyInTo_GM(nSock, nAlgo, bKEK, bKeyUnderKEK, \
			nKeyLen, bKeyUnderLMK);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 1, "无效数据长度[32]测试未失败");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	XXX_OUTPUT_NONE_XXX
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void TranslateKeyInTo_GM_Test_19(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bKEK[32];
	BYTE bKeyUnderKEK[32];
	int  nKeyLen;
	BYTE bKeyUnderLMK[32];
	BYTE bKeyUnderLMKExp[32];

	bufclr(bKEK);
	bufclr(bKeyUnderKEK);
	bufclr(bKeyUnderLMK);
	bufclr(bKeyUnderLMKExp);

	nAlgo = 4;
	nKeyLen = 16;
	//bKEK = 0000 0000 0000 0000 0000 0000 0000 0000
	memcpy(bKEK, "\x1F\x1E\xA8\x25\x54\x22\xD2\x75\x1F\x1E\xA8\x25\x54\x22\xD2\x75", 16);
	/* 1122 3344 5566 7788 99AA BBCC DDEE FF00*/
	memcpy(bKeyUnderKEK, "\xAB\x53\x46\x28\xA8\xE2\x82\xBD\x50\x94\xD0\x3C\xCA\xDE\x1D\x81", 16);
	memcpy(bKeyUnderLMKExp, "\x91\x21\x98\xF1\x03\x6B\xBA\x33\x8C\x35\x9E\x9E\xE5\xA5\x72\x0D", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock        = %d\n", nSock);
	printf("[IN ]nAlgo        = %d\n", nAlgo);
	DspHex("[IN ]bKEK         =", bKEK, 16);
	printf("[IN ]nKeyLen      = %d\n", nKeyLen);
	DspHex("[IN ]bKeyUnderKEK =", bKeyUnderKEK, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPITranslateKeyInTo_GM(nSock, nAlgo, bKEK, bKeyUnderKEK, \
			nKeyLen, bKeyUnderLMK);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "KEK明文为空，测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[OUT]bKeyUnderLMK    =", bKeyUnderLMK, 16);
    DspHex("[OUT]bKeyUnderLMKExp =", bKeyUnderLMKExp, 16);
    ASSERT_OUT_HEX(bKeyUnderLMK, bKeyUnderLMKExp, 16);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void TranslateKeyInTo_GM_Test_20(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;

	int  nAlgo;
	BYTE bKEK[32];
	BYTE bKeyUnderKEK[32];
	int  nKeyLen;
	BYTE bKeyUnderLMK[32];
	BYTE bKeyUnderLMKExp[32];

	bufclr(bKEK);
	bufclr(bKeyUnderKEK);
	bufclr(bKeyUnderLMK);
	bufclr(bKeyUnderLMKExp);

	nAlgo = 4;
	nKeyLen = 16;
	//bKEK = 0123 4567 89AB CDEF FEDC BA98 7654 3210
	memcpy(bKEK, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A", 16);
	/* 0000 0000 0000 0000 0000 0000 0000 0000 */
	memcpy(bKeyUnderKEK, "\x26\x77\xF4\x6B\x09\xC1\x22\xCC\x97\x55\x33\x10\x5B\xD4\xA2\x2A", 16);
	memcpy(bKeyUnderLMKExp, "\x1F\x1E\xA8\x25\x54\x22\xD2\x75\x1F\x1E\xA8\x25\x54\x22\xD2\x75", 16);

	XXX_INPUT_XXX
	printf("[IN ]nSock        = %d\n", nSock);
	printf("[IN ]nAlgo        = %d\n", nAlgo);
	DspHex("[IN ]bKEK         =", bKEK, 16);
	printf("[IN ]nKeyLen      = %d\n", nKeyLen);
	DspHex("[IN ]bKeyUnderKEK =", bKeyUnderKEK, 16);
	XXX_INPUT_XXX

	/* Call Test Target Function Start */
	nRet = SMAPITranslateKeyInTo_GM(nSock, nAlgo, bKEK, bKeyUnderKEK, \
			nKeyLen, bKeyUnderLMK);
	/* Call Test Target Function End */

	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "KEY明文为空，测试未成功");
	XXX_RESULT_XXX

	XXX_OUTPUT_XXX
	DspHex("[OUT]bKeyUnderLMK    =", bKeyUnderLMK, 16);
    DspHex("[OUT]bKeyUnderLMKExp =", bKeyUnderLMKExp, 16);
    ASSERT_OUT_HEX(bKeyUnderLMK, bKeyUnderLMKExp, 16);
	XXX_OUTPUT_XXX

	XXX_TEST_END_XXX
}

void ExpMod_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
	
	BYTE bpBase[2048];
	int nBaseLen;
	BYTE bpExp[2048];
	int nExpLen;
	BYTE bpModule[2048];
	int nModuleLen;
	BYTE bpOut[2048];
	int npOutLen;

    bufclr(bpBase);
    bufclr(bpExp);
	bufclr(bpModule);
	bufclr(bpOut);

	nBaseLen = 10;
	nExpLen = 10;
	nModuleLen = 10;
	//bpBase = 0x31323334353637383930
	memcpy(bpBase,"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x30",nBaseLen);
	//bpExp = 0x31323334353637383930
	memcpy(bpExp,"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x30",nExpLen);
	//bpModule =0x39383736353433323130
	memcpy(bpModule,"\x39\x38\x37\x36\x35\x34\x33\x32\x31\x30",nModuleLen);

    XXX_INPUT_XXX
    DspHex("[IN ]bpBase      =", bpBase, nBaseLen);
    printf("[IN ]nBaseLen    = %d\n", nBaseLen);
    DspHex("[IN ]bpExp       =", bpExp, nExpLen);
    printf("[IN ]nExpLen     = %d\n", nExpLen);
    DspHex("[IN ]bpModule    =", bpModule, nModuleLen);
    printf("[IN ]nModuleLen  = %d\n", nModuleLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIExpMod(nSock, bpBase, nBaseLen, bpExp, \
                     nExpLen, bpModule, nModuleLen, bpOut, &npOutLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "正常测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bpOut    =", bpOut, npOutLen);
    printf("[OUT]npOutLen = %d\n", npOutLen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ExpMod_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
	
	BYTE bpBase[2048];
	int nBaseLen;
	BYTE bpExp[2048];
	int nExpLen;
	BYTE bpModule[2048];
	int nModuleLen;
	BYTE bpOut[2048];
	int npOutLen;

    bufclr(bpBase);
    bufclr(bpExp);
	bufclr(bpModule);
	bufclr(bpOut);

	nBaseLen = 1;
	nExpLen = 1;
	nModuleLen = 1;
	//bpBase = 0x05
	memcpy(bpBase,"\x05",nBaseLen);
	//bpExp = 0x02
	memcpy(bpExp,"\x02",nExpLen);
	//bpModule =0x0A
	memcpy(bpModule,"\x0A",nModuleLen);

    XXX_INPUT_XXX
    DspHex("[IN ]bpBase      =", bpBase, nBaseLen);
    printf("[IN ]nBaseLen    = %d\n", nBaseLen);
    DspHex("[IN ]bpExp       =", bpExp, nExpLen);
    printf("[IN ]nExpLen     = %d\n", nExpLen);
    DspHex("[IN ]bpModule    =", bpModule, nModuleLen);
    printf("[IN ]nModuleLen  = %d\n", nModuleLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIExpMod(nSock, bpBase, nBaseLen, bpExp, \
                     nExpLen, bpModule, nModuleLen, bpOut, &npOutLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "正常测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bpOut    =", bpOut, npOutLen);
    printf("[OUT]npOutLen = %d\n", npOutLen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ExpMod_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
	
	BYTE bpBase[2048];
	int nBaseLen;
	BYTE bpExp[2048];
	int nExpLen;
	BYTE bpModule[2048];
	int nModuleLen;
	BYTE bpOut[2048];
	int npOutLen;

    bufclr(bpBase);
    bufclr(bpExp);
	bufclr(bpModule);
	bufclr(bpOut);

	nBaseLen = 1;
	nExpLen = 1;
	nModuleLen = 1;
	//bpBase = 0x05
	memcpy(bpBase,"\x05",nBaseLen);
	//bpExp = 0x02
	memcpy(bpExp,"\x02",nExpLen);
	//bpModule =0x00
	memcpy(bpModule,"\x00",nModuleLen);

    XXX_INPUT_XXX
    DspHex("[IN ]bpBase      =", bpBase, nBaseLen);
    printf("[IN ]nBaseLen    = %d\n", nBaseLen);
    DspHex("[IN ]bpExp       =", bpExp, nExpLen);
    printf("[IN ]nExpLen     = %d\n", nExpLen);
    DspHex("[IN ]bpModule    =", bpModule, nModuleLen);
    printf("[IN ]nModuleLen  = %d\n", nModuleLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIExpMod(nSock, bpBase, nBaseLen, bpExp, \
                     nExpLen, bpModule, nModuleLen, bpOut, &npOutLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 5, "Module=0, 测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ExpMod_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = -1;
	
	BYTE bpBase[2048];
	int nBaseLen;
	BYTE bpExp[2048];
	int nExpLen;
	BYTE bpModule[2048];
	int nModuleLen;
	BYTE bpOut[2048];
	int npOutLen;

    bufclr(bpBase);
    bufclr(bpExp);
	bufclr(bpModule);
	bufclr(bpOut);

	nBaseLen = 1;
	nExpLen = 1;
	nModuleLen = 1;
	//bpBase = 0x05
	memcpy(bpBase,"\x05",nBaseLen);
	//bpExp = 0x02
	memcpy(bpExp,"\x02",nExpLen);
	//bpModule =0x00
	memcpy(bpModule,"\x00",nModuleLen);

    XXX_INPUT_XXX
    DspHex("[IN ]bpBase      =", bpBase, nBaseLen);
    printf("[IN ]nBaseLen    = %d\n", nBaseLen);
    DspHex("[IN ]bpExp       =", bpExp, nExpLen);
    printf("[IN ]nExpLen     = %d\n", nExpLen);
    DspHex("[IN ]bpModule    =", bpModule, nModuleLen);
    printf("[IN ]nModuleLen  = %d\n", nModuleLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIExpMod(nSock, bpBase, nBaseLen, bpExp, \
                     nExpLen, bpModule, nModuleLen, bpOut, &npOutLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "Socket[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ExpMod_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = 8;
	
	BYTE bpBase[2048];
	int nBaseLen;
	BYTE bpExp[2048];
	int nExpLen;
	BYTE bpModule[2048];
	int nModuleLen;
	BYTE bpOut[2048];
	int npOutLen;

    bufclr(bpBase);
    bufclr(bpExp);
	bufclr(bpModule);
	bufclr(bpOut);

	nBaseLen = 1;
	nExpLen = 1;
	nModuleLen = 1;
	//bpBase = 0x05
	memcpy(bpBase,"\x05",nBaseLen);
	//bpExp = 0x02
	memcpy(bpExp,"\x02",nExpLen);
	//bpModule =0x00
	memcpy(bpModule,"\x00",nModuleLen);

    XXX_INPUT_XXX
    DspHex("[IN ]bpBase      =", bpBase, nBaseLen);
    printf("[IN ]nBaseLen    = %d\n", nBaseLen);
    DspHex("[IN ]bpExp       =", bpExp, nExpLen);
    printf("[IN ]nExpLen     = %d\n", nExpLen);
    DspHex("[IN ]bpModule    =", bpModule, nModuleLen);
    printf("[IN ]nModuleLen  = %d\n", nModuleLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIExpMod(nSock, bpBase, nBaseLen, bpExp, \
                     nExpLen, bpModule, nModuleLen, bpOut, &npOutLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "Socket[8]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenBigPrime_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nPrimeBit;
    BYTE bPrime[1024];

    bufclr(bPrime);

    nPrimeBit = 512;

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nPrimeBit = %d\n", nPrimeBit);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenBigPrime(nSock, nPrimeBit, bPrime);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "512位素数测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bPrime    =", bPrime, 64);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenBigPrime_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nPrimeBit;
    BYTE bPrime[1024];

    bufclr(bPrime);

    nPrimeBit = 1024;

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nPrimeBit = %d\n", nPrimeBit);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenBigPrime(nSock, nPrimeBit, bPrime);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "1024位素数测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bPrime    =", bPrime, 128);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenBigPrime_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nPrimeBit;
    BYTE bPrime[2056];

    bufclr(bPrime);

    nPrimeBit = 2048;

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nPrimeBit = %d\n", nPrimeBit);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenBigPrime(nSock, nPrimeBit, bPrime);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "2048位素数测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bPrime    =", bPrime, 256);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

/*
void TransKeyIntoSKAndPrint_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  nAlgo;	//KEK加密算法类型 1-DES, 2-2DES, 3-3DES, 4-SM4
	int nSKAlg;	//非对称算法 1-RSA, 7-SM2
	int nPad;	//填充模式 SKAlg为1时有效 1-PKCS#1填充算法
	int uiIndex;	//索引位 0-使用外部部私钥
	BYTE bSK[2048];	//私钥的密文（被HMK加密），DER格式
	int nSKLen;
	BYTE bKeyByPK[2048];	//被公钥PK加密的密钥
	int nKeyCipherLen;
	char szServId[100];	//终端编号，ASCII字符
	int nServLen;
	//输出参数
	BYTE bKeyByHMK[2048];
	int nKeyByHMKLen;
	char szCheckValue[16];
	char KEK[50];

    bufclr(bSK);
	bufclr(bKeyByPK);
	bufclr(szServId);
	bufclr(bKeyByHMK);
	bufclr(szCheckValue);
	bufclr(KEK);

    nAlgo=2;
	nSKAlg=1;
	nPad=1;
	uiIndex=0;
	nSKLen=320;
	memcpy(bSK,"\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x6B\xF9\xD6\x7E\x7D\xA4\xE0\x5D\x57\xFC\x2F\xB6\x7D\x21\xD5\x10\xAA\xCD\xD1\x14\x15\x30\x69\xAD\x92\x00\x1A\xDE\x5F\x7E\xFF\x2E\x3E\x6D\x4B\xDA\xDC\x6A\xCB\xA6\x14\xA5\x73\xA6\x6B\xBF\x6C\xF2\x08\x36\x0B\x60\xAB\x49\xF2\x5E\xAC\x88\x2F\xB5\x56\x02\x15\x9A\x7E\xFC\xAF\xB4\xDC\x70\x9A\xC6\x6B\x4B\x79\x56\xF6\xF3\x71\x5D\x82\xE9\x98\xB8\xDF\x24\x52\x72\xB8\xEE\x16\x5D\x20\xF9\xA8\x87\x44\xF7\x9E\x89\x79\x33\x34\xCB\x6A\xFE\x14\xD4\xD9\x32\x6D\x3E\xF6\x43\x14\x9F\x20\x04\xBA\x56\x9B\x3E\xF7\xBD\xAC\xA6\x44\x64\x29\x42\x3E\xD3\x33\x7A\x52\xD2\x1D\x8E\x5B\x0F\x88\xD6\x18\xC4\x28\x56\xE7\x14\xA5\x80\xFA\xB6\x8C\x60\x7E\xAF\x18\xE0\x5B\x3E\x12\x9B\x74\x79\x56\xEC\xCF\x26\x04\x13\xE4\xF1\x97\x5F\x4C\x69\xAB\x00\xC8\x1B\x61\x64\xAB\xCF\xE7\x23\x5B\x0F\x05\x16\x95\xBD\x75\x95\x92\xBA\xA1\x4A\xBE\xC2\xDC\x7C\x65\x3E\x6C\x1A\x76\xDE\xA7\xA5\xB4\x4F\x1E\x6C\x11\x07\x45\x7C\xCC\xF0\x98\x88\x2A\x02\x02\x82\xF7\xF7\xC7\xBC\x37\xBB\x12\x09\x70\x03\x91\x67\x5B\x04\x92\x6B\x9C\xA8\xF8\x78\xFD\x9D\xFD\x4D\x40\x80\x2D\x79\xE8\x6D\x9C\x0E\xC6\x8D\xAB\x31\x32\x29\x17\xCA\xC3\x21\x01\xDC\x8E\x65\x5E\xD2\xC2\xB3\x3E\xC6\xA1\xDE\x22\x5F\x5A\x90\xDE\x67\x98\x4A\x40\x40\x5E\x01\xE4\xFE\xB0\x96\xD8\xAD\xF9\x9C\xF8\xD2\x5C\x9D\x69\x88\x55\x5B\x95\xAA\x77\x7A",nSKLen);
	nKeyCipherLen = 64;
	memcpy(bKeyByPK,"\x69\xd2\xaa\xb0\x8d\xa4\x38\xf2\xae\x87\x80\x5d\x29\x1b\x16\xb5\x6c\x54\x13\x4f\x3e\xa3\x60\x2a\xc3\x1e\x97\x2e\x2a\xf7\xe5\x51\x74\xe6\x7f\x4e\xca\xe9\x85\xbb\x45\x37\x0b\x2e\x09\x93\x15\xbb\xda\x91\x14\x12\x77\xf6\x52\x49\xc9\xfe\xb9\x85\x8b\xb4\x98\xc3",nKeyCipherLen);
	nServLen = 10;
	strcpy(szServId,"99BCAC9999");
	
	memcpy(KEK,"\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x41\x42\x43\x44\x45\x46",16);
	char bpk[1024];
	char outdata[1024];
	char outdata_1[1024];
	bufclr(bpk);
	bufclr(outdata);
	bufclr(outdata_1);
	int outlen, outlen_1;
	memcpy(bpk,"\x30\x48\x02\x41\x00\xB7\x33\x15\xF6\x73\x6A\xEC\x3C\x70\x1B\x49\x1E\xC2\x7E\x97\x4F\x39\x48\xE3\x1F\x16\x4E\x55\xA0\xEB\x02\x8C\x06\xCF\x19\x4A\x5C\xC5\xF7\xFD\x1A\xAE\xD8\x4A\xDF\xBB\x46\x40\x75\x70\x0F\xEC\xAF\x21\xEB\x9D\xD3\x72\x92\x4D\x11\x87\x32\xA8\xEB\xB0\xE5\xE3\xB9\x02\x03\x01\x00\x01",74);
	int retu = SMAPIPublicCalc(nSock,1,1,bpk,74,KEK,16,outdata,&outlen);
	printf("\nreturn:[%d]\n",retu);
	printf("outlen:[%d]\n",outlen);
	ShiftHexToChar(outdata,outdata_1,outlen);
	printf("outlen_1:[%d]\n",strlen(outdata_1));
	printf("out:%s\n",outdata_1);

	char temp[1024];
	bufclr(temp);
	bufclr(outdata_1);
	retu = SMAPIPrivateCalc(nSock,0,1,bSK,nSKLen,outdata,outlen,outdata_1,&outlen_1);
	printf("\nreturn:[%d]\n",retu);
	printf("outlen_1:[%d]\n",outlen_1);
	ShiftHexToChar(outdata_1,temp,outlen_1);
	printf("tempLen:[%d]\n",strlen(temp));
	printf("out:%s\n",temp);
	
    XXX_INPUT_XXX
    XXX_INPUT_XXX

    // Call Test Target Function Start 

    
    nRet = SMAPITransKeyIntoSKAndPrint(nSock,nAlgo,nSKAlg,nPad,uiIndex,\
			bSK,nSKLen,outdata,outlen,szServId,nServLen,\
			bKeyByHMK,&nKeyByHMKLen,szCheckValue);
    // Call Test Target Function End 

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "正常测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}
*/
/* For print */
void GenerateKey_Test_P(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKeyLen;
    char szServId[32];
    int  nServIdLen;
    int  nMode;
    int  nIndex;
    BYTE bKey[32];
    char szCheckValue[16];

    sprintf(szServId, "1234567890");
    nServIdLen = strlen(szServId);

    bufclr(bKey);
    bufclr(szCheckValue);

    nKeyLen = 16;
    nMode = 1;
    nIndex = 257;

    XXX_INPUT_XXX
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    printf("[IN ]nMode   = %d\n", nMode);
    printf("[IN ]nIndex  = %d\n", nIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenerateKey(nSock, nKeyLen, szServId, nServIdLen, \
                            nMode, nIndex, bKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "Sepcial NG");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKey        =", bKey, nKeyLen);
    printf("[OUT]szCheckValue = %s\n", szCheckValue);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

/* For Key Management Test */
BYTE KEK257[32];
BYTE KEK257CV[16];

void GenerateKey_Test_K(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKeyLen;
    char szServId[32];
    int  nServIdLen;
    int  nMode;
    int  nIndex;
    BYTE bKey[32];
    char szCheckValue[16];

    sprintf(szServId, "1234567890");
    nServIdLen = strlen(szServId);

    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(KEK257);
    bufclr(KEK257CV);

    nKeyLen = 16;
    nMode = 2;
    nIndex = 257;

    XXX_INPUT_XXX
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    printf("[IN ]nMode   = %d\n", nMode);
    printf("[IN ]nIndex  = %d\n", nIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenerateKey(nSock, nKeyLen, szServId, nServIdLen, \
                            nMode, nIndex, bKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "Sepcial NG");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKey        =", bKey, nKeyLen);
    printf("[OUT]szCheckValue = %s\n", szCheckValue);
    XXX_OUTPUT_XXX
    
    memcpy(KEK257, bKey, nKeyLen);
    memcpy(KEK257CV, szCheckValue, 8);

    XXX_TEST_END_XXX
}

void GenerateKey_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKeyLen;
    char szServId[32];
    int  nServIdLen;
    int  nMode;
    int  nIndex;
    BYTE bKey[32];
    char szCheckValue[16];

    sprintf(szServId, "1234567890");
    nServIdLen = strlen(szServId);

    bufclr(bKey);
    bufclr(szCheckValue);

    nKeyLen = 8;
    nMode = 0;
    nIndex = 0;

    XXX_INPUT_XXX
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    printf("[IN ]nMode   = %d\n", nMode);
    printf("[IN ]nIndex  = %d\n", nIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenerateKey(nSock, nKeyLen, szServId, nServIdLen, \
                            nMode, nIndex, bKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密钥长度=8测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHex("[OUT]bKey        =", bKey, 8);
    printf("[OUT]szCheckValue = %s\n", szCheckValue);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenerateKey_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKeyLen;
    char szServId[32];
    int  nServIdLen;
    int  nMode;
    int  nIndex;
    BYTE bKey[32];
    char szCheckValue[16];

    sprintf(szServId, "1234567890");
    nServIdLen = strlen(szServId);

    bufclr(bKey);
    bufclr(szCheckValue);

    nKeyLen = 16;
    nMode = 0;
    nIndex = 0;

    XXX_INPUT_XXX
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    printf("[IN ]nMode   = %d\n", nMode);
    printf("[IN ]nIndex  = %d\n", nIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenerateKey(nSock, nKeyLen, szServId, nServIdLen, \
                            nMode, nIndex, bKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密钥长度=16测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHex("[OUT]bKey         =", bKey, 16);
    printf("[OUT]szCheckValue = %s\n", szCheckValue);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenerateKey_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKeyLen;
    char szServId[32];
    int  nServIdLen;
    int  nMode;
    int  nIndex;
    BYTE bKey[32];
    char szCheckValue[16];

    sprintf(szServId, "1234567890");
    nServIdLen = strlen(szServId);

    bufclr(bKey);
    bufclr(szCheckValue);

    nKeyLen = 24;
    nMode = 0;
    nIndex = 0;

    XXX_INPUT_XXX
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    printf("[IN ]nMode   = %d\n", nMode);
    printf("[IN ]nIndex  = %d\n", nIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenerateKey(nSock, nKeyLen, szServId, nServIdLen, \
                            nMode, nIndex, bKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密钥长度=24测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHex("[OUT]bKey         =", bKey, 24);
    printf("[OUT]szCheckValue = %s\n", szCheckValue);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenerateKey_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKeyLen;
    char szServId[32];
    int  nServIdLen;
    int  nMode;
    int  nIndex;
    BYTE bKey[32];
    char szCheckValue[16];

    sprintf(szServId, "1234567890");
    nServIdLen = strlen(szServId);

    bufclr(bKey);
    bufclr(szCheckValue);

    nKeyLen = 0;
    nMode = 0;
    nIndex = 0;

    XXX_INPUT_XXX
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    printf("[IN ]nMode   = %d\n", nMode);
    printf("[IN ]nIndex  = %d\n", nIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenerateKey(nSock, nKeyLen, szServId, nServIdLen, \
                            nMode, nIndex, bKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效密钥长度=0测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenerateKey_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKeyLen;
    char szServId[32];
    int  nServIdLen;
    int  nMode;
    int  nIndex;
    BYTE bKey[32];
    char szCheckValue[16];

    sprintf(szServId, "1234567890");
    nServIdLen = strlen(szServId);

    bufclr(bKey);
    bufclr(szCheckValue);

    nKeyLen = 7;
    nMode = 0;
    nIndex = 0;

    XXX_INPUT_XXX
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    printf("[IN ]nMode   = %d\n", nMode);
    printf("[IN ]nIndex  = %d\n", nIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenerateKey(nSock, nKeyLen, szServId, nServIdLen, \
                            nMode, nIndex, bKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效密钥长度=7测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenerateKey_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKeyLen;
    char szServId[32];
    int  nServIdLen;
    int  nMode;
    int  nIndex;
    BYTE bKey[32];
    char szCheckValue[16];

    sprintf(szServId, "1234567890");
    nServIdLen = strlen(szServId);

    bufclr(bKey);
    bufclr(szCheckValue);

    nKeyLen = 20;
    nMode = 0;
    nIndex = 0;

    XXX_INPUT_XXX
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    printf("[IN ]nMode   = %d\n", nMode);
    printf("[IN ]nIndex  = %d\n", nIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenerateKey(nSock, nKeyLen, szServId, nServIdLen, \
                            nMode, nIndex, bKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效密钥长度=20测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenerateKey_Test_07(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKeyLen;
    char szServId[32];
    int  nServIdLen;
    int  nMode;
    int  nIndex;
    BYTE bKey[32];
    char szCheckValue[16];

    sprintf(szServId, "1234567890");
    nServIdLen = strlen(szServId);

    bufclr(bKey);
    bufclr(szCheckValue);

    nKeyLen = 25;
    nMode = 0;
    nIndex = 0;

    XXX_INPUT_XXX
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    printf("[IN ]nMode   = %d\n", nMode);
    printf("[IN ]nIndex  = %d\n", nIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenerateKey(nSock, nKeyLen, szServId, nServIdLen, \
                            nMode, nIndex, bKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效密钥长度=25测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenerateKey_Test_08(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKeyLen;
    char szServId[32];
    int  nServIdLen;
    int  nMode;
    int  nIndex;
    BYTE bKey[32];
    char szCheckValue[16];

    sprintf(szServId, "1234567890");
    nServIdLen = strlen(szServId);

    bufclr(bKey);
    bufclr(szCheckValue);

    nKeyLen = 32;
    nMode = 0;
    nIndex = 0;

    XXX_INPUT_XXX
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    printf("[IN ]nMode   = %d\n", nMode);
    printf("[IN ]nIndex  = %d\n", nIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenerateKey(nSock, nKeyLen, szServId, nServIdLen, \
                            nMode, nIndex, bKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效密钥长度=32测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void HideBlock_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    char szPlainText[264];
    int  nTextLen;
    char szHiddenText[264];

    bufclr(szPlainText);
    bufclr(szHiddenText);

    sprintf(szPlainText, "@");
    nTextLen = strlen(szPlainText);

    XXX_INPUT_XXX
    printf("[IN ]szPlainText  = %s\n", szPlainText);
    printf("[IN ]nTextLen     = %d\n", nTextLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIHideBlock(nSock, szPlainText, nTextLen, szHiddenText);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "数据长度=1测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    printf("[OUT]szHiddenText = %s\n", szHiddenText);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void HideBlock_Test_xx(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    char szPlainText[264];
    int  nTextLen;
    char szHiddenText[264];

    bufclr(szPlainText);
    bufclr(szHiddenText);

    sprintf(szPlainText, "1234567890");
    nTextLen = 10;

    XXX_INPUT_XXX
    printf("[IN ]szPlainText  = %s\n", szPlainText);
    printf("[IN ]nTextLen     = %d\n", nTextLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIHideBlock(nSock, szPlainText, nTextLen, szHiddenText);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "数据长度=255测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    printf("[OUT]szHiddenText = %s\n", szHiddenText);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void HideBlock_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    char szPlainText[264];
    int  nTextLen;
    char szHiddenText[264];

    bufclr(szPlainText);
    bufclr(szHiddenText);

    sprintf(szPlainText, "1234567890123456789012345678901234567890" \
                         "1234567890123456789012345678901234567890" \
                         "1234567890123456789012345678901234567890" \
                         "1234567890123456789012345678901234567890" \
                         "1234567890123456789012345678901234567890" \
                         "1234567890123456789012345678901234567890" \
                         "123456789012345");
    nTextLen = 255;

    XXX_INPUT_XXX
    printf("[IN ]szPlainText  = %s\n", szPlainText);
    printf("[IN ]nTextLen     = %d\n", nTextLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIHideBlock(nSock, szPlainText, nTextLen, szHiddenText);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "数据长度=255测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    printf("[OUT]szHiddenText = %s\n", szHiddenText);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void HideBlock_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    char szPlainText[264];
    int  nTextLen;
    char szHiddenText[264];

    bufclr(szPlainText);
    bufclr(szHiddenText);

    nTextLen = 0;

    XXX_INPUT_XXX
    printf("[IN ]szPlainText  = %s\n", szPlainText);
    printf("[IN ]nTextLen     = %d\n", nTextLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIHideBlock(nSock, szPlainText, nTextLen, szHiddenText);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "数据长度=0测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szHiddenText = %s\n", szHiddenText);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void HideBlock_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    char szPlainText[264];
    int  nTextLen;
    char szHiddenText[264];

    bufclr(szPlainText);
    bufclr(szHiddenText);

    sprintf(szPlainText, "1234567890123456789012345678901234567890" \
                         "1234567890123456789012345678901234567890" \
                         "1234567890123456789012345678901234567890" \
                         "1234567890123456789012345678901234567890" \
                         "1234567890123456789012345678901234567890" \
                         "1234567890123456789012345678901234567890" \
                         "1234567890123456");
    nTextLen = 256;

    XXX_INPUT_XXX
    printf("[IN ]szPlainText  = %s\n", szPlainText);
    nRet = SMAPIHideBlock(nSock, szPlainText, nTextLen, szHiddenText);
    printf("[IN ]nTextLen     = %d\n", nTextLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "数据长度=256测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szHiddenText = %s\n", szHiddenText);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void RevealBlock_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    char szPlainText[264];
    int  nTextLen;
    char szHiddenText[264];

    bufclr(szHiddenText);
    bufclr(szPlainText);

    sprintf(szHiddenText, ")");
    nTextLen = 1;

    XXX_INPUT_XXX
    printf("[IN ]szHiddenText = %s\n", szHiddenText);
    printf("[IN ]nTextLen     = %d\n", nTextLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIRevalBlock(nSock, szHiddenText, nTextLen, szPlainText);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "数据长度=1测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    printf("[OUT]szPlainText  = %s\n", szPlainText);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void RevealBlock_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    char szPlainText[264];
    int  nTextLen;
    char szHiddenText[264];

    bufclr(szHiddenText);
    bufclr(szPlainText);

    /* 需要取 HideBlock_Test_02 的输出结果作为输入 */
/*
    strcpy(szHiddenText, "Q.b|RbWxtOsL@cc58vJ'S2I!:h701q~a\\(gNdv[)"
                         "fs_hPi!7:VG5&}*(_'DwL:x|sM@A(0|9WN3S$[$%"
                         "P<1]0B4),oic~SoL]1#W4#M\"!(yHJGv+eBaZ5sj^"
                         "L;K^v5zE(H[QSZIz@\\\\\\u`&.?*[JFe8Mn;iy$P*-"
                         "ARIht):FuCQ.b|RbWxtOsL@cc58vJ'S2I!:h701q"
                         "~a\\(gNdv[)fs_hPi!7:VG5&}*(_'DwL:x|sM@A(0"
                         "|9WN3S$[$%P<1]0");
*/
    strcpy(szHiddenText, "/$584726;3/$584737<40%695837<40%7:6948=51&7:6948>62'8;7:59>62'8;8;6:?73(9<8;6:?74):=9<7;@84):=9<8<A95*;>:=8<A95*<?;>9=B:6+<?;>9=C;7,=@<?:>C;7,=@=@;?D<8->A=@;?D<9.?B>A<@E=9.?B>A=AF>:/@C?B=AF>:/AD@C>BG?;0AD@C>BH@<1BEAD?CH@<1BEBE@DIA=2CFBE@DIA>3DGCFAEJB>3DGC");

    nTextLen = 255;

    XXX_INPUT_XXX
    printf("[IN ]szHiddenText = %s\n", szHiddenText);
    printf("[IN ]nTextLen     = %d\n", nTextLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIRevalBlock(nSock, szHiddenText, nTextLen, szPlainText);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "数据长度=255测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    printf("[OUT]szPlainText  = %s\n", szPlainText);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void RevealBlock_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    char szPlainText[264];
    int  nTextLen;
    char szHiddenText[264];

    bufclr(szHiddenText);
    bufclr(szPlainText);

    nTextLen = 0;

    XXX_INPUT_XXX
    printf("[IN ]szHiddenText = %s\n", szHiddenText);
    printf("[IN ]nTextLen     = %d\n", nTextLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIRevalBlock(nSock, szHiddenText, nTextLen, szPlainText);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "数据长度=0测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szPlainText  = %s\n", szPlainText);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void RevealBlock_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    char szPlainText[264];
    int  nTextLen;
    char szHiddenText[264];

    bufclr(szHiddenText);
    bufclr(szPlainText);

    strcpy(szHiddenText, ")oX!Adlz&).5>IVeny',3<GT[do|,3<GLS\\gt$5>"
                          "AFMVan}/:=BIR]jy#.;@GP[hox$1@GP[`gp{)8IR"
                          "UZaju#2CNQV]fq~.7BOT[do|$-8ET[dot{%0=L]f"
                          "inu~*7FWbejqz&3BKVchox$18ALYhox$)09DQ`qz"
                          "}#*3>KZkvy~&/:GV_jw|$-8ELU`m|$-8=DMXet&/"
                          "27>GR_n +.3:CN[js~,18ALY`it\"18ALQXaly):C"
                          "FKR[fs#4?BGNWbo~");
    nTextLen = 256;

    XXX_INPUT_XXX
    printf("[IN ]szHiddenText = %s\n", szHiddenText);
    nRet = SMAPIRevalBlock(nSock, szHiddenText, nTextLen, szPlainText);
    printf("[IN ]nTextLen     = %d\n", nTextLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "数据长度=256测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szPlainText  = %s\n", szPlainText);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptKey_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bPlainKey[32];
    int  nKeyLen;
    BYTE bKeyUnderLMK[32];
    BYTE bKeyUnderLMKExp[32];

    bufclr(bPlainKey);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderLMKExp);

    /* 3210 7654 BA98 FEDC */
    memcpy(bPlainKey, "\x32\x10\x76\x54\xBA\x98\xFE\xDC", 8);
    nKeyLen = 8;
    /* 2D68 6F97 FBB5 82E1 */
    memcpy(bKeyUnderLMKExp, "\x2D\x68\x6F\x97\xFB\xB5\x82\xE1", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock           = %d\n", nSock);
    DspHex("[IN ]bPlainKey       =", bPlainKey, 8);
    printf("[IN ]nKeyLen         = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptKey(nSock, bPlainKey, nKeyLen, bKeyUnderLMK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密钥长度=8测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[IN ]bKeyUnderLMK    =", bKeyUnderLMK, 8);
    DspHex("[IN ]bKeyUnderLMKExp =", bKeyUnderLMKExp, 8);
    ASSERT_OUT_HEX(bKeyUnderLMK, bKeyUnderLMKExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptKey_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bPlainKey[32];
    int  nKeyLen;
    BYTE bKeyUnderLMK[32];
    BYTE bKeyUnderLMKExp[32];

    bufclr(bPlainKey);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderLMKExp);

    /* 3210 7654 BA98 FEDC 3245 7689 ABDC EF54 */
    memcpy(bPlainKey, "\x32\x10\x76\x54\xBA\x98\xFE\xDC"  \
                      "\x32\x45\x76\x89\xAB\xDC\xEF\x54", \
                      16);
    nKeyLen = 16;
    /* 2D68 6F97 FBB5 82E1 7579 3584 27F3 1A31 */
    memcpy(bKeyUnderLMKExp, 
           "\x2D\x68\x6F\x97\xFB\xB5\x82\xE1" \
           "\x7E\xBA\xB7\x37\xFA\xA7\x68\xF8" \
           , 16);

    XXX_INPUT_XXX
    printf("[IN ]nSock           = %d\n", nSock);
    DspHex("[IN ]bPlainKey       =", bPlainKey, 16);
    printf("[IN ]nKeyLen         = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptKey(nSock, bPlainKey, nKeyLen, bKeyUnderLMK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密钥长度=16测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[IN ]bKeyUnderLMK    =", bKeyUnderLMK, 16);
    DspHex("[IN ]bKeyUnderLMKExp =", bKeyUnderLMKExp, 16);
    ASSERT_OUT_HEX(bKeyUnderLMK, bKeyUnderLMKExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptKey_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bPlainKey[32];
    int  nKeyLen;
    BYTE bKeyUnderLMK[32];
    BYTE bKeyUnderLMKExp[32];

    bufclr(bPlainKey);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderLMKExp);

    /* 3210 7654 BA98 FEDC 3245 7689 ABDC EF54 2323 6767 ABAB 7676 */
    memcpy(bPlainKey, 
           "\x32\x10\x76\x54\xBA\x98\xFE\xDC" \
           "\x32\x45\x76\x89\xAB\xDC\xEF\x54" \
           "\x23\x23\x67\x67\xAB\xAB\x76\x76" \
           , 24);
    nKeyLen = 24;
    /* 2C68 6E97 FBB5 83E0 7579 3485 26F2 1A31 E085 C180 7ABA DFF4 */
    memcpy(bKeyUnderLMKExp, 
           "\x2D\x68\x6F\x97\xFB\xB5\x82\xE1" \
           "\x7E\xBA\xB7\x37\xFA\xA7\x68\xF8" \
           "\x39\x22\x83\xAB\xA5\x29\x78\x30" \
           , 24);

    XXX_INPUT_XXX
    printf("[IN ]nSock           = %d\n", nSock);
    DspHex("[IN ]bPlainKey       =", bPlainKey, 24);
    printf("[IN ]nKeyLen         = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptKey(nSock, bPlainKey, nKeyLen, bKeyUnderLMK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密钥长度=24测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[IN ]bKeyUnderLMK    =", bKeyUnderLMK, 24);
    DspHex("[IN ]bKeyUnderLMKExp =", bKeyUnderLMKExp, 24);
    ASSERT_OUT_HEX(bKeyUnderLMK, bKeyUnderLMKExp, 24);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptKey_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bPlainKey[32];
    int  nKeyLen;
    BYTE bKeyUnderLMK[32];
    BYTE bKeyUnderLMKExp[32];

    bufclr(bPlainKey);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderLMKExp);

    /* 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 */
    memset(bPlainKey, 0x00, 24);
    nKeyLen = 24;
    /* 1F1E A825 5422 D275 1F1E A825 5422 D275 1F1E A825 5422 D275 */
    memcpy(bKeyUnderLMKExp, "\x1F\x1E\xA8\x25\x54\x22\xD2\x75"  \
                            "\x1F\x1E\xA8\x25\x54\x22\xD2\x75"  \
                            "\x1F\x1E\xA8\x25\x54\x22\xD2\x75", \
                            24);

    XXX_INPUT_XXX
    printf("[IN ]nSock           = %d\n", nSock);
    DspHex("[IN ]bPlainKey       =", bPlainKey, 24);
    printf("[IN ]nKeyLen         = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptKey(nSock, bPlainKey, nKeyLen, bKeyUnderLMK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "空密钥0x00测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[IN ]bKeyUnderLMK    =", bKeyUnderLMK, 24);
    DspHex("[IN ]bKeyUnderLMKExp =", bKeyUnderLMKExp, 24);
    ASSERT_OUT_HEX(bKeyUnderLMK, bKeyUnderLMKExp, 24);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptKey_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bPlainKey[32];
    int  nKeyLen;
    BYTE bKeyUnderLMK[32];
    BYTE bKeyUnderLMKExp[32];

    bufclr(bPlainKey);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderLMKExp);

    /* FFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFF */
    memset(bPlainKey, 0xFF, 24);
    nKeyLen = 24;
    /* 7B81 70A0 4A60 4D9B 7B81 70A0 4A60 4D9B 7B81 70A0 4A60 4D9B */
    memcpy(bKeyUnderLMKExp, "\x7B\x81\x70\xA0\x4A\x60\x4D\x9B"  \
                            "\x7B\x81\x70\xA0\x4A\x60\x4D\x9B"  \
                            "\x7B\x81\x70\xA0\x4A\x60\x4D\x9B", \
                            24);

    XXX_INPUT_XXX
    printf("[IN ]nSock           = %d\n", nSock);
    DspHex("[IN ]bPlainKey       =", bPlainKey, 24);
    printf("[IN ]nKeyLen         = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptKey(nSock, bPlainKey, nKeyLen, bKeyUnderLMK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "特殊密钥0xFF测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[IN ]bKeyUnderLMK    =", bKeyUnderLMK, 24);
    DspHex("[IN ]bKeyUnderLMKExp =", bKeyUnderLMKExp, 24);
    ASSERT_OUT_HEX(bKeyUnderLMK, bKeyUnderLMKExp, 24);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptKey_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bPlainKey[32];
    int  nKeyLen;
    BYTE bKeyUnderLMK[32];
    BYTE bKeyUnderLMKExp[32];

    bufclr(bPlainKey);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderLMKExp);

    nSock = -1;

    /* 3210 7654 BA98 FEDC */
    memcpy(bPlainKey, "\x32\x10\x76\x54\xBA\x98\xFE\xDC", 8);
    nKeyLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock           = %d\n", nSock);
    DspHex("[IN ]bPlainKey       =", bPlainKey, 8);
    printf("[IN ]nKeyLen         = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptKey(nSock, bPlainKey, nKeyLen, bKeyUnderLMK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void EncryptKey_Test_07(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bPlainKey[32];
    int  nKeyLen;
    BYTE bKeyUnderLMK[32];
    BYTE bKeyUnderLMKExp[32];

    bufclr(bPlainKey);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderLMKExp);

    nSock = 8;

    /* 3210 7654 BA98 FEDC */
    memcpy(bPlainKey, "\x32\x10\x76\x54\xBA\x98\xFE\xDC", 8);
    nKeyLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock           = %d\n", nSock);
    DspHex("[IN ]bPlainKey       =", bPlainKey, 8);
    printf("[IN ]nKeyLen         = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptKey(nSock, bPlainKey, nKeyLen, bKeyUnderLMK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[8]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void EncryptKey_Test_08(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bPlainKey[32];
    int  nKeyLen;
    BYTE bKeyUnderLMK[32];
    BYTE bKeyUnderLMKExp[32];

    bufclr(bPlainKey);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderLMKExp);

    nKeyLen = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock           = %d\n", nSock);
    DspHex("[IN ]bPlainKey       =", bPlainKey, 8);
    printf("[IN ]nKeyLen         = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptKey(nSock, bPlainKey, nKeyLen, bKeyUnderLMK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效密钥长度=0测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptKey_Test_09(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bPlainKey[32];
    int  nKeyLen;
    BYTE bKeyUnderLMK[32];
    BYTE bKeyUnderLMKExp[32];

    bufclr(bPlainKey);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderLMKExp);

    /* 3210 7654 BA98 FE */
    memcpy(bPlainKey, "\x32\x10\x76\x54\xBA\x98\xFE", 7);
    nKeyLen = 7;

    XXX_INPUT_XXX
    printf("[IN ]nSock           = %d\n", nSock);
    DspHex("[IN ]bPlainKey       =", bPlainKey, 8);
    printf("[IN ]nKeyLen         = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptKey(nSock, bPlainKey, nKeyLen, bKeyUnderLMK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效密钥长度=7测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptKey_Test_10(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bPlainKey[32];
    int  nKeyLen;
    BYTE bKeyUnderLMK[32];
    BYTE bKeyUnderLMKExp[32];

    bufclr(bPlainKey);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderLMKExp);

    /* 3210 7654 BA98 FEDC 3344 7788 AADD EE55 2222 6666*/
    memcpy(bPlainKey, "\x32\x10\x76\x54\xBA\x98\xFE\xDC"  \
                      "\x33\x44\x77\x88\xAA\xDD\xEE\x55"  \
                      "\x22\x22\x66\x66", \
                      20);
    nKeyLen = 20;

    XXX_INPUT_XXX
    printf("[IN ]nSock           = %d\n", nSock);
    DspHex("[IN ]bPlainKey       =", bPlainKey, 20);
    printf("[IN ]nKeyLen         = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptKey(nSock, bPlainKey, nKeyLen, bKeyUnderLMK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效密钥长度=20测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptKey_Test_11(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bPlainKey[32];
    int  nKeyLen;
    BYTE bKeyUnderLMK[32];
    BYTE bKeyUnderLMKExp[32];

    bufclr(bPlainKey);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderLMKExp);

    /* 3210 7654 BA98 FEDC 3344 7788 AADD EE55 2222 6666 AAAA 7777 EF */
    memcpy(bPlainKey, "\x32\x10\x76\x54\xBA\x98\xFE\xDC"  \
                      "\x33\x44\x77\x88\xAA\xDD\xEE\x55"  \
                      "\x22\x22\x66\x66\xAA\xAA\x77\x77"  \
                      "\xEF", \
                      25);
    nKeyLen = 25;

    XXX_INPUT_XXX
    printf("[IN ]nSock           = %d\n", nSock);
    DspHex("[IN ]bPlainKey       =", bPlainKey, 25);
    printf("[IN ]nKeyLen         = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptKey(nSock, bPlainKey, nKeyLen, bKeyUnderLMK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效密钥长度=25测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptKey_Test_12(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bPlainKey[32];
    int  nKeyLen;
    BYTE bKeyUnderLMK[32];
    BYTE bKeyUnderLMKExp[32];

    bufclr(bPlainKey);
    bufclr(bKeyUnderLMK);
    bufclr(bKeyUnderLMKExp);

    /* 3210 7654 BA98 FEDC 3344 7788 AADD EE55 2222 6666 AAAA 7777 EFFE 0110 FEFE 0110 */
    memcpy(bPlainKey, "\x32\x10\x76\x54\xBA\x98\xFE\xDC"  \
                      "\x33\x44\x77\x88\xAA\xDD\xEE\x55"  \
                      "\x22\x22\x66\x66\xAA\xAA\x77\x77"  \
                      "\xEF\xFE\x01\x10\xEF\xFE\x01\x10", \
                      32);
    nKeyLen = 32;

    XXX_INPUT_XXX
    printf("[IN ]nSock           = %d\n", nSock);
    DspHex("[IN ]bPlainKey       =", bPlainKey, 32);
    printf("[IN ]nKeyLen         = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptKey(nSock, bPlainKey, nKeyLen, bKeyUnderLMK);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效密钥长度=32测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptBlock_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bPlainBlock[4104];
    int  nBlockLen;
    BYTE bCryptBlock[4104];
    BYTE bCryptBlockExp[4104];

    bufclr(bKey);
    bufclr(bPlainBlock);
    bufclr(bCryptBlock);
    bufclr(bCryptBlockExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    /* 0123 4567 89AB CDEF */
    memcpy(bPlainBlock, "\x01\x23\x45\x67\x89\xAB\xCD\xEF", 8);
    nBlockLen = 8;
    memcpy(bCryptBlockExp, "\x56\xCC\x09\xE7\xCF\xDC\x4C\xEF", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bPlainBlock    =", bPlainBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptBlock(nSock, nAlgo, bKey, bPlainBlock, \
                             nBlockLen, bCryptBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "算法类型=1，数据长度=8，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bCryptBlock, bCryptBlockExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptBlock_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bPlainBlock[4104];
    int  nBlockLen;
    BYTE bCryptBlock[4104];
    BYTE bCryptBlockExp[4104];

    bufclr(bKey);
    bufclr(bPlainBlock);
    bufclr(bCryptBlock);
    bufclr(bCryptBlockExp);

    nAlgo = 2;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
                 16);
    /* 0123 4567 89AB CDEF */
    memcpy(bPlainBlock, "\x01\x23\x45\x67\x89\xAB\xCD\xEF", 8);
    nBlockLen = 8;
    memcpy(bCryptBlockExp, "\x1A\x4D\x67\x2D\xCA\x6C\xB3\x35", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 16);
    DspHex("[IN ]bPlainBlock    =", bPlainBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptBlock(nSock, nAlgo, bKey, bPlainBlock, \
                             nBlockLen, bCryptBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "算法类型=2，数据长度=8，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bCryptBlock, bCryptBlockExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptBlock_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bPlainBlock[4104];
    int  nBlockLen;
    BYTE bCryptBlock[4104];
    BYTE bCryptBlockExp[4104];

    bufclr(bKey);
    bufclr(bPlainBlock);
    bufclr(bCryptBlock);
    bufclr(bCryptBlockExp);

    nAlgo = 3;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8697 A4B5 C2D3 E0F1 */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\x59\x99\xC3\x06\xAB\x84\x01\xB2",\
                 24);
    /* 0123 4567 89AB CDEF */
    memcpy(bPlainBlock, "\x01\x23\x45\x67\x89\xAB\xCD\xEF", 8);
    nBlockLen = 8;
    memcpy(bCryptBlockExp, "\xB1\xBD\x7B\x27\x8E\xA6\x2F\xCD", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 24);
    DspHex("[IN ]bPlainBlock    =", bPlainBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptBlock(nSock, nAlgo, bKey, bPlainBlock, \
                             nBlockLen, bCryptBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "算法类型=3，数据长度=8，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bCryptBlock, bCryptBlockExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptBlock_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bPlainBlock[4104];
    int  nBlockLen;
    BYTE bCryptBlock[4104];
    BYTE bCryptBlockExp[4104];

    bufclr(bKey);
    bufclr(bPlainBlock);
    bufclr(bCryptBlock);
    bufclr(bCryptBlockExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memset(bPlainBlock, 0x5C, 4096);
    bPlainBlock[0] = 0x25;
    bPlainBlock[4095] = 0x22;
    nBlockLen = 4096;
    memcpy(bCryptBlockExp, "\x6E\x0F\x4E\x43\xFF\xCB\x0C\x0A", 8);
    for(i = 8; i < 4088; i += 8)
        memcpy(&bCryptBlockExp[i], "\x92\x3D\x2E\x67\x72\x08\x81\x74", 8);
    memcpy(&bCryptBlockExp[4088], "\x2D\xFF\x5C\xD8\x7F\x92\x78\xD6", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bPlainBlock    =", bPlainBlock, 4096);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptBlock(nSock, nAlgo, bKey, bPlainBlock, \
                             nBlockLen, bCryptBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "算法类型=1，数据长度=4096，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bCryptBlock, bCryptBlockExp, 4096);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptBlock_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bPlainBlock[4104];
    int  nBlockLen;
    BYTE bCryptBlock[4104];
    BYTE bCryptBlockExp[4104];

    bufclr(bKey);
    bufclr(bPlainBlock);
    bufclr(bCryptBlock);
    bufclr(bCryptBlockExp);

    nAlgo = 2;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
                 16);
    memset(bPlainBlock, 0x5C, 4096);
    bPlainBlock[0] = 0x25;
    bPlainBlock[4095] = 0x22;
    nBlockLen = 4096;
    memcpy(bCryptBlockExp, "\x2B\xB5\x43\x79\x10\x13\x91\x7C", 8);
    for(i = 8; i < 4088; i += 8)
        memcpy(&bCryptBlockExp[i], "\xE1\xA7\x6F\x20\xBE\x3C\x25\xAF", 8);
    memcpy(&bCryptBlockExp[4088], "\x27\x99\x35\xF2\x56\x63\x81\xE3", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 16);
    DspHex("[IN ]bPlainBlock    =", bPlainBlock, 4096);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptBlock(nSock, nAlgo, bKey, bPlainBlock, \
                             nBlockLen, bCryptBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "算法类型=2，数据长度=4096，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bCryptBlock, bCryptBlockExp, 4096);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptBlock_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bPlainBlock[4104];
    int  nBlockLen;
    BYTE bCryptBlock[4104];
    BYTE bCryptBlockExp[4104];

    bufclr(bKey);
    bufclr(bPlainBlock);
    bufclr(bCryptBlock);
    bufclr(bCryptBlockExp);

    nAlgo = 3;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8697 A4B5 C2D3 E0F1 */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\x59\x99\xC3\x06\xAB\x84\x01\xB2",\
                 24);
    memset(bPlainBlock, 0x5C, 4096);
    bPlainBlock[0] = 0x25;
    bPlainBlock[4095] = 0x22;
    nBlockLen = 4096;
    memcpy(bCryptBlockExp, "\x1B\x7E\xEC\x99\xFD\xA8\xE8\x98", 8);
    for(i = 8; i < 4088; i += 8)
        memcpy(&bCryptBlockExp[i], "\x83\x10\xF1\x99\xE3\xA9\xAE\x8E", 8);
    memcpy(&bCryptBlockExp[4088], "\x76\x94\xF9\xF4\x81\xBD\x90\xA7", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 24);
    DspHex("[IN ]bPlainBlock    =", bPlainBlock, 4096);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptBlock(nSock, nAlgo, bKey, bPlainBlock, \
                             nBlockLen, bCryptBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "算法类型=3，数据长度=4096，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bCryptBlock, bCryptBlockExp, 4096);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptBlock_Test_07(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bPlainBlock[4104];
    int  nBlockLen;
    BYTE bCryptBlock[4104];
    BYTE bCryptBlockExp[4104];

    bufclr(bKey);
    bufclr(bPlainBlock);
    bufclr(bCryptBlock);
    bufclr(bCryptBlockExp);

    nAlgo = 3;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8697 A4B5 C2D3 E0F1 */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\x59\x99\xC3\x06\xAB\x84\x01\xB2",\
                 24);
    nBlockLen = 4096;
    for(i = 0; i < 4096; i += 8)
        memcpy(&bCryptBlockExp[i], "\xBA\xF9\xEF\x36\xAC\x80\x81\x58", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 24);
    DspHex("[IN ]bPlainBlock    =", bPlainBlock, 4096);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptBlock(nSock, nAlgo, bKey, bPlainBlock, \
                             nBlockLen, bCryptBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "算法类型=3，数据长度=4096，空数据测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bCryptBlock, bCryptBlockExp, 4096);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptBlock_Test_08(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bPlainBlock[4104];
    int  nBlockLen;
    BYTE bCryptBlock[4104];
    BYTE bCryptBlockExp[4104];

    bufclr(bKey);
    bufclr(bPlainBlock);
    bufclr(bCryptBlock);
    bufclr(bCryptBlockExp);

    nSock = -1;
    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memcpy(bPlainBlock, "\x01\x23\x45\x67\x89\xAB\xCD\xEF", 8);
    nBlockLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bPlainBlock    =", bPlainBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptBlock(nSock, nAlgo, bKey, bPlainBlock, \
                             nBlockLen, bCryptBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void EncryptBlock_Test_09(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bPlainBlock[4104];
    int  nBlockLen;
    BYTE bCryptBlock[4104];
    BYTE bCryptBlockExp[4104];

    bufclr(bKey);
    bufclr(bPlainBlock);
    bufclr(bCryptBlock);
    bufclr(bCryptBlockExp);

    nSock = 8;
    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memcpy(bPlainBlock, "\x01\x23\x45\x67\x89\xAB\xCD\xEF", 8);
    nBlockLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bPlainBlock    =", bPlainBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptBlock(nSock, nAlgo, bKey, bPlainBlock, \
                             nBlockLen, bCryptBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[8]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void EncryptBlock_Test_10(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bPlainBlock[4104];
    int  nBlockLen;
    BYTE bCryptBlock[4104];
    BYTE bCryptBlockExp[4104];

    bufclr(bKey);
    bufclr(bPlainBlock);
    bufclr(bCryptBlock);
    bufclr(bCryptBlockExp);

    nAlgo = 0;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memcpy(bPlainBlock, "\x01\x23\x45\x67\x89\xAB\xCD\xEF", 8);
    nBlockLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bPlainBlock    =", bPlainBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptBlock(nSock, nAlgo, bKey, bPlainBlock, \
                             nBlockLen, bCryptBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效算法类型[0]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptBlock_Test_11(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bPlainBlock[4104];
    int  nBlockLen;
    BYTE bCryptBlock[4104];
    BYTE bCryptBlockExp[4104];

    bufclr(bKey);
    bufclr(bPlainBlock);
    bufclr(bCryptBlock);
    bufclr(bCryptBlockExp);

    nAlgo = 4;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memcpy(bPlainBlock, "\x01\x23\x45\x67\x89\xAB\xCD\xEF", 8);
    nBlockLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bPlainBlock    =", bPlainBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptBlock(nSock, nAlgo, bKey, bPlainBlock, \
                             nBlockLen, bCryptBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效算法类型[4]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptBlock_Test_12(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bPlainBlock[4104];
    int  nBlockLen;
    BYTE bCryptBlock[4104];
    BYTE bCryptBlockExp[4104];

    bufclr(bKey);
    bufclr(bPlainBlock);
    bufclr(bCryptBlock);
    bufclr(bCryptBlockExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    nBlockLen = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bPlainBlock    =", bPlainBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptBlock(nSock, nAlgo, bKey, bPlainBlock, \
                             nBlockLen, bCryptBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效数据长度=0，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptBlock_Test_13(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bPlainBlock[4104];
    int  nBlockLen;
    BYTE bCryptBlock[4104];
    BYTE bCryptBlockExp[4104];

    bufclr(bKey);
    bufclr(bPlainBlock);
    bufclr(bCryptBlock);
    bufclr(bCryptBlockExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memcpy(bPlainBlock, "\x01\x23\x45\x67\x89\xAB\xCD", 7);
    nBlockLen = 7;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bPlainBlock    =", bPlainBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptBlock(nSock, nAlgo, bKey, bPlainBlock, \
                             nBlockLen, bCryptBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效数据长度=7，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptBlock_Test_14(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bPlainBlock[4104];
    int  nBlockLen;
    BYTE bCryptBlock[4104];
    BYTE bCryptBlockExp[4104];

    bufclr(bKey);
    bufclr(bPlainBlock);
    bufclr(bCryptBlock);
    bufclr(bCryptBlockExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memset(bPlainBlock, 0x5C, 4097);
    bPlainBlock[0] = 0x25;
    bPlainBlock[4096] = 0x22;
    nBlockLen = 4097;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bPlainBlock    =", bPlainBlock, 4097);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptBlock(nSock, nAlgo, bKey, bPlainBlock, \
                             nBlockLen, bCryptBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效数据长度=4097，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptBlock_Test_15(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bPlainBlock[4104];
    int  nBlockLen;
    BYTE bCryptBlock[4104];
    BYTE bCryptBlockExp[4104];

    bufclr(bKey);
    bufclr(bPlainBlock);
    bufclr(bCryptBlock);
    bufclr(bCryptBlockExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memset(bPlainBlock, 0x5C, 4104);
    bPlainBlock[0] = 0x25;
    bPlainBlock[4103] = 0x22;
    nBlockLen = 4104;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bPlainBlock    =", bPlainBlock, 4104);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptBlock(nSock, nAlgo, bKey, bPlainBlock, \
                             nBlockLen, bCryptBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效数据长度=4104，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptBlock_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bCryptBlock[4104];
    int  nBlockLen;
    BYTE bPlainBlock[4104];
    BYTE bPlainBlockExp[4104];

    bufclr(bKey);
    bufclr(bCryptBlock);
    bufclr(bPlainBlock);
    bufclr(bPlainBlockExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    /* 0123 4567 89AB CDEF */
    memcpy(bCryptBlock, "\x56\xCC\x09\xE7\xCF\xDC\x4C\xEF", 8);
    nBlockLen = 8;
    memcpy(bPlainBlockExp, "\x01\x23\x45\x67\x89\xAB\xCD\xEF", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bCryptBlock    =", bCryptBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptBlock(nSock, nAlgo, bKey, bCryptBlock, \
                             nBlockLen, bPlainBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "算法类型=1，数据长度=8，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bPlainBlock, bPlainBlockExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptBlock_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bCryptBlock[4104];
    int  nBlockLen;
    BYTE bPlainBlock[4104];
    BYTE bPlainBlockExp[4104];

    bufclr(bKey);
    bufclr(bCryptBlock);
    bufclr(bPlainBlock);
    bufclr(bPlainBlockExp);

    nAlgo = 2;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
                 16);
    /* 0123 4567 89AB CDEF */
    memcpy(bCryptBlock, "\x1A\x4D\x67\x2D\xCA\x6C\xB3\x35", 8);
    nBlockLen = 8;
    memcpy(bPlainBlockExp, "\x01\x23\x45\x67\x89\xAB\xCD\xEF", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 16);
    DspHex("[IN ]bCryptBlock    =", bCryptBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptBlock(nSock, nAlgo, bKey, bCryptBlock, \
                             nBlockLen, bPlainBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "算法类型=2，数据长度=8，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bPlainBlock, bPlainBlockExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptBlock_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bCryptBlock[4104];
    int  nBlockLen;
    BYTE bPlainBlock[4104];
    BYTE bPlainBlockExp[4104];

    bufclr(bKey);
    bufclr(bCryptBlock);
    bufclr(bPlainBlock);
    bufclr(bPlainBlockExp);

    nAlgo = 3;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8697 A4B5 C2D3 E0F1 */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\x59\x99\xC3\x06\xAB\x84\x01\xB2",\
                 24);
    /* 0123 4567 89AB CDEF */
    memcpy(bCryptBlock, "\xB1\xBD\x7B\x27\x8E\xA6\x2F\xCD", 8);
    nBlockLen = 8;
    memcpy(bPlainBlockExp, "\x01\x23\x45\x67\x89\xAB\xCD\xEF", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 24);
    DspHex("[IN ]bCryptBlock    =", bCryptBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptBlock(nSock, nAlgo, bKey, bCryptBlock, \
                             nBlockLen, bPlainBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "算法类型=3，数据长度=8，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bPlainBlock, bPlainBlockExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptBlock_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bCryptBlock[4104];
    int  nBlockLen;
    BYTE bPlainBlock[4104];
    BYTE bPlainBlockExp[4104];

    bufclr(bKey);
    bufclr(bCryptBlock);
    bufclr(bPlainBlock);
    bufclr(bPlainBlockExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memcpy(bCryptBlock, "\x6E\x0F\x4E\x43\xFF\xCB\x0C\x0A", 8);
    for(i = 8; i < 4088; i += 8)
        memcpy(&bCryptBlock[i], "\x92\x3D\x2E\x67\x72\x08\x81\x74", 8);
    memcpy(&bCryptBlock[4088], "\x2D\xFF\x5C\xD8\x7F\x92\x78\xD6", 8);
    nBlockLen = 4096;
    memset(bPlainBlockExp, 0x5C, 4096);
    bPlainBlockExp[0] = 0x25;
    bPlainBlockExp[4095] = 0x22;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bCryptBlock    =", bCryptBlock, 4096);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptBlock(nSock, nAlgo, bKey, bCryptBlock, \
                             nBlockLen, bPlainBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "算法类型=1，数据长度=4096，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bPlainBlock, bPlainBlockExp, 4096);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptBlock_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bCryptBlock[4104];
    int  nBlockLen;
    BYTE bPlainBlock[4104];
    BYTE bPlainBlockExp[4104];

    bufclr(bKey);
    bufclr(bCryptBlock);
    bufclr(bPlainBlock);
    bufclr(bPlainBlockExp);

    nAlgo = 2;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
                 16);
    memcpy(bCryptBlock, "\x2B\xB5\x43\x79\x10\x13\x91\x7C", 8);
    for(i = 8; i < 4088; i += 8)
        memcpy(&bCryptBlock[i], "\xE1\xA7\x6F\x20\xBE\x3C\x25\xAF", 8);
    memcpy(&bCryptBlock[4088], "\x27\x99\x35\xF2\x56\x63\x81\xE3", 8);
    nBlockLen = 4096;
    memset(bPlainBlockExp, 0x5C, 4096);
    bPlainBlockExp[0] = 0x25;
    bPlainBlockExp[4095] = 0x22;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 16);
    DspHex("[IN ]bCryptBlock    =", bCryptBlock, 4096);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptBlock(nSock, nAlgo, bKey, bCryptBlock, \
                             nBlockLen, bPlainBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "算法类型=2，数据长度=4096，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bPlainBlock, bPlainBlockExp, 4096);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptBlock_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bCryptBlock[4104];
    int  nBlockLen;
    BYTE bPlainBlock[4104];
    BYTE bPlainBlockExp[4104];

    bufclr(bKey);
    bufclr(bCryptBlock);
    bufclr(bPlainBlock);
    bufclr(bPlainBlockExp);

    nAlgo = 3;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8697 A4B5 C2D3 E0F1 */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\x59\x99\xC3\x06\xAB\x84\x01\xB2",\
                 24);
    memcpy(bCryptBlock, "\x1B\x7E\xEC\x99\xFD\xA8\xE8\x98", 8);
    for(i = 8; i < 4088; i += 8)
        memcpy(&bCryptBlock[i], "\x83\x10\xF1\x99\xE3\xA9\xAE\x8E", 8);
    memcpy(&bCryptBlock[4088], "\x76\x94\xF9\xF4\x81\xBD\x90\xA7", 8);
    nBlockLen = 4096;
    memset(bPlainBlockExp, 0x5C, 4096);
    bPlainBlockExp[0] = 0x25;
    bPlainBlockExp[4095] = 0x22;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 24);
    DspHex("[IN ]bCryptBlock    =", bCryptBlock, 4096);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptBlock(nSock, nAlgo, bKey, bCryptBlock, \
                             nBlockLen, bPlainBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "算法类型=3，数据长度=4096，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bPlainBlock, bPlainBlockExp, 4096);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptBlock_Test_07(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bCryptBlock[4104];
    int  nBlockLen;
    BYTE bPlainBlock[4104];
    BYTE bPlainBlockExp[4104];

    bufclr(bKey);
    bufclr(bCryptBlock);
    bufclr(bPlainBlock);
    bufclr(bPlainBlockExp);

    nAlgo = 3;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8697 A4B5 C2D3 E0F1 */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\x59\x99\xC3\x06\xAB\x84\x01\xB2",\
                 24);
    for(i = 0; i < 4096; i += 8)
        memcpy(&bCryptBlock[i], "\xBA\xF9\xEF\x36\xAC\x80\x81\x58", 8);
    nBlockLen = 4096;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 24);
    DspHex("[IN ]bCryptBlock    =", bCryptBlock, 4096);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptBlock(nSock, nAlgo, bKey, bCryptBlock, \
                             nBlockLen, bPlainBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "算法类型=3，数据长度=4096，空数据测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bPlainBlock, bPlainBlockExp, 4096);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptBlock_Test_08(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bCryptBlock[4104];
    int  nBlockLen;
    BYTE bPlainBlock[4104];
    BYTE bPlainBlockExp[4104];

    bufclr(bKey);
    bufclr(bCryptBlock);
    bufclr(bPlainBlock);
    bufclr(bPlainBlockExp);

    nSock = -1;
    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memcpy(bCryptBlock, "\x56\xCC\x09\xE7\xCF\xDC\x4C\xEF", 8);
    nBlockLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bCryptBlock    =", bCryptBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptBlock(nSock, nAlgo, bKey, bCryptBlock, \
                             nBlockLen, bPlainBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void DecryptBlock_Test_09(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bCryptBlock[4104];
    int  nBlockLen;
    BYTE bPlainBlock[4104];
    BYTE bPlainBlockExp[4104];

    bufclr(bKey);
    bufclr(bCryptBlock);
    bufclr(bPlainBlock);
    bufclr(bPlainBlockExp);

    nSock = 8;
    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memcpy(bCryptBlock, "\x56\xCC\x09\xE7\xCF\xDC\x4C\xEF", 8);
    nBlockLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bCryptBlock    =", bCryptBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptBlock(nSock, nAlgo, bKey, bCryptBlock, \
                             nBlockLen, bPlainBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[8]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void DecryptBlock_Test_10(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bCryptBlock[4104];
    int  nBlockLen;
    BYTE bPlainBlock[4104];
    BYTE bPlainBlockExp[4104];

    bufclr(bKey);
    bufclr(bCryptBlock);
    bufclr(bPlainBlock);
    bufclr(bPlainBlockExp);

    nAlgo = 0;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memcpy(bCryptBlock, "\x56\xCC\x09\xE7\xCF\xDC\x4C\xEF", 8);
    nBlockLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bCryptBlock    =", bCryptBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptBlock(nSock, nAlgo, bKey, bCryptBlock, \
                             nBlockLen, bPlainBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效算法类型[0]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptBlock_Test_11(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bCryptBlock[4104];
    int  nBlockLen;
    BYTE bPlainBlock[4104];
    BYTE bPlainBlockExp[4104];

    bufclr(bKey);
    bufclr(bCryptBlock);
    bufclr(bPlainBlock);
    bufclr(bPlainBlockExp);

    nAlgo = 4;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memcpy(bCryptBlock, "\x56\xCC\x09\xE7\xCF\xDC\x4C\xEF", 8);
    nBlockLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bCryptBlock    =", bCryptBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptBlock(nSock, nAlgo, bKey, bCryptBlock, \
                             nBlockLen, bPlainBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效算法类型[4]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptBlock_Test_12(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bCryptBlock[4104];
    int  nBlockLen;
    BYTE bPlainBlock[4104];
    BYTE bPlainBlockExp[4104];

    bufclr(bKey);
    bufclr(bCryptBlock);
    bufclr(bPlainBlock);
    bufclr(bPlainBlockExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    nBlockLen = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bCryptBlock    =", bCryptBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptBlock(nSock, nAlgo, bKey, bCryptBlock, \
                             nBlockLen, bPlainBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效数据长度=0测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptBlock_Test_13(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bCryptBlock[4104];
    int  nBlockLen;
    BYTE bPlainBlock[4104];
    BYTE bPlainBlockExp[4104];

    bufclr(bKey);
    bufclr(bCryptBlock);
    bufclr(bPlainBlock);
    bufclr(bPlainBlockExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memcpy(bCryptBlock, "\x56\xCC\x09\xE7\xCF\xDC\x4C", 7);
    nBlockLen = 7;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bCryptBlock    =", bCryptBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptBlock(nSock, nAlgo, bKey, bCryptBlock, \
                             nBlockLen, bPlainBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效数据长度=7测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptBlock_Test_14(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bCryptBlock[4104];
    int  nBlockLen;
    BYTE bPlainBlock[4104];
    BYTE bPlainBlockExp[4104];

    bufclr(bKey);
    bufclr(bCryptBlock);
    bufclr(bPlainBlock);
    bufclr(bPlainBlockExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memset(bCryptBlock, 0x5C, 4097);
    bCryptBlock[0] = 0x25;
    bCryptBlock[4096] = 0x22;
    nBlockLen = 4097;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bCryptBlock    =", bCryptBlock, 4097);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptBlock(nSock, nAlgo, bKey, bCryptBlock, \
                             nBlockLen, bPlainBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效数据长度=4097测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptBlock_Test_15(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bCryptBlock[4104];
    int  nBlockLen;
    BYTE bPlainBlock[4104];
    BYTE bPlainBlockExp[4104];

    bufclr(bKey);
    bufclr(bCryptBlock);
    bufclr(bPlainBlock);
    bufclr(bPlainBlockExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memset(bCryptBlock, 0x5C, 4104);
    bCryptBlock[0] = 0x25;
    bCryptBlock[4103] = 0x22;
    nBlockLen = 4104;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bCryptBlock    =", bCryptBlock, 4104);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptBlock(nSock, nAlgo, bKey, bCryptBlock, \
                             nBlockLen, bPlainBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效数据长度=4104测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptCBC_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bPlainBlock[4104];
    int  nBlockLen;
    BYTE bCryptBlock[4104];
    BYTE bIV[16];
    BYTE bCryptBlockExp[4104];

    bufclr(bKey);
    bufclr(bPlainBlock);
    bufclr(bCryptBlock);
    bufclr(bIV);
    bufclr(bCryptBlockExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    /* 0123 4567 89AB CDEF */
    memcpy(bPlainBlock, "\x01\x23\x45\x67\x89\xAB\xCD\xEF", 8);
    nBlockLen = 8;
    memcpy(bCryptBlockExp, "\x56\xCC\x09\xE7\xCF\xDC\x4C\xEF", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bPlainBlock    =", bPlainBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    DspHex("[IN ]bIV            =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptCBC(nSock, nAlgo, bKey, bPlainBlock, \
                             nBlockLen, bIV, bCryptBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "算法类型=1，数据长度=8，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptBlock    =", bCryptBlock, 8);
    DspHex("[OUT]bCryptBlockExp =", bCryptBlockExp, 8);
    ASSERT_OUT_HEX(bCryptBlock, bCryptBlockExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptCBC_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bPlainBlock[4104];
    int  nBlockLen;
    BYTE bCryptBlock[4104];
    BYTE bIV[16];
    BYTE bCryptBlockExp[4104];

    bufclr(bKey);
    bufclr(bPlainBlock);
    bufclr(bCryptBlock);
    bufclr(bIV);
    bufclr(bCryptBlockExp);

    nAlgo = 2;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
                 16);
    /* 0123 4567 89AB CDEF */
    memcpy(bPlainBlock, "\x01\x23\x45\x67\x89\xAB\xCD\xEF", 8);
    nBlockLen = 8;
    memcpy(bCryptBlockExp, "\x1A\x4D\x67\x2D\xCA\x6C\xB3\x35", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 16);
    DspHex("[IN ]bPlainBlock    =", bPlainBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    DspHex("[IN ]bIV            =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptCBC(nSock, nAlgo, bKey, bPlainBlock, \
                             nBlockLen, bIV, bCryptBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "算法类型=2，数据长度=8，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptBlock    =", bCryptBlock, 8);
    DspHex("[OUT]bCryptBlockExp =", bCryptBlockExp, 8);
    ASSERT_OUT_HEX(bCryptBlock, bCryptBlockExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptCBC_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bPlainBlock[4104];
    int  nBlockLen;
    BYTE bCryptBlock[4104];
    BYTE bIV[16];
    BYTE bCryptBlockExp[4104];

    bufclr(bKey);
    bufclr(bPlainBlock);
    bufclr(bCryptBlock);
    bufclr(bIV);
    bufclr(bCryptBlockExp);

    nAlgo = 3;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8697 A4B5 C2D3 E0F1 */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\x59\x99\xC3\x06\xAB\x84\x01\xB2",\
                 24);
    /* 0123 4567 89AB CDEF */
    memcpy(bPlainBlock, "\x01\x23\x45\x67\x89\xAB\xCD\xEF", 8);
    nBlockLen = 8;
    memcpy(bCryptBlockExp, "\xB1\xBD\x7B\x27\x8E\xA6\x2F\xCD", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 24);
    DspHex("[IN ]bPlainBlock    =", bPlainBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    DspHex("[IN ]bIV            =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptCBC(nSock, nAlgo, bKey, bPlainBlock, \
                             nBlockLen, bIV, bCryptBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "算法类型=3，数据长度=8，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptBlock    =", bCryptBlock, 8);
    DspHex("[OUT]bCryptBlockExp =", bCryptBlockExp, 8);
    ASSERT_OUT_HEX(bCryptBlock, bCryptBlockExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptCBC_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bPlainBlock[4104];
    int  nBlockLen;
    BYTE bCryptBlock[4104];
    BYTE bIV[16];
    BYTE bCryptBlockExp[4104];

    bufclr(bKey);
    bufclr(bPlainBlock);
    bufclr(bCryptBlock);
    bufclr(bIV);
    bufclr(bCryptBlockExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memset(bPlainBlock, 0x5C, 4096);
    bPlainBlock[0] = 0x25;
    bPlainBlock[4095] = 0x22;
    nBlockLen = 4096;
    memcpy(bCryptBlockExp, \
          "\x6E\x0F\x4E\x43\xFF\xCB\x0C\x0A\x23\x1E\x80\xF8\x9F\x2D\x3F\xAB" \
          "\x0E\x65\x6B\x21\x7B\x19\xB9\x15\x36\xAE\x40\x24\x15\x8E\xC4\xE5" \
          "\xAB\xBD\x93\xBF\xA8\x58\x5A\x36\x7D\x9E\x3E\xE0\xEB\x3A\x3E\x6F" \
          "\xE1\x09\x2B\xD2\x90\x15\xC3\x33\x2D\x74\x31\x46\xC0\x10\x0B\x20" \
          "\xBD\x05\xFF\xBE\xF6\xB7\x42\x21\xC1\xA9\x8E\x05\x4E\x9C\x3C\x05" \
          "\x38\xB0\x0F\xFA\xDB\xC8\x0E\xEB\x17\xCF\x9C\x46\xE1\x02\xC6\xD0" \
          "\xAF\xA6\xE1\x29\x0A\x96\xD3\x4B\x4F\x44\x45\x47\x59\x7C\xF6\xAD" \
          "\xB4\xEA\x14\x0E\xA6\x66\xA4\x9D\x9C\xA8\xEC\x24\xB8\x06\x61\x72" \
          "\xF3\x51\x21\x3E\x68\xD0\x0F\xDD\x70\xE0\x50\xEE\x8B\x8A\xE8\x3F" \
          "\xFB\x5C\x08\xB9\xCA\x40\xD7\xD0\xE0\xEB\xC8\xB0\x53\x30\xA7\xC7" \
          "\x1A\x0A\x08\xC6\x9C\x3F\x22\xD5\xFA\x3F\x98\x77\x52\xD4\xFB\xE0" \
          "\xAF\x2E\xB2\xE2\x09\x10\xBD\xFC\x14\x8E\x8A\xE9\x64\x43\x54\xE2" \
          "\x40\xF3\x37\xE1\xD0\x5B\xA8\x26\x48\xC2\x21\x5F\x83\xF8\x2A\xA3" \
          "\xE8\xEF\xC6\x4F\x04\x2A\x4D\x59\x8D\x3A\x5A\xB9\xF7\xA4\xFA\x39" \
          "\xF0\xDE\xB0\x49\x85\x1C\x28\x92\xAD\xF3\xA5\x3C\x6A\xE5\x21\x6C" \
          "\x17\x7A\x8D\xC7\x00\x34\x6D\x91\x51\x73\xE8\xE7\x93\x11\x74\x6F" \
          "\x04\xAE\x41\x71\x94\xFA\xB7\x5E\xAD\x31\x42\xE4\x5F\x4E\x0E\xE6" \
          "\x1A\x4C\x07\xF5\xCD\x5D\xDC\xCF\x28\x7B\xB7\x87\x1E\x38\x48\x2D" \
          "\xBE\x59\x3C\xA1\x5C\x86\x78\x08\xFD\x6A\x16\x16\x00\xC2\xDE\xDF" \
          "\x62\x89\x90\x67\x80\xA6\xB3\xA3\xD3\x68\x1E\xAA\x2A\xAA\xDD\xCA" \
          "\xFB\x8D\x49\xFA\x0A\x63\xC9\xBD\x3E\x22\x89\x11\xA6\xB8\x91\x36" \
          "\x3B\x9E\xAD\x38\x61\xC4\x39\x0D\xA7\x0E\xA7\x23\x0E\x4E\xE2\x10" \
          "\xD0\x89\xF0\x18\x08\xAB\x89\x9B\x63\x46\xC5\xA3\x58\x74\xF7\xC5" \
          "\xF2\x82\xBE\xC8\x77\x97\xBC\x11\x9A\x78\x66\x18\x52\x7C\xD9\x5B" \
          "\x63\x91\x74\x64\x85\x7D\xEE\x11\xA8\x43\x0B\x1B\xD2\x81\xD8\xD7" \
          "\x8C\x88\x39\xEB\xA0\x67\x1E\xE0\xB9\xEA\x7D\xCB\x6D\x92\x40\x0B" \
          "\x64\x1D\x14\xAD\xF3\x85\xF6\x86\x1D\xAF\x2D\x27\x18\x4B\xFA\x20" \
          "\x09\x5C\xEA\xFE\x7B\xC3\x0B\xDB\xFB\x60\x4D\x30\xB9\x9D\xDF\x0F" \
          "\xFA\x8F\x89\xEA\x21\x4F\x84\xCF\xE0\x20\xAF\x71\x02\xE9\xB5\xD9" \
          "\xBD\x36\x39\x38\x62\x82\x25\x5A\x8B\xA1\x54\xD4\x1B\x55\xA3\x51" \
          "\x7E\xA2\x87\xFC\x99\xC2\x82\xAC\xDE\x55\x30\x43\x68\xC1\xA4\xEB" \
          "\xEA\xFA\x12\xA4\xCB\xC2\xA2\x93\xC4\x41\x93\x0B\x25\xFB\x6F\x94" \
          "\x17\xA9\x31\xB3\xAE\x33\x5A\xB3\x17\xC6\x1E\x12\xFF\x02\xF8\x10" \
          "\x21\xEF\xB6\x65\xD8\xF2\x6E\xF9\xB6\xD0\x0A\xC8\x8B\x05\x83\xCB" \
          "\xFE\xE7\xB6\x8D\xBD\x0F\x6C\x7A\xD0\x60\x8B\xCD\xF4\x3A\x82\xDA" \
          "\x7B\x0F\x1D\x81\xBB\x02\x8D\x83\x49\xC1\x3D\x8C\x52\x16\x82\x22" \
          "\xBF\x54\x76\xFF\xE0\xB6\x70\xCA\x35\x2C\x65\x98\x9A\x77\x6A\x56" \
          "\xEA\xAC\xC5\x30\xD8\xA2\x4A\x0D\x1E\xAB\xB1\x19\xB4\x32\x8B\x86" \
          "\x46\x4A\x94\x0D\xBA\xBF\xD8\xEF\x67\xFF\x6B\x19\x7C\x6D\xF5\x3B" \
          "\xAA\x8A\x14\xDB\x84\x0E\x32\x7F\x5F\xD6\x5C\x3A\xA0\x21\x8A\x58" \
          "\xE4\x01\x2D\x6F\x61\x83\xEA\x36\x1E\xAC\xE0\x03\xEF\xB5\x87\xEF" \
          "\x05\xEE\x4A\x00\xF3\xFF\xDF\x88\xA0\xA5\xC2\xBD\x85\x2C\x37\xB5" \
          "\x21\x4A\x88\xB3\xC6\x36\x26\x45\x46\x06\x3C\xB5\x93\x3B\xBC\x6C" \
          "\x49\xAB\xC2\x77\xD5\x9A\x73\x48\x3B\xDA\xC5\x56\x9B\x4E\x42\xB6" \
          "\x24\x49\x12\xFD\x76\x76\x82\x29\xBB\x72\xDF\xF7\xD2\x53\x7B\xA6" \
          "\x88\x1C\xB6\x7A\x23\x5C\x50\xBC\x50\x13\xDC\xBA\x8F\x13\x79\x52" \
          "\x42\x6F\xBF\x25\x9E\xE7\xC4\x97\x57\xA7\x6F\xAF\x09\xC4\x41\x43" \
          "\xFF\xE6\x33\x9D\xAC\xFF\x39\xD0\xC3\xA9\xAD\x2C\xCC\x68\xAF\x01" \
          "\x2A\x52\xDA\x06\xC3\xA9\xB2\xF7\x10\x93\xA9\x87\xD6\x4E\x66\xA9" \
          "\x62\x5A\x35\xD0\x5B\xD9\x46\xCB\x7A\xD9\x75\xB4\xA0\xCE\x77\x80" \
          "\x9E\x97\xC9\x92\xB6\x74\xB6\xA4\xC9\xD9\x2B\xEB\xF7\x6A\x27\xEA" \
          "\x76\x1F\xC9\x02\xCB\x17\x33\x11\x13\x5C\x6B\x98\x49\xAF\x07\x18" \
          "\x5A\x7B\x57\xB9\x01\xC1\xE8\x73\x40\x13\xC3\x24\x85\x31\x7F\xCE" \
          "\x96\xC9\x16\x19\x7D\xBA\xFD\x93\x84\xE3\xED\x70\x0E\x8E\x45\xA4" \
          "\x7F\xC4\x80\xF1\xEA\xCF\x53\x32\x7C\xC1\x63\xC4\xC0\x85\x77\x6A" \
          "\xF6\xE6\xEF\x40\xFD\x2B\xB3\xC2\x0C\x5A\xB8\x37\x4A\x09\x68\x0B" \
          "\xF2\x73\x3B\x6F\xAC\x71\xB3\xA9\x0F\x92\xDE\xFC\x1E\x9E\x48\x34" \
          "\xE4\x61\x71\x9E\x16\x14\xEC\x1F\xE5\x9C\x44\xBF\x13\x93\x12\x75" \
          "\xFF\x0E\x58\x86\x65\x29\xA1\xCC\xBC\x48\x26\x5C\xB6\x1C\x7F\x77" \
          "\x3B\x3A\x61\xE9\xBD\x89\x85\x6D\x33\x6E\xF1\x18\x15\x78\x2A\x21" \
          "\x7D\xF6\x58\x37\xEE\x68\x49\x1E\x9C\xF6\x11\x01\xFA\x55\xCD\x4A" \
          "\x86\xBE\xC0\xF1\x4B\x92\xFF\xBA\x7C\xB9\x8D\x45\x61\xFB\x07\x61" \
          "\xD0\x7F\x38\x52\xB2\x50\x25\x03\x58\x00\x4E\x55\xA2\x2D\x75\x6F" \
          "\x40\x03\x8E\x0F\xB0\xB3\x85\x9E\x3E\x3C\x28\xA1\x4A\xB0\xAF\x4D" \
          , 1024);
    memcpy(&bCryptBlockExp[1024], \
          "\xFA\xC9\x9B\x55\x15\x0D\x36\x11\x17\x60\xB2\xCC\xED\xB8\xF0\x29" \
          "\x17\xDA\xE6\xDF\xC7\x3C\xAF\x56\x23\xE3\xF2\xF0\xB9\xFE\xE5\x1F" \
          "\x0C\x02\xF7\xA5\xAE\x8F\x1D\xBC\xB4\x5B\x43\x17\x7A\x3A\x53\x7D" \
          "\x65\xC6\x9D\x20\x1C\x9D\xB6\xAE\xC6\xBE\xE1\xC0\x05\x11\xDF\xC1" \
          "\x09\xB0\x57\xE2\x03\xB5\x17\xFE\xD5\x9A\xFB\x1E\x55\x60\xE4\xAE" \
          "\xAF\xA3\x88\x11\xF1\x91\xA6\xBE\xA0\x01\xB2\x7D\x43\xE5\x89\xCE" \
          "\x30\xB1\x97\x29\x17\x26\xB4\x11\x1E\x50\xC4\x6D\xCD\xA1\x62\x59" \
          "\x60\x80\x8F\xA1\xEA\x8D\x6E\x5E\x64\xF4\xBE\x4B\x06\xF8\xC3\xB9" \
          "\xF6\xE9\xC2\xEC\x2F\x30\x96\xEC\x44\x09\xC2\xAB\x8F\xDB\xAE\x9B" \
          "\x36\xE9\xAA\x66\x7D\x9E\x59\x1C\xE5\x07\xDA\x15\xC6\xFD\xC5\xFA" \
          "\x6B\x68\x47\x07\x72\xD7\x06\x8B\x88\xC8\xD4\x3B\xA6\x2F\xED\x02" \
          "\x4E\x10\x7A\x44\x91\x67\x25\xCA\x5E\x90\xF0\xEB\x9A\x24\xAE\x24" \
          "\x09\xF5\xEC\x0A\xDD\xF9\x83\x09\xBA\x49\x19\x8E\xAA\x47\x64\xE0" \
          "\xBC\xA9\xE2\xBA\xCA\xC5\xE7\x76\xF7\x72\x20\xCF\x4E\x55\xE7\xAE" \
          "\x7C\x14\x81\xB0\x66\xE7\x3B\xB3\x73\x46\x96\x1C\xE2\x0F\xE2\x11" \
          "\x0D\x4D\x69\xA2\x96\xB3\xC4\x9D\xC3\x4D\x99\x8C\xBC\x7A\x40\x0E" \
          "\x06\x63\x8E\x0D\x19\x7E\x82\x65\xCC\x74\x2E\xF9\x15\xB4\x07\x28" \
          "\xBF\xD1\x0B\x9D\x9A\xBD\x8E\x5E\x28\xF5\x95\x58\xB6\x6C\x26\xA4" \
          "\x25\xFA\xC0\x5E\x74\x77\x80\x1C\x1C\x81\x32\x20\x8C\x63\x6E\x74" \
          "\xB6\xC6\x4C\x1B\xBB\xD5\xB9\xCB\x6B\x6B\xDC\x6A\xF3\xDC\x79\x58" \
          "\xE6\xEA\xF0\x6C\x8B\x47\xBA\x3A\x47\x6E\xC0\x27\xC7\xCE\x12\x53" \
          "\x28\x5F\x77\x39\x43\x0A\xE2\x71\x2C\x3F\xC8\x2B\x07\x18\x95\x39" \
          "\x8E\x06\x72\x62\x1E\x28\xD2\x3E\xAF\x10\x6E\x4D\x73\xCE\x02\x97" \
          "\xCA\x99\x72\x2D\x6A\x07\xCD\xEC\x9F\x2F\x64\x5D\xD0\x61\x91\xB0" \
          "\xF5\xA4\x8F\x00\xDF\x2E\xA2\x30\x02\xEC\x90\xE9\xDD\xE4\x27\xBF" \
          "\x21\x06\xD5\x48\x41\xE0\xE0\x11\x64\x23\xC0\x95\x66\x0A\xED\xCB" \
          "\x38\x50\xC5\x4E\x58\xC5\x9A\xBD\x5F\xFE\x71\xB9\x71\xF4\xD0\xFA" \
          "\xA2\xB6\x74\x14\xC9\x74\x40\x31\xBE\x92\x64\x74\xC6\xB1\xEA\x71" \
          "\x58\xC0\x1C\xA0\x09\x2F\x3C\x99\x78\xA8\x1C\x9F\xA0\x7F\x82\xD1" \
          "\xFA\x3F\x54\x08\x47\x14\x09\x63\x0A\x98\x37\xAA\xAE\xB8\x44\x1D" \
          "\xC3\xEA\x4D\xC5\x1B\xF4\x79\x54\xC1\x2E\x50\x60\xEE\xC8\xC1\xF2" \
          "\x6C\x4D\xCD\x4E\x34\x33\x5A\xFA\xF0\x2D\xBC\x9D\x09\x22\x93\x82" \
          "\xB8\x60\x3D\xB1\x7C\x54\x25\x4F\xC8\x99\x4A\x9E\x01\xB6\x73\x62" \
          "\x44\x58\x89\x71\xDB\xF0\xBF\x77\x99\x02\x5A\xFA\xA8\xBE\x06\x9B" \
          "\xA2\x46\x6F\x42\xC1\xEA\x95\x16\x76\xB2\xE5\xA4\xFA\x72\xD3\x14" \
          "\xCD\xE2\x66\x30\xE2\xB1\x88\x67\xB9\x57\xAE\xC9\xE6\x16\x5F\x19" \
          "\x8B\x1A\xBD\xCA\x0B\x99\xEB\x2A\xAA\xD3\x27\x31\x29\x62\xDD\xB0" \
          "\xD6\x16\x1E\x33\x6E\x6C\x45\xCB\x81\x29\x70\xFF\x99\x57\x5F\x46" \
          "\x3B\xF3\x5E\xCB\x2B\x09\xC0\x2E\xDE\x34\x58\x83\x75\x77\x79\xEA" \
          "\x2C\x0D\xED\x36\x2B\x91\xC2\xB4\xAE\xBE\x96\x08\x8D\x69\xEC\xD9" \
          "\xAC\x66\x54\x40\xAB\xAE\x57\x7D\xF6\xC8\xF0\xC6\x8E\xB6\x3D\x65" \
          "\x4F\x67\x9C\x35\xF8\x9B\x7F\x17\xBB\xCE\xA1\xFD\xF7\x89\x38\x33" \
          "\xC8\x3B\x0E\xF1\xA2\xE0\x4B\x9F\xD3\x21\x4F\x04\xA7\xA5\x7B\xED" \
          "\xA0\xDE\x94\x34\xF5\x9B\x3A\xE0\x99\x0E\x79\x85\x98\xD6\x98\x91" \
          "\x8D\xAB\xC1\x2C\xE2\xE4\xCF\x42\xF5\x06\x0E\x6E\x57\x15\xF3\xA7" \
          "\xF5\xB6\xE1\xEB\x1A\xFF\xCF\xC3\x71\xB4\xDE\xD9\x39\xA4\x49\x6D" \
          "\x0D\xE7\x1F\x9F\xBF\x72\x99\xE0\x1B\x0E\x7E\x9D\x0F\xB3\x98\x6A" \
          "\xE4\x3B\xAA\xFA\x30\x81\xE7\x3B\xC3\x20\x4E\x11\x55\x87\x0D\x9E" \
          "\x59\xC8\x6E\x27\x91\xE5\x70\x9C\x3C\x81\x15\x48\xC4\x8B\xBF\x75" \
          "\x26\x8C\x39\x56\xB1\x67\xDA\xDB\x33\x7F\x77\x41\xDD\xEB\xEF\x4A" \
          "\x28\x9B\xF8\xFA\x8C\x80\xB3\x08\x0C\x23\xD5\x6C\x5F\x6E\xD4\x59" \
          "\x1B\x3B\xC0\xD6\x02\x48\x5B\xBB\xF8\xF7\xD0\x9B\x17\xB0\x22\x7E" \
          "\x91\xC2\xA9\x8D\x81\x2B\xB1\xA9\x53\x5B\x76\xBE\x25\x9C\x0A\xA6" \
          "\x61\x90\xFC\x4E\xAD\xDF\x8D\xE5\xF1\x1D\xD8\x25\x32\xBE\x1F\x3D" \
          "\xEA\xED\x68\x0F\x75\xE7\xCC\x4C\x4D\x18\xD8\xE2\x65\x39\x82\x61" \
          "\xB7\x4D\x5E\x09\x67\x00\xAB\x47\xFC\xEC\xA4\x26\x1B\xDB\x14\x9B" \
          "\x08\x48\x73\xB1\x35\x40\x4C\x4D\x60\x05\x5C\x33\x60\x4D\xC9\x27" \
          "\x5D\x4C\x7B\xE6\x17\xB6\x01\x72\x3F\x26\x7E\xEB\x1B\x9C\x02\x89" \
          "\x55\x7E\x66\x97\xD6\x56\xF2\x3B\x49\x4D\x2E\xFB\x86\xE2\x53\x55" \
          "\x0F\x96\xC0\x9F\xE1\x43\x9D\xB9\x77\x16\xBF\x88\x22\xEF\x07\x8D" \
          "\xAD\x38\x24\x19\x96\x6E\x92\x30\xCC\x08\x52\x7F\x2B\xB7\xBB\x00" \
          "\x20\x3B\x60\xF5\xF7\x2E\x94\xDD\x5D\x45\x68\x90\xEB\x46\xFE\xF7" \
          "\x84\xE9\x4B\xAC\xEA\xD9\x01\x24\x1E\x98\x01\xEB\xC5\x4A\x14\x7D" \
          "\x08\xB6\xCC\xD3\xEF\x0B\x86\xE0\x5E\x61\xC5\x0F\xEF\x87\x2D\xA9" \
          , 1024);
    memcpy(&bCryptBlockExp[2048], \
          "\x78\x67\x5B\x5B\x1F\x47\x01\xAB\xCF\xDE\xCE\x5B\x02\x3E\xD9\x4B" \
          "\xF2\x2E\x3C\xD1\x2E\xFA\xC1\x9D\xC2\x5A\xAD\xD6\x84\x41\xAB\xAC" \
          "\xCB\x53\x80\xE3\x03\xA4\xEA\xC2\xE4\x89\x69\x90\xA6\x68\x7E\x5B" \
          "\xAF\xB4\xB1\xA0\x14\x66\xFF\x2B\xDB\x6F\x03\xDA\x36\x10\xA3\xFC" \
          "\x09\x04\x3F\x2D\x1B\xF1\x8F\x1D\x82\x50\x2D\x7C\xA1\x52\xEB\xE5" \
          "\xBD\x2E\x80\xE2\xEB\x12\x37\x1D\xA4\x64\x92\x6F\xB2\xE7\xA6\x35" \
          "\xF2\x7C\x03\x92\x52\x74\xD9\x77\xF8\x0A\x5F\x21\x52\xA4\xCD\xB7" \
          "\x48\xB0\x41\x83\x83\xE0\xD8\xB4\xF3\xC0\xF0\x8C\xC9\x30\xB7\x7B" \
          "\xD9\x57\x23\xB8\xA5\x8D\xE8\xBA\x3E\x9D\x49\xEB\x80\x50\x82\xCA" \
          "\x16\x26\x1E\xD8\xE2\x33\x31\xBD\x51\xBD\xB2\x8F\x7C\x7A\xB4\xE3" \
          "\x12\xB7\x59\x0B\x37\x22\x15\x52\x6B\x8B\x1F\x87\x75\x34\xD3\xC2" \
          "\x9F\x11\x27\x8B\xA1\x7D\xBB\x93\x05\x45\x94\xFE\x9A\x5B\x87\x04" \
          "\x7D\x77\x1F\xBF\xA6\x33\x84\x29\xEB\x86\xD1\xAA\xFB\x11\xD1\x78" \
          "\x3B\x62\xA2\xD9\xBE\x2E\xF8\x98\xFE\xE9\xA4\x65\x53\x3E\xF3\xCB" \
          "\x00\xE1\xA8\xE3\x03\x7F\x69\x9F\x4A\x0A\x50\x00\x02\xDD\x74\xC7" \
          "\x53\xDE\xAC\x64\x14\x98\x17\x1F\x49\xB0\x8C\xA5\x53\xD8\x96\xF9" \
          "\xCB\x10\xE0\xDC\x4B\x3B\x67\x03\xBD\x9C\x08\x46\x77\x7D\xD1\xB8" \
          "\x33\xFC\xF6\x24\x52\x43\xEC\x62\x3F\x5F\x25\x59\xAB\x10\x87\xD3" \
          "\x7D\xD3\xF1\x7C\xD5\xBC\x0C\x5C\x87\xC8\x2C\x84\xD7\xDB\xB2\x72" \
          "\x9B\xE8\xD2\xE9\x40\xCE\xC4\xA8\x45\x24\x99\x01\x4E\xB0\x8E\xE9" \
          "\x15\x1D\x55\xB6\x20\x22\xE6\xC8\x44\x17\xC6\xB4\xA8\x1F\x4A\x5E" \
          "\x6C\x08\xEE\x94\xFC\xBA\x1A\x42\x03\x12\x51\xFD\xBA\xCC\xCE\x0C" \
          "\xE3\x5E\x5A\xF7\xE9\x5B\x01\x5F\x44\x07\x2E\x74\x97\xC6\xCF\x2E" \
          "\x5C\x4E\xDD\x74\xB1\x76\xC7\x79\x23\x9D\x5F\x43\xDD\x70\x98\x13" \
          "\xA2\x8C\xE7\x7B\x63\x7F\xBC\x7D\x73\x80\x9D\xE4\x74\x0C\x2F\x29" \
          "\x19\x67\x42\xE9\xCD\x02\xE0\x63\x48\xE6\xE4\x5E\xC2\x45\x36\xAC" \
          "\x89\xF2\x4B\x55\x0B\xC6\x41\xB4\x4B\x6E\x82\xDE\x72\x7E\x9E\xBB" \
          "\xC5\x26\x82\x57\x81\xD9\x15\x65\x8E\x23\xD2\xC9\xFE\x55\xFD\xC4" \
          "\xF2\x06\x9C\x3F\xAF\xB7\x8D\x2C\x38\x77\x17\xD6\x26\x35\x68\xD2" \
          "\xBB\x01\xD6\xAA\xA4\xC5\x11\x7D\xD1\xDA\x70\x23\x80\x81\x4E\x42" \
          "\x34\xE9\x3D\x86\x54\xAB\x8C\x43\x0E\xBA\x7E\xCE\x42\xDB\x69\xDC" \
          "\xBC\x0B\xE2\x23\x44\x06\xDF\x68\x89\xB3\x2F\x09\xF6\xD8\x77\xD0" \
          "\xD5\xFB\x24\x2B\x08\x30\x80\xAC\x4D\xFE\xFE\xEF\x73\x93\xB6\xCC" \
          "\xF6\x38\x09\x37\xE8\x2D\x2C\x1E\x82\xB6\x67\x65\xA4\xAA\xE2\xB1" \
          "\x1B\x1C\x05\x70\x72\xF8\x17\x9E\xF9\xCD\x9B\x75\xE7\xF8\xAB\x41" \
          "\xEF\x0B\xF7\x6E\xC6\x7A\xA2\x16\x87\x9A\xF5\x01\xC9\x54\xE9\x5F" \
          "\x12\xA3\x14\xCB\x5C\xDF\x95\xDA\xDA\xB8\x59\x43\x8B\x4D\xBB\xBD" \
          "\xD6\x03\x88\xE9\x80\x8E\xF3\x87\x05\x57\x62\x08\xAE\x9D\x76\x69" \
          "\x43\x32\x47\x28\x5D\xF0\xBA\x3E\x9B\x71\xAC\xCF\xED\xFA\xF9\xC1" \
          "\xED\xEF\xFD\xC6\x31\xFC\x09\x66\xE4\x8F\xD9\x97\x61\xE1\x0F\xAB" \
          "\x2F\xA8\x85\x83\x66\xAF\xAB\xFA\x4B\xF1\x82\xA0\xD4\x67\x6D\x2B" \
          "\x11\x4D\x57\x32\xC5\x45\x99\x19\xE6\xEB\x6D\x93\xB9\x8D\x35\x1F" \
          "\xA3\x1E\x56\x09\x43\xDE\x08\xCF\x3B\x6A\x89\x6F\x7C\x00\xD4\x76" \
          "\xB2\x67\x25\x0A\x68\x9A\x24\xFB\x1C\xBF\xFC\x1B\x91\x57\x11\x7A" \
          "\x4F\xB1\xEC\x92\xEA\xF7\x54\xAA\x78\x51\xC9\x23\xEA\xA6\x49\x88" \
          "\xDF\x36\x1C\x79\xBB\x65\xBE\x8B\xE7\x2A\x3D\xBD\x24\x66\xB0\x3B" \
          "\x42\x14\x0D\x43\x1E\x44\x1F\x46\x0A\x32\xE0\xB6\xB3\x44\x8E\x4F" \
          "\x12\x06\x9A\x00\x6C\xA9\xB7\x14\x57\x4A\xD0\x70\xDD\xE3\xB5\x19" \
          "\x5B\xE6\xA7\x30\x67\x6F\xD1\x5A\xB7\x53\x2C\x85\xF0\x30\x6F\xE0" \
          "\x8A\xBF\x90\xE9\xF0\xF3\x68\x83\x8B\x35\x78\x78\xC5\xC4\x3C\x30" \
          "\x57\xAF\xB6\x1D\x9A\x3F\xE5\x3D\xB9\xC6\xBD\x48\x8B\x8C\xC3\xDC" \
          "\xD1\x2A\x48\x4A\x58\xED\x1B\x25\xB0\x80\x83\x7A\xB5\x58\xD3\x53" \
          "\x5D\xC3\xCB\xF2\x77\x4D\x49\xC3\xCC\xA3\xE3\x14\x42\x5C\x13\xC4" \
          "\x73\x09\xF0\x4D\x5D\x97\x54\xDE\xC7\x1B\x5D\x13\x8D\x78\x6E\x9B" \
          "\xEC\xB8\xB7\x96\x4A\x39\x03\xD1\xBA\x69\xDB\x8E\x6A\x8E\xF8\xC7" \
          "\xDB\x42\xE7\xE1\x77\x6D\x71\xA1\x30\x32\x36\xD8\x91\x48\xF9\x05" \
          "\x32\x59\xAA\xD1\x8C\x74\x58\x23\xC5\xDD\x3F\x01\x52\x61\x44\x55" \
          "\x79\xCD\x1A\x29\x43\xBE\xED\x9C\x25\x22\xF4\x1E\x54\x21\xDF\x6A" \
          "\x29\xC8\x33\x9C\x00\x5F\xF9\x48\xA0\x6B\x88\x3F\xA1\x4E\xB3\x2F" \
          "\x96\x76\x32\xCD\xC0\xDD\x10\x1A\x7F\xC3\x1D\x95\xA0\xE3\x32\xA1" \
          "\xE6\x6C\x78\xFE\x0E\xD1\x08\x0D\x6A\x9F\x5A\x2E\x51\x52\x27\xC6" \
          "\x83\x32\x30\xDF\x34\x86\x33\xAF\x73\xF1\x1A\x90\x82\x54\x8B\xBA" \
          "\x47\x10\x6D\x1E\x36\x31\x85\xD5\x73\x96\xBA\x90\x46\x7C\x3A\xCC" \
          "\x30\xAE\xBE\xC7\x00\x32\xFA\x36\xDD\x1C\x57\x45\x67\xF0\x7A\xA1" \
          , 1024);
    memcpy(&bCryptBlockExp[3072], \
          "\xF5\xC6\xAB\x3D\x28\x09\x08\xA2\x70\x36\x42\x7E\x9E\xC6\x42\xA4" \
          "\xEA\x4F\x46\xD8\x99\xCE\x35\x6B\xDB\xF5\xC7\x50\xEB\x6D\x9F\xAE" \
          "\x50\x23\x0C\x6B\xD3\x83\x11\xCA\xC5\x3E\xA9\xAA\x25\xB9\x4A\xFC" \
          "\x1B\x91\x60\xBF\x54\x80\xAF\xEA\xD7\x5C\x0B\x6B\x25\x6E\x10\x87" \
          "\x98\x06\x97\xBE\x07\x06\x54\xED\xA8\x02\xAD\xFB\x64\x48\xEF\x48" \
          "\x76\xE7\xBB\xE8\x0D\x7E\x3B\x09\x99\x1B\x75\x1F\x6D\xC9\x54\xD3" \
          "\xDF\x19\x36\xBC\x01\x9E\x5C\x4C\x98\x0C\xFD\x71\xAD\xB2\xAC\x6E" \
          "\x23\xF9\x9B\x02\x31\xE5\x36\x93\xA7\x24\x33\xDC\xEB\xDA\xB4\xAC" \
          "\x25\xBA\x76\xA7\x5E\x6C\x5E\x6A\xF9\x19\x75\x1D\x17\x8E\xBE\xC9" \
          "\x4C\x40\xCF\x87\xE1\x7F\x89\xC7\x3E\x91\xC7\xC2\x92\xB1\x5A\x0A" \
          "\x62\x4C\x1C\x45\xCD\xFB\x02\xEE\xED\x7B\x4B\xC1\x7A\xE3\x29\x40" \
          "\x4F\x65\xBB\xB0\xF1\xE1\xD4\x66\x41\xB6\x5D\x9E\x76\xBC\xCE\xC5" \
          "\x35\x3E\x06\x2D\x19\xF2\x1C\xD6\x30\xEC\xEB\x10\x84\x63\xA0\xFA" \
          "\x22\x11\xDB\xAA\x3B\xDF\x68\x90\xAA\xA6\x8F\xD5\x8A\xD8\x69\x06" \
          "\x4E\x4F\x57\x9D\xEA\x6E\x78\xF8\x71\xD4\x9D\x3A\xD3\x64\xF2\x47" \
          "\x9E\x46\xDB\x90\x16\x6D\x12\xA2\x32\xD0\xD0\x31\xC5\xD6\xA5\x2A" \
          "\x9A\x0E\x90\x8C\xC8\xE6\x78\xE3\xBC\xFF\x29\x5E\x92\x4B\x38\x71" \
          "\x65\x83\xC3\x3E\xD9\xA5\x0B\x6B\xF6\x87\x1C\x87\xE8\xF8\xA8\xF4" \
          "\xAB\x47\x72\xFE\x95\x8E\xC0\x4E\xEC\xC8\x66\x4D\xA8\xBD\xA9\x57" \
          "\x8F\xCC\x36\xE9\x3F\x39\x9D\xB1\xA7\x3B\x8C\x76\x9E\x3D\xF7\x2F" \
          "\xC1\xF2\xCA\x37\x7A\xC2\x13\xD8\x6D\xD6\xEA\x10\x64\x1C\x8F\xE4" \
          "\xDD\xBB\x57\x27\xC6\xA6\x69\xAE\x8D\xA7\x01\x13\x64\x99\xEB\x89" \
          "\xD5\x6E\x8F\x1D\xF3\xCF\x5A\x3C\x01\xF4\xA4\xF0\xEE\xF6\x4A\xEB" \
          "\x67\xA9\x8E\x25\xF9\x6C\xC6\x7D\x38\x24\x5A\x2F\x40\x17\x64\x7C" \
          "\xDF\x89\xC5\x0C\xB9\x21\x12\x25\x92\x4F\x10\x1F\x9B\xFD\x01\x09" \
          "\x16\xB2\x3C\x32\xF2\x17\x1F\x70\xB1\x0A\xB6\xDE\xB6\x7A\x19\x07" \
          "\x93\x7A\x89\xF2\xBF\xCD\x6E\xBD\x0C\xDC\x49\x7F\xD7\xE3\xD6\x8A" \
          "\xD2\x79\x44\x00\x0F\x1D\x85\x20\xC5\x11\xEA\x8D\x40\xDE\x55\x48" \
          "\x2F\xE2\xD5\xD8\x7D\x46\xF6\x04\x4B\xD7\x9C\x22\x1C\x3D\x22\x33" \
          "\x3B\x3A\xAC\x1C\x28\x9A\x15\x42\x81\xAA\xA5\x84\x6B\xD9\xCC\xC1" \
          "\x83\xC9\x32\xC8\xC6\xED\x9F\x67\x69\x84\x25\x0A\xB9\x3A\x36\x14" \
          "\xB4\x67\x49\x2D\x17\xBD\x11\xC3\xCC\xE9\x48\x33\x69\xE7\x38\x57" \
          "\xD5\xAF\x83\xC6\x72\xE6\x28\xA7\x27\xDD\xCF\x73\x12\xF8\xCF\x1B" \
          "\x28\x34\x1B\x02\x1D\x47\x59\x6B\xA3\xC4\x9E\xD6\x8A\x3B\xBF\x93" \
          "\x8D\xBD\x41\x31\x87\x4F\x2D\x2C\xBD\x5A\x88\xAB\xFB\x94\xFC\x4B" \
          "\x9D\xBB\x2A\x62\x73\x40\xE4\x9D\x83\x8F\x7A\xCA\x25\x08\xB7\x75" \
          "\x68\x54\x87\x69\x56\x4E\x9D\xF3\xF6\x8D\x68\x6E\xA4\x1A\xB9\x3A" \
          "\xA8\x4D\x36\xF7\x65\x21\x19\x83\xE3\x5C\xD7\x95\xAE\xE1\x4A\x99" \
          "\xE8\xFB\x9B\x1A\x6E\xD4\x97\xA5\xBD\xAB\x8A\x5A\x55\xDB\x7B\xAC" \
          "\x6C\x3D\x7B\x75\xC5\x74\x20\x2B\xA3\xE3\xDE\x9F\xB5\xC2\xBD\x2F" \
          "\xE5\x71\xC1\xA1\xE9\x5B\xF6\x94\xDC\x04\xC8\x40\x2C\xDA\x09\xD7" \
          "\xD4\xF6\x26\xA9\x17\xD5\x04\x13\x1C\xB4\x67\xEB\xF9\xCC\x02\xE6" \
          "\xF4\xB4\x71\xA1\xC3\xCC\x29\x5A\x2A\x7D\x6D\xEC\x8F\xFC\x05\x0E" \
          "\x29\x76\x44\x92\x58\xE6\xAC\x46\x38\x74\x79\xC9\xAC\x68\x2B\xCB" \
          "\x07\x5D\x44\x38\x46\xAC\x38\x9F\xAE\x85\xF7\x76\x47\xB2\x2E\xFD" \
          "\xB7\xCD\x27\x7A\xCB\xE7\x7A\x47\x5A\xE0\xF9\x60\x9F\x66\x2F\xE7" \
          "\x3F\x41\x55\x67\xA3\x58\x3A\x87\x11\x03\xAC\xC4\x9F\x32\x4B\xA8" \
          "\x3E\x7E\xE1\x98\xB0\x13\xEC\x87\x64\x57\xB7\xD4\x97\x1A\x79\x4E" \
          "\x02\x25\xCE\xE8\x4F\x27\xDD\x4F\x53\xC9\xFA\xEE\x1A\x34\xB2\xA4" \
          "\xD4\x64\xB4\x07\x1A\xAE\xD7\x17\x76\x86\x99\x58\xE7\xDB\x7B\x8E" \
          "\x2C\x56\xB9\xF2\x7E\xEB\x88\x4E\xFF\xC4\x77\x51\x34\xF5\x48\x84" \
          "\x32\xE9\x23\x19\xC6\x78\x83\x60\xBE\x51\xD4\x43\xB9\xD0\x47\x9F" \
          "\xFE\x38\x91\x4D\x61\x22\xC1\xB9\x6B\xD8\xEE\x94\x45\x30\x8D\x35" \
          "\x11\x40\xB5\x45\x33\xBD\xE2\x41\x36\x1A\x43\xB6\xAC\x3D\xFA\xD6" \
          "\x47\xE1\xA4\x05\x4E\x62\xBB\xCC\x57\x3B\x59\x55\x63\x45\xFA\xCE" \
          "\x6B\x66\x29\x56\x7E\xD6\x5D\x7D\x51\xDC\x37\x0C\x5D\x28\xB8\x67" \
          "\x23\xED\x70\x37\x8C\x78\xF6\x0F\x77\x06\x64\x98\x55\x5E\xBF\x0D" \
          "\xCA\x4C\xF3\x7A\x4B\x3B\xBF\xAF\x6C\x2B\x41\x83\xD2\xBD\x15\x3E" \
          "\x32\x3A\x96\x1E\x9C\xA2\x0C\xF1\x87\xDF\x84\x61\x79\xF3\x1F\x69" \
          "\x0F\xAE\xDE\xBB\xC9\x35\xA9\x55\x95\x94\x48\x79\x46\x53\x76\xC5" \
          "\xA5\xE7\xC6\xAB\xA2\x9E\xFB\xC2\x3A\xB6\x10\x4A\x14\x06\x19\xE8" \
          "\xF5\xBD\x9F\x91\xEA\x32\xA0\x09\x54\x7A\x8D\x21\x23\x7A\x6D\x16" \
          "\xD0\x30\xAA\xFE\x3E\x9D\x37\x9C\x44\x7E\xBF\x89\x94\xAA\xBE\xE3" \
          "\x4B\xD0\xB2\xA1\x11\xE3\x28\x07\xA6\x14\x38\x85\x15\xC7\xDA\x04" \
          , 1024);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bPlainBlock    =", bPlainBlock, 4096);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    DspHex("[IN ]bIV            =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptCBC(nSock, nAlgo, bKey, bPlainBlock, \
                             nBlockLen, bIV, bCryptBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "算法类型=1，数据长度=4096，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptBlock    =", bCryptBlock, 4096);
    DspHex("[OUT]bCryptBlockExp =", bCryptBlockExp, 4096);
    ASSERT_OUT_HEX(bCryptBlock, bCryptBlockExp, 4096);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptCBC_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bPlainBlock[4104];
    int  nBlockLen;
    BYTE bCryptBlock[4104];
    BYTE bIV[16];
    BYTE bCryptBlockExp[4104];

    bufclr(bKey);
    bufclr(bPlainBlock);
    bufclr(bCryptBlock);
    bufclr(bIV);
    bufclr(bCryptBlockExp);

    nAlgo = 2;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
                 16);
    memset(bPlainBlock, 0x5C, 4096);
    bPlainBlock[0] = 0x25;
    bPlainBlock[4095] = 0x22;
    nBlockLen = 4096;
    memcpy(bCryptBlockExp, \
          "\x2B\xB5\x43\x79\x10\x13\x91\x7C\xAD\xC5\x5E\x6A\x4F\x84\x19\x68" \
          "\x88\xDB\x64\x06\x91\x85\x06\xF4\x69\xAD\x1C\x46\xBE\x39\x96\xD9" \
          "\x9A\x39\x57\x05\x86\xF8\x7B\xF5\x05\x57\xA3\x56\xC7\xA8\x7D\xDA" \
          "\x24\xD3\xF9\x72\x54\x77\xF7\xCD\x27\xF7\xD1\x02\x86\xAB\xE5\x3C" \
          "\xC2\xBE\x05\x24\x4A\x38\x7D\x91\x9D\xFF\x35\x6F\xD4\xBA\x5A\xBE" \
          "\x05\x0B\x06\xF3\xAF\x90\x08\x6B\xCA\x94\x76\xCC\x7D\x5A\xAC\x61" \
          "\x6D\x78\x3B\x89\x66\x9D\x44\x54\x73\xAF\xBD\xC1\xE7\x57\x1B\x14" \
          "\xA6\x0A\x16\xEC\x64\x1E\x65\x01\x4B\x8F\xD7\x4C\x30\xB3\xE9\xC7" \
          "\xEF\xCE\x55\x01\x38\x2B\x4F\xCE\xBC\xD1\x14\xCC\x6E\xC6\x16\xF4" \
          "\x60\xD8\x27\x3B\x5F\xE2\x85\x1E\x70\x42\x27\xF7\xDE\x70\x10\x10" \
          "\x69\x3D\xF6\x25\x9D\x30\x9F\xC8\xFC\xAB\xE0\x32\x0B\x9A\xCB\xD0" \
          "\x19\xEB\x22\xA3\xE1\xBC\x82\xD6\x0F\x6A\xF2\xD1\x70\xA4\x59\xEB" \
          "\x91\x92\xED\xA0\x29\x49\xA6\x62\x91\x23\x0D\x9D\xB7\x85\xA3\x23" \
          "\x1F\xA5\x5B\x3D\x5C\x7D\x25\x15\xAD\x04\xFE\x92\x30\x0A\x0C\xE4" \
          "\xFB\xB1\x3D\x59\x7F\x54\x7E\xFB\x7C\x87\xC8\xE1\xEB\xE7\x69\xA1" \
          "\xE7\x95\xB4\xE6\x67\x6F\xE0\x6C\xED\x43\x8F\xCB\x83\xB9\x32\x2A" \
          "\x01\x61\xD2\xFC\x06\xF1\x86\xF0\xC2\xD3\x8E\xF6\x34\xBD\x81\x31" \
          "\x62\x37\x8E\x6C\xC0\xA3\x1F\x08\xDE\x29\x6D\x66\xBD\x93\x28\xEB" \
          "\xE9\x61\x15\xE7\x68\x43\x1C\xDB\xD5\xC9\x62\x01\x91\x2F\xF3\xCC" \
          "\xE8\xEA\x21\x7D\xF6\xD2\x29\x14\x74\xB1\xC9\x36\xCC\x4C\xE6\x8F" \
          "\x83\x5E\x08\xB1\xF7\x62\x66\x83\xE4\x21\x42\xDA\xA6\x17\x30\x25" \
          "\xDB\x25\x29\x74\x6D\xC6\xF2\x6B\xBD\xC2\x45\xDE\x33\x78\xA1\x1E" \
          "\x5C\xB8\x15\x7C\x1B\xC8\x1C\x91\x1F\xBE\x39\x87\x1D\x0E\x8B\x9E" \
          "\xB9\xF3\x3F\x37\x0C\xFB\x45\x54\xE2\xC0\x9D\x69\x62\xD1\x94\xC5" \
          "\x8B\xB1\xED\x6B\x26\xE3\x74\x4E\xA0\x3C\x00\xCA\x88\x05\x39\x98" \
          "\x5F\xBF\x13\xBE\xFF\xC1\x4C\xB9\xA9\x0B\x32\xDF\xAE\x7D\x70\xF5" \
          "\x3E\x30\x4A\xB7\xFB\x33\xF2\x98\xBD\xAE\x84\x11\x1B\x0F\x39\x2A" \
          "\xF6\x8D\x6A\x2A\x69\xFF\x5C\xB4\x99\x6A\x4C\xD0\x53\x59\x3D\xF0" \
          "\x72\x8D\x1B\x91\xCE\x88\x3B\x7C\x28\x9E\xFB\xC4\x6E\xD8\xD8\x11" \
          "\x60\x11\x21\xDE\xF7\x70\xC6\x37\x11\x3B\x33\xB3\x25\xB8\x87\x4E" \
          "\x12\x2B\xB7\x67\x11\x54\xE6\x51\x22\x03\x97\x76\x17\x0F\xCB\x1D" \
          "\x6B\x29\x06\x93\x49\x04\xE1\xDC\xC8\x5A\x40\xE1\xBB\x6C\x11\xCA" \
          "\xC5\xE1\x08\x6B\x5E\x96\x28\x4D\x54\x8E\x8D\x8F\xA6\x65\xBA\x51" \
          "\xFC\x52\x71\x0F\xF7\x9E\x24\xEE\x3F\x1C\x69\xFF\x13\x17\x8E\x56" \
          "\xCC\x02\xB0\x8F\x0A\x3B\xC5\x3D\xA2\x90\x24\x27\x29\xA1\xF7\x7B" \
          "\xAC\x02\x74\x62\x82\x4F\x6D\xF6\xDA\x19\x4A\x11\x1E\x38\x48\xAE" \
          "\xBC\x19\x83\x20\xE4\xA6\x47\x97\x46\x04\x3C\xF8\x96\xFE\xC1\xB6" \
          "\xE5\xB7\x9B\x6E\x9A\xD8\x4F\xC0\x4D\xEF\x6B\x55\xA0\x30\xAA\xED" \
          "\x23\x9C\x63\x9D\xD2\x3C\xDC\x4C\x16\x10\x8A\x38\xAA\x8E\x7E\x0A" \
          "\x4D\x13\x43\x84\x51\x96\xA6\xD8\xFE\x05\x79\x6F\x6B\xF9\x39\x4B" \
          "\xC4\x02\x62\xAC\xBB\xCC\x1D\xC7\x79\x86\xE2\x23\x1C\x44\xE9\x1A" \
          "\xF2\x95\xED\xB4\x81\xC9\x5B\x2F\xB6\x72\xE2\xD7\xE6\x02\xDD\x5F" \
          "\x15\x17\x00\x20\xBA\x6E\xDF\xD1\x75\xB5\x30\x96\x09\xBA\x45\x12" \
          "\x9D\x89\x5E\x18\xC5\x06\xE5\x80\xA7\xEA\x78\x7C\x89\x41\xDD\x37" \
          "\x3C\x76\x0E\x77\xA7\x4D\xFB\xBF\x8E\x99\x6F\x76\xCC\xFD\xAE\x90" \
          "\x5C\x86\x2A\xA6\xBF\x95\x3B\xF2\x33\x8A\x57\x3E\x90\x01\xA9\xA5" \
          "\x58\x9A\xF8\xEF\x47\xFF\x32\x68\x11\x6E\x42\x40\x6D\x9B\xF5\x88" \
          "\x1C\x81\x3F\x34\xFF\x6C\xD4\x47\x6C\xC6\x3D\x8D\xB5\xC1\xD2\x55" \
          "\x72\xE0\x04\x3B\x88\xCE\x0D\x99\x4F\x4A\xF3\x89\x0C\x3B\xD6\xD7" \
          "\xA6\x14\x28\x6E\xF1\xA6\x2F\xEF\x3B\x5C\x9A\x83\x5C\xCD\x0F\xC4" \
          "\x16\xF2\x25\x59\x4C\x3A\x4F\x63\xEC\xE2\x27\xD0\x6C\x00\x32\x58" \
          "\xD1\xB1\xAD\xC0\x5F\xD5\x01\x42\x75\x8E\xDD\x76\x7D\x76\x31\xE4" \
          "\x07\x46\x30\x53\x23\x7F\x1C\x43\xE8\xA4\x8A\x6F\xC5\xBC\xF4\x73" \
          "\x1F\x8A\x89\x3D\x81\x06\x2B\xBD\x47\x9F\xAD\xE5\x70\xC7\x06\x58" \
          "\x2E\x81\x80\x5C\xAF\x39\xDD\x1B\x1C\x53\x6E\xE5\xC2\x2D\x57\x5D" \
          "\x35\x32\x3C\x12\xC3\xBE\x93\x86\xED\xBD\xD6\xE1\x3A\xCD\xB1\x34" \
          "\x3F\x04\x0E\xA2\x60\x68\x72\xF0\x5A\x70\xC1\x51\xBB\x5C\x3C\x54" \
          "\x57\x82\x56\x01\x4B\xF8\xB3\x2A\x2C\x19\xBC\x60\x4E\x8B\x9B\x43" \
          "\xB6\xD0\x2B\x23\xCA\x3D\x8F\x9B\x72\x8D\xDE\xFC\xF1\x63\xFD\xEE" \
          "\x6D\x21\xCF\xA0\x7E\xE2\x45\x97\xA0\xBB\x95\xCD\x05\x29\xC4\xCB" \
          "\x9D\x0B\x05\x57\x40\x68\x97\xB4\x73\x5F\x2D\xB4\x9C\x45\xC5\x06" \
          "\xCA\xE5\xF9\x92\xB5\x41\xC3\xFC\xCF\x81\x14\x91\xA0\x5A\xB7\x5A" \
          "\x78\xE7\x88\x49\x3D\xA8\xA5\xCB\xA6\x05\x80\xEC\x56\xD3\xEF\x20" \
          "\xB1\x8E\x6D\x4F\x7C\x85\xE1\x16\x39\xD3\x82\xE4\xD0\xFC\x3A\x4C" \
           , 1024);
    memcpy(&bCryptBlockExp[1024], \
          "\x53\x3A\x28\x7B\x50\xC0\x4B\x07\x08\x89\x8C\x2D\x0A\xCE\xF0\x6D" \
          "\xB6\x0E\x5A\x8A\xA3\xBE\xDC\xA7\x6B\x66\x22\x89\xE5\x1B\x19\x42" \
          "\x5D\xB9\x5F\xEF\x25\x65\x2A\x57\xAB\x2F\x69\xE6\x9E\x4C\xB6\x8F" \
          "\x67\x28\x88\x0F\x03\x39\x96\xC7\x13\x9D\xCE\xD1\x44\xBD\x61\xF3" \
          "\x83\x91\xEF\x97\x29\x4F\xD9\x66\x94\x6B\x6E\xFD\x31\x37\x5B\x74" \
          "\xA5\x7E\xD1\xE3\x3A\x58\x28\xC8\xAD\xCE\xC8\xCD\x27\xC3\xDB\xC8" \
          "\x21\xBE\x6A\xCB\xEE\xDA\x7E\x6A\x70\xB9\x41\xD2\x68\x79\xC1\xDF" \
          "\xA1\x6A\x17\x91\x40\x81\x22\x19\x2B\xB2\x0C\x6F\xCB\xA5\xD1\x87" \
          "\xFF\x29\x8C\x5D\xBA\xC7\x0F\xA9\x66\xC1\xE0\x4B\xEF\xDD\x91\x47" \
          "\x68\xC4\xDE\x87\x97\xE9\xFD\x2C\x11\x66\x9E\x9B\xAA\x7E\xB1\x22" \
          "\x2C\x1F\x98\x2F\x76\x1E\xDB\x68\xA7\x84\x4D\x98\xC2\x16\x49\xCE" \
          "\x98\xB4\xB9\x47\x2D\xAD\x83\x43\x10\xF0\xEC\x37\xFF\xBE\xB3\x08" \
          "\xD9\x03\xB1\x3E\x0B\x57\xA1\x27\x15\x8B\x5D\xF6\x95\xA4\x6B\x94" \
          "\x30\x3F\x37\x92\xA2\x27\x06\x96\x92\xD9\xE1\x94\x1F\x8F\x9E\x00" \
          "\x17\x0B\x04\xD8\x37\x26\x84\x19\xA3\x35\x2E\x4F\x23\xF9\x51\xB6" \
          "\xF9\xFB\x77\x18\xB6\x3B\xD9\xC4\xA5\xE8\xD0\x15\xFD\x07\xF0\xA3" \
          "\xC6\xD2\xCB\x2D\xC8\x56\x24\xE0\x97\x1A\xD9\x10\xBE\xD8\x21\xDD" \
          "\xAB\xBF\x90\x4B\xC0\x2C\x7C\x22\x8F\x9B\x8E\x8B\x93\x20\x61\x34" \
          "\x78\x2B\x3D\x1E\x80\xBA\x53\xFE\x9A\xAD\x26\xE6\xC6\x1B\xED\x5E" \
          "\xC5\x83\xFA\xAB\x73\x40\xD6\xA4\xBD\xE7\xF7\xF8\x63\xAF\x17\xC7" \
          "\x96\x3B\x86\x85\x91\x0B\x27\xCC\x49\xAC\x5D\x87\xF8\x6A\x79\x60" \
          "\xCD\xEF\x14\x10\x67\xF0\x91\x36\x55\xF8\x41\x73\x6A\x9F\xC7\xFF" \
          "\x8B\xED\xB8\x64\x16\x25\x49\x83\x43\x7B\xDD\xA8\xA3\xE0\xC9\x75" \
          "\xEA\xEF\x32\xB6\x96\x62\xEC\x08\x9D\xA8\x7C\xD1\x17\x96\x00\x7F" \
          "\x4F\x31\x6F\xC4\x57\x86\xA0\xD4\x05\x3A\xB4\x75\xA9\x49\xD8\x81" \
          "\x55\xBF\x91\x0B\x57\xAA\x4A\xAA\x67\x98\xF2\x4F\xFC\x80\x20\x23" \
          "\x33\xA3\x50\xBF\xAA\xD0\xB4\xF0\x8E\x54\x46\xD9\x0A\x11\xED\x1F" \
          "\xAC\x26\x3A\xC2\x9D\x96\xDE\xAE\xD6\x57\xE9\xCB\x27\x67\xE7\xFD" \
          "\x63\x2B\x40\xB4\x9B\x50\x7B\x61\x96\xC2\xA0\x45\x1F\x8E\xB1\x0D" \
          "\xD3\x81\x1F\xD1\x81\x64\x82\xF6\x38\x28\x0E\x8A\x7A\xDE\xA6\x16" \
          "\xDF\xE5\x75\xE5\x39\x44\x24\x7C\xAB\x83\xC6\x6A\x08\x14\x84\x77" \
          "\x6C\xBC\xB7\xCA\x9E\x19\xDE\x1C\xEC\xCA\x45\xA7\x47\xA9\x2F\xB1" \
          "\x75\xE7\xA2\x55\x24\x18\x9B\x3E\xD9\xCA\x93\xAD\xBB\x50\xEA\x26" \
          "\x6F\x72\xBE\x44\xD0\x75\x63\xF8\xC4\x48\x97\xED\xF6\x00\x98\x51" \
          "\x44\xB9\x13\xA1\xD1\xD3\x18\xB9\x1F\x0D\xED\x08\xF7\xD2\x4B\xAE" \
          "\xB6\x9A\x34\x64\x13\xF5\x79\x85\xF1\x4F\x17\xD0\x3E\x19\x14\x0B" \
          "\x5D\xA6\x94\xF3\x3F\x91\x82\x12\x74\xA4\xFD\x40\xBD\xF2\x6B\x1B" \
          "\xBF\x53\xF7\x48\x72\x35\xEA\x89\x91\xD3\xE2\x4C\x0D\x8C\x54\x57" \
          "\x5A\xDD\xCA\x12\xB5\xF4\x31\x1D\xAF\x51\x68\xF8\xFB\xFF\x62\x7A" \
          "\x20\x4D\xE2\x29\xF4\xC3\x2B\x5B\x15\x55\xF0\x80\xD7\x68\xDD\xBA" \
          "\x34\x85\x9D\x82\x7A\xDE\x6A\x38\x35\xC2\xA4\xDB\xC6\x9C\xA3\xA5" \
          "\xEB\x66\x56\x84\xA1\x38\xFD\x5F\x4B\x0C\xBF\x5F\xA3\x58\x04\x79" \
          "\x4F\xA0\xA7\x6F\xE2\x00\xFA\x20\xA2\xBE\xCC\x59\xE4\x40\xBA\x5B" \
          "\x5F\xC8\xA9\xD4\x16\xBB\x17\x98\x53\x66\xA7\x0F\x0B\xEB\xC6\xB4" \
          "\x5F\xC4\x90\x39\x44\xA2\xE9\xF1\x1F\x36\xF2\x5D\x4C\x03\x60\x88" \
          "\x03\xF4\xBB\x36\x3E\x2B\x96\x36\x30\x93\x05\x79\x8A\x8A\x93\x8A" \
          "\xF1\xFD\xFC\x17\x88\xE3\x37\xF2\x54\xF2\xD4\xF7\x04\x27\x2B\xB0" \
          "\xC4\x0E\xDC\xC1\xB0\x93\xD6\xF5\x6F\x7C\x27\x26\xCB\x4E\x85\xCC" \
          "\x56\x4B\xE9\xA0\x13\x2E\x69\xA2\xD5\x0A\x9C\x99\xBD\xDE\xD0\x82" \
          "\x72\xDA\xDF\xD7\xE8\xE1\x71\x57\x2B\x27\x8F\x4C\xBB\x4C\x96\xA6" \
          "\xDD\x56\xA9\xA9\xBE\x9C\xCD\xF1\x2C\xD9\x4A\xBF\x94\x85\x6D\x30" \
          "\x56\x53\x05\x35\x7C\x0E\x1D\x6C\xFC\xCF\xF6\x37\x3E\x07\xC7\x95" \
          "\x4C\xDA\x18\x02\x78\x58\xF6\x38\xFC\x1D\xC4\x73\x56\x8F\x90\xD7" \
          "\x84\x21\x2A\xF7\x3E\x0F\xAA\x06\x19\xB4\xCA\xEF\x14\x12\x1F\x07" \
          "\x80\xE0\xBA\x28\xD4\xC7\x17\x2C\x0D\xD4\x9D\x76\x59\x77\x87\x8E" \
          "\xE6\x28\x72\x35\x0B\x73\x74\x7F\x96\x72\xF6\x3E\xE7\xCC\x5E\xA3" \
          "\xE3\x9E\x70\x21\xB3\x1C\xA0\xC9\x5B\x93\xB9\x2D\x69\x59\x46\xF8" \
          "\xE5\xD4\x97\x9A\xE6\x66\xD2\x3F\xD5\x0B\xBC\x7E\x8D\xA0\xC7\xAF" \
          "\x3F\xF4\x09\x00\x80\xC1\x5A\x22\xDD\x2E\x47\x16\x82\xC0\x32\xA2" \
          "\x70\x32\x9C\x22\x33\x49\x73\x0C\x68\x92\x3D\xB9\xBB\x5B\x9E\xCD" \
          "\xFA\x6E\x20\x78\x56\xB7\xBA\x8C\x9C\x53\xF8\x18\x06\x82\x9E\xDD" \
          "\x47\xE6\x21\x03\x91\xF5\x94\x3C\xFA\x96\xEB\x07\xEC\x43\x92\x66" \
          "\x9F\x59\x2A\x5C\xC3\x3B\xED\x18\xA2\x9E\x5F\x0D\x09\x6C\x3F\x02" \
          "\x01\xE5\x48\x39\xD6\x67\x75\xAB\xAF\x2B\x22\xCD\x14\x12\xD1\x6F" \
           , 1024);
    memcpy(&bCryptBlockExp[2048], \
          "\x17\x69\xEA\x01\xE5\x79\xF2\xE9\xE6\x09\xCF\xBF\x2E\x3A\xF1\xB6" \
          "\x27\xD2\x2D\xE4\x9B\x9F\x6F\x0F\xF5\xFA\x4F\x46\xAC\xB9\xC5\x9C" \
          "\xCC\x21\xD6\x77\xF5\xCD\x4A\xBA\xCD\xAC\x8D\xE7\x6F\xD2\x2B\xA2" \
          "\x46\xE0\x78\x03\xB3\x40\xD9\x39\x16\xDC\x46\x26\x6D\x78\xFA\xA6" \
          "\x03\x9E\x43\x39\xED\xB7\x6E\xC7\xAA\x28\x26\x3D\x1E\xD0\x9F\x26" \
          "\xF6\x18\x73\x68\xE4\xD4\x00\x84\x66\xC0\xB1\x84\x64\x3C\x3F\x86" \
          "\x40\x63\x79\x8D\x6D\x0D\xF0\x1D\x87\xDC\x3C\x8E\x0F\xD2\xD5\x33" \
          "\x0F\x68\xC7\xEA\xF7\xEC\xC0\x63\xCA\x3F\xF2\x5D\x12\x39\x1D\xBA" \
          "\xC1\xE0\x83\xC8\x61\x27\x0E\x4C\x84\xE9\x62\xB9\x48\x32\x10\x39" \
          "\xD7\x77\x80\x2E\xF4\xFF\x20\x79\x1B\xEB\x54\xBB\x9B\x41\x26\xB5" \
          "\x1E\xAD\x8E\xF3\x8C\xA0\xEE\x18\xE2\x79\xD6\xA8\xAE\xE8\x2B\xC8" \
          "\xBB\x1D\x71\xDC\xD6\x7B\x2D\xEC\x77\x9B\xB2\x99\x0F\x28\xC7\xB5" \
          "\x81\x44\x52\xA3\xEF\x56\xEF\x65\xD3\xBC\xC9\x51\x5F\xD1\x00\xA6" \
          "\x4B\xA9\x4E\xA1\xB4\x94\xC6\x92\xBD\x0C\x62\x3B\x2A\xE8\x81\x12" \
          "\x84\x40\xFF\x99\x1F\x0D\xA0\xA9\xED\xA2\x70\xC9\x45\xFD\xA2\x30" \
          "\x1C\x97\x71\x18\x86\xF0\x08\x50\xC4\xDF\x92\x0F\xAC\xAF\xEF\xCB" \
          "\x02\x6C\x28\x09\x4E\xE0\x68\x14\xE1\x26\x53\xE6\xD6\x25\xE2\xF0" \
          "\x7D\xBB\x0B\xA1\xCC\xD2\x25\xD4\xAE\x97\xC6\x82\x04\x3F\x97\x10" \
          "\xAD\x97\x90\x11\x44\xBE\x29\xFC\xA4\xB8\x6A\x43\x43\x6C\x68\xBE" \
          "\x33\xBF\xDB\xCB\xBB\xDD\x9B\xA3\x95\x10\x35\xB7\x10\x01\x02\xC5" \
          "\x8D\xD8\xD7\x19\xF9\xF0\x17\xA3\x9C\x11\xC3\x99\xC6\x36\x75\xE7" \
          "\xD2\xBA\x55\x1E\x0C\xE3\xD7\x7D\x99\x52\xE5\x87\xEB\xC3\x26\x58" \
          "\x1A\xC2\x00\xB6\xBB\xA0\x17\x06\x26\xE4\x7E\xF2\x6A\x16\xFA\xE0" \
          "\x85\x96\x50\x9D\x27\x24\x61\xEB\x93\xE9\xCF\x70\xAA\x77\x88\x8A" \
          "\x37\x7F\x23\xA9\x61\xEA\xEB\x4C\xAC\xDE\x4E\x50\x84\xCD\xC6\x5E" \
          "\x9C\x6B\x5B\xAC\x58\x17\xC7\xFD\xD0\x5C\xF6\x25\xEA\xE5\xAB\x2C" \
          "\x57\x51\x62\x63\xB1\xF1\xA6\xB4\x1D\x69\xFE\xA7\x6B\xE9\xBE\x83" \
          "\x51\x97\x0C\x5A\x1D\xC0\x57\xE6\xA0\x9D\x3E\xDF\xDF\x0C\x60\xEB" \
          "\x68\x38\x5C\x8B\x27\x00\xF1\x21\xE2\x8E\x0F\xC3\xF6\x4F\x93\x9F" \
          "\x65\xCC\x70\xCA\xCC\x20\xB0\x40\x47\xA2\x97\x6E\x9C\x0B\x8A\x56" \
          "\xD8\x35\xDB\xD6\x62\x48\x1C\x85\xD7\x69\x7B\x78\xBB\x84\x53\xC6" \
          "\x2A\xA0\x71\x18\x28\x47\x16\x0C\x53\x24\x31\x3D\xD9\xCD\xE3\xFA" \
          "\xE4\x9A\x58\xFF\x29\xA6\x1E\x43\x27\x02\xA3\x0B\xF6\x1E\xC3\x85" \
          "\x7F\x7C\x89\x6A\xB2\xF5\xAB\x67\x37\x3C\x70\x1F\x30\x01\x9B\xA0" \
          "\x2C\x6D\x9C\xBA\x4D\xC9\x61\x29\xE6\x8E\x9F\x0F\xAB\xDB\x66\x05" \
          "\xB0\x04\x6F\xE7\xF6\x44\xFA\xB7\x9B\x1D\x13\x7A\x1D\xE0\xDA\x75" \
          "\x61\xA4\x95\xFD\x22\xCF\x59\x31\xAA\xC5\x28\x2A\xC7\x44\x83\xD8" \
          "\x41\x9E\xEA\xAA\x7F\xD5\x3B\xAA\xFF\x3C\xCA\x58\x7C\x20\x71\xDE" \
          "\x3B\xEB\x5D\xAC\xFD\x5D\x09\xCA\xA3\xE2\x21\x12\xC2\x2D\x61\xEB" \
          "\x38\x61\x16\x09\x14\x4D\x1F\x9C\xC7\x03\x5D\xBD\x6D\x27\x0E\x10" \
          "\x95\xFE\x7E\x5C\xB0\x8C\xA7\x23\x31\xE0\xD5\x3D\x77\xF3\x5A\xA0" \
          "\x40\xF9\x39\xF9\x2C\x4A\xCC\xAA\xF4\x33\x0D\xD3\xDA\xCA\x10\xC0" \
          "\xFC\x98\x8D\x65\xF3\x6A\xBA\x44\x84\xEF\xFE\x0A\x09\xFB\x49\x60" \
          "\x45\x81\x25\xB7\x98\xF7\xE9\x0E\x91\x1B\xD8\xB7\xB0\x9E\x74\xFB" \
          "\x35\xEB\xAC\x12\xFD\xAA\xAE\x3C\xEE\xCD\xA6\x3D\x1C\x33\x46\x53" \
          "\x03\xFC\xEC\xD5\x13\x32\xA8\x69\xAC\x14\xA1\x17\x63\x1A\xB9\xF8" \
          "\xA1\x55\x09\x50\xB3\x43\xCD\x1E\x77\x15\x46\xDD\x6E\x06\x5D\xCC" \
          "\xA5\x6F\xD9\xB3\x5B\x49\xC6\x47\xBD\x49\x5E\xD8\x35\x97\xEB\xCE" \
          "\xF8\x0E\x24\x1A\x02\x7C\xD2\xFA\xBE\x5E\x4B\xA4\xC9\x0C\xBD\xA7" \
          "\x58\x98\x83\xBB\x91\x31\x5A\x7B\x2A\x13\x5F\x52\x2D\x7D\xBB\xCB" \
          "\x10\x90\xF4\xF1\xB9\xC7\xE6\x2E\xE7\xBC\x7E\x84\x6A\x5E\x3B\xF6" \
          "\x78\xC8\xD7\xB3\xF4\x73\xC1\x11\x40\x35\xD6\x6B\x4C\x13\x03\x83" \
          "\x7E\xA1\xA4\x3B\xB6\x5B\x66\x56\x65\xBD\x32\xB4\x00\x89\x3F\x8C" \
          "\xB9\x8C\x4B\x6B\xDE\xF0\x67\xC1\xD5\xC9\x22\x9C\x86\x1B\xFA\x2D" \
          "\x3A\x02\x38\x2D\x3D\x90\xEB\x97\xDA\x22\x9F\x9D\xD2\x92\x01\x08" \
          "\x2F\xB7\xCB\xDF\xC9\x5C\xF2\x18\x3C\x45\x88\x25\x2D\x23\x51\x41" \
          "\xEA\x2C\x02\xA9\x27\xE3\x11\xF2\x44\x0D\x2A\x86\x0A\xED\x54\xF3" \
          "\xE1\xE3\x41\x3F\x0B\xAC\xDB\xA3\x27\xC4\xB5\xC2\x22\x66\x63\x50" \
          "\xEF\x94\x7F\x67\xE1\xB7\xA8\xFA\x15\xA7\xE6\x69\x58\x4D\x3E\x6F" \
          "\xBC\x9F\x52\xFD\x86\x25\xB1\xE5\x24\xA3\x25\xE6\x7A\xEE\x3E\xB9" \
          "\x53\x98\xE2\xC1\xA7\x56\x9D\xE1\x36\xD7\x06\x1D\x6D\x4D\xD6\xBB" \
          "\x8A\x55\xE1\x2A\xC8\x11\xFA\x57\x6F\xAE\xF0\x63\x8B\x1A\xCC\x8B" \
          "\x8B\xE0\x84\x88\xC8\x35\x62\x80\x4E\x06\x3E\x19\x97\xEC\x10\x2D" \
          "\xD0\x34\x92\x97\x7C\xB5\xD9\x85\x0F\x9E\xAA\xFC\xD9\xD6\xD5\xC5" \
           , 1024);
    memcpy(&bCryptBlockExp[3072], \
          "\x24\xC5\x70\x4A\xE2\xEE\x7D\x44\x4C\x2E\x55\xB7\x7B\x5D\xB6\x13" \
          "\xE0\xFB\x8A\x5C\x04\x05\x6D\x1E\xEC\x7F\x6A\xDB\xA6\xDF\xC8\x88" \
          "\x13\x66\x40\xB0\x3F\x4D\x83\xF0\xB6\xDE\xDB\xD4\x0A\xC9\xD7\x76" \
          "\x6D\x2E\x7E\xBB\x13\x3A\x45\xDA\xD6\x9A\x3E\x78\xC9\x4D\x90\x7C" \
          "\xB1\x7A\x51\x72\x9B\x5D\x8A\x49\x85\x9E\x54\x3E\x04\x17\x9A\x7C" \
          "\xC3\x2E\xDE\x08\xA1\x50\x52\xC3\x9A\x8F\xDD\x84\xAE\xF4\x42\x8F" \
          "\x4B\xC4\x06\xE0\xE5\xC8\xEE\x26\x60\xA3\x1E\x23\xF4\xAE\x25\xE0" \
          "\xF2\x2A\xDA\x66\x1E\x9E\xF8\xB6\xF3\x44\x1A\x03\x66\x74\x0B\x23" \
          "\x71\x43\x6E\xA1\xC3\x3C\xD1\x05\x51\xD2\x2B\x92\xD7\xC9\x91\xB7" \
          "\x90\xC0\x01\xA5\xD1\xF7\xEF\x77\xFA\x9C\xE9\xB8\x52\x67\xC1\xA4" \
          "\x96\x48\x6F\x09\x75\xF9\xED\xFC\x32\x32\xF6\x70\x10\xE9\x0D\x7D" \
          "\xC8\xB5\xBA\xB9\x8A\xF4\xE6\x30\x67\x04\x14\x0E\x02\x46\xAE\x3D" \
          "\x41\x6C\x94\xBD\xDC\xE5\x85\x4F\x6C\xDB\x49\x5F\xFD\xBD\xA9\x08" \
          "\x17\xF7\x43\x60\x51\xB5\x37\xF5\x45\xAC\x0F\x60\xEC\xF2\x70\x87" \
          "\xE7\xFD\x26\x21\xDF\x7C\x4F\x30\x7F\x63\xC5\x19\x87\x7D\x27\xFC" \
          "\xEC\x98\x82\x82\x1D\x86\x4E\x98\x1D\xEE\x44\xBA\xDF\xFD\xCB\x64" \
          "\x07\xAF\x78\x20\xFC\xA3\x90\x39\x25\x22\xA4\x29\xA5\xDB\x62\x72" \
          "\xA9\x69\x7A\x97\x95\x40\x53\x8B\x7F\xBD\xF5\x1C\x82\xDD\x2E\x94" \
          "\x55\xB1\x63\xB2\xA6\x23\xA6\x1C\xDA\xBA\xE9\xDC\x4C\x08\xE1\xC1" \
          "\x84\x76\x89\x0C\x86\x8E\xEC\x20\x16\xEB\x59\x0B\x89\x67\x37\xAF" \
          "\x93\xF1\x07\xB6\x70\x64\xCE\x30\xB0\x80\x5D\x24\x35\xA1\x83\xC4" \
          "\x0F\x3D\x5B\xAF\xDD\x53\x73\xEC\x1F\x2E\x5F\x8C\x6A\x4A\x67\x4E" \
          "\xD9\x52\xD5\xAC\x4C\xB3\x5D\xB8\x6B\xA7\xB3\x6A\xDB\xF2\x45\xCB" \
          "\xC4\x4A\xC5\x37\xA5\x5B\xFB\xE7\x63\x61\xFF\xF7\xC8\x3C\x03\x49" \
          "\x39\x8F\x2B\xBF\x59\x82\xA3\xF7\x22\x00\xD7\x16\xA0\x36\x19\x3C" \
          "\x0F\x3A\x2D\x7E\x6C\x0E\x41\xE0\x7F\x67\xF1\x1B\xAC\xBC\x9B\xA5" \
          "\xDC\x62\x89\xC8\x64\x2E\x44\xB6\x72\x3F\x72\x4B\xB5\x64\x8C\x11" \
          "\x13\xE9\xC7\xCD\xA9\x8D\xB2\x6C\x73\x8B\xCE\x1C\xFA\xA6\x00\xCD" \
          "\xB2\xE1\xCE\xDF\xA5\x19\x72\x6A\xE9\x0D\x3E\x39\x07\x81\xFA\x9E" \
          "\x94\x54\xBC\x9C\x1F\x0E\x3A\x1D\x73\x96\xD5\xA8\x33\x9E\xA0\x2F" \
          "\x94\xD4\x37\x64\xAD\x95\x7C\x21\x53\x1B\x17\x19\x1D\x5D\x28\x7C" \
          "\x33\xE5\x6A\x03\x6F\xD6\x33\x37\x52\x6A\x8A\x30\x2A\x0E\x6D\x38" \
          "\xDF\x7B\xDE\xE6\x94\x2D\xF9\x98\x41\x1E\xC7\x55\xBB\x97\xC9\x3E" \
          "\x72\xC0\x7B\x13\x79\xAE\xBB\x4B\x96\x55\x76\x1D\x3B\xFF\x40\x3A" \
          "\x76\x15\x8E\x7C\xC2\xE4\xD1\xA5\xB9\x44\x02\xE7\x27\xEC\xEB\x21" \
          "\x5B\x20\xDB\x00\x8C\x68\x78\xD5\x15\x48\x4A\xA9\xAA\xA5\x26\xB1" \
          "\xED\x6B\x92\xB3\x0B\xF7\x85\x3F\x73\xE6\x93\xE0\xE6\x84\x5B\x0C" \
          "\x31\x0D\xCD\x95\x44\xE7\x2E\xF7\xE5\x05\xC0\x85\x4F\x45\x74\xA5" \
          "\x39\xD0\xF4\xAF\x45\x9B\xF1\xCA\x31\xAE\xA3\x60\xD5\x79\x94\x4A" \
          "\x31\x5A\xE4\x37\xDB\x6F\x83\x99\xD0\xD4\x68\xDD\x9E\xB7\xD3\x9E" \
          "\x5C\x3C\x89\xF3\xF7\x46\x9C\xF8\xC5\x41\x54\xE8\x7D\x42\x2D\x93" \
          "\x65\x1C\x47\xF8\x46\x7B\x61\x42\x1E\xAD\x04\xD2\xE8\x16\x43\x8D" \
          "\x18\xDE\xE3\xBB\x52\x25\x2D\x54\xBD\x73\x2F\x3C\x4F\xA9\xFE\x70" \
          "\x97\x4B\x67\x07\x0C\xF7\x9B\xBC\xD5\xE5\xED\xE4\xE0\x3E\x73\x21" \
          "\x09\xF1\xAE\xB5\x4B\x41\xD3\xAF\x93\x3B\x26\x4D\x9C\x6B\xE2\xA1" \
          "\x1B\xEB\x2C\xAC\xE8\x04\x44\x66\x69\x1C\x5B\xE7\x40\x7B\x4F\x6D" \
          "\x8A\xA0\xF3\x85\x6A\xC9\x1F\xD1\x5F\xB4\x1D\x02\x8E\x1D\xDA\xD9" \
          "\x9F\xE3\xFC\x0A\x20\x03\x54\x04\x95\x61\x03\xBA\x66\xC1\x1B\x38" \
          "\x21\x8B\xDA\xA6\x83\xA0\x5A\xBE\x5F\x5B\x46\x4A\x38\xEB\xCA\xA0" \
          "\xC8\x98\x94\x9C\xD9\x20\x70\x42\xD6\xB6\xA8\x12\xE2\xDA\x59\x8D" \
          "\xEE\x7A\xBC\xD4\x20\x15\xC9\xF3\xAF\x76\x45\x69\xBB\x9E\x47\xF6" \
          "\x3A\x0F\xDC\xB8\x44\x47\x26\x23\xAD\x8F\xAC\x3B\x56\x30\x86\x46" \
          "\x45\x42\x60\x8D\x6F\xF5\x77\x5E\x41\x58\xC9\xF7\x04\xF1\xE1\x5D" \
          "\x08\x46\x7C\xE9\x1B\x96\xFC\x6B\xA0\x95\x4C\x26\xD7\xFE\x03\xF5" \
          "\xA7\x9C\xC9\x2F\xF1\xF4\x8C\xE4\x3B\x04\x6D\x11\xCB\x82\x1C\x77" \
          "\x7C\xE5\x27\x33\xF4\xED\xC3\x23\xD7\x67\xBA\x36\xB4\x29\x78\xBA" \
          "\x9C\x56\xC6\xCA\xC4\xD7\x22\x00\x31\x7C\xB6\x28\x6F\x80\xBA\xF0" \
          "\x9E\x3A\x0B\x31\xBF\x5E\x4D\xF5\xA9\x60\x99\x12\x9E\xD4\xF0\x9D" \
          "\x26\x4A\x15\x71\x9B\x88\xF9\xAC\xE4\x2F\x8B\xCA\xAA\x48\x0C\xBD" \
          "\x8C\x48\xB4\xFF\x1B\xB9\x2C\x6C\x25\xED\x80\xD7\x18\xD9\xFB\x46" \
          "\xCF\x65\x2A\x07\xCD\x76\xDF\xBA\x40\x7C\xBA\x7E\x8A\x8A\xC0\x64" \
          "\x31\x7D\x44\x76\xF4\x8E\x88\x24\x42\x58\x46\x19\x1D\x64\xCB\xEE" \
          "\x26\x3B\x6C\xB1\xD1\x20\x28\x01\x82\xD1\x4E\xB1\x98\x5B\xCB\x05" \
          "\x0F\xF4\x46\x10\xB4\x08\x4F\x8C\x1A\x88\xBD\xA6\xB9\x25\xB9\xC1" \
           , 1024);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 16);
    DspHex("[IN ]bPlainBlock    =", bPlainBlock, 4096);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    DspHex("[IN ]bIV            =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptCBC(nSock, nAlgo, bKey, bPlainBlock, \
                             nBlockLen, bIV, bCryptBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "算法类型=2，数据长度=4096，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptBlock    =", bCryptBlock, 4096);
    DspHex("[OUT]bCryptBlockExp =", bCryptBlockExp, 4096);
    ASSERT_OUT_HEX(bCryptBlock, bCryptBlockExp, 4096);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptCBC_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bPlainBlock[4104];
    int  nBlockLen;
    BYTE bCryptBlock[4104];
    BYTE bIV[16];
    BYTE bCryptBlockExp[4104];

    bufclr(bKey);
    bufclr(bPlainBlock);
    bufclr(bCryptBlock);
    bufclr(bIV);
    bufclr(bCryptBlockExp);

    nAlgo = 3;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8697 A4B5 C2D3 E0F1 */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\x59\x99\xC3\x06\xAB\x84\x01\xB2",\
                 24);
    memset(bPlainBlock, 0x5C, 4096);
    bPlainBlock[0] = 0x25;
    bPlainBlock[4095] = 0x22;
    nBlockLen = 4096;
    memcpy(bCryptBlockExp, \
          "\x1B\x7E\xEC\x99\xFD\xA8\xE8\x98\x91\x2B\x05\x2E\x24\xAF\x61\xCB" \
          "\xA9\xC8\x44\x26\x0A\x52\x7B\x45\x50\x55\xB4\xF5\x24\xA2\x0B\xEE" \
          "\xE0\xF2\x61\x7D\x67\xE6\x22\x3A\x84\x4E\x71\xC6\xA7\xE2\x3F\x59" \
          "\x09\x57\xA4\xED\x10\x44\xE8\xB2\x56\xE1\x6E\xD1\xF4\x9F\xDA\x21" \
          "\x7D\x62\xC6\xB2\xAB\x9E\x78\x57\x81\xA7\xBA\x20\x87\xEC\x67\x9F" \
          "\x51\xE0\xE5\x3E\xB5\xE8\xE1\x68\x18\x08\xE4\x04\x80\xEE\x02\x30" \
          "\x64\xB4\x39\x43\x93\x33\xC0\x22\xA8\xD6\xF5\x0B\x89\xEB\xC8\x69" \
          "\x3D\x41\x2F\xB4\x1A\x11\xBD\xD2\x89\x08\x24\x73\xDF\xB7\xD6\x0E" \
          "\x45\x7A\x42\x1E\xE9\x19\x60\xCC\xDD\x9D\xDF\x75\x70\xA6\xA6\xEE" \
          "\x80\xCB\xA1\x51\xFA\x5D\x3E\x8F\xCF\xD6\xE5\x8E\x83\x37\x76\xA4" \
          "\x9F\xA1\xCE\x0A\x3E\x73\xC8\x07\x72\x50\xF1\x6D\x45\xDB\x91\x5C" \
          "\xC8\xC3\xDF\x5B\x21\xEE\x69\x46\xDE\x43\x44\xFD\x91\xDC\x27\xAD" \
          "\xC3\xDC\x6B\xFD\x7B\x06\x21\xED\x7D\x07\xAE\xF5\x4C\x71\x5C\xF7" \
          "\x34\x4F\x2E\x43\x67\xEF\x9E\xA8\x51\xCE\x1D\x96\xC2\x7F\x71\x69" \
          "\x13\x22\x50\x8D\xC1\x4C\x4E\x71\x30\x38\xF3\xA4\x46\x18\x91\x70" \
          "\x68\x2D\x15\x70\xF5\x2B\xA7\x42\x10\xE0\x79\xEC\x27\x9E\x5F\x36" \
          "\xA9\x08\xE6\x55\xB1\x13\x78\x44\x25\x65\xE8\x6D\xFF\xF3\xE6\x7C" \
          "\x38\x21\x57\x83\xD7\xED\xC7\x8E\x0C\x98\x27\x23\x91\xAB\x8D\xB0" \
          "\xC2\x4C\x2F\xC5\x89\x78\xA4\x70\xC5\xF3\x7F\x8B\x3C\xF4\x3E\x48" \
          "\xF5\x66\x9E\xCB\xC6\xF2\xAE\x37\x7D\x38\x0E\x2B\xB4\x14\x3C\x9D" \
          "\x98\x08\x1D\x96\x36\xE3\x2C\xD7\x38\x29\x21\x35\x24\xDE\xF4\x1A" \
          "\xBC\x51\x6B\x07\x54\x3F\x33\x1C\x56\x38\x5A\xC0\xE5\x9C\x5E\xB2" \
          "\xE2\x21\x3A\xC7\xA2\xCF\x78\xF6\xA3\x09\x4C\x84\x43\x60\xCA\x5F" \
          "\x30\x6F\xAF\xE6\x64\xB0\x8E\x5C\x0C\xFF\x15\x68\x7C\x0B\x28\x63" \
          "\x46\xF9\xCC\x84\xC3\xC6\x99\xCA\x67\x1C\x5E\x01\xFE\xDD\x26\x74" \
          "\x75\xB0\x30\xC7\x80\xB2\x1D\x7A\x2C\xEB\x0A\x75\xA3\x0A\xDA\x5D" \
          "\x13\x38\x45\x2B\x44\x87\x9D\xCC\x39\xE5\x70\xD2\xE6\x0F\xE4\xB4" \
          "\xF2\xA0\xE3\xE5\x71\xA1\x42\x57\x6B\x2F\x7B\xE4\x4A\x38\x5D\x5D" \
          "\x8B\x32\xB7\x52\x7E\xC3\x41\xFF\xCC\xEB\xFC\xFC\x50\x4D\x03\xC2" \
          "\x0D\x4A\xBE\x11\xC8\x4C\xAC\xD7\x1B\xFA\x9F\xA1\x38\x81\x3C\xEC" \
          "\xEB\x49\xBA\x90\xB5\xBF\x1C\xB1\x86\x99\x54\xC8\xAC\xC4\xDB\xED" \
          "\xF2\x1D\x79\xB2\xF1\x9A\x96\x52\x81\xDC\xBF\xB5\x32\x67\xEB\x16" \
          "\x87\x81\x61\x31\xD9\x91\xC4\x59\x41\x4B\x4F\xE0\x3B\x97\x6C\xFE" \
          "\x36\x88\x75\x2C\x33\xD9\xD4\x07\xE7\xDC\x72\x82\x09\x85\xDB\x03" \
          "\xE1\x34\xCA\x43\x39\x4E\x5C\xF9\x73\xF6\x6D\x0E\x14\xD8\xBC\x97" \
          "\xDC\x8B\x62\x3E\xEC\x2A\x5D\xE6\xA2\x64\x05\x38\xAA\xB2\x16\xBA" \
          "\xC4\x95\xFD\xA4\x35\xE2\x03\x7E\xBC\x1A\xAF\x44\x50\xAC\xE6\xFA" \
          "\xDD\x95\x8E\x96\x33\x42\x19\x51\x02\x9D\x37\x6E\x41\xF8\x96\x20" \
          "\x79\x82\x38\x04\xFD\xB6\xF4\xA7\xA1\x38\xF0\xF6\x58\xC6\x71\x5F" \
          "\xF9\x3E\xB4\x86\x2E\xC2\x64\x9D\xF0\x14\x58\x2E\x35\x7B\xB7\x6C" \
          "\xF6\xF9\x48\x52\x0D\xC3\x0A\x56\x53\x4F\x99\x96\x5C\x2C\xBC\xB4" \
          "\xA3\x3F\x86\x66\x50\x92\x8C\xBD\xD9\x5D\x3A\xBF\x30\x65\x2A\x92" \
          "\xB9\x26\x91\xC9\x5A\xFA\xD7\x27\x49\x7E\x35\x91\x48\xD0\x73\x61" \
          "\x50\xB9\xCC\x73\x3A\x36\x63\x8A\x7B\x65\x87\x7E\x1F\x3C\x12\x62" \
          "\x75\x02\x30\x85\xCB\x15\xB3\x98\x12\x33\x17\xE7\x29\xB0\x88\xB9" \
          "\x1A\x6B\xAB\xDD\xFF\x47\x79\x26\x77\x9B\x6B\x67\x0C\x5B\x53\x65" \
          "\x74\x01\x19\x29\x8F\x62\x06\x6F\xFC\x46\xE1\x4E\xA9\x75\x48\x61" \
          "\xAE\xCD\xC9\xF2\xB4\x8B\x33\x3E\xA2\xB0\x61\x79\xB3\x38\x3A\x22" \
          "\x20\x7E\x6D\xA8\xA4\xBA\x95\x2D\x62\xA3\x3B\x20\x3C\x12\x9E\x26" \
          "\x04\x66\x5E\xF0\x4A\x53\xC5\x4B\xFC\x34\xCB\xEB\x11\x5D\x30\xD9" \
          "\x15\xF4\x83\x6F\x24\x4D\x49\x78\xDD\x60\x05\x9C\x38\xE5\x65\x3D" \
          "\x05\x8D\x58\xAC\x5C\x5C\xFC\xA9\x09\x62\xA9\x97\x6B\x8C\x7C\x40" \
          "\xF3\x04\x09\xAF\xC9\x21\x21\x1B\x93\xF9\xD3\xCF\x5E\x7E\xDA\x87" \
          "\xC0\x0E\xE5\x1E\x80\x8C\xEF\xC8\xDA\x2F\x11\x6C\x79\x2C\x28\x42" \
          "\x62\x26\x01\xE7\x22\xC3\xDF\x57\xCF\xCC\x9B\x4A\x2D\xB5\xF1\xF1" \
          "\x35\x80\x72\xA1\x2E\xA2\xAE\x92\xC8\x5A\xE5\xB1\xCE\x2F\xAA\x4C" \
          "\x2E\x3F\x80\x46\x6B\x01\x38\xA1\xA3\x28\x71\x40\x9F\x61\x3A\x65" \
          "\xCD\xB2\x7F\xF6\xFF\x9F\x62\xBE\x4F\x81\xBA\x4D\x9B\xB3\x29\xD7" \
          "\xB4\xE6\x7C\x1B\xF6\xFA\x3B\x41\xEC\x31\x84\xB1\x1E\x98\x5E\x4C" \
          "\x82\x0F\x8A\x3D\x62\x05\xC3\x6D\x4C\xBF\x1F\xF4\xF1\xDD\xB6\x51" \
          "\xA6\x60\xD3\x37\x76\x0E\x3A\x57\x36\x90\x07\x9A\x36\x1C\x5F\xBE" \
          "\x72\x05\xAC\x0B\x64\xE8\xE1\x87\x2C\x50\x5B\xDC\x51\x77\x06\x2C" \
          "\xA0\xCB\xB8\x2C\xEF\x0F\x99\xC8\x85\x17\x9A\x54\x51\x62\x15\xB6" \
          "\x87\x49\xF2\xF1\x30\x84\x88\x06\x05\x1E\xA0\xE0\xDA\x6B\x4B\xEF" \
           , 1024);
    memcpy(&bCryptBlockExp[1024], \
          "\xFF\xA1\x72\xA4\x4A\xFD\xC5\x83\xC6\x25\xE1\x82\x24\xA6\x9A\xBA" \
          "\x8D\x86\x90\x46\xAC\x4E\x49\x41\xDD\x92\xB8\x04\xA4\x21\x08\x72" \
          "\x01\xD2\x77\x3E\x84\x24\x28\xE3\x3C\x52\x15\x14\x85\xDC\xB5\x9C" \
          "\x9A\x0E\x3B\x90\x9E\xD8\x36\xD4\x0F\x7E\x5F\x02\xC6\x03\x15\x3E" \
          "\x0C\x5A\xD6\x8A\x94\x03\xE4\x89\x69\x6A\xF6\x9C\xE4\x5C\xF1\x58" \
          "\x81\xC3\xC6\x60\xB5\xAF\x60\xFE\x43\xBC\xC1\x2C\xA5\x39\x9A\xF5" \
          "\xE9\x26\x3D\x12\x27\x0F\xD0\x85\xE5\x9F\xE0\x7A\x5B\xDA\x7C\xD1" \
          "\x3E\xEF\xC0\xB0\x4B\x36\xAD\xB0\xE9\x27\xF5\x47\xB1\xA5\x02\xDD" \
          "\xD9\x0D\x07\xAE\x96\x64\x0E\x2A\x4E\x92\x49\xCB\x3B\xD4\xF1\xAF" \
          "\x3E\x64\xA7\x12\xBC\x56\xBA\x22\x93\x63\x56\x7A\x0C\x44\x09\x91" \
          "\x8E\x78\x6A\x42\x2F\x10\x2E\xF3\x16\xDE\xA2\xA9\xF8\x3F\xDD\x09" \
          "\x67\xAA\x58\xB8\xDA\xBF\x81\x98\x7B\x7F\xE5\x10\x00\x85\xC5\x2B" \
          "\x8B\x8F\x9F\x8B\xB2\x49\x5A\xE9\x3F\xDA\x60\xD6\x60\x20\xC9\x10" \
          "\xF5\x9F\xFE\xB8\x0D\x68\xAD\x66\x3F\x52\xB5\xC3\x4A\xBD\x65\x44" \
          "\xBB\xC1\x01\x7F\x0E\xA9\xE3\x50\xDF\x58\x08\xB7\x65\x5B\xF2\x03" \
          "\x48\xD0\x9E\x77\x94\x05\xEB\xF4\xDD\x5D\xD7\xFA\xDB\x30\x84\xC9" \
          "\x6E\xFA\x14\x3F\xF2\x6E\x29\xFA\x38\xB1\x3E\x9C\xEF\x3D\x96\x4A" \
          "\x2A\x4D\x62\xFE\x0F\x82\x96\x3D\x82\xB8\x12\x52\xA2\x0B\x11\x24" \
          "\x0B\x8F\x64\x37\x1B\x11\x6D\xAC\x00\x1A\xF3\x5A\x7C\xFD\xFD\x73" \
          "\x05\xC1\xB4\x09\x86\x2F\x57\x45\x50\xAD\xBD\x9D\x63\x92\x24\x69" \
          "\xED\x31\x19\x79\x96\x02\x25\x15\xF2\xD4\x4F\x2C\x80\x4D\x03\x03" \
          "\xC8\xA1\x19\x4E\xA5\x0B\x87\x4C\x68\x0A\x1A\xB6\x14\x45\x2A\x77" \
          "\x4D\x58\x77\xA4\xDC\xAB\xA6\x60\xEC\x71\x70\x86\x49\x0E\x42\xFD" \
          "\x42\xAB\x35\x1F\xEA\x0F\x78\xD8\x0D\x36\x7E\x65\x88\xEC\x12\xED" \
          "\xE8\x30\x0F\x62\x9C\xD9\x0B\x24\x97\x70\xA3\xBD\xA4\x01\x93\x59" \
          "\x98\x57\x79\xEE\x7E\xA8\xF0\xA1\xAD\x2D\x23\x30\x4F\xD1\xC2\x23" \
          "\x8C\xCD\x89\x8E\xD9\x79\x0D\x69\xC3\x94\x88\xFD\xA3\x46\x23\xF7" \
          "\x1D\x50\x8D\xEC\x47\x66\xFC\xB6\x3B\x69\xBC\x62\x33\x29\x16\x66" \
          "\xEF\x13\x6C\x13\xEE\x29\xC7\x8A\x41\x2E\x48\x0C\xB3\xF0\x26\x48" \
          "\x97\xAD\xF3\x0E\xB9\x4B\x67\x7A\x1D\xBA\x82\x77\x11\xDD\xFD\x93" \
          "\x51\xDF\x15\x3F\x29\xDA\x98\x29\x01\x08\xD2\xD0\x82\xF5\x65\x42" \
          "\xFD\x6A\x22\x48\x69\x3A\x70\x5A\x00\x9C\x0E\x4B\xFF\x98\x51\x30" \
          "\x6B\x3D\x02\xDA\xB5\x42\xB7\x13\x48\x44\x3F\x36\xDE\xBE\xAB\x81" \
          "\x33\x96\x5A\x50\x3D\xA0\x79\x60\x81\x32\x49\xED\x00\x2C\x81\xA3" \
          "\xC0\x87\xC1\xD4\x15\xF8\x53\x78\xCA\xF9\xD4\x7B\x00\x37\xDE\x64" \
          "\x96\xD7\xEA\x38\xA8\x45\xFB\x46\x9D\x53\x00\x18\xA7\x3C\x16\x0D" \
          "\x91\x9E\xF8\x8B\xAA\x9A\xE6\x1F\x89\x2D\xC5\x4B\xF1\x47\xFB\xA6" \
          "\xF0\x13\x53\x29\xA7\x62\xF5\x88\x22\xF0\x26\xDF\x95\x5F\xC6\xC5" \
          "\x7F\x07\xF5\x0A\x66\x23\x78\x8D\x87\xC1\x93\x7E\xC8\x81\x83\x6B" \
          "\x8C\x2D\x30\x1E\xDC\x5C\x1C\x46\xD7\xC2\xC0\x1D\x65\x95\x51\x95" \
          "\xD2\xED\xF1\xF8\x92\x49\xAD\x03\x44\xC9\x16\xA1\x3D\x3F\xCB\xD5" \
          "\x7A\xC6\xCA\x4B\xE7\x91\x74\x7B\xBD\x1F\xB2\xE1\x96\xD0\x8E\xAA" \
          "\x86\x55\x03\x6D\x54\xFA\x7C\x79\x28\x53\xA3\xCD\x6C\x75\x2A\xB3" \
          "\x5C\xFC\xBE\x3C\x5C\xF6\xE8\xB5\x7C\x6D\x6C\x49\x6E\xB2\xF9\x99" \
          "\xEF\x70\x84\x4F\x26\x0E\x68\x47\xB8\x3C\x60\x2F\x6F\x6E\x17\xBB" \
          "\xAF\x36\x3A\x46\x45\x22\x09\xE4\x08\xC6\x7A\xCA\x7D\x21\xCD\xC4" \
          "\x1C\x65\x14\x24\x04\xAD\xA9\xAC\x6B\x6F\xE2\xE7\x6E\xB9\xB0\x3F" \
          "\xB3\x41\xD4\x99\x23\x5E\x86\x8F\xFC\x2E\x93\x11\x44\x46\x0B\x26" \
          "\xC5\xDC\x94\x9A\x91\xA3\x8B\x71\x8E\xD3\xB5\x51\x7A\xF0\x00\x27" \
          "\x5C\x0E\x0C\xF4\xCC\x90\xAD\xD5\x63\x67\x6A\xAD\x22\xFA\xBC\xEE" \
          "\x57\x8E\x63\x15\x6D\x24\x75\x97\x38\x3E\xF8\x28\x97\x54\x9B\x2A" \
          "\xF2\x4F\xAA\xD2\xCA\xA8\x73\xC5\x57\x8F\x2E\x61\xF7\xAE\xBA\x2A" \
          "\x5E\xA6\xD5\xA4\x44\xD7\xBB\xBD\x67\x15\x9D\xD0\x9D\xA7\x65\xE3" \
          "\xFD\x11\x2E\x35\xFC\xAE\xCD\x42\x7C\x91\xE6\x27\xAA\x4F\xF3\x73" \
          "\xF3\xDB\xCE\xB0\x74\x98\x6F\x12\xBB\xF9\x18\x27\x6E\xAC\xD8\x4F" \
          "\x89\xE5\xEC\xC4\x09\x65\x05\xEF\x32\x46\x01\x6D\xF0\x0C\xFC\x63" \
          "\x7B\x9F\x8D\x3E\xFB\x8F\x7A\xA9\x64\x41\x12\x6D\xD7\xD2\xD4\xF9" \
          "\xDC\xD0\x83\x8D\x98\x33\xCB\xC1\xC4\x22\xDA\x48\x36\xE2\x59\x3C" \
          "\x5D\xF5\x3F\xAC\xE6\x6D\x90\xD1\xD5\xD1\x5E\x46\x6E\xC3\xA9\x8D" \
          "\x4D\xF8\xDF\xE3\x7C\xA7\xB9\x5A\xF0\x2A\xA3\x4D\x65\xF0\x7A\x6E" \
          "\x2B\x40\x1E\x23\xD9\xAF\x3B\xCA\x34\x9D\x70\xD9\x9E\xDD\xB8\x66" \
          "\xD7\x47\xB6\x50\x6B\xA5\xD7\x27\x98\xB6\xBE\xD1\xC0\x7F\x2B\x0A" \
          "\x43\x95\x6A\x35\xC2\x6C\x58\x42\x0B\xCE\x7B\xBA\x42\xDD\x50\xE2" \
          "\xFA\xEA\xDD\xAC\x2D\xD5\x0D\x28\x06\x59\x72\x35\xB7\x23\xF6\x3E" \
           , 1024);
    memcpy(&bCryptBlockExp[2048], \
          "\x3D\xCD\xE9\xC9\xF6\xB0\x55\x00\xF8\x24\x9E\x4A\xC0\xFC\x6D\x7C" \
          "\x23\xCB\x5B\x0F\xF4\x84\x54\xB9\xDA\x4F\xB2\xAB\x9E\xA9\xEF\x92" \
          "\x81\x6D\x0A\x34\xBA\xB2\xE7\x6D\x31\x06\x71\x8A\x30\x82\xAC\xE9" \
          "\x3F\x02\xCC\x31\x57\x6C\x73\xCB\x6F\xBA\x2F\x15\xD8\xAD\x63\xDE" \
          "\xB7\xEB\x4B\x47\x23\x70\xB9\xD9\x13\x29\xCC\x46\x69\x04\x96\x58" \
          "\x55\x24\x2C\x28\x50\xC0\x98\xA5\x4C\x8D\x22\xE6\x3A\xDC\x2E\x5A" \
          "\x5E\xA4\x27\xEC\x83\x3D\xF8\xDC\xA1\x30\x67\x57\xF5\xC8\xAA\xEA" \
          "\xF6\xC2\x81\x71\xD0\x9C\x05\xF8\x39\xDA\xA1\xCD\xE3\x7F\xC0\xD1" \
          "\x43\x1C\xB4\x0F\xC8\x6B\x52\x1E\xF9\xCF\x09\x51\x0E\xDA\x66\x25" \
          "\xB3\x53\x56\x6A\x29\x1E\x3D\x6B\x41\xB2\x9F\xD7\xA7\xC7\x1E\x09" \
          "\xA8\x42\xAD\x75\xCC\x4E\x3A\xA8\x9D\xE0\xF5\x0C\x77\x61\x82\xD0" \
          "\xFB\x0D\xB5\xA6\xB1\x14\x04\x2E\x5E\x85\x90\x53\xB2\x9C\x45\x0A" \
          "\x9C\x0B\xE9\xBA\xA6\x3F\x36\x88\x67\xC4\x2F\x51\xA4\x88\x52\xB3" \
          "\x21\x6A\xD7\xC5\x00\x1D\x86\x62\x90\xA1\x70\x03\xD9\x82\xF2\x05" \
          "\xFB\x54\x38\x3B\x3B\x96\x1F\x01\xE7\x15\xDC\xDD\x71\xB4\x89\xB2" \
          "\x43\x55\x2E\xC4\xCC\x42\x04\x0F\x6A\xBF\xF3\x2C\x7D\x0F\xFA\x14" \
          "\xC5\xB6\x17\x77\x35\x1C\x50\xF3\x51\xA1\x6E\x11\x71\x78\x84\xC1" \
          "\x3D\x01\xAE\x2C\x23\x38\x44\x9C\x69\xF2\x54\xE4\xD2\x31\xB9\x3A" \
          "\x66\x9A\xA1\x45\x48\xB5\x3A\x51\xAB\xA9\x60\x91\xC7\x1E\xA2\x94" \
          "\x22\xF9\xEC\xE5\x71\xE9\x7F\x56\x9D\x19\xE7\xED\x75\x23\x49\x7E" \
          "\xA9\x0A\xF0\xAA\xB8\xEC\x16\x4A\x6E\x7B\xE0\xF1\xDB\xEF\x1D\x19" \
          "\x3E\x2D\x3E\xB2\x55\xE9\x45\xA5\xAD\xAF\x1B\x3D\x36\xDE\x9A\xD4" \
          "\x3A\x7E\xA6\x41\x54\x27\x2C\x0C\x94\x7D\xBA\xB0\x09\x47\xC1\x92" \
          "\x2C\x3C\xF6\xCE\xB1\x7E\x09\xA1\xAB\x57\x4C\x6B\xBF\x8B\x6C\x31" \
          "\xCD\xE3\x51\x95\xED\xF5\xF8\xCE\xFD\xB0\x68\x80\x5C\xF0\x27\x79" \
          "\x1C\x4C\x32\x64\x79\x04\x0B\x41\xCA\xDF\x2F\xBE\xD1\xD4\xDA\x9B" \
          "\x8E\x50\x10\xFA\xCD\x57\x28\xFF\x86\x6E\xF4\xAB\xDF\x68\xA0\x89" \
          "\xB5\xFF\xFB\x07\x07\x5A\xB5\x3A\x3F\x41\xE2\x6A\xBC\x14\xA7\xDF" \
          "\x78\xE0\x83\x94\x6A\x48\x1A\x8A\xF7\x1F\x9C\xEF\xBA\x85\x6E\x5A" \
          "\xD3\xCA\xA8\x41\x43\x75\x94\xB5\x3A\xAA\xBD\x47\xEC\xC1\x2A\xA8" \
          "\x9A\xF7\x81\x05\xAB\x8C\xDC\x9D\xE1\x6C\xED\x19\x54\x50\x4D\x4F" \
          "\x63\x9C\x42\xD8\x86\xE1\x4D\xD1\xB7\x2E\xC3\xDC\xFE\x9F\xA0\x1B" \
          "\x5C\x5F\x4C\x66\xAD\x6C\xA6\x6C\xE9\xC7\x97\x6E\x7C\xC8\x0C\xC2" \
          "\xBF\x0F\x7C\x20\x55\x70\xE0\x62\x22\xE1\x81\x9E\x29\xDF\x1C\x56" \
          "\x00\x84\x63\xC1\xC4\x8F\xEE\xCB\xA4\x20\xF2\x37\x69\xBD\x22\xCA" \
          "\xE2\x63\x1A\x71\x36\xD8\xC9\xAE\xFA\xB6\xB8\x9F\xCA\x8E\x9E\xF8" \
          "\x19\x79\x34\x3A\x36\x74\xAB\x13\xB5\x90\x97\x0E\x08\x97\xD5\xB7" \
          "\x10\xEE\x17\xF8\xD7\xBE\x18\xAC\xD5\x94\x26\x38\xAE\x45\x3F\xB6" \
          "\x4C\xB9\x33\xC3\x50\xB5\x0A\x0D\xCC\xDD\xEF\x6C\x3C\x2D\x5D\xDB" \
          "\x8C\x2B\x17\x48\x66\x68\xA7\xD7\xA0\xC1\x53\x9D\x66\x80\x76\x05" \
          "\x47\x0F\x89\x53\xC8\x9F\xB5\x51\x7D\xDC\x62\x2B\xFF\xDE\x84\x37" \
          "\xDB\x51\xE7\xF4\x2D\x92\x9C\xC5\x11\xDA\xE6\x45\xAD\x5B\x5C\xB8" \
          "\x7B\xE0\xBF\xDC\xF5\xC3\xC1\x95\x49\xE8\x54\xB0\x94\x90\x0F\x9D" \
          "\xC0\x7F\x3A\x56\x01\x4E\xA2\x6E\xFB\xC6\x27\x46\x05\x9A\xE8\x15" \
          "\xA0\x64\xC1\xBE\x08\x29\x77\x19\x34\x67\x59\x4D\x4E\x88\x36\x70" \
          "\xBD\x78\xD4\x8F\xE3\x0B\x54\xF4\xF8\x6D\x62\x97\x4E\x30\x35\xA9" \
          "\x7F\xD7\x70\x7D\x60\x70\xE7\xAE\xC1\x29\xA9\xED\xFF\xB2\x6E\xEC" \
          "\x6C\xFD\x79\xA4\xB2\x32\x8A\xC0\x71\x1A\xDD\xD5\xA9\x27\x3F\xCF" \
          "\x79\x9B\x45\x3D\x72\xB5\x52\x24\x0C\x7B\x7E\x4C\x4D\x7C\xFD\xF7" \
          "\xCA\x35\xE8\x85\xA1\x8B\xC4\xC2\x1B\x4D\xDF\xA0\x88\x24\xAF\x1F" \
          "\xB6\x33\xED\x44\x69\x58\x42\x39\xA3\x1C\x82\x49\xDB\x51\x80\xFE" \
          "\x65\xFA\x71\xEF\x3C\x42\xA5\x33\x84\x6A\x0C\x5E\x9B\xCF\xE4\x4B" \
          "\x16\xD3\x5B\xE3\x81\x13\x51\x78\xAD\xB5\x54\x8C\xB5\xE0\x6B\x4A" \
          "\x3B\x92\x98\xAC\x13\x62\xE6\xA0\xA1\x26\x2B\x8F\x1A\xA7\xEF\xDD" \
          "\x7C\x47\x24\x7D\xAD\x52\xEA\x8D\xBF\xEC\x0A\xF3\x75\xE5\xE6\x09" \
          "\x8A\xC4\x94\xF2\x4F\x78\xC0\xB0\x9A\x38\x41\x1F\xBE\xFD\x4C\x1C" \
          "\x24\x7C\x50\x88\x3E\xA4\x81\x6C\x5E\x5A\xB6\x9A\x47\xAF\x0C\xBF" \
          "\x55\xDB\xE2\xDF\xA4\x9D\xB4\xA9\x12\xCF\x39\xE3\x43\x22\xC9\x16" \
          "\x82\x44\xE3\x84\x63\xF5\xF7\xEF\x90\x66\x48\x4E\x85\xCD\x7C\x6B" \
          "\xFF\x4F\x9A\xE6\x6F\xFF\xE0\xC1\x50\x58\x40\x14\xAB\x8D\xC9\xD9" \
          "\xAE\xEF\xDA\xAA\x87\xC1\x75\x7A\x2E\x16\x74\x2E\xF9\xAD\xE8\x02" \
          "\x1C\xF1\xB6\xCD\xF5\xDA\x38\x6D\x03\xD9\x2B\x40\x63\x8A\xDD\xB0" \
          "\x5D\xF6\x33\x5E\x20\x51\x90\xB4\x6E\xEB\x49\x0E\x6A\xE1\x6A\x52" \
          "\x8B\x4E\x69\x98\x11\x37\x20\xB4\x2D\xA5\xB2\xBB\xBF\x98\x55\xF0" \
           , 1024);
    memcpy(&bCryptBlockExp[3072], \
          "\x21\xE9\x7E\xBD\x43\x6A\xB9\x94\xE3\xC0\xF6\xE2\x44\x10\xCB\xE5" \
          "\xCA\x7E\x6D\xB7\x3B\x9B\xF5\xFB\xF7\xBA\xF5\x79\x5D\x8A\xA5\x73" \
          "\x2E\xCE\xAB\x90\x10\xDE\x7F\x7A\x43\x64\xBA\x3B\x90\x2C\xC5\x01" \
          "\xA8\x91\xBF\xB4\x2E\x02\x71\xCD\xF2\x40\x8F\xE3\x6C\x9D\xD6\x75" \
          "\x49\xB3\x25\x2E\x38\x31\x52\x01\x16\x19\x53\x0D\xC9\x37\xB8\x6D" \
          "\x68\xB5\xB5\x38\xC9\x1D\x95\xAD\xD7\xB4\x4B\xDA\xED\x77\x50\xB7" \
          "\xF1\x44\xC1\xCE\x30\x93\xA0\xE7\x54\x4B\x71\x2F\x1D\xE9\x1C\x2C" \
          "\x3F\x98\xDA\x05\x58\xDE\xA8\xB8\x16\x9E\xBF\x55\xB9\x14\x4A\xB4" \
          "\xE3\x69\x12\x3D\x09\x9C\xA2\xCB\xBC\x74\xA1\xFC\x91\x63\x02\x2D" \
          "\x43\x38\x4A\x3A\x92\x37\x8C\xAB\x95\xB7\x4C\xB9\xFA\x46\x53\xEB" \
          "\x40\x91\x80\x8C\xC7\xC1\x69\xCE\xBB\xB7\x80\xDA\xFE\x5B\x67\x30" \
          "\xC4\xF8\xA3\x60\xE2\xD9\x1B\x3D\xBA\xCC\x6F\x13\x1A\x5A\xA5\x6F" \
          "\x11\x82\xBE\x57\xAD\xEF\x1E\x2E\x3B\x2F\x35\x8F\xC6\xB1\x01\xEF" \
          "\x14\x91\x61\x16\xC5\xA9\xD1\xB8\x28\x0E\xAD\xA6\x5A\x5B\x39\x15" \
          "\xB3\x32\x25\x76\xCF\xBF\x23\x71\xA6\xB2\x3F\x83\x1F\x3E\xD5\x15" \
          "\xEF\xAD\xC9\xF4\x79\xAC\x5E\xA1\x1D\xBC\xE5\x72\x89\x50\x34\x07" \
          "\x9B\x71\xD7\xCF\xC8\xB6\x7E\xEF\x7F\x3B\x54\x70\xFD\x55\x6B\x95" \
          "\xF1\x55\xE6\xFF\x32\xE9\x06\x3C\x2A\xA2\x63\x7E\xED\x7E\xAC\xB8" \
          "\x59\x43\x77\x7C\x2B\xFE\xC6\x3C\xAE\xBA\x95\xAC\x51\x35\xE1\xD8" \
          "\xB2\x60\xD0\x0A\x46\x9D\xFE\x22\x3A\x6B\xB6\xC5\xF1\xC3\x14\xC9" \
          "\xC8\x2E\xED\x17\x72\xF8\x28\x2B\x7C\xC8\x96\xE9\x39\xAC\xD8\x05" \
          "\x6C\x75\x6B\x90\x45\x3B\xF7\xF9\x56\xA5\x69\xEB\xDB\x61\x51\x29" \
          "\xF8\xF5\x40\x65\xAF\xA0\xD2\x38\x59\x68\x42\x50\xB1\xD3\xC3\x8C" \
          "\xB0\xB8\x13\x68\xC2\x9C\xAC\x16\x98\x5C\xCE\xA3\xE6\x76\xD4\x20" \
          "\x46\xAA\xB5\x8B\x75\x59\x1F\xC9\x5B\xAE\x46\x98\x09\xC5\x5C\x15" \
          "\x3C\x74\x40\xAF\xAB\x75\x58\x02\x10\x18\xF8\xCB\xD8\x5E\xFD\x2E" \
          "\x3B\x47\xE4\x7A\xB9\xBB\xC9\x42\xDC\x05\x57\xFC\x2C\x9A\x0F\x5C" \
          "\xD8\x82\xB9\xD6\xAA\x57\xF4\xE6\x52\xA5\x77\x33\x5F\x0E\x41\x8E" \
          "\xEB\x29\xB1\x59\xA5\x28\x06\x8E\xC8\xCB\xC6\xFD\x89\x68\xF4\x34" \
          "\x7A\xD7\xF4\x1E\xA5\x49\xB3\x26\xC4\x8C\x60\xD8\x97\x33\xD2\x9E" \
          "\xA5\x6E\x78\x3F\x2B\xCE\xCD\xD4\x9B\x90\xD7\x49\x0A\xCF\x05\xF8" \
          "\xF4\xFA\x79\xDA\x97\xCA\x01\xB1\xD9\x55\x20\x31\x47\x99\x49\xF0" \
          "\xEB\x0E\x14\x5B\xB8\x6D\x74\xE2\x52\xA0\xCF\x45\xA4\x1C\x24\x34" \
          "\x76\x8E\x46\x7E\x53\x7C\x32\x79\x4F\x23\x3E\xF6\xA0\xBA\xED\x5D" \
          "\x53\x6D\x91\xA5\x43\xE4\xB5\xB2\x78\xBD\xD8\x3E\x84\x1E\xB8\xB2" \
          "\x70\x65\xAD\xDC\x60\x00\xFE\x3B\xB4\xCB\x3F\x74\xE2\xC9\xA9\xB0" \
          "\x5A\x92\x87\x87\x9E\x3C\xEE\x22\x11\xE8\x99\xD3\xBE\x81\xAD\x15" \
          "\xE7\xEA\xF6\x34\x23\xF9\xF7\xF4\x35\x87\xE9\x08\x82\x31\xDA\x39" \
          "\xEC\x79\xA7\xA4\x0E\x35\xAB\x44\x8C\xB8\x77\x82\x97\xC3\x33\x5D" \
          "\x00\x77\xD1\x4B\x4A\x89\x9E\x9F\x24\xDE\x36\xFF\x4B\xFD\xA5\xED" \
          "\x5B\x5D\x46\x22\xA2\x8F\xA8\x55\x5A\x32\x62\xE1\xBA\xBC\x63\x83" \
          "\x15\x95\xEA\x90\x61\x53\xFD\xE7\x97\x71\xA6\xAA\xD4\xFB\x8A\x46" \
          "\xA3\xD5\x6E\xC2\xE2\xB6\x81\x26\x69\x2D\xB0\xEE\x9E\xFE\x0A\xD3" \
          "\xE6\x91\x26\x4A\x12\xD1\x7E\xB6\x66\x26\xD7\xBB\x61\x7D\xA5\x6B" \
          "\x2A\xEE\xD6\x53\xD3\xB9\xE6\x0F\xE0\xA2\x3D\x78\x53\x03\xF1\x52" \
          "\x27\x04\xF7\x42\x97\x9F\x4F\x65\xE6\x8C\xB0\x24\x17\x06\xF7\x96" \
          "\x1C\x92\x34\x92\x09\xDC\x89\xB8\xFC\x3B\x5C\xF6\x64\x89\x9C\x71" \
          "\x5A\x51\x8D\xD5\x7F\x20\x53\xE5\x69\xA6\xCA\xDF\xBE\x2A\xBD\x2C" \
          "\xAA\x75\xEF\x78\x00\xCF\x36\xC4\xC6\x5E\x62\x42\x07\x4F\x1C\x28" \
          "\xE1\xA4\x7C\xD3\xBA\xF7\xD1\x99\x52\x63\x00\x19\x14\xA3\xCC\x61" \
          "\xF6\x14\x41\x6D\x9E\x29\x1D\x9A\x8D\x9A\x77\x67\x7B\x01\x48\x1F" \
          "\x07\x59\xF0\x30\xF6\x94\xAA\x75\x6B\x03\x5D\x07\xEF\xA5\x9B\xED" \
          "\xBC\x57\x88\x1E\xCA\xDA\x67\xD1\x21\x40\x09\x7C\x21\x1E\xE9\xB3" \
          "\x07\xD9\x10\xF0\x5A\x5C\x6B\xFA\x0F\xB4\xDE\x4D\x33\x3C\x30\x0F" \
          "\x53\xC8\xE3\x26\x4F\xF6\xB9\x03\xC5\x54\xCA\x81\xEB\x61\x16\xEB" \
          "\x06\x97\x5B\xB8\x90\xB4\x26\x1C\x40\x82\x8A\xEB\x39\x12\x0C\xBB" \
          "\x32\xE6\xE1\x1A\x38\x5C\x5E\xD5\xE2\xE3\x20\xDF\x3C\x1E\x1C\xA9" \
          "\x1E\xB3\x86\x54\x8A\xE9\xD0\x76\x27\xAF\x62\x70\x0B\xB5\xFF\x2B" \
          "\xA0\xDD\x69\x58\x5F\xAE\x42\x6E\x16\x89\x46\x19\xB2\x77\x17\xC7" \
          "\x63\x25\xF2\x3B\x75\xF6\x3E\xD4\x47\xDF\x65\x94\xE7\x3C\x94\xE3" \
          "\x32\xD5\x0C\xBE\x82\xE2\x6E\xF0\x82\x92\x48\x67\xA2\x39\x19\xE6" \
          "\x73\x12\x9F\x51\xDC\x07\xA6\x7A\x26\x40\x07\xB2\xBC\xC8\x54\x55" \
          "\x54\xB0\xC3\x1E\x6F\x8C\x3D\x34\x81\xE0\xE5\x8D\x1C\x43\x25\x12" \
          "\xF2\x02\xC4\xEF\xAD\x99\x6D\x2B\x9E\x44\x81\x99\xB1\x69\x8D\x93" \
           , 1024);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 24);
    DspHex("[IN ]bPlainBlock    =", bPlainBlock, 4096);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    DspHex("[IN ]bIV            =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptCBC(nSock, nAlgo, bKey, bPlainBlock, \
                             nBlockLen, bIV, bCryptBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "算法类型=3，数据长度=4096，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptBlock    =", bCryptBlock, 4096);
    DspHex("[OUT]bCryptBlockExp =", bCryptBlockExp, 4096);
    ASSERT_OUT_HEX(bCryptBlock, bCryptBlockExp, 4096);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptCBC_Test_07(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bPlainBlock[4104];
    int  nBlockLen;
    BYTE bCryptBlock[4104];
    BYTE bIV[16];
    BYTE bCryptBlockExp[4104];

    bufclr(bKey);
    bufclr(bPlainBlock);
    bufclr(bCryptBlock);
    bufclr(bIV);
    bufclr(bCryptBlockExp);

    nAlgo = 3;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8697 A4B5 C2D3 E0F1 */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\x59\x99\xC3\x06\xAB\x84\x01\xB2",\
                 24);
    nBlockLen = 4096;
    memcpy(bCryptBlockExp, \
           "\xBA\xF9\xEF\x36\xAC\x80\x81\x58\x8D\xEC\x81\x3A\x77\x10\xE0\x58" \
           "\x9F\x5D\xDF\xEE\x03\xD6\x7C\x9F\x80\x07\x30\x03\x3D\xE8\x44\x67" \
           "\x27\x07\x51\x81\xC3\x8C\x98\x96\x2D\x6F\xE2\x39\x93\x63\xF5\x71" \
           "\x33\x35\x64\x18\x78\xF5\x22\xDA\xD0\x3A\x31\x8B\xB8\x0F\x24\xC3" \
           "\x7E\xF0\x92\x29\x31\x7B\xC4\xD8\x5C\x59\xCD\xCE\xF0\x2B\x83\xD2" \
           "\x77\x36\xAB\x29\xDD\x93\x06\xCD\xE1\x54\xED\x64\xB5\x28\x92\x59" \
           "\xA0\xC1\x66\x7B\xA8\xDF\xCE\x7A\xBD\xD4\x9B\x60\x5D\xDD\xCD\x87" \
           "\x9F\x11\x9C\x8B\x60\xC8\x8A\xB8\xDE\x2D\xF4\x6E\x4C\x54\x0A\xCA" \
           "\xE8\xD1\x10\x95\x80\xDF\xF9\x6B\x6C\xEA\xCD\x45\xC9\x25\x18\xEF" \
           "\xA7\x7D\x2A\x27\xAC\xA9\x69\x91\x91\x10\x64\x56\x81\xB1\x21\x4B" \
           "\xEB\x66\xB4\xCD\xC2\x51\x0A\xEC\x58\x47\x21\x2B\x2C\xDF\x71\x78" \
           "\x64\x15\xE4\x74\x9C\x3D\x99\xA5\x6A\x90\x7F\x5C\xC5\xD0\xBD\xE9" \
           "\x4F\xC3\x22\x8C\xEC\xF3\xB0\xD5\xCA\x72\xD3\x3D\xF9\xE1\x4C\x01" \
           "\xE9\xC8\x10\x14\x45\x4E\x1C\xEF\x8E\xB3\x40\x67\xD3\xB3\x3D\x5F" \
           "\x09\x70\x1F\x18\x47\x9D\xDC\x3C\x9D\x81\xD6\xFB\xFA\xAA\xF2\x9F" \
           "\xA8\xEF\x0A\x12\x97\x9B\x1D\xA1\x06\x65\x84\x7F\x42\x5D\x99\xED" \
           "\x30\x96\xC8\x05\x4B\xF7\x36\x70\x27\x3B\x27\x8C\x0C\x3C\x0D\x94" \
           "\x4F\x35\xC7\x57\xDC\x4D\x6B\xBE\x4D\xB9\x19\xC2\xC1\x1D\x0E\x06" \
           "\x27\xB3\x86\x45\xE8\xCB\x98\x5A\xAF\x63\x65\x57\x64\xD7\x26\x8A" \
           "\x68\x79\x65\x78\x48\x47\x00\xE5\xEB\xB5\x1C\x48\xA5\xAF\x43\x87" \
           "\xB9\x51\x66\x4B\xA7\x1B\x64\xD9\x0B\x46\x3F\x02\x76\x7F\x89\x91" \
           "\x55\xAF\xB5\xEF\x5D\x98\xFE\xBB\x7D\xA2\xE8\xAB\xCE\x78\x3D\x4C" \
           "\x29\x4C\xE6\xDB\x3C\x83\xE5\xA8\xD6\x77\xF7\x2A\x30\xA1\x10\x97" \
           "\xBD\xA6\x8C\x6F\x38\x6E\x3A\xD9\x77\x3E\xCC\xDA\xF1\xFC\xB8\xCB" \
           "\xA6\x44\x13\x1E\xAF\xE4\x9F\x50\x3F\xA8\x2B\x56\x84\x80\x56\x83" \
           "\x53\xE1\x1E\xC1\xC3\x72\x06\x58\x98\x67\x8A\x2E\xED\x98\x23\xF7" \
           "\xF5\x51\x69\x61\xC7\xE6\xD2\x4A\x8C\xB1\xA9\xCE\x7C\x66\x93\xC6" \
           "\xE5\x83\xC2\xA8\x42\x27\x2C\xE6\xA4\xA2\xE0\x79\xBF\xF6\xDB\xF4" \
           "\xF9\xF6\x7E\xEC\x25\x21\xF6\x37\x39\x14\x0E\x41\x3F\xA9\xB0\x29" \
           "\x0B\x42\x43\xCF\xD7\xF3\x0B\xD2\xCF\x74\xD4\x88\x29\x6C\x95\x42" \
           "\xBD\x13\xF1\xDF\xDA\x0D\x6B\x1B\xC5\x36\xBA\xCF\x13\x22\xBF\x78" \
           "\x74\x0B\x43\x3F\x2C\x38\xBE\x4C\x54\x04\x03\xBB\xFB\x91\x16\x8B" \
           "\xEC\xA7\xF6\xE2\x5A\x47\x0D\xF8\xB5\x1D\xBD\x30\xD9\x09\x06\xFA" \
           "\x0E\xBB\x8B\x2F\xFE\xEB\xAA\x54\xB6\x30\x83\x84\x74\x8F\x9B\x3D" \
           "\x6F\x69\x8A\x76\x16\x0E\xE0\xDF\x39\x08\x79\xCE\x12\x1B\x30\x2E" \
           "\x4E\xCC\xE9\x60\x09\x3F\x4E\x78\xBA\xC4\x84\x12\x84\x3E\x84\x77" \
           "\xB0\x9D\x45\xF1\xC2\x37\xC7\xC6\x3E\xA5\x04\x96\x90\xA5\x03\x21" \
           "\x37\x20\xE6\x41\x9B\xF7\xC6\xFD\x4A\x59\x02\x1F\x0A\xF7\x34\x93" \
           "\x48\xBC\xEF\x1A\xE8\x73\xE8\x5E\xDE\x7C\xF4\x85\x26\x14\x01\x74" \
           "\x70\x2B\x6D\xE3\x37\x47\x37\x4C\xF0\xE9\x6D\xD7\xB9\x04\x58\xD9" \
           "\x8F\x51\x1A\xEE\xF4\x43\x26\x8D\x6B\x91\x61\xE5\xD2\x21\xB9\x03" \
           "\xED\x0D\x83\xCA\xCB\x25\x87\xD2\xD7\xCF\xF6\x3B\x52\x92\xE5\x83" \
           "\xEE\x36\x8C\x91\xD2\x58\x14\x60\x35\xF3\xDE\xE8\xBA\x01\x43\x87" \
           "\x59\x43\xBC\x27\x8E\x1E\xC3\x32\x88\x07\x21\x8B\xA2\xC5\xF0\x46" \
           "\xE0\xB8\x0B\x88\xC4\x9C\x4B\xBE\x39\x94\xA5\xC6\x7E\xB2\xA7\x5C" \
           "\xAE\xFA\x92\xB4\x42\xFD\xCE\xBB\x2E\x0A\xA3\xC5\x3C\xF3\x6C\x88" \
           "\x30\x0A\xB3\x80\x84\x4A\xC0\x74\xE0\x61\x03\xB0\x59\xF1\xD8\x4E" \
           "\x84\x96\x45\x26\xFA\x28\xFD\x01\x5C\xC9\x56\xB1\x43\x8A\x14\x99" \
           "\xF0\xCF\x69\xAB\xFC\x71\x0B\x45\x21\x15\x68\x69\x98\x17\xA1\x67" \
           "\xD1\x65\xDD\xD4\x44\x1F\xB1\xA4\x65\xB1\xFF\x60\x25\xA3\xA4\x9A" \
           "\xB9\x99\x03\x15\x83\x41\xD5\x90\xF4\xDC\x23\x0D\x6D\xC8\x12\x6D" \
           "\x14\x5C\xD7\xCC\x8E\x1A\xF4\x69\xB5\x62\xC6\x7A\x75\x0D\x8B\x32" \
           "\x16\x4B\x47\xCB\xDA\x81\xE8\xC2\xB1\x1B\x5D\x65\xA7\x25\x49\x48" \
           "\x06\x7F\xBC\x59\xC2\x46\xA7\x1C\xCF\x67\xCD\x02\xB8\xC6\x78\xF9" \
           "\x1D\x34\x8C\x24\xC4\xFE\xFC\x17\x14\x87\xFE\xA9\x41\x4E\x3D\x59" \
           "\xC0\x7A\x01\x53\x0E\x76\x46\xE0\xB7\xFC\x72\xB4\x5B\x3D\xF6\xBF" \
           "\x58\x74\x4A\xB8\xAF\x24\xC1\xD6\xF0\x77\xDD\x28\x09\x43\x29\xBA" \
           "\x1B\x2E\xF5\xEF\x24\xCE\x83\x8E\x90\xDA\xE6\xC0\xE0\x07\x92\xC1" \
           "\xDD\x2E\x95\x5B\xEB\xC7\xD6\x2C\x20\x4A\xD1\x22\x2B\xCD\x41\x4E" \
           "\x4D\x99\xCD\xAC\xF5\x81\x76\x0D\x10\xEA\xA6\xB3\xF3\x75\x65\x12" \
           "\xBC\xAD\xA2\x43\x20\x8C\x06\xD0\xAD\x8C\x06\x0A\x9A\x13\x68\xA8" \
           "\xFA\xD9\xB2\x0C\xAE\x1D\x45\xD2\x67\x81\xF0\xE7\x62\xAF\x0C\x4B" \
           "\x52\xE1\xED\x7E\x82\x09\x43\xC5\x15\x9A\xF9\xAF\x75\xDA\xAA\x9F" \
           "\xF6\x20\xF3\x36\xF1\xE7\x9D\xA2\x88\x82\xB8\x0E\xB3\x4E\xD0\x99" \
           , 1024);
    memcpy(&bCryptBlockExp[1024], \
           "\x90\x18\x00\x79\xD7\x05\x20\x72\xE5\xCE\x26\x9E\x39\xB1\x8B\x56" \
           "\x3F\x73\xDC\xCC\x99\xDF\x8A\xD3\xB0\xA6\x1E\xEE\x69\x6E\xB0\x69" \
           "\xAC\xEB\x8A\x67\xD2\xAE\x63\xC3\xE9\xB7\x69\xE6\x47\xBB\x1A\x93" \
           "\x69\xD7\x17\x76\x99\x8B\xFA\xBD\x9E\xAA\x17\x5D\x00\xAF\x6C\xDE" \
           "\x8A\x15\x46\x18\xF8\x1E\xDF\x2E\xD6\x7E\xA3\x21\x1C\x3B\xFC\x80" \
           "\x4E\x54\xA0\x52\x43\x29\x52\x46\x92\xA4\x9A\x96\xB2\xD7\x44\xCF" \
           "\xC6\x53\x82\x6E\x98\x06\xF0\x81\x13\xF8\x0E\xB3\x17\x60\x51\x1D" \
           "\x16\xCC\x0D\x39\x22\xED\xB9\x98\x8E\xBB\x00\xB4\xED\xEE\x38\xAC" \
           "\xE7\x3C\x3D\x21\xBD\xB1\xA8\xF0\x67\x71\x55\x61\x2D\xB5\x54\xFB" \
           "\xE8\x30\x7C\x44\xAF\x8A\x1C\xED\xBB\x34\xA3\x6B\x2D\xD1\x6E\x34" \
           "\x97\x23\x88\x2D\x2E\x8F\xBA\xC0\x5F\x46\x87\xCB\x62\x3C\x26\x5B" \
           "\xCA\xCD\xB2\x57\xBE\x08\x81\x09\x18\xCE\xF6\x49\x48\x60\xAA\x68" \
           "\x8E\xB0\x71\xCE\xD3\x8E\x2D\x16\x6A\x8D\x4D\x4A\x55\x2E\xBF\x36" \
           "\x1A\xEB\xCA\x94\xA2\x4F\x4A\x3C\x52\x1B\x1E\xD3\x16\x7B\x83\x0B" \
           "\x72\xAB\x81\x39\x7F\x10\x6B\xEE\x8B\x94\xF7\x29\xF9\x02\x12\xB2" \
           "\x6F\x23\x89\x95\x3F\x20\xEB\xE7\x6F\xA1\x46\xCB\x4C\xD3\x73\xF7" \
           "\x60\xB8\x25\x6F\x87\xD1\x44\x78\xC9\xFD\xC0\xAA\x32\x22\x94\x19" \
           "\x82\x78\x80\x2A\xCC\x65\x7A\xE3\x30\x57\x9B\xB5\x30\xA4\xEA\xF9" \
           "\x51\x25\x80\x41\x5B\xF8\xD1\xEA\x59\x0F\xCA\x2B\xB8\x47\x4E\xA5" \
           "\x43\xF0\xEA\x9E\x51\x52\x78\xCB\xA8\x0B\xA9\x7D\x46\x96\x43\xC3" \
           "\xBB\xA5\x20\xC0\xBF\x8C\x7C\xC9\xAC\x82\x2C\x0F\x51\x74\x6C\x04" \
           "\x65\xAA\x9B\xE4\x29\x22\x87\xFE\xD3\xC3\x64\x44\x38\x03\xB0\x4F" \
           "\xAD\xF2\x6F\x01\x8D\xFB\xD2\xA2\x12\x08\xD4\x49\x6C\xC5\x55\xCE" \
           "\xBA\x84\x3C\x0D\xBC\xB9\x5D\x17\x25\xA1\x23\xA3\x84\xF2\x36\xD5" \
           "\xD2\x63\x56\x88\x2D\x3F\xBA\x4B\xD2\x96\xBF\x1D\x8A\x06\x57\xA7" \
           "\x94\xA0\x2E\x2A\x0D\xDD\x7A\x89\xD0\x36\x04\x7A\xF8\xE8\x0C\x82" \
           "\x1C\x35\x5E\x09\x8F\xDC\x8B\xCC\xE3\x62\x17\xB5\xF5\x7B\x59\x4D" \
           "\xB6\xD9\x3E\xD1\x0C\x6A\x62\x4A\x41\x9E\xE5\x84\xAC\x62\x81\x00" \
           "\xCC\x0B\x98\xEC\x61\x47\x04\x96\x49\x21\xC0\x98\x64\x88\x6E\x49" \
           "\x28\xF7\x66\x7F\x0B\x2E\xD0\x98\xE2\x6D\x47\x4A\xBE\xE5\x4B\x28" \
           "\x49\x9D\xE8\xEE\x74\x78\x16\xBC\x76\xA8\x28\x3A\x1C\xDA\x1E\xCF" \
           "\xC9\x84\x1E\xFF\xF4\xDB\x3E\x03\xD5\x77\x87\x8A\x83\x83\x84\x22" \
           "\x16\xF6\x26\xF8\x9F\x55\xBB\x6B\x2F\xF3\xB1\xB9\x18\x40\x75\xE4" \
           "\xF8\xF0\x65\xC4\xF0\x8E\x84\x03\x59\x2F\x0B\x96\xCA\xBE\x1F\xD6" \
           "\xF8\xCA\xD5\x03\x36\x5F\xBC\x26\x24\xB4\x36\x5B\x50\x53\x87\x15" \
           "\xEE\x2E\x50\x0D\xFE\x8F\xD5\x3C\xC6\xD9\xA1\xAF\x02\xF1\xC9\x73" \
           "\xB8\xB4\x87\xBE\x8D\xBE\x4D\xAD\xBD\x2C\x15\x59\x9C\xE0\x57\xF9" \
           "\x52\x93\xC7\xB0\xB8\x01\xBA\x93\x29\x96\x3A\x67\x58\xD0\x0D\x26" \
           "\xD9\x63\xDE\xA5\xDA\xA9\x51\xA4\xEC\x6C\x73\x31\x83\xB0\xD7\xCA" \
           "\x7B\x30\xDF\x7B\xDF\x09\x97\xA6\xFE\x30\x0D\x75\x2B\xB5\x7D\x8E" \
           "\xCA\x53\x2E\xBE\xC4\xB6\xD0\x56\x1F\xE0\x17\xAC\x43\xB9\xD1\xD6" \
           "\xF7\xCB\x4A\x32\x76\xA1\x07\x23\x31\xFA\x6D\xA5\x95\x85\x40\x29" \
           "\x19\x72\x9F\xCF\x0A\xA9\xB8\x11\xA5\x90\xEA\x67\x81\x2A\x2F\x23" \
           "\x17\xBE\xA2\x9C\xFE\x2D\x17\x19\x99\xD0\x86\x46\x99\x4B\x4D\x7E" \
           "\xD4\x53\x7B\xBE\xA7\x6D\x71\x52\x11\x29\x50\x23\xE7\x93\x07\xCA" \
           "\x41\x1F\x9E\x03\x9A\x5B\xDA\x52\xEA\xF1\x47\x07\x38\x09\x6D\x13" \
           "\x9C\xD3\xBB\x27\xB3\x09\xF8\xF7\xD0\xB7\xDB\x0D\x79\x75\xD0\x74" \
           "\x08\xD3\xD7\xF5\x21\x66\x26\x6C\xB0\xA6\x24\x6B\xE5\xD5\xC9\xFC" \
           "\xA0\x98\xBC\xF3\xCD\xD4\xA2\xD5\xE0\x64\x0E\xCC\xB7\x2B\x25\x26" \
           "\x77\x7F\x29\x79\x50\x6E\xBA\x1A\x16\x00\x3F\xB8\xA6\x56\x80\x5F" \
           "\x6C\xA5\x4B\xA7\x12\xDA\xFF\x18\xD5\xFE\xBC\xC1\x20\xAC\xC0\x0F" \
           "\xAB\x06\x23\x89\x5B\xCB\x2C\x9C\x76\xAE\xB1\xFF\xCB\xE4\xAE\xBA" \
           "\x90\xAA\xF3\x36\xD7\xBB\xE2\x5B\x46\x18\xC6\x91\x5F\x51\x27\x89" \
           "\x70\x71\xF0\xEC\x7C\xF3\x32\x29\xB5\x7E\xD0\xE5\x61\x6C\xAF\xCE" \
           "\xC1\xFA\xB2\xF4\xEB\xC9\xA6\x9A\x01\x7F\x95\x37\x85\x71\x88\xAA" \
           "\xB0\x57\xF7\x47\xC4\xF5\x50\x3B\xE7\xFC\x7A\x80\x64\x4A\x0E\xBC" \
           "\xE7\xB4\x57\x29\x18\x3C\x3F\x58\xE5\xE8\xB0\xFC\x98\xD7\xD6\x84" \
           "\xA6\xE3\x1E\x69\x9C\x1F\x9F\x1A\x35\x4F\x05\x43\x2A\x11\x13\x91" \
           "\xCD\xB9\x5E\xE9\x5C\x35\x4E\x66\x01\x6F\x7F\x22\x8D\x35\xF8\x96" \
           "\xBD\xED\x4D\xE9\x8B\x34\x02\x12\x7F\xF9\x5B\xFA\x0A\xAF\xB7\x7A" \
           "\xEC\xF3\x4D\xE3\x8E\x69\x2F\xE4\x7A\xB7\x03\x3D\x7E\xC9\xCC\x81" \
           "\x2E\x6D\x54\xD6\x93\x8E\xDE\xD4\xE8\x72\x3D\x73\x07\xB1\x23\x31" \
           "\xE7\x57\xDA\x35\xA0\x02\x4B\x3B\x2F\x3E\xB4\xBB\x0D\xDE\xFD\x7E" \
           "\x53\xDA\xB8\xB7\x0E\x05\xF2\x24\x01\xED\xBF\x08\xB1\x90\xB7\xE5" \
           , 1024);
    memcpy(&bCryptBlockExp[2048], \
          "\xDC\x57\xF6\x07\x4D\xEB\xE1\x5A\x44\xC0\xDC\x13\x01\x0A\xBF\xD8" \
          "\x48\xFA\x53\x4C\x14\x93\x42\xE5\xCE\xAC\xDD\x18\x56\xE8\xA9\xD4" \
          "\x45\x2E\x59\xF9\x1B\x17\xF1\x80\x0D\x36\xB3\x31\x2B\x8C\x2C\x93" \
          "\x2F\xD6\x90\xAA\xA5\x92\x9D\x5F\x80\x6E\x25\xFC\xF1\xFC\xF6\x38" \
          "\xDD\x07\x11\x85\x81\x5D\x63\x7A\x7E\x4E\xC7\x90\xD5\x91\x61\x91" \
          "\xED\xB2\xC3\x34\x25\x7B\x06\xE7\x83\x15\xB1\xD3\x04\x4E\xE5\x84" \
          "\x28\x55\xE1\xB2\x40\x8A\x9A\x54\x38\x3A\x34\x68\xAE\xC3\x3D\xCA" \
          "\x9C\xEB\x7D\x09\xE3\xDC\x4B\x38\x85\x72\xC9\xE9\x32\x96\x38\x41" \
          "\xDD\x5F\x45\x3B\xB6\x49\xFE\x0B\x83\xD7\xC7\xA0\xC8\xAF\x8A\xE3" \
          "\x43\x7B\x71\xF3\x97\xEF\x90\x3E\x7E\x1C\xD4\x8B\xA2\x65\x23\x44" \
          "\xCC\x78\xC4\x83\x35\x09\x90\xB7\xA2\x1E\x76\x13\x23\x89\x24\x04" \
          "\x5F\xDE\x0B\x56\x7D\x8B\x42\x79\x4F\xB5\xC1\xFA\x78\x5D\xB2\x5B" \
          "\x0E\x10\x8B\x7D\x27\x47\x41\x2A\xDE\xFB\x5A\x92\x7D\xAE\xC3\xF4" \
          "\x82\xF9\xBA\xD2\x42\x6D\xD1\x90\xF9\x5A\xB3\x1E\x1E\x06\x24\xFE" \
          "\x3F\x8A\x22\xE9\x9D\xFB\x48\x56\x11\x42\x87\xEC\x93\x17\x8C\x80" \
          "\xC2\xBB\x4C\xDA\xDD\x30\x87\xD3\xA9\x52\x3C\x09\x71\xB0\x26\xBE" \
          "\xD6\xB1\xF7\x69\xF8\x42\x31\x31\xA3\x96\xAD\x4C\x53\x62\x21\xD0" \
          "\xC1\x3B\x3E\x78\x7D\x87\x51\x37\xD8\xD1\x57\xE5\xD7\x94\x97\xC8" \
          "\xB9\x8A\x63\xA7\x72\xE3\x9E\x36\x68\x23\xDB\x44\x61\x54\x6F\x13" \
          "\x9D\x93\x55\x68\xE7\x54\xE3\xD3\x96\xEF\x59\x35\x66\xD1\x41\x47" \
          "\x86\x86\x6B\x2F\xE7\x5F\x47\x8E\xB7\x42\x4B\x9F\x78\xA3\x6C\xEF" \
          "\xB6\x56\x27\x69\x20\x6C\x30\x98\x12\x7E\xCA\xCA\xB9\x66\xD0\xDB" \
          "\xAF\xA6\x1A\x11\xAA\xE5\xED\x6A\x26\x54\x43\x80\xF0\x81\x33\xAF" \
          "\x57\x7F\x7C\xD1\xB1\xE1\x90\xB5\xDA\x86\x61\x7B\x17\x48\x1D\xC8" \
          "\x95\xC5\xAB\x00\x3D\x18\x1C\xE5\x8E\x71\xBB\x03\x3A\x0E\x31\xBE" \
          "\xB7\xD0\x6F\xA0\x9D\xD0\xCC\x75\xEF\x13\x22\x4C\x0E\x5A\xFF\xB5" \
          "\x71\xE1\x48\x4C\x9C\x89\xF2\x65\x65\x3B\x3E\xAD\x2C\x1D\x38\x97" \
          "\x62\x6D\xDB\x26\x93\x97\x8A\x53\xAA\x68\x1E\x6E\x5F\x52\x42\xEB" \
          "\xE0\xCB\xEE\xC8\xD0\xAF\x21\x16\x21\x1E\xB3\x62\x20\x4E\xFA\xF2" \
          "\x77\x17\x6A\x15\x64\x4A\xC6\xBF\xB2\x3F\x56\xFD\xAA\x63\x47\xC0" \
          "\x3D\x6A\x65\x64\xCE\x28\x9C\x99\x82\x0A\xB7\x78\xCB\x67\x1E\x34" \
          "\x02\x27\x12\x61\x10\xBB\x5F\xEF\x86\x8D\x9D\x07\x83\xBA\xCA\x0F" \
          "\x83\x1F\xD0\xFB\x38\x61\x2B\x29\xBD\x5F\x8C\xF9\xEE\x5C\x2D\x34" \
          "\xFB\xCB\x2E\xE6\xE9\xF3\x47\xD1\x19\x29\xDC\xF3\x5E\xAF\x48\x52" \
          "\x7B\xF3\x24\x09\x40\x75\x65\x76\x25\x51\x0B\xFF\x83\xC3\xC8\x99" \
          "\xF6\xF0\xE6\xC0\xD4\x09\xD0\x23\xC2\x20\x21\xBA\x70\x49\x56\x66" \
          "\x7B\xA8\x5E\xB3\x0D\xF8\xCE\x89\xF7\xF1\x65\x02\xF7\xA7\x48\x7B" \
          "\xE8\x76\x70\xD3\x96\xB5\xB3\x35\x81\xB1\xE5\x2B\x19\xA2\x06\xB3" \
          "\xEE\xD2\x41\x23\x49\x4C\x39\xEB\x12\x74\x03\x76\xAC\x27\xA2\x6F" \
          "\x4C\xFB\x47\x8F\x4B\x86\x88\x1F\x80\x4B\x19\x66\xC1\x8F\xD4\xEB" \
          "\x44\x85\x66\x87\x8F\xB6\xC3\x41\xB1\x97\xA9\x3E\xA5\x4F\x56\xB3" \
          "\x82\x81\xB8\x15\x67\xFF\x40\xFF\xAB\x60\x9F\x16\x42\x7E\x81\x27" \
          "\x1E\xE9\x06\xCC\x4F\xC6\x1C\x9C\xA6\xF3\xC9\x5D\x1A\x6C\x1A\xFF" \
          "\xC1\x21\x55\xFD\x6E\x7E\x75\x87\x9B\x43\x51\xD1\xF9\x38\x45\x19" \
          "\xDB\xBA\xA6\x87\xC2\xBF\x07\x63\x08\xC8\x64\x8B\xA1\x0B\x59\xC4" \
          "\x6B\xBD\x60\x79\x68\xD8\xBD\x3C\xC2\xF9\x31\x5E\x43\x01\x49\xA6" \
          "\x0E\x5E\xE5\xF9\xEA\xEF\xE9\xCF\x60\xD6\xDA\x8E\x86\xA0\x86\x2E" \
          "\xF8\xE2\xFB\xCA\x1C\xE1\x43\x2E\xE0\xE2\xB8\xB8\x86\xD6\xF0\x82" \
          "\x88\x16\x66\x1C\x3B\x1C\xB0\xEB\x14\x5B\x8A\x1D\xD4\xB7\x7F\xA2" \
          "\x8A\xFD\x03\x1D\x14\x93\x12\xCA\xC3\x88\xDC\x70\x16\x84\xCE\x54" \
          "\x54\x8D\x16\x5A\x37\x06\xDF\x9B\x00\x1C\x79\xFE\x95\x10\x44\xC8" \
          "\xF0\x27\x27\x91\x7C\x64\x15\x1C\x44\x28\xFB\x87\xAE\xA7\x80\xAB" \
          "\x37\x1D\x03\xFC\xF4\x63\xA5\x1D\x3A\x52\x0C\x78\x18\xEB\x8B\x87" \
          "\xDF\x51\xCE\x73\x46\xC7\xAD\xC1\x57\xDB\x75\x64\x1A\x58\x9C\x18" \
          "\x18\xF0\x75\x06\x64\xA7\x64\x42\x4A\x4B\x11\x4C\x15\x5F\x64\xF1" \
          "\xD8\x9B\xD9\xA1\x3E\x97\x40\xE1\x4E\xE8\x2C\x04\xF7\x72\x05\x93" \
          "\x25\xDF\x7A\x96\xFA\xC9\x50\x08\xE0\x72\xF4\xFE\xB0\xE2\x28\xC1" \
          "\x81\x53\xAE\xDE\xFD\x7C\xF9\xD2\xE6\xC3\x74\x0B\xF1\x05\x62\x29" \
          "\x21\x33\x1C\x99\x05\xC5\xCF\xBD\xCA\x18\xD0\x35\x0B\x6E\x9E\xDF" \
          "\x63\x3E\xA6\x2E\xCF\x58\x5B\x66\xD3\xCD\x88\x25\xB7\xC2\x13\x63" \
          "\x1D\x06\x2D\xEE\x9C\x41\x4E\xB2\x9D\xE0\x48\x63\xD5\x26\x18\x79" \
          "\x47\xEB\x2D\xB4\x92\xB8\x1A\x3E\x3B\x7A\x96\x04\x2D\xC4\xEA\xE5" \
          "\xEC\xE9\x5D\xCE\xF8\xC8\x62\x63\x11\x5B\xB8\x81\xAB\x51\x7A\xD4" \
          "\x86\xD6\xFC\x51\xE2\x7D\x87\x81\xDC\x9E\x71\x65\xF2\xA8\x65\x7F" \
          , 1024);
    memcpy(&bCryptBlockExp[3072], \
          "\x66\x71\x83\x72\x51\x40\x24\x06\x3B\x71\xC6\xB4\x00\xA3\xD4\x32" \
          "\xD8\x10\x90\xB7\x80\x31\x43\x9E\xC7\x34\x2F\xC7\x02\x8A\x64\xB0" \
          "\x2C\xC5\x1D\xA6\x9F\x5D\xE2\x80\x0C\x44\xF5\x16\x6D\xE9\x78\x80" \
          "\x5F\x5D\x96\xF7\x44\xD1\xD4\x08\x6C\xC5\x9F\x64\x7D\x67\xC1\xA9" \
          "\x23\x22\x20\xBE\xDC\x80\x73\x37\x7B\xE1\xB9\x82\x7A\x08\x9D\x15" \
          "\x31\x2F\x6C\x0B\xAF\xBC\x88\xAC\xC9\x0E\x02\xA9\xDD\xD2\x06\x23" \
          "\x01\xAD\x18\xE9\x61\x0C\x3B\x9D\xED\x5D\x84\xFD\x6B\x5C\x96\xB4" \
          "\x00\xEF\xF4\x34\xC7\x4E\x3F\xC6\xD7\x57\xC4\x37\xC4\xB4\x7C\x77" \
          "\x66\xA3\x0C\x17\x7E\x57\xE8\x91\x84\x26\x8C\x7B\x7F\xFF\x8A\xFC" \
          "\xA4\x3F\x82\x6F\x25\xD7\x9C\x4B\x7D\x10\x35\xA4\xC2\x43\x38\x29" \
          "\xDE\x7F\x48\x0E\x21\xF7\x47\x5D\x3F\x34\x64\xB2\x14\xA2\x8A\x38" \
          "\xC0\xAA\xB4\xBE\xE6\x2B\x84\xBD\xDC\x71\x69\xDE\xCC\xFF\xB3\x8D" \
          "\x73\x57\x16\x62\xB5\x54\x1E\xA2\x1F\x25\xC2\xE5\x76\x5A\x62\x68" \
          "\x90\x38\x52\x38\xB7\x45\x6E\x03\xA2\xFD\x57\x04\x33\x1F\xE9\x49" \
          "\x2F\x6A\x63\xE6\x51\x26\x30\x48\x98\x67\xEC\x03\x1E\x01\xDB\xAC" \
          "\x12\xF1\x5F\x22\xC8\xF3\x83\x90\xDD\x4E\xEC\xFB\x8F\x3A\x36\xB2" \
          "\xAC\x0C\xA7\x40\xD0\x8D\x26\xDD\xC9\x74\xFA\xA0\x76\xE6\x8B\x38" \
          "\x6E\x88\xD6\xEA\xAF\x34\x1F\x35\x79\xE2\xDC\xA8\x21\x7F\x2B\xE5" \
          "\x8A\x11\xF1\xE4\x4B\xF4\xAE\xD0\x76\x0A\x76\x8C\x79\xBD\x1B\x71" \
          "\xF0\x09\x3A\x17\xE3\xCF\x7F\xDA\xC0\xC2\x87\x5A\x15\x13\xB6\x29" \
          "\x2B\x80\xE4\x1E\xA7\x96\x6F\x64\x03\xA0\x96\x1A\x9B\xE8\xFB\xE8" \
          "\xB8\xBA\xCC\x49\x3C\x93\x7A\x97\xD9\x6A\x06\xB4\xDF\x25\x40\x11" \
          "\x1D\xBB\x1B\xDA\x21\x5E\xBC\x03\xF1\x74\x59\x3F\x73\x9F\x2D\xB1" \
          "\x77\xA2\xF7\xF2\xFC\xE3\x3B\xFD\x42\x28\x6C\xDF\x30\xAE\x96\xB6" \
          "\x8E\xCC\x91\x40\xE5\x0D\xAA\x36\x82\xFC\x9A\xE5\x8F\xBB\xF6\x73" \
          "\x5E\xE6\x7B\xA7\xD1\x32\xDC\x29\x95\xD9\x17\x10\x58\x09\x7A\x99" \
          "\xBB\x64\x45\x46\xA7\x1B\xA3\x99\xDF\x54\xA0\x0B\x35\x35\x7F\x38" \
          "\x16\xDB\x0A\xBE\xB8\x24\x68\x65\x5A\xF6\x64\xB3\x86\xE1\x8F\x86" \
          "\xDD\x8F\xB5\xE1\xB5\x9C\xDD\x1F\x5E\x31\x63\xB2\x6F\x8E\x6D\x94" \
          "\x5A\x73\xC9\x3E\x13\x5E\x66\xE7\xD1\x97\x88\xF1\xB2\x0D\xAF\x17" \
          "\x55\xE8\x8B\x0C\x0E\x9A\x2D\xD2\x4E\x37\x35\x8E\x58\x7E\xF6\xA3" \
          "\x69\x10\xC5\xD3\x2D\x69\x82\x30\x01\xA7\x0C\xA9\x2B\xDC\xD7\x97" \
          "\x5E\x5E\x9D\xAF\x40\x59\x79\x49\x19\x1C\x6D\x89\x85\x5D\x75\xFB" \
          "\xB4\x6A\x2A\x3F\x58\x17\xA2\xC5\xEF\xBB\x35\xB2\x12\xAE\x66\x96" \
          "\x1D\x16\x8B\xE6\xE8\x3F\xFF\xB2\x31\xEB\x62\xAF\xD2\xF3\x96\x34" \
          "\x0E\x3F\xAE\x23\xA4\xDD\x13\xF1\x79\x88\x60\xAC\x07\x44\xEF\x0D" \
          "\x64\x76\x0E\x21\xF6\x5C\x00\xCA\xC3\xAB\xF7\xAD\xC3\xA5\x9A\x33" \
          "\x6A\xBA\x92\x83\x97\x48\xA0\x67\xB0\x80\x5D\xFE\x89\xB6\x6C\x7A" \
          "\x48\x95\x4F\xAA\x4A\xAF\xC2\x0F\xFD\x75\x1E\xAE\xB1\x55\xDF\xA1" \
          "\xA9\x8F\x96\x51\x98\x13\x2D\xB0\x3B\x70\x11\xCC\xBD\xC0\xCF\x62" \
          "\xDA\x98\x72\xB2\x58\x52\x14\xFE\x6F\x69\x21\x60\x12\x4C\xFB\xB4" \
          "\x16\x36\xC7\xBC\xEA\x0D\xE6\x57\xA0\xD0\x66\x3A\xE7\x12\x14\xB3" \
          "\xCE\x27\x2B\x35\x15\x6B\x64\x23\x71\x0E\x2C\xB5\x4C\x7D\x20\x34" \
          "\x15\xA3\x65\xBC\x35\xCE\xFD\xCC\xF4\x0E\x41\x50\x83\x93\x34\x96" \
          "\x83\xA2\x6A\xB6\xD9\xF0\xE7\x2F\x14\xB4\x71\x5D\x2D\xCD\xD0\xB1" \
          "\x80\x30\x1E\x33\xAA\x29\x5D\x02\x32\x74\x4D\xEB\xC6\x52\xD6\xDE" \
          "\xA3\x12\x45\xE3\x7B\x0C\x9D\xF3\xFB\x57\x26\x77\x87\x54\x9E\xE2" \
          "\x72\xD7\xF0\xCC\xBF\x1E\x00\xDA\x74\xB3\x23\x0C\xE4\x05\xF6\x49" \
          "\x36\x19\xBF\x17\x2E\xCC\xB4\x60\x0C\xD4\xC9\x6A\x58\x16\xB3\xAD" \
          "\x68\x51\x78\xBB\x9A\x12\x73\xA8\xE7\x5E\x8E\xD8\x59\xE0\x31\x17" \
          "\x87\x08\x1A\x7F\x34\x20\x4A\xAB\x64\xEF\x8E\x7D\xD2\x96\xF7\x04" \
          "\x4D\x12\x7F\x2F\x09\x38\x92\x79\x2D\x28\x7D\xF7\x0F\x95\x6A\x53" \
          "\xD6\xDE\x52\x31\x57\x31\x6B\xC9\xE9\xE5\x9F\x89\xDA\x2F\x15\x26" \
          "\x80\x56\xE0\x66\x5C\x88\xCE\x80\xBF\x99\x79\xF3\xCC\x2E\xC4\xAC" \
          "\x11\xE6\x47\x39\x44\x38\xBA\x20\x04\xFF\x08\xB8\x33\xC2\x84\xB6" \
          "\xA3\x5D\x2E\xE6\x06\x8C\xBB\x87\xE7\x57\x07\x95\x99\x65\x2E\x94" \
          "\x97\x49\xC0\x42\x34\xAC\x86\x95\xF2\x02\x1D\xB1\x10\x4E\xDD\x0A" \
          "\x86\x10\x27\xC4\xF3\xA6\x9E\x24\xA1\xE1\xC5\x71\x37\x3E\xF9\x30" \
          "\x63\xD8\x0E\x36\xBC\xB4\x78\x8F\x23\x00\x45\xA0\x58\xC2\x26\x38" \
          "\x22\xCB\x5C\xBC\x32\x6A\xF1\xD8\xAF\x40\xD5\x34\xFE\x45\x14\xAC" \
          "\xD4\x52\xFC\x42\xF2\x90\x22\xAB\x4F\x55\x73\x13\x74\x34\xFE\xE3" \
          "\x24\x49\x65\x32\x91\xF4\xA0\xB9\x09\xBC\x2C\x9E\x48\x98\xB9\x8A" \
          "\x2B\xC5\x0F\xB6\x50\x0A\x01\xF7\x15\xEB\x87\x3B\x39\x91\xF0\xED" \
          "\x17\xA1\xE8\x17\x1F\xAF\x46\x9F\x4F\xC1\x46\xEE\x62\x76\xF7\xD2" \
          , 1024);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 24);
    DspHex("[IN ]bPlainBlock    =", bPlainBlock, 4096);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    DspHex("[IN ]bIV            =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptCBC(nSock, nAlgo, bKey, bPlainBlock, \
                             nBlockLen, bIV, bCryptBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "算法类型=3，数据长度=4096，空数据测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptBlock    =", bCryptBlock, 4096);
    DspHex("[OUT]bCryptBlockExp =", bCryptBlockExp, 4096);
    ASSERT_OUT_HEX(bCryptBlock, bCryptBlockExp, 4096);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptCBC_Test_08(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bPlainBlock[4104];
    int  nBlockLen;
    BYTE bCryptBlock[4104];
    BYTE bIV[16];
    BYTE bCryptBlockExp[4104];

    bufclr(bKey);
    bufclr(bPlainBlock);
    bufclr(bCryptBlock);
    bufclr(bIV);
    bufclr(bCryptBlockExp);

    nSock = -1;
    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memcpy(bPlainBlock, "\x01\x23\x45\x67\x89\xAB\xCD\xEF", 8);
    nBlockLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bPlainBlock    =", bPlainBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    DspHex("[IN ]bIV            =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptCBC(nSock, nAlgo, bKey, bPlainBlock, \
                             nBlockLen, bIV, bCryptBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void EncryptCBC_Test_09(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bPlainBlock[4104];
    int  nBlockLen;
    BYTE bCryptBlock[4104];
    BYTE bIV[16];
    BYTE bCryptBlockExp[4104];

    bufclr(bKey);
    bufclr(bPlainBlock);
    bufclr(bCryptBlock);
    bufclr(bIV);
    bufclr(bCryptBlockExp);

    nSock = 8;
    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memcpy(bPlainBlock, "\x01\x23\x45\x67\x89\xAB\xCD\xEF", 8);
    nBlockLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bPlainBlock    =", bPlainBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    DspHex("[IN ]bIV            =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptCBC(nSock, nAlgo, bKey, bPlainBlock, \
                             nBlockLen, bIV, bCryptBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[8]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void EncryptCBC_Test_10(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bPlainBlock[4104];
    int  nBlockLen;
    BYTE bCryptBlock[4104];
    BYTE bIV[16];
    BYTE bCryptBlockExp[4104];

    bufclr(bKey);
    bufclr(bPlainBlock);
    bufclr(bCryptBlock);
    bufclr(bIV);
    bufclr(bCryptBlockExp);

    nAlgo = 0;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memcpy(bPlainBlock, "\x01\x23\x45\x67\x89\xAB\xCD\xEF", 8);
    nBlockLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bPlainBlock    =", bPlainBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    DspHex("[IN ]bIV            =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptCBC(nSock, nAlgo, bKey, bPlainBlock, \
                             nBlockLen, bIV, bCryptBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效算法类型[0]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptCBC_Test_11(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bPlainBlock[4104];
    int  nBlockLen;
    BYTE bCryptBlock[4104];
    BYTE bIV[16];
    BYTE bCryptBlockExp[4104];

    bufclr(bKey);
    bufclr(bPlainBlock);
    bufclr(bCryptBlock);
    bufclr(bIV);
    bufclr(bCryptBlockExp);

    nAlgo = 4;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memcpy(bPlainBlock, "\x01\x23\x45\x67\x89\xAB\xCD\xEF", 8);
    nBlockLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bPlainBlock    =", bPlainBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    DspHex("[IN ]bIV            =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptCBC(nSock, nAlgo, bKey, bPlainBlock, \
                             nBlockLen, bIV, bCryptBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效算法类型[4]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptCBC_Test_12(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bPlainBlock[4104];
    int  nBlockLen;
    BYTE bCryptBlock[4104];
    BYTE bIV[16];
    BYTE bCryptBlockExp[4104];

    bufclr(bKey);
    bufclr(bPlainBlock);
    bufclr(bCryptBlock);
    bufclr(bIV);
    bufclr(bCryptBlockExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    nBlockLen = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bPlainBlock    =", bPlainBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    DspHex("[IN ]bIV            =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptCBC(nSock, nAlgo, bKey, bPlainBlock, \
                             nBlockLen, bIV, bCryptBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效数据长度=0测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptCBC_Test_13(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bPlainBlock[4104];
    int  nBlockLen;
    BYTE bCryptBlock[4104];
    BYTE bIV[16];
    BYTE bCryptBlockExp[4104];

    bufclr(bKey);
    bufclr(bPlainBlock);
    bufclr(bCryptBlock);
    bufclr(bIV);
    bufclr(bCryptBlockExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memcpy(bPlainBlock, "\x01\x23\x45\x67\x89\xAB\xCD", 7);
    nBlockLen = 7;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bPlainBlock    =", bPlainBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    DspHex("[IN ]bIV            =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptCBC(nSock, nAlgo, bKey, bPlainBlock, \
                             nBlockLen, bIV, bCryptBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效数据长度=7测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptCBC_Test_14(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bPlainBlock[4104];
    int  nBlockLen;
    BYTE bCryptBlock[4104];
    BYTE bIV[16];
    BYTE bCryptBlockExp[4104];

    bufclr(bKey);
    bufclr(bPlainBlock);
    bufclr(bCryptBlock);
    bufclr(bIV);
    bufclr(bCryptBlockExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memset(bPlainBlock, 0x5C, 4097);
    bPlainBlock[0] = 0x25;
    bPlainBlock[4096] = 0x22;
    nBlockLen = 4097;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bPlainBlock    =", bPlainBlock, 4097);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    DspHex("[IN ]bIV            =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptCBC(nSock, nAlgo, bKey, bPlainBlock, \
                             nBlockLen, bIV, bCryptBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效数据长度=4097测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptCBC_Test_15(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bPlainBlock[4104];
    int  nBlockLen;
    BYTE bCryptBlock[4104];
    BYTE bIV[16];
    BYTE bCryptBlockExp[4104];

    bufclr(bKey);
    bufclr(bPlainBlock);
    bufclr(bCryptBlock);
    bufclr(bIV);
    bufclr(bCryptBlockExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memset(bPlainBlock, 0x5C, 4104);
    bPlainBlock[0] = 0x25;
    bPlainBlock[4103] = 0x22;
    nBlockLen = 4104;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bPlainBlock    =", bPlainBlock, 4104);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    DspHex("[IN ]bIV            =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptCBC(nSock, nAlgo, bKey, bPlainBlock, \
                             nBlockLen, bIV, bCryptBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效数据长度=4104测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptCBC_Test_16(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bPlainBlock[4104];
    int  nBlockLen;
    BYTE bCryptBlock[4104];
    BYTE bIV[16];
    BYTE bCryptBlockExp[4104];

    bufclr(bKey);
    bufclr(bPlainBlock);
    bufclr(bCryptBlock);
    bufclr(bIV);
    bufclr(bCryptBlockExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    /* 0123 4567 89AB CDEF */
    memcpy(bPlainBlock, "\x01\x23\x45\x67\x89\xAB\xCD\xEF", 8);
    nBlockLen = 8;
    memcpy(bIV, "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF", 8);
    memcpy(bCryptBlockExp, "\x12\xC6\x26\xAF\x05\x8B\x43\x3B", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bPlainBlock    =", bPlainBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    DspHex("[IN ]bIV            =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptCBC(nSock, nAlgo, bKey, bPlainBlock, \
                             nBlockLen, bIV, bCryptBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "算法类型=1，数据长度=8，初始向量=FF，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptBlock    =", bCryptBlock, 8);
    DspHex("[OUT]bCryptBlockExp =", bCryptBlockExp, 8);
    ASSERT_OUT_HEX(bCryptBlock, bCryptBlockExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptCBC_Test_17(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bPlainBlock[4104];
    int  nBlockLen;
    BYTE bCryptBlock[4104];
    BYTE bIV[16];
    BYTE bCryptBlockExp[4104];

    bufclr(bKey);
    bufclr(bPlainBlock);
    bufclr(bCryptBlock);
    bufclr(bIV);
    bufclr(bCryptBlockExp);

    nAlgo = 2;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
                 16);
    /* 0123 4567 89AB CDEF */
    memcpy(bPlainBlock, "\x01\x23\x45\x67\x89\xAB\xCD\xEF", 8);
    nBlockLen = 8;
    memcpy(bIV, "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF", 8);
    memcpy(bCryptBlockExp, "\x1F\xD1\xB0\x2B\x23\x7A\xF9\xAE", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 16);
    DspHex("[IN ]bPlainBlock    =", bPlainBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    DspHex("[IN ]bIV            =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptCBC(nSock, nAlgo, bKey, bPlainBlock, \
                             nBlockLen, bIV, bCryptBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "算法类型=2，数据长度=8，初始向量=FF，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptBlock    =", bCryptBlock, 8);
    DspHex("[OUT]bCryptBlockExp =", bCryptBlockExp, 8);
    ASSERT_OUT_HEX(bCryptBlock, bCryptBlockExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptCBC_Test_18(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bPlainBlock[4104];
    int  nBlockLen;
    BYTE bCryptBlock[4104];
    BYTE bIV[16];
    BYTE bCryptBlockExp[4104];

    bufclr(bKey);
    bufclr(bPlainBlock);
    bufclr(bCryptBlock);
    bufclr(bIV);
    bufclr(bCryptBlockExp);

    nAlgo = 3;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8697 A4B5 C2D3 E0F1 */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\x59\x99\xC3\x06\xAB\x84\x01\xB2",\
                 24);
    /* 0123 4567 89AB CDEF */
    memcpy(bPlainBlock, "\x01\x23\x45\x67\x89\xAB\xCD\xEF", 8);
    nBlockLen = 8;
    memcpy(bIV, "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF", 8);
    memcpy(bCryptBlockExp, "\x90\x26\x84\x9C\xA0\x1B\x4B\x05", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 24);
    DspHex("[IN ]bPlainBlock    =", bPlainBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    DspHex("[IN ]bIV            =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptCBC(nSock, nAlgo, bKey, bPlainBlock, \
                             nBlockLen, bIV, bCryptBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "算法类型=3，数据长度=8，初始向量=FF，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bCryptBlock    =", bCryptBlock, 8);
    DspHex("[OUT]bCryptBlockExp =", bCryptBlockExp, 8);
    ASSERT_OUT_HEX(bCryptBlock, bCryptBlockExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptCBC_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bCryptBlock[4104];
    int  nBlockLen;
    BYTE bPlainBlock[4104];
    BYTE bIV[16];
    BYTE bPlainBlockExp[4104];

    bufclr(bKey);
    bufclr(bCryptBlock);
    bufclr(bPlainBlock);
    bufclr(bIV);
    bufclr(bPlainBlockExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    /* 0123 4567 89AB CDEF */
    memcpy(bCryptBlock, "\x56\xCC\x09\xE7\xCF\xDC\x4C\xEF", 8);
    nBlockLen = 8;
    memcpy(bPlainBlockExp, "\x01\x23\x45\x67\x89\xAB\xCD\xEF", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bCryptBlock    =", bCryptBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    DspHex("[IN ]bIV            =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptCBC(nSock, nAlgo, bKey, bCryptBlock, \
                             nBlockLen, bIV, bPlainBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "算法类型=1，数据长度=8，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bPlainBlock    =", bPlainBlock, 8);
    DspHex("[OUT]bPlainBlockExp =", bPlainBlockExp, 8);
    ASSERT_OUT_HEX(bPlainBlock, bPlainBlockExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptCBC_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bCryptBlock[4104];
    int  nBlockLen;
    BYTE bPlainBlock[4104];
    BYTE bIV[16];
    BYTE bPlainBlockExp[4104];

    bufclr(bKey);
    bufclr(bCryptBlock);
    bufclr(bPlainBlock);
    bufclr(bIV);
    bufclr(bPlainBlockExp);

    nAlgo = 2;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
                 16);
    /* 0123 4567 89AB CDEF */
    memcpy(bCryptBlock, "\x1A\x4D\x67\x2D\xCA\x6C\xB3\x35", 8);
    nBlockLen = 8;
    memcpy(bPlainBlockExp, "\x01\x23\x45\x67\x89\xAB\xCD\xEF", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 16);
    DspHex("[IN ]bCryptBlock    =", bCryptBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    DspHex("[IN ]bIV            =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptCBC(nSock, nAlgo, bKey, bCryptBlock, \
                             nBlockLen, bIV, bPlainBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "算法类型=2，数据长度=8，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bPlainBlock    =", bPlainBlock, 8);
    DspHex("[OUT]bPlainBlockExp =", bPlainBlockExp, 8);
    ASSERT_OUT_HEX(bPlainBlock, bPlainBlockExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptCBC_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bCryptBlock[4104];
    int  nBlockLen;
    BYTE bPlainBlock[4104];
    BYTE bIV[16];
    BYTE bPlainBlockExp[4104];

    bufclr(bKey);
    bufclr(bCryptBlock);
    bufclr(bPlainBlock);
    bufclr(bIV);
    bufclr(bPlainBlockExp);

    nAlgo = 3;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8697 A4B5 C2D3 E0F1 */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\x59\x99\xC3\x06\xAB\x84\x01\xB2",\
                 24);
    /* 0123 4567 89AB CDEF */
    memcpy(bCryptBlock, "\xB1\xBD\x7B\x27\x8E\xA6\x2F\xCD", 8);
    nBlockLen = 8;
    memcpy(bPlainBlockExp, "\x01\x23\x45\x67\x89\xAB\xCD\xEF", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 24);
    DspHex("[IN ]bCryptBlock    =", bCryptBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    DspHex("[IN ]bIV            =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptCBC(nSock, nAlgo, bKey, bCryptBlock, \
                             nBlockLen, bIV, bPlainBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "算法类型=3，数据长度=8，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bPlainBlock    =", bPlainBlock, 8);
    DspHex("[OUT]bPlainBlockExp =", bPlainBlockExp, 8);
    ASSERT_OUT_HEX(bPlainBlock, bPlainBlockExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptCBC_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bCryptBlock[4104];
    int  nBlockLen;
    BYTE bPlainBlock[4104];
    BYTE bIV[16];
    BYTE bPlainBlockExp[4104];

    bufclr(bKey);
    bufclr(bCryptBlock);
    bufclr(bPlainBlock);
    bufclr(bIV);
    bufclr(bPlainBlockExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memcpy(bCryptBlock, \
          "\x6E\x0F\x4E\x43\xFF\xCB\x0C\x0A\x23\x1E\x80\xF8\x9F\x2D\x3F\xAB" \
          "\x0E\x65\x6B\x21\x7B\x19\xB9\x15\x36\xAE\x40\x24\x15\x8E\xC4\xE5" \
          "\xAB\xBD\x93\xBF\xA8\x58\x5A\x36\x7D\x9E\x3E\xE0\xEB\x3A\x3E\x6F" \
          "\xE1\x09\x2B\xD2\x90\x15\xC3\x33\x2D\x74\x31\x46\xC0\x10\x0B\x20" \
          "\xBD\x05\xFF\xBE\xF6\xB7\x42\x21\xC1\xA9\x8E\x05\x4E\x9C\x3C\x05" \
          "\x38\xB0\x0F\xFA\xDB\xC8\x0E\xEB\x17\xCF\x9C\x46\xE1\x02\xC6\xD0" \
          "\xAF\xA6\xE1\x29\x0A\x96\xD3\x4B\x4F\x44\x45\x47\x59\x7C\xF6\xAD" \
          "\xB4\xEA\x14\x0E\xA6\x66\xA4\x9D\x9C\xA8\xEC\x24\xB8\x06\x61\x72" \
          "\xF3\x51\x21\x3E\x68\xD0\x0F\xDD\x70\xE0\x50\xEE\x8B\x8A\xE8\x3F" \
          "\xFB\x5C\x08\xB9\xCA\x40\xD7\xD0\xE0\xEB\xC8\xB0\x53\x30\xA7\xC7" \
          "\x1A\x0A\x08\xC6\x9C\x3F\x22\xD5\xFA\x3F\x98\x77\x52\xD4\xFB\xE0" \
          "\xAF\x2E\xB2\xE2\x09\x10\xBD\xFC\x14\x8E\x8A\xE9\x64\x43\x54\xE2" \
          "\x40\xF3\x37\xE1\xD0\x5B\xA8\x26\x48\xC2\x21\x5F\x83\xF8\x2A\xA3" \
          "\xE8\xEF\xC6\x4F\x04\x2A\x4D\x59\x8D\x3A\x5A\xB9\xF7\xA4\xFA\x39" \
          "\xF0\xDE\xB0\x49\x85\x1C\x28\x92\xAD\xF3\xA5\x3C\x6A\xE5\x21\x6C" \
          "\x17\x7A\x8D\xC7\x00\x34\x6D\x91\x51\x73\xE8\xE7\x93\x11\x74\x6F" \
          "\x04\xAE\x41\x71\x94\xFA\xB7\x5E\xAD\x31\x42\xE4\x5F\x4E\x0E\xE6" \
          "\x1A\x4C\x07\xF5\xCD\x5D\xDC\xCF\x28\x7B\xB7\x87\x1E\x38\x48\x2D" \
          "\xBE\x59\x3C\xA1\x5C\x86\x78\x08\xFD\x6A\x16\x16\x00\xC2\xDE\xDF" \
          "\x62\x89\x90\x67\x80\xA6\xB3\xA3\xD3\x68\x1E\xAA\x2A\xAA\xDD\xCA" \
          "\xFB\x8D\x49\xFA\x0A\x63\xC9\xBD\x3E\x22\x89\x11\xA6\xB8\x91\x36" \
          "\x3B\x9E\xAD\x38\x61\xC4\x39\x0D\xA7\x0E\xA7\x23\x0E\x4E\xE2\x10" \
          "\xD0\x89\xF0\x18\x08\xAB\x89\x9B\x63\x46\xC5\xA3\x58\x74\xF7\xC5" \
          "\xF2\x82\xBE\xC8\x77\x97\xBC\x11\x9A\x78\x66\x18\x52\x7C\xD9\x5B" \
          "\x63\x91\x74\x64\x85\x7D\xEE\x11\xA8\x43\x0B\x1B\xD2\x81\xD8\xD7" \
          "\x8C\x88\x39\xEB\xA0\x67\x1E\xE0\xB9\xEA\x7D\xCB\x6D\x92\x40\x0B" \
          "\x64\x1D\x14\xAD\xF3\x85\xF6\x86\x1D\xAF\x2D\x27\x18\x4B\xFA\x20" \
          "\x09\x5C\xEA\xFE\x7B\xC3\x0B\xDB\xFB\x60\x4D\x30\xB9\x9D\xDF\x0F" \
          "\xFA\x8F\x89\xEA\x21\x4F\x84\xCF\xE0\x20\xAF\x71\x02\xE9\xB5\xD9" \
          "\xBD\x36\x39\x38\x62\x82\x25\x5A\x8B\xA1\x54\xD4\x1B\x55\xA3\x51" \
          "\x7E\xA2\x87\xFC\x99\xC2\x82\xAC\xDE\x55\x30\x43\x68\xC1\xA4\xEB" \
          "\xEA\xFA\x12\xA4\xCB\xC2\xA2\x93\xC4\x41\x93\x0B\x25\xFB\x6F\x94" \
          "\x17\xA9\x31\xB3\xAE\x33\x5A\xB3\x17\xC6\x1E\x12\xFF\x02\xF8\x10" \
          "\x21\xEF\xB6\x65\xD8\xF2\x6E\xF9\xB6\xD0\x0A\xC8\x8B\x05\x83\xCB" \
          "\xFE\xE7\xB6\x8D\xBD\x0F\x6C\x7A\xD0\x60\x8B\xCD\xF4\x3A\x82\xDA" \
          "\x7B\x0F\x1D\x81\xBB\x02\x8D\x83\x49\xC1\x3D\x8C\x52\x16\x82\x22" \
          "\xBF\x54\x76\xFF\xE0\xB6\x70\xCA\x35\x2C\x65\x98\x9A\x77\x6A\x56" \
          "\xEA\xAC\xC5\x30\xD8\xA2\x4A\x0D\x1E\xAB\xB1\x19\xB4\x32\x8B\x86" \
          "\x46\x4A\x94\x0D\xBA\xBF\xD8\xEF\x67\xFF\x6B\x19\x7C\x6D\xF5\x3B" \
          "\xAA\x8A\x14\xDB\x84\x0E\x32\x7F\x5F\xD6\x5C\x3A\xA0\x21\x8A\x58" \
          "\xE4\x01\x2D\x6F\x61\x83\xEA\x36\x1E\xAC\xE0\x03\xEF\xB5\x87\xEF" \
          "\x05\xEE\x4A\x00\xF3\xFF\xDF\x88\xA0\xA5\xC2\xBD\x85\x2C\x37\xB5" \
          "\x21\x4A\x88\xB3\xC6\x36\x26\x45\x46\x06\x3C\xB5\x93\x3B\xBC\x6C" \
          "\x49\xAB\xC2\x77\xD5\x9A\x73\x48\x3B\xDA\xC5\x56\x9B\x4E\x42\xB6" \
          "\x24\x49\x12\xFD\x76\x76\x82\x29\xBB\x72\xDF\xF7\xD2\x53\x7B\xA6" \
          "\x88\x1C\xB6\x7A\x23\x5C\x50\xBC\x50\x13\xDC\xBA\x8F\x13\x79\x52" \
          "\x42\x6F\xBF\x25\x9E\xE7\xC4\x97\x57\xA7\x6F\xAF\x09\xC4\x41\x43" \
          "\xFF\xE6\x33\x9D\xAC\xFF\x39\xD0\xC3\xA9\xAD\x2C\xCC\x68\xAF\x01" \
          "\x2A\x52\xDA\x06\xC3\xA9\xB2\xF7\x10\x93\xA9\x87\xD6\x4E\x66\xA9" \
          "\x62\x5A\x35\xD0\x5B\xD9\x46\xCB\x7A\xD9\x75\xB4\xA0\xCE\x77\x80" \
          "\x9E\x97\xC9\x92\xB6\x74\xB6\xA4\xC9\xD9\x2B\xEB\xF7\x6A\x27\xEA" \
          "\x76\x1F\xC9\x02\xCB\x17\x33\x11\x13\x5C\x6B\x98\x49\xAF\x07\x18" \
          "\x5A\x7B\x57\xB9\x01\xC1\xE8\x73\x40\x13\xC3\x24\x85\x31\x7F\xCE" \
          "\x96\xC9\x16\x19\x7D\xBA\xFD\x93\x84\xE3\xED\x70\x0E\x8E\x45\xA4" \
          "\x7F\xC4\x80\xF1\xEA\xCF\x53\x32\x7C\xC1\x63\xC4\xC0\x85\x77\x6A" \
          "\xF6\xE6\xEF\x40\xFD\x2B\xB3\xC2\x0C\x5A\xB8\x37\x4A\x09\x68\x0B" \
          "\xF2\x73\x3B\x6F\xAC\x71\xB3\xA9\x0F\x92\xDE\xFC\x1E\x9E\x48\x34" \
          "\xE4\x61\x71\x9E\x16\x14\xEC\x1F\xE5\x9C\x44\xBF\x13\x93\x12\x75" \
          "\xFF\x0E\x58\x86\x65\x29\xA1\xCC\xBC\x48\x26\x5C\xB6\x1C\x7F\x77" \
          "\x3B\x3A\x61\xE9\xBD\x89\x85\x6D\x33\x6E\xF1\x18\x15\x78\x2A\x21" \
          "\x7D\xF6\x58\x37\xEE\x68\x49\x1E\x9C\xF6\x11\x01\xFA\x55\xCD\x4A" \
          "\x86\xBE\xC0\xF1\x4B\x92\xFF\xBA\x7C\xB9\x8D\x45\x61\xFB\x07\x61" \
          "\xD0\x7F\x38\x52\xB2\x50\x25\x03\x58\x00\x4E\x55\xA2\x2D\x75\x6F" \
          "\x40\x03\x8E\x0F\xB0\xB3\x85\x9E\x3E\x3C\x28\xA1\x4A\xB0\xAF\x4D" \
          , 1024);
    memcpy(&bCryptBlock[1024], \
          "\xFA\xC9\x9B\x55\x15\x0D\x36\x11\x17\x60\xB2\xCC\xED\xB8\xF0\x29" \
          "\x17\xDA\xE6\xDF\xC7\x3C\xAF\x56\x23\xE3\xF2\xF0\xB9\xFE\xE5\x1F" \
          "\x0C\x02\xF7\xA5\xAE\x8F\x1D\xBC\xB4\x5B\x43\x17\x7A\x3A\x53\x7D" \
          "\x65\xC6\x9D\x20\x1C\x9D\xB6\xAE\xC6\xBE\xE1\xC0\x05\x11\xDF\xC1" \
          "\x09\xB0\x57\xE2\x03\xB5\x17\xFE\xD5\x9A\xFB\x1E\x55\x60\xE4\xAE" \
          "\xAF\xA3\x88\x11\xF1\x91\xA6\xBE\xA0\x01\xB2\x7D\x43\xE5\x89\xCE" \
          "\x30\xB1\x97\x29\x17\x26\xB4\x11\x1E\x50\xC4\x6D\xCD\xA1\x62\x59" \
          "\x60\x80\x8F\xA1\xEA\x8D\x6E\x5E\x64\xF4\xBE\x4B\x06\xF8\xC3\xB9" \
          "\xF6\xE9\xC2\xEC\x2F\x30\x96\xEC\x44\x09\xC2\xAB\x8F\xDB\xAE\x9B" \
          "\x36\xE9\xAA\x66\x7D\x9E\x59\x1C\xE5\x07\xDA\x15\xC6\xFD\xC5\xFA" \
          "\x6B\x68\x47\x07\x72\xD7\x06\x8B\x88\xC8\xD4\x3B\xA6\x2F\xED\x02" \
          "\x4E\x10\x7A\x44\x91\x67\x25\xCA\x5E\x90\xF0\xEB\x9A\x24\xAE\x24" \
          "\x09\xF5\xEC\x0A\xDD\xF9\x83\x09\xBA\x49\x19\x8E\xAA\x47\x64\xE0" \
          "\xBC\xA9\xE2\xBA\xCA\xC5\xE7\x76\xF7\x72\x20\xCF\x4E\x55\xE7\xAE" \
          "\x7C\x14\x81\xB0\x66\xE7\x3B\xB3\x73\x46\x96\x1C\xE2\x0F\xE2\x11" \
          "\x0D\x4D\x69\xA2\x96\xB3\xC4\x9D\xC3\x4D\x99\x8C\xBC\x7A\x40\x0E" \
          "\x06\x63\x8E\x0D\x19\x7E\x82\x65\xCC\x74\x2E\xF9\x15\xB4\x07\x28" \
          "\xBF\xD1\x0B\x9D\x9A\xBD\x8E\x5E\x28\xF5\x95\x58\xB6\x6C\x26\xA4" \
          "\x25\xFA\xC0\x5E\x74\x77\x80\x1C\x1C\x81\x32\x20\x8C\x63\x6E\x74" \
          "\xB6\xC6\x4C\x1B\xBB\xD5\xB9\xCB\x6B\x6B\xDC\x6A\xF3\xDC\x79\x58" \
          "\xE6\xEA\xF0\x6C\x8B\x47\xBA\x3A\x47\x6E\xC0\x27\xC7\xCE\x12\x53" \
          "\x28\x5F\x77\x39\x43\x0A\xE2\x71\x2C\x3F\xC8\x2B\x07\x18\x95\x39" \
          "\x8E\x06\x72\x62\x1E\x28\xD2\x3E\xAF\x10\x6E\x4D\x73\xCE\x02\x97" \
          "\xCA\x99\x72\x2D\x6A\x07\xCD\xEC\x9F\x2F\x64\x5D\xD0\x61\x91\xB0" \
          "\xF5\xA4\x8F\x00\xDF\x2E\xA2\x30\x02\xEC\x90\xE9\xDD\xE4\x27\xBF" \
          "\x21\x06\xD5\x48\x41\xE0\xE0\x11\x64\x23\xC0\x95\x66\x0A\xED\xCB" \
          "\x38\x50\xC5\x4E\x58\xC5\x9A\xBD\x5F\xFE\x71\xB9\x71\xF4\xD0\xFA" \
          "\xA2\xB6\x74\x14\xC9\x74\x40\x31\xBE\x92\x64\x74\xC6\xB1\xEA\x71" \
          "\x58\xC0\x1C\xA0\x09\x2F\x3C\x99\x78\xA8\x1C\x9F\xA0\x7F\x82\xD1" \
          "\xFA\x3F\x54\x08\x47\x14\x09\x63\x0A\x98\x37\xAA\xAE\xB8\x44\x1D" \
          "\xC3\xEA\x4D\xC5\x1B\xF4\x79\x54\xC1\x2E\x50\x60\xEE\xC8\xC1\xF2" \
          "\x6C\x4D\xCD\x4E\x34\x33\x5A\xFA\xF0\x2D\xBC\x9D\x09\x22\x93\x82" \
          "\xB8\x60\x3D\xB1\x7C\x54\x25\x4F\xC8\x99\x4A\x9E\x01\xB6\x73\x62" \
          "\x44\x58\x89\x71\xDB\xF0\xBF\x77\x99\x02\x5A\xFA\xA8\xBE\x06\x9B" \
          "\xA2\x46\x6F\x42\xC1\xEA\x95\x16\x76\xB2\xE5\xA4\xFA\x72\xD3\x14" \
          "\xCD\xE2\x66\x30\xE2\xB1\x88\x67\xB9\x57\xAE\xC9\xE6\x16\x5F\x19" \
          "\x8B\x1A\xBD\xCA\x0B\x99\xEB\x2A\xAA\xD3\x27\x31\x29\x62\xDD\xB0" \
          "\xD6\x16\x1E\x33\x6E\x6C\x45\xCB\x81\x29\x70\xFF\x99\x57\x5F\x46" \
          "\x3B\xF3\x5E\xCB\x2B\x09\xC0\x2E\xDE\x34\x58\x83\x75\x77\x79\xEA" \
          "\x2C\x0D\xED\x36\x2B\x91\xC2\xB4\xAE\xBE\x96\x08\x8D\x69\xEC\xD9" \
          "\xAC\x66\x54\x40\xAB\xAE\x57\x7D\xF6\xC8\xF0\xC6\x8E\xB6\x3D\x65" \
          "\x4F\x67\x9C\x35\xF8\x9B\x7F\x17\xBB\xCE\xA1\xFD\xF7\x89\x38\x33" \
          "\xC8\x3B\x0E\xF1\xA2\xE0\x4B\x9F\xD3\x21\x4F\x04\xA7\xA5\x7B\xED" \
          "\xA0\xDE\x94\x34\xF5\x9B\x3A\xE0\x99\x0E\x79\x85\x98\xD6\x98\x91" \
          "\x8D\xAB\xC1\x2C\xE2\xE4\xCF\x42\xF5\x06\x0E\x6E\x57\x15\xF3\xA7" \
          "\xF5\xB6\xE1\xEB\x1A\xFF\xCF\xC3\x71\xB4\xDE\xD9\x39\xA4\x49\x6D" \
          "\x0D\xE7\x1F\x9F\xBF\x72\x99\xE0\x1B\x0E\x7E\x9D\x0F\xB3\x98\x6A" \
          "\xE4\x3B\xAA\xFA\x30\x81\xE7\x3B\xC3\x20\x4E\x11\x55\x87\x0D\x9E" \
          "\x59\xC8\x6E\x27\x91\xE5\x70\x9C\x3C\x81\x15\x48\xC4\x8B\xBF\x75" \
          "\x26\x8C\x39\x56\xB1\x67\xDA\xDB\x33\x7F\x77\x41\xDD\xEB\xEF\x4A" \
          "\x28\x9B\xF8\xFA\x8C\x80\xB3\x08\x0C\x23\xD5\x6C\x5F\x6E\xD4\x59" \
          "\x1B\x3B\xC0\xD6\x02\x48\x5B\xBB\xF8\xF7\xD0\x9B\x17\xB0\x22\x7E" \
          "\x91\xC2\xA9\x8D\x81\x2B\xB1\xA9\x53\x5B\x76\xBE\x25\x9C\x0A\xA6" \
          "\x61\x90\xFC\x4E\xAD\xDF\x8D\xE5\xF1\x1D\xD8\x25\x32\xBE\x1F\x3D" \
          "\xEA\xED\x68\x0F\x75\xE7\xCC\x4C\x4D\x18\xD8\xE2\x65\x39\x82\x61" \
          "\xB7\x4D\x5E\x09\x67\x00\xAB\x47\xFC\xEC\xA4\x26\x1B\xDB\x14\x9B" \
          "\x08\x48\x73\xB1\x35\x40\x4C\x4D\x60\x05\x5C\x33\x60\x4D\xC9\x27" \
          "\x5D\x4C\x7B\xE6\x17\xB6\x01\x72\x3F\x26\x7E\xEB\x1B\x9C\x02\x89" \
          "\x55\x7E\x66\x97\xD6\x56\xF2\x3B\x49\x4D\x2E\xFB\x86\xE2\x53\x55" \
          "\x0F\x96\xC0\x9F\xE1\x43\x9D\xB9\x77\x16\xBF\x88\x22\xEF\x07\x8D" \
          "\xAD\x38\x24\x19\x96\x6E\x92\x30\xCC\x08\x52\x7F\x2B\xB7\xBB\x00" \
          "\x20\x3B\x60\xF5\xF7\x2E\x94\xDD\x5D\x45\x68\x90\xEB\x46\xFE\xF7" \
          "\x84\xE9\x4B\xAC\xEA\xD9\x01\x24\x1E\x98\x01\xEB\xC5\x4A\x14\x7D" \
          "\x08\xB6\xCC\xD3\xEF\x0B\x86\xE0\x5E\x61\xC5\x0F\xEF\x87\x2D\xA9" \
          , 1024);
    memcpy(&bCryptBlock[2048], \
          "\x78\x67\x5B\x5B\x1F\x47\x01\xAB\xCF\xDE\xCE\x5B\x02\x3E\xD9\x4B" \
          "\xF2\x2E\x3C\xD1\x2E\xFA\xC1\x9D\xC2\x5A\xAD\xD6\x84\x41\xAB\xAC" \
          "\xCB\x53\x80\xE3\x03\xA4\xEA\xC2\xE4\x89\x69\x90\xA6\x68\x7E\x5B" \
          "\xAF\xB4\xB1\xA0\x14\x66\xFF\x2B\xDB\x6F\x03\xDA\x36\x10\xA3\xFC" \
          "\x09\x04\x3F\x2D\x1B\xF1\x8F\x1D\x82\x50\x2D\x7C\xA1\x52\xEB\xE5" \
          "\xBD\x2E\x80\xE2\xEB\x12\x37\x1D\xA4\x64\x92\x6F\xB2\xE7\xA6\x35" \
          "\xF2\x7C\x03\x92\x52\x74\xD9\x77\xF8\x0A\x5F\x21\x52\xA4\xCD\xB7" \
          "\x48\xB0\x41\x83\x83\xE0\xD8\xB4\xF3\xC0\xF0\x8C\xC9\x30\xB7\x7B" \
          "\xD9\x57\x23\xB8\xA5\x8D\xE8\xBA\x3E\x9D\x49\xEB\x80\x50\x82\xCA" \
          "\x16\x26\x1E\xD8\xE2\x33\x31\xBD\x51\xBD\xB2\x8F\x7C\x7A\xB4\xE3" \
          "\x12\xB7\x59\x0B\x37\x22\x15\x52\x6B\x8B\x1F\x87\x75\x34\xD3\xC2" \
          "\x9F\x11\x27\x8B\xA1\x7D\xBB\x93\x05\x45\x94\xFE\x9A\x5B\x87\x04" \
          "\x7D\x77\x1F\xBF\xA6\x33\x84\x29\xEB\x86\xD1\xAA\xFB\x11\xD1\x78" \
          "\x3B\x62\xA2\xD9\xBE\x2E\xF8\x98\xFE\xE9\xA4\x65\x53\x3E\xF3\xCB" \
          "\x00\xE1\xA8\xE3\x03\x7F\x69\x9F\x4A\x0A\x50\x00\x02\xDD\x74\xC7" \
          "\x53\xDE\xAC\x64\x14\x98\x17\x1F\x49\xB0\x8C\xA5\x53\xD8\x96\xF9" \
          "\xCB\x10\xE0\xDC\x4B\x3B\x67\x03\xBD\x9C\x08\x46\x77\x7D\xD1\xB8" \
          "\x33\xFC\xF6\x24\x52\x43\xEC\x62\x3F\x5F\x25\x59\xAB\x10\x87\xD3" \
          "\x7D\xD3\xF1\x7C\xD5\xBC\x0C\x5C\x87\xC8\x2C\x84\xD7\xDB\xB2\x72" \
          "\x9B\xE8\xD2\xE9\x40\xCE\xC4\xA8\x45\x24\x99\x01\x4E\xB0\x8E\xE9" \
          "\x15\x1D\x55\xB6\x20\x22\xE6\xC8\x44\x17\xC6\xB4\xA8\x1F\x4A\x5E" \
          "\x6C\x08\xEE\x94\xFC\xBA\x1A\x42\x03\x12\x51\xFD\xBA\xCC\xCE\x0C" \
          "\xE3\x5E\x5A\xF7\xE9\x5B\x01\x5F\x44\x07\x2E\x74\x97\xC6\xCF\x2E" \
          "\x5C\x4E\xDD\x74\xB1\x76\xC7\x79\x23\x9D\x5F\x43\xDD\x70\x98\x13" \
          "\xA2\x8C\xE7\x7B\x63\x7F\xBC\x7D\x73\x80\x9D\xE4\x74\x0C\x2F\x29" \
          "\x19\x67\x42\xE9\xCD\x02\xE0\x63\x48\xE6\xE4\x5E\xC2\x45\x36\xAC" \
          "\x89\xF2\x4B\x55\x0B\xC6\x41\xB4\x4B\x6E\x82\xDE\x72\x7E\x9E\xBB" \
          "\xC5\x26\x82\x57\x81\xD9\x15\x65\x8E\x23\xD2\xC9\xFE\x55\xFD\xC4" \
          "\xF2\x06\x9C\x3F\xAF\xB7\x8D\x2C\x38\x77\x17\xD6\x26\x35\x68\xD2" \
          "\xBB\x01\xD6\xAA\xA4\xC5\x11\x7D\xD1\xDA\x70\x23\x80\x81\x4E\x42" \
          "\x34\xE9\x3D\x86\x54\xAB\x8C\x43\x0E\xBA\x7E\xCE\x42\xDB\x69\xDC" \
          "\xBC\x0B\xE2\x23\x44\x06\xDF\x68\x89\xB3\x2F\x09\xF6\xD8\x77\xD0" \
          "\xD5\xFB\x24\x2B\x08\x30\x80\xAC\x4D\xFE\xFE\xEF\x73\x93\xB6\xCC" \
          "\xF6\x38\x09\x37\xE8\x2D\x2C\x1E\x82\xB6\x67\x65\xA4\xAA\xE2\xB1" \
          "\x1B\x1C\x05\x70\x72\xF8\x17\x9E\xF9\xCD\x9B\x75\xE7\xF8\xAB\x41" \
          "\xEF\x0B\xF7\x6E\xC6\x7A\xA2\x16\x87\x9A\xF5\x01\xC9\x54\xE9\x5F" \
          "\x12\xA3\x14\xCB\x5C\xDF\x95\xDA\xDA\xB8\x59\x43\x8B\x4D\xBB\xBD" \
          "\xD6\x03\x88\xE9\x80\x8E\xF3\x87\x05\x57\x62\x08\xAE\x9D\x76\x69" \
          "\x43\x32\x47\x28\x5D\xF0\xBA\x3E\x9B\x71\xAC\xCF\xED\xFA\xF9\xC1" \
          "\xED\xEF\xFD\xC6\x31\xFC\x09\x66\xE4\x8F\xD9\x97\x61\xE1\x0F\xAB" \
          "\x2F\xA8\x85\x83\x66\xAF\xAB\xFA\x4B\xF1\x82\xA0\xD4\x67\x6D\x2B" \
          "\x11\x4D\x57\x32\xC5\x45\x99\x19\xE6\xEB\x6D\x93\xB9\x8D\x35\x1F" \
          "\xA3\x1E\x56\x09\x43\xDE\x08\xCF\x3B\x6A\x89\x6F\x7C\x00\xD4\x76" \
          "\xB2\x67\x25\x0A\x68\x9A\x24\xFB\x1C\xBF\xFC\x1B\x91\x57\x11\x7A" \
          "\x4F\xB1\xEC\x92\xEA\xF7\x54\xAA\x78\x51\xC9\x23\xEA\xA6\x49\x88" \
          "\xDF\x36\x1C\x79\xBB\x65\xBE\x8B\xE7\x2A\x3D\xBD\x24\x66\xB0\x3B" \
          "\x42\x14\x0D\x43\x1E\x44\x1F\x46\x0A\x32\xE0\xB6\xB3\x44\x8E\x4F" \
          "\x12\x06\x9A\x00\x6C\xA9\xB7\x14\x57\x4A\xD0\x70\xDD\xE3\xB5\x19" \
          "\x5B\xE6\xA7\x30\x67\x6F\xD1\x5A\xB7\x53\x2C\x85\xF0\x30\x6F\xE0" \
          "\x8A\xBF\x90\xE9\xF0\xF3\x68\x83\x8B\x35\x78\x78\xC5\xC4\x3C\x30" \
          "\x57\xAF\xB6\x1D\x9A\x3F\xE5\x3D\xB9\xC6\xBD\x48\x8B\x8C\xC3\xDC" \
          "\xD1\x2A\x48\x4A\x58\xED\x1B\x25\xB0\x80\x83\x7A\xB5\x58\xD3\x53" \
          "\x5D\xC3\xCB\xF2\x77\x4D\x49\xC3\xCC\xA3\xE3\x14\x42\x5C\x13\xC4" \
          "\x73\x09\xF0\x4D\x5D\x97\x54\xDE\xC7\x1B\x5D\x13\x8D\x78\x6E\x9B" \
          "\xEC\xB8\xB7\x96\x4A\x39\x03\xD1\xBA\x69\xDB\x8E\x6A\x8E\xF8\xC7" \
          "\xDB\x42\xE7\xE1\x77\x6D\x71\xA1\x30\x32\x36\xD8\x91\x48\xF9\x05" \
          "\x32\x59\xAA\xD1\x8C\x74\x58\x23\xC5\xDD\x3F\x01\x52\x61\x44\x55" \
          "\x79\xCD\x1A\x29\x43\xBE\xED\x9C\x25\x22\xF4\x1E\x54\x21\xDF\x6A" \
          "\x29\xC8\x33\x9C\x00\x5F\xF9\x48\xA0\x6B\x88\x3F\xA1\x4E\xB3\x2F" \
          "\x96\x76\x32\xCD\xC0\xDD\x10\x1A\x7F\xC3\x1D\x95\xA0\xE3\x32\xA1" \
          "\xE6\x6C\x78\xFE\x0E\xD1\x08\x0D\x6A\x9F\x5A\x2E\x51\x52\x27\xC6" \
          "\x83\x32\x30\xDF\x34\x86\x33\xAF\x73\xF1\x1A\x90\x82\x54\x8B\xBA" \
          "\x47\x10\x6D\x1E\x36\x31\x85\xD5\x73\x96\xBA\x90\x46\x7C\x3A\xCC" \
          "\x30\xAE\xBE\xC7\x00\x32\xFA\x36\xDD\x1C\x57\x45\x67\xF0\x7A\xA1" \
          , 1024);
    memcpy(&bCryptBlock[3072], \
          "\xF5\xC6\xAB\x3D\x28\x09\x08\xA2\x70\x36\x42\x7E\x9E\xC6\x42\xA4" \
          "\xEA\x4F\x46\xD8\x99\xCE\x35\x6B\xDB\xF5\xC7\x50\xEB\x6D\x9F\xAE" \
          "\x50\x23\x0C\x6B\xD3\x83\x11\xCA\xC5\x3E\xA9\xAA\x25\xB9\x4A\xFC" \
          "\x1B\x91\x60\xBF\x54\x80\xAF\xEA\xD7\x5C\x0B\x6B\x25\x6E\x10\x87" \
          "\x98\x06\x97\xBE\x07\x06\x54\xED\xA8\x02\xAD\xFB\x64\x48\xEF\x48" \
          "\x76\xE7\xBB\xE8\x0D\x7E\x3B\x09\x99\x1B\x75\x1F\x6D\xC9\x54\xD3" \
          "\xDF\x19\x36\xBC\x01\x9E\x5C\x4C\x98\x0C\xFD\x71\xAD\xB2\xAC\x6E" \
          "\x23\xF9\x9B\x02\x31\xE5\x36\x93\xA7\x24\x33\xDC\xEB\xDA\xB4\xAC" \
          "\x25\xBA\x76\xA7\x5E\x6C\x5E\x6A\xF9\x19\x75\x1D\x17\x8E\xBE\xC9" \
          "\x4C\x40\xCF\x87\xE1\x7F\x89\xC7\x3E\x91\xC7\xC2\x92\xB1\x5A\x0A" \
          "\x62\x4C\x1C\x45\xCD\xFB\x02\xEE\xED\x7B\x4B\xC1\x7A\xE3\x29\x40" \
          "\x4F\x65\xBB\xB0\xF1\xE1\xD4\x66\x41\xB6\x5D\x9E\x76\xBC\xCE\xC5" \
          "\x35\x3E\x06\x2D\x19\xF2\x1C\xD6\x30\xEC\xEB\x10\x84\x63\xA0\xFA" \
          "\x22\x11\xDB\xAA\x3B\xDF\x68\x90\xAA\xA6\x8F\xD5\x8A\xD8\x69\x06" \
          "\x4E\x4F\x57\x9D\xEA\x6E\x78\xF8\x71\xD4\x9D\x3A\xD3\x64\xF2\x47" \
          "\x9E\x46\xDB\x90\x16\x6D\x12\xA2\x32\xD0\xD0\x31\xC5\xD6\xA5\x2A" \
          "\x9A\x0E\x90\x8C\xC8\xE6\x78\xE3\xBC\xFF\x29\x5E\x92\x4B\x38\x71" \
          "\x65\x83\xC3\x3E\xD9\xA5\x0B\x6B\xF6\x87\x1C\x87\xE8\xF8\xA8\xF4" \
          "\xAB\x47\x72\xFE\x95\x8E\xC0\x4E\xEC\xC8\x66\x4D\xA8\xBD\xA9\x57" \
          "\x8F\xCC\x36\xE9\x3F\x39\x9D\xB1\xA7\x3B\x8C\x76\x9E\x3D\xF7\x2F" \
          "\xC1\xF2\xCA\x37\x7A\xC2\x13\xD8\x6D\xD6\xEA\x10\x64\x1C\x8F\xE4" \
          "\xDD\xBB\x57\x27\xC6\xA6\x69\xAE\x8D\xA7\x01\x13\x64\x99\xEB\x89" \
          "\xD5\x6E\x8F\x1D\xF3\xCF\x5A\x3C\x01\xF4\xA4\xF0\xEE\xF6\x4A\xEB" \
          "\x67\xA9\x8E\x25\xF9\x6C\xC6\x7D\x38\x24\x5A\x2F\x40\x17\x64\x7C" \
          "\xDF\x89\xC5\x0C\xB9\x21\x12\x25\x92\x4F\x10\x1F\x9B\xFD\x01\x09" \
          "\x16\xB2\x3C\x32\xF2\x17\x1F\x70\xB1\x0A\xB6\xDE\xB6\x7A\x19\x07" \
          "\x93\x7A\x89\xF2\xBF\xCD\x6E\xBD\x0C\xDC\x49\x7F\xD7\xE3\xD6\x8A" \
          "\xD2\x79\x44\x00\x0F\x1D\x85\x20\xC5\x11\xEA\x8D\x40\xDE\x55\x48" \
          "\x2F\xE2\xD5\xD8\x7D\x46\xF6\x04\x4B\xD7\x9C\x22\x1C\x3D\x22\x33" \
          "\x3B\x3A\xAC\x1C\x28\x9A\x15\x42\x81\xAA\xA5\x84\x6B\xD9\xCC\xC1" \
          "\x83\xC9\x32\xC8\xC6\xED\x9F\x67\x69\x84\x25\x0A\xB9\x3A\x36\x14" \
          "\xB4\x67\x49\x2D\x17\xBD\x11\xC3\xCC\xE9\x48\x33\x69\xE7\x38\x57" \
          "\xD5\xAF\x83\xC6\x72\xE6\x28\xA7\x27\xDD\xCF\x73\x12\xF8\xCF\x1B" \
          "\x28\x34\x1B\x02\x1D\x47\x59\x6B\xA3\xC4\x9E\xD6\x8A\x3B\xBF\x93" \
          "\x8D\xBD\x41\x31\x87\x4F\x2D\x2C\xBD\x5A\x88\xAB\xFB\x94\xFC\x4B" \
          "\x9D\xBB\x2A\x62\x73\x40\xE4\x9D\x83\x8F\x7A\xCA\x25\x08\xB7\x75" \
          "\x68\x54\x87\x69\x56\x4E\x9D\xF3\xF6\x8D\x68\x6E\xA4\x1A\xB9\x3A" \
          "\xA8\x4D\x36\xF7\x65\x21\x19\x83\xE3\x5C\xD7\x95\xAE\xE1\x4A\x99" \
          "\xE8\xFB\x9B\x1A\x6E\xD4\x97\xA5\xBD\xAB\x8A\x5A\x55\xDB\x7B\xAC" \
          "\x6C\x3D\x7B\x75\xC5\x74\x20\x2B\xA3\xE3\xDE\x9F\xB5\xC2\xBD\x2F" \
          "\xE5\x71\xC1\xA1\xE9\x5B\xF6\x94\xDC\x04\xC8\x40\x2C\xDA\x09\xD7" \
          "\xD4\xF6\x26\xA9\x17\xD5\x04\x13\x1C\xB4\x67\xEB\xF9\xCC\x02\xE6" \
          "\xF4\xB4\x71\xA1\xC3\xCC\x29\x5A\x2A\x7D\x6D\xEC\x8F\xFC\x05\x0E" \
          "\x29\x76\x44\x92\x58\xE6\xAC\x46\x38\x74\x79\xC9\xAC\x68\x2B\xCB" \
          "\x07\x5D\x44\x38\x46\xAC\x38\x9F\xAE\x85\xF7\x76\x47\xB2\x2E\xFD" \
          "\xB7\xCD\x27\x7A\xCB\xE7\x7A\x47\x5A\xE0\xF9\x60\x9F\x66\x2F\xE7" \
          "\x3F\x41\x55\x67\xA3\x58\x3A\x87\x11\x03\xAC\xC4\x9F\x32\x4B\xA8" \
          "\x3E\x7E\xE1\x98\xB0\x13\xEC\x87\x64\x57\xB7\xD4\x97\x1A\x79\x4E" \
          "\x02\x25\xCE\xE8\x4F\x27\xDD\x4F\x53\xC9\xFA\xEE\x1A\x34\xB2\xA4" \
          "\xD4\x64\xB4\x07\x1A\xAE\xD7\x17\x76\x86\x99\x58\xE7\xDB\x7B\x8E" \
          "\x2C\x56\xB9\xF2\x7E\xEB\x88\x4E\xFF\xC4\x77\x51\x34\xF5\x48\x84" \
          "\x32\xE9\x23\x19\xC6\x78\x83\x60\xBE\x51\xD4\x43\xB9\xD0\x47\x9F" \
          "\xFE\x38\x91\x4D\x61\x22\xC1\xB9\x6B\xD8\xEE\x94\x45\x30\x8D\x35" \
          "\x11\x40\xB5\x45\x33\xBD\xE2\x41\x36\x1A\x43\xB6\xAC\x3D\xFA\xD6" \
          "\x47\xE1\xA4\x05\x4E\x62\xBB\xCC\x57\x3B\x59\x55\x63\x45\xFA\xCE" \
          "\x6B\x66\x29\x56\x7E\xD6\x5D\x7D\x51\xDC\x37\x0C\x5D\x28\xB8\x67" \
          "\x23\xED\x70\x37\x8C\x78\xF6\x0F\x77\x06\x64\x98\x55\x5E\xBF\x0D" \
          "\xCA\x4C\xF3\x7A\x4B\x3B\xBF\xAF\x6C\x2B\x41\x83\xD2\xBD\x15\x3E" \
          "\x32\x3A\x96\x1E\x9C\xA2\x0C\xF1\x87\xDF\x84\x61\x79\xF3\x1F\x69" \
          "\x0F\xAE\xDE\xBB\xC9\x35\xA9\x55\x95\x94\x48\x79\x46\x53\x76\xC5" \
          "\xA5\xE7\xC6\xAB\xA2\x9E\xFB\xC2\x3A\xB6\x10\x4A\x14\x06\x19\xE8" \
          "\xF5\xBD\x9F\x91\xEA\x32\xA0\x09\x54\x7A\x8D\x21\x23\x7A\x6D\x16" \
          "\xD0\x30\xAA\xFE\x3E\x9D\x37\x9C\x44\x7E\xBF\x89\x94\xAA\xBE\xE3" \
          "\x4B\xD0\xB2\xA1\x11\xE3\x28\x07\xA6\x14\x38\x85\x15\xC7\xDA\x04" \
          , 1024);
    nBlockLen = 4096;
    memset(bPlainBlockExp, 0x5C, 4096);
    bPlainBlockExp[0] = 0x25;
    bPlainBlockExp[4095] = 0x22;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bCryptBlock    =", bCryptBlock, 4096);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    DspHex("[IN ]bIV            =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptCBC(nSock, nAlgo, bKey, bCryptBlock, \
                             nBlockLen, bIV, bPlainBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "算法类型=1，数据长度=4096，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bPlainBlock    =", bPlainBlock, 4096);
    DspHex("[OUT]bPlainBlockExp =", bPlainBlockExp, 4096);
    ASSERT_OUT_HEX(bPlainBlock, bPlainBlockExp, 4096);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptCBC_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bCryptBlock[4104];
    int  nBlockLen;
    BYTE bPlainBlock[4104];
    BYTE bIV[16];
    BYTE bPlainBlockExp[4104];

    bufclr(bKey);
    bufclr(bCryptBlock);
    bufclr(bPlainBlock);
    bufclr(bIV);
    bufclr(bPlainBlockExp);

    nAlgo = 2;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
                 16);
    memcpy(bCryptBlock, \
          "\x2B\xB5\x43\x79\x10\x13\x91\x7C\xAD\xC5\x5E\x6A\x4F\x84\x19\x68" \
          "\x88\xDB\x64\x06\x91\x85\x06\xF4\x69\xAD\x1C\x46\xBE\x39\x96\xD9" \
          "\x9A\x39\x57\x05\x86\xF8\x7B\xF5\x05\x57\xA3\x56\xC7\xA8\x7D\xDA" \
          "\x24\xD3\xF9\x72\x54\x77\xF7\xCD\x27\xF7\xD1\x02\x86\xAB\xE5\x3C" \
          "\xC2\xBE\x05\x24\x4A\x38\x7D\x91\x9D\xFF\x35\x6F\xD4\xBA\x5A\xBE" \
          "\x05\x0B\x06\xF3\xAF\x90\x08\x6B\xCA\x94\x76\xCC\x7D\x5A\xAC\x61" \
          "\x6D\x78\x3B\x89\x66\x9D\x44\x54\x73\xAF\xBD\xC1\xE7\x57\x1B\x14" \
          "\xA6\x0A\x16\xEC\x64\x1E\x65\x01\x4B\x8F\xD7\x4C\x30\xB3\xE9\xC7" \
          "\xEF\xCE\x55\x01\x38\x2B\x4F\xCE\xBC\xD1\x14\xCC\x6E\xC6\x16\xF4" \
          "\x60\xD8\x27\x3B\x5F\xE2\x85\x1E\x70\x42\x27\xF7\xDE\x70\x10\x10" \
          "\x69\x3D\xF6\x25\x9D\x30\x9F\xC8\xFC\xAB\xE0\x32\x0B\x9A\xCB\xD0" \
          "\x19\xEB\x22\xA3\xE1\xBC\x82\xD6\x0F\x6A\xF2\xD1\x70\xA4\x59\xEB" \
          "\x91\x92\xED\xA0\x29\x49\xA6\x62\x91\x23\x0D\x9D\xB7\x85\xA3\x23" \
          "\x1F\xA5\x5B\x3D\x5C\x7D\x25\x15\xAD\x04\xFE\x92\x30\x0A\x0C\xE4" \
          "\xFB\xB1\x3D\x59\x7F\x54\x7E\xFB\x7C\x87\xC8\xE1\xEB\xE7\x69\xA1" \
          "\xE7\x95\xB4\xE6\x67\x6F\xE0\x6C\xED\x43\x8F\xCB\x83\xB9\x32\x2A" \
          "\x01\x61\xD2\xFC\x06\xF1\x86\xF0\xC2\xD3\x8E\xF6\x34\xBD\x81\x31" \
          "\x62\x37\x8E\x6C\xC0\xA3\x1F\x08\xDE\x29\x6D\x66\xBD\x93\x28\xEB" \
          "\xE9\x61\x15\xE7\x68\x43\x1C\xDB\xD5\xC9\x62\x01\x91\x2F\xF3\xCC" \
          "\xE8\xEA\x21\x7D\xF6\xD2\x29\x14\x74\xB1\xC9\x36\xCC\x4C\xE6\x8F" \
          "\x83\x5E\x08\xB1\xF7\x62\x66\x83\xE4\x21\x42\xDA\xA6\x17\x30\x25" \
          "\xDB\x25\x29\x74\x6D\xC6\xF2\x6B\xBD\xC2\x45\xDE\x33\x78\xA1\x1E" \
          "\x5C\xB8\x15\x7C\x1B\xC8\x1C\x91\x1F\xBE\x39\x87\x1D\x0E\x8B\x9E" \
          "\xB9\xF3\x3F\x37\x0C\xFB\x45\x54\xE2\xC0\x9D\x69\x62\xD1\x94\xC5" \
          "\x8B\xB1\xED\x6B\x26\xE3\x74\x4E\xA0\x3C\x00\xCA\x88\x05\x39\x98" \
          "\x5F\xBF\x13\xBE\xFF\xC1\x4C\xB9\xA9\x0B\x32\xDF\xAE\x7D\x70\xF5" \
          "\x3E\x30\x4A\xB7\xFB\x33\xF2\x98\xBD\xAE\x84\x11\x1B\x0F\x39\x2A" \
          "\xF6\x8D\x6A\x2A\x69\xFF\x5C\xB4\x99\x6A\x4C\xD0\x53\x59\x3D\xF0" \
          "\x72\x8D\x1B\x91\xCE\x88\x3B\x7C\x28\x9E\xFB\xC4\x6E\xD8\xD8\x11" \
          "\x60\x11\x21\xDE\xF7\x70\xC6\x37\x11\x3B\x33\xB3\x25\xB8\x87\x4E" \
          "\x12\x2B\xB7\x67\x11\x54\xE6\x51\x22\x03\x97\x76\x17\x0F\xCB\x1D" \
          "\x6B\x29\x06\x93\x49\x04\xE1\xDC\xC8\x5A\x40\xE1\xBB\x6C\x11\xCA" \
          "\xC5\xE1\x08\x6B\x5E\x96\x28\x4D\x54\x8E\x8D\x8F\xA6\x65\xBA\x51" \
          "\xFC\x52\x71\x0F\xF7\x9E\x24\xEE\x3F\x1C\x69\xFF\x13\x17\x8E\x56" \
          "\xCC\x02\xB0\x8F\x0A\x3B\xC5\x3D\xA2\x90\x24\x27\x29\xA1\xF7\x7B" \
          "\xAC\x02\x74\x62\x82\x4F\x6D\xF6\xDA\x19\x4A\x11\x1E\x38\x48\xAE" \
          "\xBC\x19\x83\x20\xE4\xA6\x47\x97\x46\x04\x3C\xF8\x96\xFE\xC1\xB6" \
          "\xE5\xB7\x9B\x6E\x9A\xD8\x4F\xC0\x4D\xEF\x6B\x55\xA0\x30\xAA\xED" \
          "\x23\x9C\x63\x9D\xD2\x3C\xDC\x4C\x16\x10\x8A\x38\xAA\x8E\x7E\x0A" \
          "\x4D\x13\x43\x84\x51\x96\xA6\xD8\xFE\x05\x79\x6F\x6B\xF9\x39\x4B" \
          "\xC4\x02\x62\xAC\xBB\xCC\x1D\xC7\x79\x86\xE2\x23\x1C\x44\xE9\x1A" \
          "\xF2\x95\xED\xB4\x81\xC9\x5B\x2F\xB6\x72\xE2\xD7\xE6\x02\xDD\x5F" \
          "\x15\x17\x00\x20\xBA\x6E\xDF\xD1\x75\xB5\x30\x96\x09\xBA\x45\x12" \
          "\x9D\x89\x5E\x18\xC5\x06\xE5\x80\xA7\xEA\x78\x7C\x89\x41\xDD\x37" \
          "\x3C\x76\x0E\x77\xA7\x4D\xFB\xBF\x8E\x99\x6F\x76\xCC\xFD\xAE\x90" \
          "\x5C\x86\x2A\xA6\xBF\x95\x3B\xF2\x33\x8A\x57\x3E\x90\x01\xA9\xA5" \
          "\x58\x9A\xF8\xEF\x47\xFF\x32\x68\x11\x6E\x42\x40\x6D\x9B\xF5\x88" \
          "\x1C\x81\x3F\x34\xFF\x6C\xD4\x47\x6C\xC6\x3D\x8D\xB5\xC1\xD2\x55" \
          "\x72\xE0\x04\x3B\x88\xCE\x0D\x99\x4F\x4A\xF3\x89\x0C\x3B\xD6\xD7" \
          "\xA6\x14\x28\x6E\xF1\xA6\x2F\xEF\x3B\x5C\x9A\x83\x5C\xCD\x0F\xC4" \
          "\x16\xF2\x25\x59\x4C\x3A\x4F\x63\xEC\xE2\x27\xD0\x6C\x00\x32\x58" \
          "\xD1\xB1\xAD\xC0\x5F\xD5\x01\x42\x75\x8E\xDD\x76\x7D\x76\x31\xE4" \
          "\x07\x46\x30\x53\x23\x7F\x1C\x43\xE8\xA4\x8A\x6F\xC5\xBC\xF4\x73" \
          "\x1F\x8A\x89\x3D\x81\x06\x2B\xBD\x47\x9F\xAD\xE5\x70\xC7\x06\x58" \
          "\x2E\x81\x80\x5C\xAF\x39\xDD\x1B\x1C\x53\x6E\xE5\xC2\x2D\x57\x5D" \
          "\x35\x32\x3C\x12\xC3\xBE\x93\x86\xED\xBD\xD6\xE1\x3A\xCD\xB1\x34" \
          "\x3F\x04\x0E\xA2\x60\x68\x72\xF0\x5A\x70\xC1\x51\xBB\x5C\x3C\x54" \
          "\x57\x82\x56\x01\x4B\xF8\xB3\x2A\x2C\x19\xBC\x60\x4E\x8B\x9B\x43" \
          "\xB6\xD0\x2B\x23\xCA\x3D\x8F\x9B\x72\x8D\xDE\xFC\xF1\x63\xFD\xEE" \
          "\x6D\x21\xCF\xA0\x7E\xE2\x45\x97\xA0\xBB\x95\xCD\x05\x29\xC4\xCB" \
          "\x9D\x0B\x05\x57\x40\x68\x97\xB4\x73\x5F\x2D\xB4\x9C\x45\xC5\x06" \
          "\xCA\xE5\xF9\x92\xB5\x41\xC3\xFC\xCF\x81\x14\x91\xA0\x5A\xB7\x5A" \
          "\x78\xE7\x88\x49\x3D\xA8\xA5\xCB\xA6\x05\x80\xEC\x56\xD3\xEF\x20" \
          "\xB1\x8E\x6D\x4F\x7C\x85\xE1\x16\x39\xD3\x82\xE4\xD0\xFC\x3A\x4C" \
           , 1024);
    memcpy(&bCryptBlock[1024], \
          "\x53\x3A\x28\x7B\x50\xC0\x4B\x07\x08\x89\x8C\x2D\x0A\xCE\xF0\x6D" \
          "\xB6\x0E\x5A\x8A\xA3\xBE\xDC\xA7\x6B\x66\x22\x89\xE5\x1B\x19\x42" \
          "\x5D\xB9\x5F\xEF\x25\x65\x2A\x57\xAB\x2F\x69\xE6\x9E\x4C\xB6\x8F" \
          "\x67\x28\x88\x0F\x03\x39\x96\xC7\x13\x9D\xCE\xD1\x44\xBD\x61\xF3" \
          "\x83\x91\xEF\x97\x29\x4F\xD9\x66\x94\x6B\x6E\xFD\x31\x37\x5B\x74" \
          "\xA5\x7E\xD1\xE3\x3A\x58\x28\xC8\xAD\xCE\xC8\xCD\x27\xC3\xDB\xC8" \
          "\x21\xBE\x6A\xCB\xEE\xDA\x7E\x6A\x70\xB9\x41\xD2\x68\x79\xC1\xDF" \
          "\xA1\x6A\x17\x91\x40\x81\x22\x19\x2B\xB2\x0C\x6F\xCB\xA5\xD1\x87" \
          "\xFF\x29\x8C\x5D\xBA\xC7\x0F\xA9\x66\xC1\xE0\x4B\xEF\xDD\x91\x47" \
          "\x68\xC4\xDE\x87\x97\xE9\xFD\x2C\x11\x66\x9E\x9B\xAA\x7E\xB1\x22" \
          "\x2C\x1F\x98\x2F\x76\x1E\xDB\x68\xA7\x84\x4D\x98\xC2\x16\x49\xCE" \
          "\x98\xB4\xB9\x47\x2D\xAD\x83\x43\x10\xF0\xEC\x37\xFF\xBE\xB3\x08" \
          "\xD9\x03\xB1\x3E\x0B\x57\xA1\x27\x15\x8B\x5D\xF6\x95\xA4\x6B\x94" \
          "\x30\x3F\x37\x92\xA2\x27\x06\x96\x92\xD9\xE1\x94\x1F\x8F\x9E\x00" \
          "\x17\x0B\x04\xD8\x37\x26\x84\x19\xA3\x35\x2E\x4F\x23\xF9\x51\xB6" \
          "\xF9\xFB\x77\x18\xB6\x3B\xD9\xC4\xA5\xE8\xD0\x15\xFD\x07\xF0\xA3" \
          "\xC6\xD2\xCB\x2D\xC8\x56\x24\xE0\x97\x1A\xD9\x10\xBE\xD8\x21\xDD" \
          "\xAB\xBF\x90\x4B\xC0\x2C\x7C\x22\x8F\x9B\x8E\x8B\x93\x20\x61\x34" \
          "\x78\x2B\x3D\x1E\x80\xBA\x53\xFE\x9A\xAD\x26\xE6\xC6\x1B\xED\x5E" \
          "\xC5\x83\xFA\xAB\x73\x40\xD6\xA4\xBD\xE7\xF7\xF8\x63\xAF\x17\xC7" \
          "\x96\x3B\x86\x85\x91\x0B\x27\xCC\x49\xAC\x5D\x87\xF8\x6A\x79\x60" \
          "\xCD\xEF\x14\x10\x67\xF0\x91\x36\x55\xF8\x41\x73\x6A\x9F\xC7\xFF" \
          "\x8B\xED\xB8\x64\x16\x25\x49\x83\x43\x7B\xDD\xA8\xA3\xE0\xC9\x75" \
          "\xEA\xEF\x32\xB6\x96\x62\xEC\x08\x9D\xA8\x7C\xD1\x17\x96\x00\x7F" \
          "\x4F\x31\x6F\xC4\x57\x86\xA0\xD4\x05\x3A\xB4\x75\xA9\x49\xD8\x81" \
          "\x55\xBF\x91\x0B\x57\xAA\x4A\xAA\x67\x98\xF2\x4F\xFC\x80\x20\x23" \
          "\x33\xA3\x50\xBF\xAA\xD0\xB4\xF0\x8E\x54\x46\xD9\x0A\x11\xED\x1F" \
          "\xAC\x26\x3A\xC2\x9D\x96\xDE\xAE\xD6\x57\xE9\xCB\x27\x67\xE7\xFD" \
          "\x63\x2B\x40\xB4\x9B\x50\x7B\x61\x96\xC2\xA0\x45\x1F\x8E\xB1\x0D" \
          "\xD3\x81\x1F\xD1\x81\x64\x82\xF6\x38\x28\x0E\x8A\x7A\xDE\xA6\x16" \
          "\xDF\xE5\x75\xE5\x39\x44\x24\x7C\xAB\x83\xC6\x6A\x08\x14\x84\x77" \
          "\x6C\xBC\xB7\xCA\x9E\x19\xDE\x1C\xEC\xCA\x45\xA7\x47\xA9\x2F\xB1" \
          "\x75\xE7\xA2\x55\x24\x18\x9B\x3E\xD9\xCA\x93\xAD\xBB\x50\xEA\x26" \
          "\x6F\x72\xBE\x44\xD0\x75\x63\xF8\xC4\x48\x97\xED\xF6\x00\x98\x51" \
          "\x44\xB9\x13\xA1\xD1\xD3\x18\xB9\x1F\x0D\xED\x08\xF7\xD2\x4B\xAE" \
          "\xB6\x9A\x34\x64\x13\xF5\x79\x85\xF1\x4F\x17\xD0\x3E\x19\x14\x0B" \
          "\x5D\xA6\x94\xF3\x3F\x91\x82\x12\x74\xA4\xFD\x40\xBD\xF2\x6B\x1B" \
          "\xBF\x53\xF7\x48\x72\x35\xEA\x89\x91\xD3\xE2\x4C\x0D\x8C\x54\x57" \
          "\x5A\xDD\xCA\x12\xB5\xF4\x31\x1D\xAF\x51\x68\xF8\xFB\xFF\x62\x7A" \
          "\x20\x4D\xE2\x29\xF4\xC3\x2B\x5B\x15\x55\xF0\x80\xD7\x68\xDD\xBA" \
          "\x34\x85\x9D\x82\x7A\xDE\x6A\x38\x35\xC2\xA4\xDB\xC6\x9C\xA3\xA5" \
          "\xEB\x66\x56\x84\xA1\x38\xFD\x5F\x4B\x0C\xBF\x5F\xA3\x58\x04\x79" \
          "\x4F\xA0\xA7\x6F\xE2\x00\xFA\x20\xA2\xBE\xCC\x59\xE4\x40\xBA\x5B" \
          "\x5F\xC8\xA9\xD4\x16\xBB\x17\x98\x53\x66\xA7\x0F\x0B\xEB\xC6\xB4" \
          "\x5F\xC4\x90\x39\x44\xA2\xE9\xF1\x1F\x36\xF2\x5D\x4C\x03\x60\x88" \
          "\x03\xF4\xBB\x36\x3E\x2B\x96\x36\x30\x93\x05\x79\x8A\x8A\x93\x8A" \
          "\xF1\xFD\xFC\x17\x88\xE3\x37\xF2\x54\xF2\xD4\xF7\x04\x27\x2B\xB0" \
          "\xC4\x0E\xDC\xC1\xB0\x93\xD6\xF5\x6F\x7C\x27\x26\xCB\x4E\x85\xCC" \
          "\x56\x4B\xE9\xA0\x13\x2E\x69\xA2\xD5\x0A\x9C\x99\xBD\xDE\xD0\x82" \
          "\x72\xDA\xDF\xD7\xE8\xE1\x71\x57\x2B\x27\x8F\x4C\xBB\x4C\x96\xA6" \
          "\xDD\x56\xA9\xA9\xBE\x9C\xCD\xF1\x2C\xD9\x4A\xBF\x94\x85\x6D\x30" \
          "\x56\x53\x05\x35\x7C\x0E\x1D\x6C\xFC\xCF\xF6\x37\x3E\x07\xC7\x95" \
          "\x4C\xDA\x18\x02\x78\x58\xF6\x38\xFC\x1D\xC4\x73\x56\x8F\x90\xD7" \
          "\x84\x21\x2A\xF7\x3E\x0F\xAA\x06\x19\xB4\xCA\xEF\x14\x12\x1F\x07" \
          "\x80\xE0\xBA\x28\xD4\xC7\x17\x2C\x0D\xD4\x9D\x76\x59\x77\x87\x8E" \
          "\xE6\x28\x72\x35\x0B\x73\x74\x7F\x96\x72\xF6\x3E\xE7\xCC\x5E\xA3" \
          "\xE3\x9E\x70\x21\xB3\x1C\xA0\xC9\x5B\x93\xB9\x2D\x69\x59\x46\xF8" \
          "\xE5\xD4\x97\x9A\xE6\x66\xD2\x3F\xD5\x0B\xBC\x7E\x8D\xA0\xC7\xAF" \
          "\x3F\xF4\x09\x00\x80\xC1\x5A\x22\xDD\x2E\x47\x16\x82\xC0\x32\xA2" \
          "\x70\x32\x9C\x22\x33\x49\x73\x0C\x68\x92\x3D\xB9\xBB\x5B\x9E\xCD" \
          "\xFA\x6E\x20\x78\x56\xB7\xBA\x8C\x9C\x53\xF8\x18\x06\x82\x9E\xDD" \
          "\x47\xE6\x21\x03\x91\xF5\x94\x3C\xFA\x96\xEB\x07\xEC\x43\x92\x66" \
          "\x9F\x59\x2A\x5C\xC3\x3B\xED\x18\xA2\x9E\x5F\x0D\x09\x6C\x3F\x02" \
          "\x01\xE5\x48\x39\xD6\x67\x75\xAB\xAF\x2B\x22\xCD\x14\x12\xD1\x6F" \
           , 1024);
    memcpy(&bCryptBlock[2048], \
          "\x17\x69\xEA\x01\xE5\x79\xF2\xE9\xE6\x09\xCF\xBF\x2E\x3A\xF1\xB6" \
          "\x27\xD2\x2D\xE4\x9B\x9F\x6F\x0F\xF5\xFA\x4F\x46\xAC\xB9\xC5\x9C" \
          "\xCC\x21\xD6\x77\xF5\xCD\x4A\xBA\xCD\xAC\x8D\xE7\x6F\xD2\x2B\xA2" \
          "\x46\xE0\x78\x03\xB3\x40\xD9\x39\x16\xDC\x46\x26\x6D\x78\xFA\xA6" \
          "\x03\x9E\x43\x39\xED\xB7\x6E\xC7\xAA\x28\x26\x3D\x1E\xD0\x9F\x26" \
          "\xF6\x18\x73\x68\xE4\xD4\x00\x84\x66\xC0\xB1\x84\x64\x3C\x3F\x86" \
          "\x40\x63\x79\x8D\x6D\x0D\xF0\x1D\x87\xDC\x3C\x8E\x0F\xD2\xD5\x33" \
          "\x0F\x68\xC7\xEA\xF7\xEC\xC0\x63\xCA\x3F\xF2\x5D\x12\x39\x1D\xBA" \
          "\xC1\xE0\x83\xC8\x61\x27\x0E\x4C\x84\xE9\x62\xB9\x48\x32\x10\x39" \
          "\xD7\x77\x80\x2E\xF4\xFF\x20\x79\x1B\xEB\x54\xBB\x9B\x41\x26\xB5" \
          "\x1E\xAD\x8E\xF3\x8C\xA0\xEE\x18\xE2\x79\xD6\xA8\xAE\xE8\x2B\xC8" \
          "\xBB\x1D\x71\xDC\xD6\x7B\x2D\xEC\x77\x9B\xB2\x99\x0F\x28\xC7\xB5" \
          "\x81\x44\x52\xA3\xEF\x56\xEF\x65\xD3\xBC\xC9\x51\x5F\xD1\x00\xA6" \
          "\x4B\xA9\x4E\xA1\xB4\x94\xC6\x92\xBD\x0C\x62\x3B\x2A\xE8\x81\x12" \
          "\x84\x40\xFF\x99\x1F\x0D\xA0\xA9\xED\xA2\x70\xC9\x45\xFD\xA2\x30" \
          "\x1C\x97\x71\x18\x86\xF0\x08\x50\xC4\xDF\x92\x0F\xAC\xAF\xEF\xCB" \
          "\x02\x6C\x28\x09\x4E\xE0\x68\x14\xE1\x26\x53\xE6\xD6\x25\xE2\xF0" \
          "\x7D\xBB\x0B\xA1\xCC\xD2\x25\xD4\xAE\x97\xC6\x82\x04\x3F\x97\x10" \
          "\xAD\x97\x90\x11\x44\xBE\x29\xFC\xA4\xB8\x6A\x43\x43\x6C\x68\xBE" \
          "\x33\xBF\xDB\xCB\xBB\xDD\x9B\xA3\x95\x10\x35\xB7\x10\x01\x02\xC5" \
          "\x8D\xD8\xD7\x19\xF9\xF0\x17\xA3\x9C\x11\xC3\x99\xC6\x36\x75\xE7" \
          "\xD2\xBA\x55\x1E\x0C\xE3\xD7\x7D\x99\x52\xE5\x87\xEB\xC3\x26\x58" \
          "\x1A\xC2\x00\xB6\xBB\xA0\x17\x06\x26\xE4\x7E\xF2\x6A\x16\xFA\xE0" \
          "\x85\x96\x50\x9D\x27\x24\x61\xEB\x93\xE9\xCF\x70\xAA\x77\x88\x8A" \
          "\x37\x7F\x23\xA9\x61\xEA\xEB\x4C\xAC\xDE\x4E\x50\x84\xCD\xC6\x5E" \
          "\x9C\x6B\x5B\xAC\x58\x17\xC7\xFD\xD0\x5C\xF6\x25\xEA\xE5\xAB\x2C" \
          "\x57\x51\x62\x63\xB1\xF1\xA6\xB4\x1D\x69\xFE\xA7\x6B\xE9\xBE\x83" \
          "\x51\x97\x0C\x5A\x1D\xC0\x57\xE6\xA0\x9D\x3E\xDF\xDF\x0C\x60\xEB" \
          "\x68\x38\x5C\x8B\x27\x00\xF1\x21\xE2\x8E\x0F\xC3\xF6\x4F\x93\x9F" \
          "\x65\xCC\x70\xCA\xCC\x20\xB0\x40\x47\xA2\x97\x6E\x9C\x0B\x8A\x56" \
          "\xD8\x35\xDB\xD6\x62\x48\x1C\x85\xD7\x69\x7B\x78\xBB\x84\x53\xC6" \
          "\x2A\xA0\x71\x18\x28\x47\x16\x0C\x53\x24\x31\x3D\xD9\xCD\xE3\xFA" \
          "\xE4\x9A\x58\xFF\x29\xA6\x1E\x43\x27\x02\xA3\x0B\xF6\x1E\xC3\x85" \
          "\x7F\x7C\x89\x6A\xB2\xF5\xAB\x67\x37\x3C\x70\x1F\x30\x01\x9B\xA0" \
          "\x2C\x6D\x9C\xBA\x4D\xC9\x61\x29\xE6\x8E\x9F\x0F\xAB\xDB\x66\x05" \
          "\xB0\x04\x6F\xE7\xF6\x44\xFA\xB7\x9B\x1D\x13\x7A\x1D\xE0\xDA\x75" \
          "\x61\xA4\x95\xFD\x22\xCF\x59\x31\xAA\xC5\x28\x2A\xC7\x44\x83\xD8" \
          "\x41\x9E\xEA\xAA\x7F\xD5\x3B\xAA\xFF\x3C\xCA\x58\x7C\x20\x71\xDE" \
          "\x3B\xEB\x5D\xAC\xFD\x5D\x09\xCA\xA3\xE2\x21\x12\xC2\x2D\x61\xEB" \
          "\x38\x61\x16\x09\x14\x4D\x1F\x9C\xC7\x03\x5D\xBD\x6D\x27\x0E\x10" \
          "\x95\xFE\x7E\x5C\xB0\x8C\xA7\x23\x31\xE0\xD5\x3D\x77\xF3\x5A\xA0" \
          "\x40\xF9\x39\xF9\x2C\x4A\xCC\xAA\xF4\x33\x0D\xD3\xDA\xCA\x10\xC0" \
          "\xFC\x98\x8D\x65\xF3\x6A\xBA\x44\x84\xEF\xFE\x0A\x09\xFB\x49\x60" \
          "\x45\x81\x25\xB7\x98\xF7\xE9\x0E\x91\x1B\xD8\xB7\xB0\x9E\x74\xFB" \
          "\x35\xEB\xAC\x12\xFD\xAA\xAE\x3C\xEE\xCD\xA6\x3D\x1C\x33\x46\x53" \
          "\x03\xFC\xEC\xD5\x13\x32\xA8\x69\xAC\x14\xA1\x17\x63\x1A\xB9\xF8" \
          "\xA1\x55\x09\x50\xB3\x43\xCD\x1E\x77\x15\x46\xDD\x6E\x06\x5D\xCC" \
          "\xA5\x6F\xD9\xB3\x5B\x49\xC6\x47\xBD\x49\x5E\xD8\x35\x97\xEB\xCE" \
          "\xF8\x0E\x24\x1A\x02\x7C\xD2\xFA\xBE\x5E\x4B\xA4\xC9\x0C\xBD\xA7" \
          "\x58\x98\x83\xBB\x91\x31\x5A\x7B\x2A\x13\x5F\x52\x2D\x7D\xBB\xCB" \
          "\x10\x90\xF4\xF1\xB9\xC7\xE6\x2E\xE7\xBC\x7E\x84\x6A\x5E\x3B\xF6" \
          "\x78\xC8\xD7\xB3\xF4\x73\xC1\x11\x40\x35\xD6\x6B\x4C\x13\x03\x83" \
          "\x7E\xA1\xA4\x3B\xB6\x5B\x66\x56\x65\xBD\x32\xB4\x00\x89\x3F\x8C" \
          "\xB9\x8C\x4B\x6B\xDE\xF0\x67\xC1\xD5\xC9\x22\x9C\x86\x1B\xFA\x2D" \
          "\x3A\x02\x38\x2D\x3D\x90\xEB\x97\xDA\x22\x9F\x9D\xD2\x92\x01\x08" \
          "\x2F\xB7\xCB\xDF\xC9\x5C\xF2\x18\x3C\x45\x88\x25\x2D\x23\x51\x41" \
          "\xEA\x2C\x02\xA9\x27\xE3\x11\xF2\x44\x0D\x2A\x86\x0A\xED\x54\xF3" \
          "\xE1\xE3\x41\x3F\x0B\xAC\xDB\xA3\x27\xC4\xB5\xC2\x22\x66\x63\x50" \
          "\xEF\x94\x7F\x67\xE1\xB7\xA8\xFA\x15\xA7\xE6\x69\x58\x4D\x3E\x6F" \
          "\xBC\x9F\x52\xFD\x86\x25\xB1\xE5\x24\xA3\x25\xE6\x7A\xEE\x3E\xB9" \
          "\x53\x98\xE2\xC1\xA7\x56\x9D\xE1\x36\xD7\x06\x1D\x6D\x4D\xD6\xBB" \
          "\x8A\x55\xE1\x2A\xC8\x11\xFA\x57\x6F\xAE\xF0\x63\x8B\x1A\xCC\x8B" \
          "\x8B\xE0\x84\x88\xC8\x35\x62\x80\x4E\x06\x3E\x19\x97\xEC\x10\x2D" \
          "\xD0\x34\x92\x97\x7C\xB5\xD9\x85\x0F\x9E\xAA\xFC\xD9\xD6\xD5\xC5" \
           , 1024);
    memcpy(&bCryptBlock[3072], \
          "\x24\xC5\x70\x4A\xE2\xEE\x7D\x44\x4C\x2E\x55\xB7\x7B\x5D\xB6\x13" \
          "\xE0\xFB\x8A\x5C\x04\x05\x6D\x1E\xEC\x7F\x6A\xDB\xA6\xDF\xC8\x88" \
          "\x13\x66\x40\xB0\x3F\x4D\x83\xF0\xB6\xDE\xDB\xD4\x0A\xC9\xD7\x76" \
          "\x6D\x2E\x7E\xBB\x13\x3A\x45\xDA\xD6\x9A\x3E\x78\xC9\x4D\x90\x7C" \
          "\xB1\x7A\x51\x72\x9B\x5D\x8A\x49\x85\x9E\x54\x3E\x04\x17\x9A\x7C" \
          "\xC3\x2E\xDE\x08\xA1\x50\x52\xC3\x9A\x8F\xDD\x84\xAE\xF4\x42\x8F" \
          "\x4B\xC4\x06\xE0\xE5\xC8\xEE\x26\x60\xA3\x1E\x23\xF4\xAE\x25\xE0" \
          "\xF2\x2A\xDA\x66\x1E\x9E\xF8\xB6\xF3\x44\x1A\x03\x66\x74\x0B\x23" \
          "\x71\x43\x6E\xA1\xC3\x3C\xD1\x05\x51\xD2\x2B\x92\xD7\xC9\x91\xB7" \
          "\x90\xC0\x01\xA5\xD1\xF7\xEF\x77\xFA\x9C\xE9\xB8\x52\x67\xC1\xA4" \
          "\x96\x48\x6F\x09\x75\xF9\xED\xFC\x32\x32\xF6\x70\x10\xE9\x0D\x7D" \
          "\xC8\xB5\xBA\xB9\x8A\xF4\xE6\x30\x67\x04\x14\x0E\x02\x46\xAE\x3D" \
          "\x41\x6C\x94\xBD\xDC\xE5\x85\x4F\x6C\xDB\x49\x5F\xFD\xBD\xA9\x08" \
          "\x17\xF7\x43\x60\x51\xB5\x37\xF5\x45\xAC\x0F\x60\xEC\xF2\x70\x87" \
          "\xE7\xFD\x26\x21\xDF\x7C\x4F\x30\x7F\x63\xC5\x19\x87\x7D\x27\xFC" \
          "\xEC\x98\x82\x82\x1D\x86\x4E\x98\x1D\xEE\x44\xBA\xDF\xFD\xCB\x64" \
          "\x07\xAF\x78\x20\xFC\xA3\x90\x39\x25\x22\xA4\x29\xA5\xDB\x62\x72" \
          "\xA9\x69\x7A\x97\x95\x40\x53\x8B\x7F\xBD\xF5\x1C\x82\xDD\x2E\x94" \
          "\x55\xB1\x63\xB2\xA6\x23\xA6\x1C\xDA\xBA\xE9\xDC\x4C\x08\xE1\xC1" \
          "\x84\x76\x89\x0C\x86\x8E\xEC\x20\x16\xEB\x59\x0B\x89\x67\x37\xAF" \
          "\x93\xF1\x07\xB6\x70\x64\xCE\x30\xB0\x80\x5D\x24\x35\xA1\x83\xC4" \
          "\x0F\x3D\x5B\xAF\xDD\x53\x73\xEC\x1F\x2E\x5F\x8C\x6A\x4A\x67\x4E" \
          "\xD9\x52\xD5\xAC\x4C\xB3\x5D\xB8\x6B\xA7\xB3\x6A\xDB\xF2\x45\xCB" \
          "\xC4\x4A\xC5\x37\xA5\x5B\xFB\xE7\x63\x61\xFF\xF7\xC8\x3C\x03\x49" \
          "\x39\x8F\x2B\xBF\x59\x82\xA3\xF7\x22\x00\xD7\x16\xA0\x36\x19\x3C" \
          "\x0F\x3A\x2D\x7E\x6C\x0E\x41\xE0\x7F\x67\xF1\x1B\xAC\xBC\x9B\xA5" \
          "\xDC\x62\x89\xC8\x64\x2E\x44\xB6\x72\x3F\x72\x4B\xB5\x64\x8C\x11" \
          "\x13\xE9\xC7\xCD\xA9\x8D\xB2\x6C\x73\x8B\xCE\x1C\xFA\xA6\x00\xCD" \
          "\xB2\xE1\xCE\xDF\xA5\x19\x72\x6A\xE9\x0D\x3E\x39\x07\x81\xFA\x9E" \
          "\x94\x54\xBC\x9C\x1F\x0E\x3A\x1D\x73\x96\xD5\xA8\x33\x9E\xA0\x2F" \
          "\x94\xD4\x37\x64\xAD\x95\x7C\x21\x53\x1B\x17\x19\x1D\x5D\x28\x7C" \
          "\x33\xE5\x6A\x03\x6F\xD6\x33\x37\x52\x6A\x8A\x30\x2A\x0E\x6D\x38" \
          "\xDF\x7B\xDE\xE6\x94\x2D\xF9\x98\x41\x1E\xC7\x55\xBB\x97\xC9\x3E" \
          "\x72\xC0\x7B\x13\x79\xAE\xBB\x4B\x96\x55\x76\x1D\x3B\xFF\x40\x3A" \
          "\x76\x15\x8E\x7C\xC2\xE4\xD1\xA5\xB9\x44\x02\xE7\x27\xEC\xEB\x21" \
          "\x5B\x20\xDB\x00\x8C\x68\x78\xD5\x15\x48\x4A\xA9\xAA\xA5\x26\xB1" \
          "\xED\x6B\x92\xB3\x0B\xF7\x85\x3F\x73\xE6\x93\xE0\xE6\x84\x5B\x0C" \
          "\x31\x0D\xCD\x95\x44\xE7\x2E\xF7\xE5\x05\xC0\x85\x4F\x45\x74\xA5" \
          "\x39\xD0\xF4\xAF\x45\x9B\xF1\xCA\x31\xAE\xA3\x60\xD5\x79\x94\x4A" \
          "\x31\x5A\xE4\x37\xDB\x6F\x83\x99\xD0\xD4\x68\xDD\x9E\xB7\xD3\x9E" \
          "\x5C\x3C\x89\xF3\xF7\x46\x9C\xF8\xC5\x41\x54\xE8\x7D\x42\x2D\x93" \
          "\x65\x1C\x47\xF8\x46\x7B\x61\x42\x1E\xAD\x04\xD2\xE8\x16\x43\x8D" \
          "\x18\xDE\xE3\xBB\x52\x25\x2D\x54\xBD\x73\x2F\x3C\x4F\xA9\xFE\x70" \
          "\x97\x4B\x67\x07\x0C\xF7\x9B\xBC\xD5\xE5\xED\xE4\xE0\x3E\x73\x21" \
          "\x09\xF1\xAE\xB5\x4B\x41\xD3\xAF\x93\x3B\x26\x4D\x9C\x6B\xE2\xA1" \
          "\x1B\xEB\x2C\xAC\xE8\x04\x44\x66\x69\x1C\x5B\xE7\x40\x7B\x4F\x6D" \
          "\x8A\xA0\xF3\x85\x6A\xC9\x1F\xD1\x5F\xB4\x1D\x02\x8E\x1D\xDA\xD9" \
          "\x9F\xE3\xFC\x0A\x20\x03\x54\x04\x95\x61\x03\xBA\x66\xC1\x1B\x38" \
          "\x21\x8B\xDA\xA6\x83\xA0\x5A\xBE\x5F\x5B\x46\x4A\x38\xEB\xCA\xA0" \
          "\xC8\x98\x94\x9C\xD9\x20\x70\x42\xD6\xB6\xA8\x12\xE2\xDA\x59\x8D" \
          "\xEE\x7A\xBC\xD4\x20\x15\xC9\xF3\xAF\x76\x45\x69\xBB\x9E\x47\xF6" \
          "\x3A\x0F\xDC\xB8\x44\x47\x26\x23\xAD\x8F\xAC\x3B\x56\x30\x86\x46" \
          "\x45\x42\x60\x8D\x6F\xF5\x77\x5E\x41\x58\xC9\xF7\x04\xF1\xE1\x5D" \
          "\x08\x46\x7C\xE9\x1B\x96\xFC\x6B\xA0\x95\x4C\x26\xD7\xFE\x03\xF5" \
          "\xA7\x9C\xC9\x2F\xF1\xF4\x8C\xE4\x3B\x04\x6D\x11\xCB\x82\x1C\x77" \
          "\x7C\xE5\x27\x33\xF4\xED\xC3\x23\xD7\x67\xBA\x36\xB4\x29\x78\xBA" \
          "\x9C\x56\xC6\xCA\xC4\xD7\x22\x00\x31\x7C\xB6\x28\x6F\x80\xBA\xF0" \
          "\x9E\x3A\x0B\x31\xBF\x5E\x4D\xF5\xA9\x60\x99\x12\x9E\xD4\xF0\x9D" \
          "\x26\x4A\x15\x71\x9B\x88\xF9\xAC\xE4\x2F\x8B\xCA\xAA\x48\x0C\xBD" \
          "\x8C\x48\xB4\xFF\x1B\xB9\x2C\x6C\x25\xED\x80\xD7\x18\xD9\xFB\x46" \
          "\xCF\x65\x2A\x07\xCD\x76\xDF\xBA\x40\x7C\xBA\x7E\x8A\x8A\xC0\x64" \
          "\x31\x7D\x44\x76\xF4\x8E\x88\x24\x42\x58\x46\x19\x1D\x64\xCB\xEE" \
          "\x26\x3B\x6C\xB1\xD1\x20\x28\x01\x82\xD1\x4E\xB1\x98\x5B\xCB\x05" \
          "\x0F\xF4\x46\x10\xB4\x08\x4F\x8C\x1A\x88\xBD\xA6\xB9\x25\xB9\xC1" \
           , 1024);
    nBlockLen = 4096;
    memset(bPlainBlockExp, 0x5C, 4096);
    bPlainBlockExp[0] = 0x25;
    bPlainBlockExp[4095] = 0x22;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 16);
    DspHex("[IN ]bCryptBlock    =", bCryptBlock, 4096);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    DspHex("[IN ]bIV            =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptCBC(nSock, nAlgo, bKey, bCryptBlock, \
                             nBlockLen, bIV, bPlainBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "算法类型=2，数据长度=4096，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bPlainBlock    =", bPlainBlock, 4096);
    DspHex("[OUT]bPlainBlockExp =", bPlainBlockExp, 4096);
    ASSERT_OUT_HEX(bPlainBlock, bPlainBlockExp, 4096);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptCBC_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bCryptBlock[4104];
    int  nBlockLen;
    BYTE bPlainBlock[4104];
    BYTE bIV[16];
    BYTE bPlainBlockExp[4104];

    bufclr(bKey);
    bufclr(bCryptBlock);
    bufclr(bPlainBlock);
    bufclr(bIV);
    bufclr(bPlainBlockExp);

    nAlgo = 3;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8697 A4B5 C2D3 E0F1 */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\x59\x99\xC3\x06\xAB\x84\x01\xB2",\
                 24);
    memcpy(bCryptBlock, \
          "\x1B\x7E\xEC\x99\xFD\xA8\xE8\x98\x91\x2B\x05\x2E\x24\xAF\x61\xCB" \
          "\xA9\xC8\x44\x26\x0A\x52\x7B\x45\x50\x55\xB4\xF5\x24\xA2\x0B\xEE" \
          "\xE0\xF2\x61\x7D\x67\xE6\x22\x3A\x84\x4E\x71\xC6\xA7\xE2\x3F\x59" \
          "\x09\x57\xA4\xED\x10\x44\xE8\xB2\x56\xE1\x6E\xD1\xF4\x9F\xDA\x21" \
          "\x7D\x62\xC6\xB2\xAB\x9E\x78\x57\x81\xA7\xBA\x20\x87\xEC\x67\x9F" \
          "\x51\xE0\xE5\x3E\xB5\xE8\xE1\x68\x18\x08\xE4\x04\x80\xEE\x02\x30" \
          "\x64\xB4\x39\x43\x93\x33\xC0\x22\xA8\xD6\xF5\x0B\x89\xEB\xC8\x69" \
          "\x3D\x41\x2F\xB4\x1A\x11\xBD\xD2\x89\x08\x24\x73\xDF\xB7\xD6\x0E" \
          "\x45\x7A\x42\x1E\xE9\x19\x60\xCC\xDD\x9D\xDF\x75\x70\xA6\xA6\xEE" \
          "\x80\xCB\xA1\x51\xFA\x5D\x3E\x8F\xCF\xD6\xE5\x8E\x83\x37\x76\xA4" \
          "\x9F\xA1\xCE\x0A\x3E\x73\xC8\x07\x72\x50\xF1\x6D\x45\xDB\x91\x5C" \
          "\xC8\xC3\xDF\x5B\x21\xEE\x69\x46\xDE\x43\x44\xFD\x91\xDC\x27\xAD" \
          "\xC3\xDC\x6B\xFD\x7B\x06\x21\xED\x7D\x07\xAE\xF5\x4C\x71\x5C\xF7" \
          "\x34\x4F\x2E\x43\x67\xEF\x9E\xA8\x51\xCE\x1D\x96\xC2\x7F\x71\x69" \
          "\x13\x22\x50\x8D\xC1\x4C\x4E\x71\x30\x38\xF3\xA4\x46\x18\x91\x70" \
          "\x68\x2D\x15\x70\xF5\x2B\xA7\x42\x10\xE0\x79\xEC\x27\x9E\x5F\x36" \
          "\xA9\x08\xE6\x55\xB1\x13\x78\x44\x25\x65\xE8\x6D\xFF\xF3\xE6\x7C" \
          "\x38\x21\x57\x83\xD7\xED\xC7\x8E\x0C\x98\x27\x23\x91\xAB\x8D\xB0" \
          "\xC2\x4C\x2F\xC5\x89\x78\xA4\x70\xC5\xF3\x7F\x8B\x3C\xF4\x3E\x48" \
          "\xF5\x66\x9E\xCB\xC6\xF2\xAE\x37\x7D\x38\x0E\x2B\xB4\x14\x3C\x9D" \
          "\x98\x08\x1D\x96\x36\xE3\x2C\xD7\x38\x29\x21\x35\x24\xDE\xF4\x1A" \
          "\xBC\x51\x6B\x07\x54\x3F\x33\x1C\x56\x38\x5A\xC0\xE5\x9C\x5E\xB2" \
          "\xE2\x21\x3A\xC7\xA2\xCF\x78\xF6\xA3\x09\x4C\x84\x43\x60\xCA\x5F" \
          "\x30\x6F\xAF\xE6\x64\xB0\x8E\x5C\x0C\xFF\x15\x68\x7C\x0B\x28\x63" \
          "\x46\xF9\xCC\x84\xC3\xC6\x99\xCA\x67\x1C\x5E\x01\xFE\xDD\x26\x74" \
          "\x75\xB0\x30\xC7\x80\xB2\x1D\x7A\x2C\xEB\x0A\x75\xA3\x0A\xDA\x5D" \
          "\x13\x38\x45\x2B\x44\x87\x9D\xCC\x39\xE5\x70\xD2\xE6\x0F\xE4\xB4" \
          "\xF2\xA0\xE3\xE5\x71\xA1\x42\x57\x6B\x2F\x7B\xE4\x4A\x38\x5D\x5D" \
          "\x8B\x32\xB7\x52\x7E\xC3\x41\xFF\xCC\xEB\xFC\xFC\x50\x4D\x03\xC2" \
          "\x0D\x4A\xBE\x11\xC8\x4C\xAC\xD7\x1B\xFA\x9F\xA1\x38\x81\x3C\xEC" \
          "\xEB\x49\xBA\x90\xB5\xBF\x1C\xB1\x86\x99\x54\xC8\xAC\xC4\xDB\xED" \
          "\xF2\x1D\x79\xB2\xF1\x9A\x96\x52\x81\xDC\xBF\xB5\x32\x67\xEB\x16" \
          "\x87\x81\x61\x31\xD9\x91\xC4\x59\x41\x4B\x4F\xE0\x3B\x97\x6C\xFE" \
          "\x36\x88\x75\x2C\x33\xD9\xD4\x07\xE7\xDC\x72\x82\x09\x85\xDB\x03" \
          "\xE1\x34\xCA\x43\x39\x4E\x5C\xF9\x73\xF6\x6D\x0E\x14\xD8\xBC\x97" \
          "\xDC\x8B\x62\x3E\xEC\x2A\x5D\xE6\xA2\x64\x05\x38\xAA\xB2\x16\xBA" \
          "\xC4\x95\xFD\xA4\x35\xE2\x03\x7E\xBC\x1A\xAF\x44\x50\xAC\xE6\xFA" \
          "\xDD\x95\x8E\x96\x33\x42\x19\x51\x02\x9D\x37\x6E\x41\xF8\x96\x20" \
          "\x79\x82\x38\x04\xFD\xB6\xF4\xA7\xA1\x38\xF0\xF6\x58\xC6\x71\x5F" \
          "\xF9\x3E\xB4\x86\x2E\xC2\x64\x9D\xF0\x14\x58\x2E\x35\x7B\xB7\x6C" \
          "\xF6\xF9\x48\x52\x0D\xC3\x0A\x56\x53\x4F\x99\x96\x5C\x2C\xBC\xB4" \
          "\xA3\x3F\x86\x66\x50\x92\x8C\xBD\xD9\x5D\x3A\xBF\x30\x65\x2A\x92" \
          "\xB9\x26\x91\xC9\x5A\xFA\xD7\x27\x49\x7E\x35\x91\x48\xD0\x73\x61" \
          "\x50\xB9\xCC\x73\x3A\x36\x63\x8A\x7B\x65\x87\x7E\x1F\x3C\x12\x62" \
          "\x75\x02\x30\x85\xCB\x15\xB3\x98\x12\x33\x17\xE7\x29\xB0\x88\xB9" \
          "\x1A\x6B\xAB\xDD\xFF\x47\x79\x26\x77\x9B\x6B\x67\x0C\x5B\x53\x65" \
          "\x74\x01\x19\x29\x8F\x62\x06\x6F\xFC\x46\xE1\x4E\xA9\x75\x48\x61" \
          "\xAE\xCD\xC9\xF2\xB4\x8B\x33\x3E\xA2\xB0\x61\x79\xB3\x38\x3A\x22" \
          "\x20\x7E\x6D\xA8\xA4\xBA\x95\x2D\x62\xA3\x3B\x20\x3C\x12\x9E\x26" \
          "\x04\x66\x5E\xF0\x4A\x53\xC5\x4B\xFC\x34\xCB\xEB\x11\x5D\x30\xD9" \
          "\x15\xF4\x83\x6F\x24\x4D\x49\x78\xDD\x60\x05\x9C\x38\xE5\x65\x3D" \
          "\x05\x8D\x58\xAC\x5C\x5C\xFC\xA9\x09\x62\xA9\x97\x6B\x8C\x7C\x40" \
          "\xF3\x04\x09\xAF\xC9\x21\x21\x1B\x93\xF9\xD3\xCF\x5E\x7E\xDA\x87" \
          "\xC0\x0E\xE5\x1E\x80\x8C\xEF\xC8\xDA\x2F\x11\x6C\x79\x2C\x28\x42" \
          "\x62\x26\x01\xE7\x22\xC3\xDF\x57\xCF\xCC\x9B\x4A\x2D\xB5\xF1\xF1" \
          "\x35\x80\x72\xA1\x2E\xA2\xAE\x92\xC8\x5A\xE5\xB1\xCE\x2F\xAA\x4C" \
          "\x2E\x3F\x80\x46\x6B\x01\x38\xA1\xA3\x28\x71\x40\x9F\x61\x3A\x65" \
          "\xCD\xB2\x7F\xF6\xFF\x9F\x62\xBE\x4F\x81\xBA\x4D\x9B\xB3\x29\xD7" \
          "\xB4\xE6\x7C\x1B\xF6\xFA\x3B\x41\xEC\x31\x84\xB1\x1E\x98\x5E\x4C" \
          "\x82\x0F\x8A\x3D\x62\x05\xC3\x6D\x4C\xBF\x1F\xF4\xF1\xDD\xB6\x51" \
          "\xA6\x60\xD3\x37\x76\x0E\x3A\x57\x36\x90\x07\x9A\x36\x1C\x5F\xBE" \
          "\x72\x05\xAC\x0B\x64\xE8\xE1\x87\x2C\x50\x5B\xDC\x51\x77\x06\x2C" \
          "\xA0\xCB\xB8\x2C\xEF\x0F\x99\xC8\x85\x17\x9A\x54\x51\x62\x15\xB6" \
          "\x87\x49\xF2\xF1\x30\x84\x88\x06\x05\x1E\xA0\xE0\xDA\x6B\x4B\xEF" \
           , 1024);
    memcpy(&bCryptBlock[1024], \
          "\xFF\xA1\x72\xA4\x4A\xFD\xC5\x83\xC6\x25\xE1\x82\x24\xA6\x9A\xBA" \
          "\x8D\x86\x90\x46\xAC\x4E\x49\x41\xDD\x92\xB8\x04\xA4\x21\x08\x72" \
          "\x01\xD2\x77\x3E\x84\x24\x28\xE3\x3C\x52\x15\x14\x85\xDC\xB5\x9C" \
          "\x9A\x0E\x3B\x90\x9E\xD8\x36\xD4\x0F\x7E\x5F\x02\xC6\x03\x15\x3E" \
          "\x0C\x5A\xD6\x8A\x94\x03\xE4\x89\x69\x6A\xF6\x9C\xE4\x5C\xF1\x58" \
          "\x81\xC3\xC6\x60\xB5\xAF\x60\xFE\x43\xBC\xC1\x2C\xA5\x39\x9A\xF5" \
          "\xE9\x26\x3D\x12\x27\x0F\xD0\x85\xE5\x9F\xE0\x7A\x5B\xDA\x7C\xD1" \
          "\x3E\xEF\xC0\xB0\x4B\x36\xAD\xB0\xE9\x27\xF5\x47\xB1\xA5\x02\xDD" \
          "\xD9\x0D\x07\xAE\x96\x64\x0E\x2A\x4E\x92\x49\xCB\x3B\xD4\xF1\xAF" \
          "\x3E\x64\xA7\x12\xBC\x56\xBA\x22\x93\x63\x56\x7A\x0C\x44\x09\x91" \
          "\x8E\x78\x6A\x42\x2F\x10\x2E\xF3\x16\xDE\xA2\xA9\xF8\x3F\xDD\x09" \
          "\x67\xAA\x58\xB8\xDA\xBF\x81\x98\x7B\x7F\xE5\x10\x00\x85\xC5\x2B" \
          "\x8B\x8F\x9F\x8B\xB2\x49\x5A\xE9\x3F\xDA\x60\xD6\x60\x20\xC9\x10" \
          "\xF5\x9F\xFE\xB8\x0D\x68\xAD\x66\x3F\x52\xB5\xC3\x4A\xBD\x65\x44" \
          "\xBB\xC1\x01\x7F\x0E\xA9\xE3\x50\xDF\x58\x08\xB7\x65\x5B\xF2\x03" \
          "\x48\xD0\x9E\x77\x94\x05\xEB\xF4\xDD\x5D\xD7\xFA\xDB\x30\x84\xC9" \
          "\x6E\xFA\x14\x3F\xF2\x6E\x29\xFA\x38\xB1\x3E\x9C\xEF\x3D\x96\x4A" \
          "\x2A\x4D\x62\xFE\x0F\x82\x96\x3D\x82\xB8\x12\x52\xA2\x0B\x11\x24" \
          "\x0B\x8F\x64\x37\x1B\x11\x6D\xAC\x00\x1A\xF3\x5A\x7C\xFD\xFD\x73" \
          "\x05\xC1\xB4\x09\x86\x2F\x57\x45\x50\xAD\xBD\x9D\x63\x92\x24\x69" \
          "\xED\x31\x19\x79\x96\x02\x25\x15\xF2\xD4\x4F\x2C\x80\x4D\x03\x03" \
          "\xC8\xA1\x19\x4E\xA5\x0B\x87\x4C\x68\x0A\x1A\xB6\x14\x45\x2A\x77" \
          "\x4D\x58\x77\xA4\xDC\xAB\xA6\x60\xEC\x71\x70\x86\x49\x0E\x42\xFD" \
          "\x42\xAB\x35\x1F\xEA\x0F\x78\xD8\x0D\x36\x7E\x65\x88\xEC\x12\xED" \
          "\xE8\x30\x0F\x62\x9C\xD9\x0B\x24\x97\x70\xA3\xBD\xA4\x01\x93\x59" \
          "\x98\x57\x79\xEE\x7E\xA8\xF0\xA1\xAD\x2D\x23\x30\x4F\xD1\xC2\x23" \
          "\x8C\xCD\x89\x8E\xD9\x79\x0D\x69\xC3\x94\x88\xFD\xA3\x46\x23\xF7" \
          "\x1D\x50\x8D\xEC\x47\x66\xFC\xB6\x3B\x69\xBC\x62\x33\x29\x16\x66" \
          "\xEF\x13\x6C\x13\xEE\x29\xC7\x8A\x41\x2E\x48\x0C\xB3\xF0\x26\x48" \
          "\x97\xAD\xF3\x0E\xB9\x4B\x67\x7A\x1D\xBA\x82\x77\x11\xDD\xFD\x93" \
          "\x51\xDF\x15\x3F\x29\xDA\x98\x29\x01\x08\xD2\xD0\x82\xF5\x65\x42" \
          "\xFD\x6A\x22\x48\x69\x3A\x70\x5A\x00\x9C\x0E\x4B\xFF\x98\x51\x30" \
          "\x6B\x3D\x02\xDA\xB5\x42\xB7\x13\x48\x44\x3F\x36\xDE\xBE\xAB\x81" \
          "\x33\x96\x5A\x50\x3D\xA0\x79\x60\x81\x32\x49\xED\x00\x2C\x81\xA3" \
          "\xC0\x87\xC1\xD4\x15\xF8\x53\x78\xCA\xF9\xD4\x7B\x00\x37\xDE\x64" \
          "\x96\xD7\xEA\x38\xA8\x45\xFB\x46\x9D\x53\x00\x18\xA7\x3C\x16\x0D" \
          "\x91\x9E\xF8\x8B\xAA\x9A\xE6\x1F\x89\x2D\xC5\x4B\xF1\x47\xFB\xA6" \
          "\xF0\x13\x53\x29\xA7\x62\xF5\x88\x22\xF0\x26\xDF\x95\x5F\xC6\xC5" \
          "\x7F\x07\xF5\x0A\x66\x23\x78\x8D\x87\xC1\x93\x7E\xC8\x81\x83\x6B" \
          "\x8C\x2D\x30\x1E\xDC\x5C\x1C\x46\xD7\xC2\xC0\x1D\x65\x95\x51\x95" \
          "\xD2\xED\xF1\xF8\x92\x49\xAD\x03\x44\xC9\x16\xA1\x3D\x3F\xCB\xD5" \
          "\x7A\xC6\xCA\x4B\xE7\x91\x74\x7B\xBD\x1F\xB2\xE1\x96\xD0\x8E\xAA" \
          "\x86\x55\x03\x6D\x54\xFA\x7C\x79\x28\x53\xA3\xCD\x6C\x75\x2A\xB3" \
          "\x5C\xFC\xBE\x3C\x5C\xF6\xE8\xB5\x7C\x6D\x6C\x49\x6E\xB2\xF9\x99" \
          "\xEF\x70\x84\x4F\x26\x0E\x68\x47\xB8\x3C\x60\x2F\x6F\x6E\x17\xBB" \
          "\xAF\x36\x3A\x46\x45\x22\x09\xE4\x08\xC6\x7A\xCA\x7D\x21\xCD\xC4" \
          "\x1C\x65\x14\x24\x04\xAD\xA9\xAC\x6B\x6F\xE2\xE7\x6E\xB9\xB0\x3F" \
          "\xB3\x41\xD4\x99\x23\x5E\x86\x8F\xFC\x2E\x93\x11\x44\x46\x0B\x26" \
          "\xC5\xDC\x94\x9A\x91\xA3\x8B\x71\x8E\xD3\xB5\x51\x7A\xF0\x00\x27" \
          "\x5C\x0E\x0C\xF4\xCC\x90\xAD\xD5\x63\x67\x6A\xAD\x22\xFA\xBC\xEE" \
          "\x57\x8E\x63\x15\x6D\x24\x75\x97\x38\x3E\xF8\x28\x97\x54\x9B\x2A" \
          "\xF2\x4F\xAA\xD2\xCA\xA8\x73\xC5\x57\x8F\x2E\x61\xF7\xAE\xBA\x2A" \
          "\x5E\xA6\xD5\xA4\x44\xD7\xBB\xBD\x67\x15\x9D\xD0\x9D\xA7\x65\xE3" \
          "\xFD\x11\x2E\x35\xFC\xAE\xCD\x42\x7C\x91\xE6\x27\xAA\x4F\xF3\x73" \
          "\xF3\xDB\xCE\xB0\x74\x98\x6F\x12\xBB\xF9\x18\x27\x6E\xAC\xD8\x4F" \
          "\x89\xE5\xEC\xC4\x09\x65\x05\xEF\x32\x46\x01\x6D\xF0\x0C\xFC\x63" \
          "\x7B\x9F\x8D\x3E\xFB\x8F\x7A\xA9\x64\x41\x12\x6D\xD7\xD2\xD4\xF9" \
          "\xDC\xD0\x83\x8D\x98\x33\xCB\xC1\xC4\x22\xDA\x48\x36\xE2\x59\x3C" \
          "\x5D\xF5\x3F\xAC\xE6\x6D\x90\xD1\xD5\xD1\x5E\x46\x6E\xC3\xA9\x8D" \
          "\x4D\xF8\xDF\xE3\x7C\xA7\xB9\x5A\xF0\x2A\xA3\x4D\x65\xF0\x7A\x6E" \
          "\x2B\x40\x1E\x23\xD9\xAF\x3B\xCA\x34\x9D\x70\xD9\x9E\xDD\xB8\x66" \
          "\xD7\x47\xB6\x50\x6B\xA5\xD7\x27\x98\xB6\xBE\xD1\xC0\x7F\x2B\x0A" \
          "\x43\x95\x6A\x35\xC2\x6C\x58\x42\x0B\xCE\x7B\xBA\x42\xDD\x50\xE2" \
          "\xFA\xEA\xDD\xAC\x2D\xD5\x0D\x28\x06\x59\x72\x35\xB7\x23\xF6\x3E" \
           , 1024);
    memcpy(&bCryptBlock[2048], \
          "\x3D\xCD\xE9\xC9\xF6\xB0\x55\x00\xF8\x24\x9E\x4A\xC0\xFC\x6D\x7C" \
          "\x23\xCB\x5B\x0F\xF4\x84\x54\xB9\xDA\x4F\xB2\xAB\x9E\xA9\xEF\x92" \
          "\x81\x6D\x0A\x34\xBA\xB2\xE7\x6D\x31\x06\x71\x8A\x30\x82\xAC\xE9" \
          "\x3F\x02\xCC\x31\x57\x6C\x73\xCB\x6F\xBA\x2F\x15\xD8\xAD\x63\xDE" \
          "\xB7\xEB\x4B\x47\x23\x70\xB9\xD9\x13\x29\xCC\x46\x69\x04\x96\x58" \
          "\x55\x24\x2C\x28\x50\xC0\x98\xA5\x4C\x8D\x22\xE6\x3A\xDC\x2E\x5A" \
          "\x5E\xA4\x27\xEC\x83\x3D\xF8\xDC\xA1\x30\x67\x57\xF5\xC8\xAA\xEA" \
          "\xF6\xC2\x81\x71\xD0\x9C\x05\xF8\x39\xDA\xA1\xCD\xE3\x7F\xC0\xD1" \
          "\x43\x1C\xB4\x0F\xC8\x6B\x52\x1E\xF9\xCF\x09\x51\x0E\xDA\x66\x25" \
          "\xB3\x53\x56\x6A\x29\x1E\x3D\x6B\x41\xB2\x9F\xD7\xA7\xC7\x1E\x09" \
          "\xA8\x42\xAD\x75\xCC\x4E\x3A\xA8\x9D\xE0\xF5\x0C\x77\x61\x82\xD0" \
          "\xFB\x0D\xB5\xA6\xB1\x14\x04\x2E\x5E\x85\x90\x53\xB2\x9C\x45\x0A" \
          "\x9C\x0B\xE9\xBA\xA6\x3F\x36\x88\x67\xC4\x2F\x51\xA4\x88\x52\xB3" \
          "\x21\x6A\xD7\xC5\x00\x1D\x86\x62\x90\xA1\x70\x03\xD9\x82\xF2\x05" \
          "\xFB\x54\x38\x3B\x3B\x96\x1F\x01\xE7\x15\xDC\xDD\x71\xB4\x89\xB2" \
          "\x43\x55\x2E\xC4\xCC\x42\x04\x0F\x6A\xBF\xF3\x2C\x7D\x0F\xFA\x14" \
          "\xC5\xB6\x17\x77\x35\x1C\x50\xF3\x51\xA1\x6E\x11\x71\x78\x84\xC1" \
          "\x3D\x01\xAE\x2C\x23\x38\x44\x9C\x69\xF2\x54\xE4\xD2\x31\xB9\x3A" \
          "\x66\x9A\xA1\x45\x48\xB5\x3A\x51\xAB\xA9\x60\x91\xC7\x1E\xA2\x94" \
          "\x22\xF9\xEC\xE5\x71\xE9\x7F\x56\x9D\x19\xE7\xED\x75\x23\x49\x7E" \
          "\xA9\x0A\xF0\xAA\xB8\xEC\x16\x4A\x6E\x7B\xE0\xF1\xDB\xEF\x1D\x19" \
          "\x3E\x2D\x3E\xB2\x55\xE9\x45\xA5\xAD\xAF\x1B\x3D\x36\xDE\x9A\xD4" \
          "\x3A\x7E\xA6\x41\x54\x27\x2C\x0C\x94\x7D\xBA\xB0\x09\x47\xC1\x92" \
          "\x2C\x3C\xF6\xCE\xB1\x7E\x09\xA1\xAB\x57\x4C\x6B\xBF\x8B\x6C\x31" \
          "\xCD\xE3\x51\x95\xED\xF5\xF8\xCE\xFD\xB0\x68\x80\x5C\xF0\x27\x79" \
          "\x1C\x4C\x32\x64\x79\x04\x0B\x41\xCA\xDF\x2F\xBE\xD1\xD4\xDA\x9B" \
          "\x8E\x50\x10\xFA\xCD\x57\x28\xFF\x86\x6E\xF4\xAB\xDF\x68\xA0\x89" \
          "\xB5\xFF\xFB\x07\x07\x5A\xB5\x3A\x3F\x41\xE2\x6A\xBC\x14\xA7\xDF" \
          "\x78\xE0\x83\x94\x6A\x48\x1A\x8A\xF7\x1F\x9C\xEF\xBA\x85\x6E\x5A" \
          "\xD3\xCA\xA8\x41\x43\x75\x94\xB5\x3A\xAA\xBD\x47\xEC\xC1\x2A\xA8" \
          "\x9A\xF7\x81\x05\xAB\x8C\xDC\x9D\xE1\x6C\xED\x19\x54\x50\x4D\x4F" \
          "\x63\x9C\x42\xD8\x86\xE1\x4D\xD1\xB7\x2E\xC3\xDC\xFE\x9F\xA0\x1B" \
          "\x5C\x5F\x4C\x66\xAD\x6C\xA6\x6C\xE9\xC7\x97\x6E\x7C\xC8\x0C\xC2" \
          "\xBF\x0F\x7C\x20\x55\x70\xE0\x62\x22\xE1\x81\x9E\x29\xDF\x1C\x56" \
          "\x00\x84\x63\xC1\xC4\x8F\xEE\xCB\xA4\x20\xF2\x37\x69\xBD\x22\xCA" \
          "\xE2\x63\x1A\x71\x36\xD8\xC9\xAE\xFA\xB6\xB8\x9F\xCA\x8E\x9E\xF8" \
          "\x19\x79\x34\x3A\x36\x74\xAB\x13\xB5\x90\x97\x0E\x08\x97\xD5\xB7" \
          "\x10\xEE\x17\xF8\xD7\xBE\x18\xAC\xD5\x94\x26\x38\xAE\x45\x3F\xB6" \
          "\x4C\xB9\x33\xC3\x50\xB5\x0A\x0D\xCC\xDD\xEF\x6C\x3C\x2D\x5D\xDB" \
          "\x8C\x2B\x17\x48\x66\x68\xA7\xD7\xA0\xC1\x53\x9D\x66\x80\x76\x05" \
          "\x47\x0F\x89\x53\xC8\x9F\xB5\x51\x7D\xDC\x62\x2B\xFF\xDE\x84\x37" \
          "\xDB\x51\xE7\xF4\x2D\x92\x9C\xC5\x11\xDA\xE6\x45\xAD\x5B\x5C\xB8" \
          "\x7B\xE0\xBF\xDC\xF5\xC3\xC1\x95\x49\xE8\x54\xB0\x94\x90\x0F\x9D" \
          "\xC0\x7F\x3A\x56\x01\x4E\xA2\x6E\xFB\xC6\x27\x46\x05\x9A\xE8\x15" \
          "\xA0\x64\xC1\xBE\x08\x29\x77\x19\x34\x67\x59\x4D\x4E\x88\x36\x70" \
          "\xBD\x78\xD4\x8F\xE3\x0B\x54\xF4\xF8\x6D\x62\x97\x4E\x30\x35\xA9" \
          "\x7F\xD7\x70\x7D\x60\x70\xE7\xAE\xC1\x29\xA9\xED\xFF\xB2\x6E\xEC" \
          "\x6C\xFD\x79\xA4\xB2\x32\x8A\xC0\x71\x1A\xDD\xD5\xA9\x27\x3F\xCF" \
          "\x79\x9B\x45\x3D\x72\xB5\x52\x24\x0C\x7B\x7E\x4C\x4D\x7C\xFD\xF7" \
          "\xCA\x35\xE8\x85\xA1\x8B\xC4\xC2\x1B\x4D\xDF\xA0\x88\x24\xAF\x1F" \
          "\xB6\x33\xED\x44\x69\x58\x42\x39\xA3\x1C\x82\x49\xDB\x51\x80\xFE" \
          "\x65\xFA\x71\xEF\x3C\x42\xA5\x33\x84\x6A\x0C\x5E\x9B\xCF\xE4\x4B" \
          "\x16\xD3\x5B\xE3\x81\x13\x51\x78\xAD\xB5\x54\x8C\xB5\xE0\x6B\x4A" \
          "\x3B\x92\x98\xAC\x13\x62\xE6\xA0\xA1\x26\x2B\x8F\x1A\xA7\xEF\xDD" \
          "\x7C\x47\x24\x7D\xAD\x52\xEA\x8D\xBF\xEC\x0A\xF3\x75\xE5\xE6\x09" \
          "\x8A\xC4\x94\xF2\x4F\x78\xC0\xB0\x9A\x38\x41\x1F\xBE\xFD\x4C\x1C" \
          "\x24\x7C\x50\x88\x3E\xA4\x81\x6C\x5E\x5A\xB6\x9A\x47\xAF\x0C\xBF" \
          "\x55\xDB\xE2\xDF\xA4\x9D\xB4\xA9\x12\xCF\x39\xE3\x43\x22\xC9\x16" \
          "\x82\x44\xE3\x84\x63\xF5\xF7\xEF\x90\x66\x48\x4E\x85\xCD\x7C\x6B" \
          "\xFF\x4F\x9A\xE6\x6F\xFF\xE0\xC1\x50\x58\x40\x14\xAB\x8D\xC9\xD9" \
          "\xAE\xEF\xDA\xAA\x87\xC1\x75\x7A\x2E\x16\x74\x2E\xF9\xAD\xE8\x02" \
          "\x1C\xF1\xB6\xCD\xF5\xDA\x38\x6D\x03\xD9\x2B\x40\x63\x8A\xDD\xB0" \
          "\x5D\xF6\x33\x5E\x20\x51\x90\xB4\x6E\xEB\x49\x0E\x6A\xE1\x6A\x52" \
          "\x8B\x4E\x69\x98\x11\x37\x20\xB4\x2D\xA5\xB2\xBB\xBF\x98\x55\xF0" \
           , 1024);
    memcpy(&bCryptBlock[3072], \
          "\x21\xE9\x7E\xBD\x43\x6A\xB9\x94\xE3\xC0\xF6\xE2\x44\x10\xCB\xE5" \
          "\xCA\x7E\x6D\xB7\x3B\x9B\xF5\xFB\xF7\xBA\xF5\x79\x5D\x8A\xA5\x73" \
          "\x2E\xCE\xAB\x90\x10\xDE\x7F\x7A\x43\x64\xBA\x3B\x90\x2C\xC5\x01" \
          "\xA8\x91\xBF\xB4\x2E\x02\x71\xCD\xF2\x40\x8F\xE3\x6C\x9D\xD6\x75" \
          "\x49\xB3\x25\x2E\x38\x31\x52\x01\x16\x19\x53\x0D\xC9\x37\xB8\x6D" \
          "\x68\xB5\xB5\x38\xC9\x1D\x95\xAD\xD7\xB4\x4B\xDA\xED\x77\x50\xB7" \
          "\xF1\x44\xC1\xCE\x30\x93\xA0\xE7\x54\x4B\x71\x2F\x1D\xE9\x1C\x2C" \
          "\x3F\x98\xDA\x05\x58\xDE\xA8\xB8\x16\x9E\xBF\x55\xB9\x14\x4A\xB4" \
          "\xE3\x69\x12\x3D\x09\x9C\xA2\xCB\xBC\x74\xA1\xFC\x91\x63\x02\x2D" \
          "\x43\x38\x4A\x3A\x92\x37\x8C\xAB\x95\xB7\x4C\xB9\xFA\x46\x53\xEB" \
          "\x40\x91\x80\x8C\xC7\xC1\x69\xCE\xBB\xB7\x80\xDA\xFE\x5B\x67\x30" \
          "\xC4\xF8\xA3\x60\xE2\xD9\x1B\x3D\xBA\xCC\x6F\x13\x1A\x5A\xA5\x6F" \
          "\x11\x82\xBE\x57\xAD\xEF\x1E\x2E\x3B\x2F\x35\x8F\xC6\xB1\x01\xEF" \
          "\x14\x91\x61\x16\xC5\xA9\xD1\xB8\x28\x0E\xAD\xA6\x5A\x5B\x39\x15" \
          "\xB3\x32\x25\x76\xCF\xBF\x23\x71\xA6\xB2\x3F\x83\x1F\x3E\xD5\x15" \
          "\xEF\xAD\xC9\xF4\x79\xAC\x5E\xA1\x1D\xBC\xE5\x72\x89\x50\x34\x07" \
          "\x9B\x71\xD7\xCF\xC8\xB6\x7E\xEF\x7F\x3B\x54\x70\xFD\x55\x6B\x95" \
          "\xF1\x55\xE6\xFF\x32\xE9\x06\x3C\x2A\xA2\x63\x7E\xED\x7E\xAC\xB8" \
          "\x59\x43\x77\x7C\x2B\xFE\xC6\x3C\xAE\xBA\x95\xAC\x51\x35\xE1\xD8" \
          "\xB2\x60\xD0\x0A\x46\x9D\xFE\x22\x3A\x6B\xB6\xC5\xF1\xC3\x14\xC9" \
          "\xC8\x2E\xED\x17\x72\xF8\x28\x2B\x7C\xC8\x96\xE9\x39\xAC\xD8\x05" \
          "\x6C\x75\x6B\x90\x45\x3B\xF7\xF9\x56\xA5\x69\xEB\xDB\x61\x51\x29" \
          "\xF8\xF5\x40\x65\xAF\xA0\xD2\x38\x59\x68\x42\x50\xB1\xD3\xC3\x8C" \
          "\xB0\xB8\x13\x68\xC2\x9C\xAC\x16\x98\x5C\xCE\xA3\xE6\x76\xD4\x20" \
          "\x46\xAA\xB5\x8B\x75\x59\x1F\xC9\x5B\xAE\x46\x98\x09\xC5\x5C\x15" \
          "\x3C\x74\x40\xAF\xAB\x75\x58\x02\x10\x18\xF8\xCB\xD8\x5E\xFD\x2E" \
          "\x3B\x47\xE4\x7A\xB9\xBB\xC9\x42\xDC\x05\x57\xFC\x2C\x9A\x0F\x5C" \
          "\xD8\x82\xB9\xD6\xAA\x57\xF4\xE6\x52\xA5\x77\x33\x5F\x0E\x41\x8E" \
          "\xEB\x29\xB1\x59\xA5\x28\x06\x8E\xC8\xCB\xC6\xFD\x89\x68\xF4\x34" \
          "\x7A\xD7\xF4\x1E\xA5\x49\xB3\x26\xC4\x8C\x60\xD8\x97\x33\xD2\x9E" \
          "\xA5\x6E\x78\x3F\x2B\xCE\xCD\xD4\x9B\x90\xD7\x49\x0A\xCF\x05\xF8" \
          "\xF4\xFA\x79\xDA\x97\xCA\x01\xB1\xD9\x55\x20\x31\x47\x99\x49\xF0" \
          "\xEB\x0E\x14\x5B\xB8\x6D\x74\xE2\x52\xA0\xCF\x45\xA4\x1C\x24\x34" \
          "\x76\x8E\x46\x7E\x53\x7C\x32\x79\x4F\x23\x3E\xF6\xA0\xBA\xED\x5D" \
          "\x53\x6D\x91\xA5\x43\xE4\xB5\xB2\x78\xBD\xD8\x3E\x84\x1E\xB8\xB2" \
          "\x70\x65\xAD\xDC\x60\x00\xFE\x3B\xB4\xCB\x3F\x74\xE2\xC9\xA9\xB0" \
          "\x5A\x92\x87\x87\x9E\x3C\xEE\x22\x11\xE8\x99\xD3\xBE\x81\xAD\x15" \
          "\xE7\xEA\xF6\x34\x23\xF9\xF7\xF4\x35\x87\xE9\x08\x82\x31\xDA\x39" \
          "\xEC\x79\xA7\xA4\x0E\x35\xAB\x44\x8C\xB8\x77\x82\x97\xC3\x33\x5D" \
          "\x00\x77\xD1\x4B\x4A\x89\x9E\x9F\x24\xDE\x36\xFF\x4B\xFD\xA5\xED" \
          "\x5B\x5D\x46\x22\xA2\x8F\xA8\x55\x5A\x32\x62\xE1\xBA\xBC\x63\x83" \
          "\x15\x95\xEA\x90\x61\x53\xFD\xE7\x97\x71\xA6\xAA\xD4\xFB\x8A\x46" \
          "\xA3\xD5\x6E\xC2\xE2\xB6\x81\x26\x69\x2D\xB0\xEE\x9E\xFE\x0A\xD3" \
          "\xE6\x91\x26\x4A\x12\xD1\x7E\xB6\x66\x26\xD7\xBB\x61\x7D\xA5\x6B" \
          "\x2A\xEE\xD6\x53\xD3\xB9\xE6\x0F\xE0\xA2\x3D\x78\x53\x03\xF1\x52" \
          "\x27\x04\xF7\x42\x97\x9F\x4F\x65\xE6\x8C\xB0\x24\x17\x06\xF7\x96" \
          "\x1C\x92\x34\x92\x09\xDC\x89\xB8\xFC\x3B\x5C\xF6\x64\x89\x9C\x71" \
          "\x5A\x51\x8D\xD5\x7F\x20\x53\xE5\x69\xA6\xCA\xDF\xBE\x2A\xBD\x2C" \
          "\xAA\x75\xEF\x78\x00\xCF\x36\xC4\xC6\x5E\x62\x42\x07\x4F\x1C\x28" \
          "\xE1\xA4\x7C\xD3\xBA\xF7\xD1\x99\x52\x63\x00\x19\x14\xA3\xCC\x61" \
          "\xF6\x14\x41\x6D\x9E\x29\x1D\x9A\x8D\x9A\x77\x67\x7B\x01\x48\x1F" \
          "\x07\x59\xF0\x30\xF6\x94\xAA\x75\x6B\x03\x5D\x07\xEF\xA5\x9B\xED" \
          "\xBC\x57\x88\x1E\xCA\xDA\x67\xD1\x21\x40\x09\x7C\x21\x1E\xE9\xB3" \
          "\x07\xD9\x10\xF0\x5A\x5C\x6B\xFA\x0F\xB4\xDE\x4D\x33\x3C\x30\x0F" \
          "\x53\xC8\xE3\x26\x4F\xF6\xB9\x03\xC5\x54\xCA\x81\xEB\x61\x16\xEB" \
          "\x06\x97\x5B\xB8\x90\xB4\x26\x1C\x40\x82\x8A\xEB\x39\x12\x0C\xBB" \
          "\x32\xE6\xE1\x1A\x38\x5C\x5E\xD5\xE2\xE3\x20\xDF\x3C\x1E\x1C\xA9" \
          "\x1E\xB3\x86\x54\x8A\xE9\xD0\x76\x27\xAF\x62\x70\x0B\xB5\xFF\x2B" \
          "\xA0\xDD\x69\x58\x5F\xAE\x42\x6E\x16\x89\x46\x19\xB2\x77\x17\xC7" \
          "\x63\x25\xF2\x3B\x75\xF6\x3E\xD4\x47\xDF\x65\x94\xE7\x3C\x94\xE3" \
          "\x32\xD5\x0C\xBE\x82\xE2\x6E\xF0\x82\x92\x48\x67\xA2\x39\x19\xE6" \
          "\x73\x12\x9F\x51\xDC\x07\xA6\x7A\x26\x40\x07\xB2\xBC\xC8\x54\x55" \
          "\x54\xB0\xC3\x1E\x6F\x8C\x3D\x34\x81\xE0\xE5\x8D\x1C\x43\x25\x12" \
          "\xF2\x02\xC4\xEF\xAD\x99\x6D\x2B\x9E\x44\x81\x99\xB1\x69\x8D\x93" \
           , 1024);
    nBlockLen = 4096;
    memset(bPlainBlockExp, 0x5C, 4096);
    bPlainBlockExp[0] = 0x25;
    bPlainBlockExp[4095] = 0x22;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 24);
    DspHex("[IN ]bCryptBlock    =", bCryptBlock, 4096);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    DspHex("[IN ]bIV            =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptCBC(nSock, nAlgo, bKey, bCryptBlock, \
                             nBlockLen, bIV, bPlainBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "算法类型=3，数据长度=4096，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bPlainBlock    =", bPlainBlock, 4096);
    DspHex("[OUT]bPlainBlockExp =", bPlainBlockExp, 4096);
    ASSERT_OUT_HEX(bPlainBlock, bPlainBlockExp, 4096);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptCBC_Test_07(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bCryptBlock[4104];
    int  nBlockLen;
    BYTE bPlainBlock[4104];
    BYTE bIV[16];
    BYTE bPlainBlockExp[4104];

    bufclr(bKey);
    bufclr(bCryptBlock);
    bufclr(bPlainBlock);
    bufclr(bIV);
    bufclr(bPlainBlockExp);

    nAlgo = 3;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8697 A4B5 C2D3 E0F1 */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\x59\x99\xC3\x06\xAB\x84\x01\xB2",\
                 24);
    memcpy(bCryptBlock, \
           "\xBA\xF9\xEF\x36\xAC\x80\x81\x58\x8D\xEC\x81\x3A\x77\x10\xE0\x58" \
           "\x9F\x5D\xDF\xEE\x03\xD6\x7C\x9F\x80\x07\x30\x03\x3D\xE8\x44\x67" \
           "\x27\x07\x51\x81\xC3\x8C\x98\x96\x2D\x6F\xE2\x39\x93\x63\xF5\x71" \
           "\x33\x35\x64\x18\x78\xF5\x22\xDA\xD0\x3A\x31\x8B\xB8\x0F\x24\xC3" \
           "\x7E\xF0\x92\x29\x31\x7B\xC4\xD8\x5C\x59\xCD\xCE\xF0\x2B\x83\xD2" \
           "\x77\x36\xAB\x29\xDD\x93\x06\xCD\xE1\x54\xED\x64\xB5\x28\x92\x59" \
           "\xA0\xC1\x66\x7B\xA8\xDF\xCE\x7A\xBD\xD4\x9B\x60\x5D\xDD\xCD\x87" \
           "\x9F\x11\x9C\x8B\x60\xC8\x8A\xB8\xDE\x2D\xF4\x6E\x4C\x54\x0A\xCA" \
           "\xE8\xD1\x10\x95\x80\xDF\xF9\x6B\x6C\xEA\xCD\x45\xC9\x25\x18\xEF" \
           "\xA7\x7D\x2A\x27\xAC\xA9\x69\x91\x91\x10\x64\x56\x81\xB1\x21\x4B" \
           "\xEB\x66\xB4\xCD\xC2\x51\x0A\xEC\x58\x47\x21\x2B\x2C\xDF\x71\x78" \
           "\x64\x15\xE4\x74\x9C\x3D\x99\xA5\x6A\x90\x7F\x5C\xC5\xD0\xBD\xE9" \
           "\x4F\xC3\x22\x8C\xEC\xF3\xB0\xD5\xCA\x72\xD3\x3D\xF9\xE1\x4C\x01" \
           "\xE9\xC8\x10\x14\x45\x4E\x1C\xEF\x8E\xB3\x40\x67\xD3\xB3\x3D\x5F" \
           "\x09\x70\x1F\x18\x47\x9D\xDC\x3C\x9D\x81\xD6\xFB\xFA\xAA\xF2\x9F" \
           "\xA8\xEF\x0A\x12\x97\x9B\x1D\xA1\x06\x65\x84\x7F\x42\x5D\x99\xED" \
           "\x30\x96\xC8\x05\x4B\xF7\x36\x70\x27\x3B\x27\x8C\x0C\x3C\x0D\x94" \
           "\x4F\x35\xC7\x57\xDC\x4D\x6B\xBE\x4D\xB9\x19\xC2\xC1\x1D\x0E\x06" \
           "\x27\xB3\x86\x45\xE8\xCB\x98\x5A\xAF\x63\x65\x57\x64\xD7\x26\x8A" \
           "\x68\x79\x65\x78\x48\x47\x00\xE5\xEB\xB5\x1C\x48\xA5\xAF\x43\x87" \
           "\xB9\x51\x66\x4B\xA7\x1B\x64\xD9\x0B\x46\x3F\x02\x76\x7F\x89\x91" \
           "\x55\xAF\xB5\xEF\x5D\x98\xFE\xBB\x7D\xA2\xE8\xAB\xCE\x78\x3D\x4C" \
           "\x29\x4C\xE6\xDB\x3C\x83\xE5\xA8\xD6\x77\xF7\x2A\x30\xA1\x10\x97" \
           "\xBD\xA6\x8C\x6F\x38\x6E\x3A\xD9\x77\x3E\xCC\xDA\xF1\xFC\xB8\xCB" \
           "\xA6\x44\x13\x1E\xAF\xE4\x9F\x50\x3F\xA8\x2B\x56\x84\x80\x56\x83" \
           "\x53\xE1\x1E\xC1\xC3\x72\x06\x58\x98\x67\x8A\x2E\xED\x98\x23\xF7" \
           "\xF5\x51\x69\x61\xC7\xE6\xD2\x4A\x8C\xB1\xA9\xCE\x7C\x66\x93\xC6" \
           "\xE5\x83\xC2\xA8\x42\x27\x2C\xE6\xA4\xA2\xE0\x79\xBF\xF6\xDB\xF4" \
           "\xF9\xF6\x7E\xEC\x25\x21\xF6\x37\x39\x14\x0E\x41\x3F\xA9\xB0\x29" \
           "\x0B\x42\x43\xCF\xD7\xF3\x0B\xD2\xCF\x74\xD4\x88\x29\x6C\x95\x42" \
           "\xBD\x13\xF1\xDF\xDA\x0D\x6B\x1B\xC5\x36\xBA\xCF\x13\x22\xBF\x78" \
           "\x74\x0B\x43\x3F\x2C\x38\xBE\x4C\x54\x04\x03\xBB\xFB\x91\x16\x8B" \
           "\xEC\xA7\xF6\xE2\x5A\x47\x0D\xF8\xB5\x1D\xBD\x30\xD9\x09\x06\xFA" \
           "\x0E\xBB\x8B\x2F\xFE\xEB\xAA\x54\xB6\x30\x83\x84\x74\x8F\x9B\x3D" \
           "\x6F\x69\x8A\x76\x16\x0E\xE0\xDF\x39\x08\x79\xCE\x12\x1B\x30\x2E" \
           "\x4E\xCC\xE9\x60\x09\x3F\x4E\x78\xBA\xC4\x84\x12\x84\x3E\x84\x77" \
           "\xB0\x9D\x45\xF1\xC2\x37\xC7\xC6\x3E\xA5\x04\x96\x90\xA5\x03\x21" \
           "\x37\x20\xE6\x41\x9B\xF7\xC6\xFD\x4A\x59\x02\x1F\x0A\xF7\x34\x93" \
           "\x48\xBC\xEF\x1A\xE8\x73\xE8\x5E\xDE\x7C\xF4\x85\x26\x14\x01\x74" \
           "\x70\x2B\x6D\xE3\x37\x47\x37\x4C\xF0\xE9\x6D\xD7\xB9\x04\x58\xD9" \
           "\x8F\x51\x1A\xEE\xF4\x43\x26\x8D\x6B\x91\x61\xE5\xD2\x21\xB9\x03" \
           "\xED\x0D\x83\xCA\xCB\x25\x87\xD2\xD7\xCF\xF6\x3B\x52\x92\xE5\x83" \
           "\xEE\x36\x8C\x91\xD2\x58\x14\x60\x35\xF3\xDE\xE8\xBA\x01\x43\x87" \
           "\x59\x43\xBC\x27\x8E\x1E\xC3\x32\x88\x07\x21\x8B\xA2\xC5\xF0\x46" \
           "\xE0\xB8\x0B\x88\xC4\x9C\x4B\xBE\x39\x94\xA5\xC6\x7E\xB2\xA7\x5C" \
           "\xAE\xFA\x92\xB4\x42\xFD\xCE\xBB\x2E\x0A\xA3\xC5\x3C\xF3\x6C\x88" \
           "\x30\x0A\xB3\x80\x84\x4A\xC0\x74\xE0\x61\x03\xB0\x59\xF1\xD8\x4E" \
           "\x84\x96\x45\x26\xFA\x28\xFD\x01\x5C\xC9\x56\xB1\x43\x8A\x14\x99" \
           "\xF0\xCF\x69\xAB\xFC\x71\x0B\x45\x21\x15\x68\x69\x98\x17\xA1\x67" \
           "\xD1\x65\xDD\xD4\x44\x1F\xB1\xA4\x65\xB1\xFF\x60\x25\xA3\xA4\x9A" \
           "\xB9\x99\x03\x15\x83\x41\xD5\x90\xF4\xDC\x23\x0D\x6D\xC8\x12\x6D" \
           "\x14\x5C\xD7\xCC\x8E\x1A\xF4\x69\xB5\x62\xC6\x7A\x75\x0D\x8B\x32" \
           "\x16\x4B\x47\xCB\xDA\x81\xE8\xC2\xB1\x1B\x5D\x65\xA7\x25\x49\x48" \
           "\x06\x7F\xBC\x59\xC2\x46\xA7\x1C\xCF\x67\xCD\x02\xB8\xC6\x78\xF9" \
           "\x1D\x34\x8C\x24\xC4\xFE\xFC\x17\x14\x87\xFE\xA9\x41\x4E\x3D\x59" \
           "\xC0\x7A\x01\x53\x0E\x76\x46\xE0\xB7\xFC\x72\xB4\x5B\x3D\xF6\xBF" \
           "\x58\x74\x4A\xB8\xAF\x24\xC1\xD6\xF0\x77\xDD\x28\x09\x43\x29\xBA" \
           "\x1B\x2E\xF5\xEF\x24\xCE\x83\x8E\x90\xDA\xE6\xC0\xE0\x07\x92\xC1" \
           "\xDD\x2E\x95\x5B\xEB\xC7\xD6\x2C\x20\x4A\xD1\x22\x2B\xCD\x41\x4E" \
           "\x4D\x99\xCD\xAC\xF5\x81\x76\x0D\x10\xEA\xA6\xB3\xF3\x75\x65\x12" \
           "\xBC\xAD\xA2\x43\x20\x8C\x06\xD0\xAD\x8C\x06\x0A\x9A\x13\x68\xA8" \
           "\xFA\xD9\xB2\x0C\xAE\x1D\x45\xD2\x67\x81\xF0\xE7\x62\xAF\x0C\x4B" \
           "\x52\xE1\xED\x7E\x82\x09\x43\xC5\x15\x9A\xF9\xAF\x75\xDA\xAA\x9F" \
           "\xF6\x20\xF3\x36\xF1\xE7\x9D\xA2\x88\x82\xB8\x0E\xB3\x4E\xD0\x99" \
           , 1024);
    memcpy(&bCryptBlock[1024], \
           "\x90\x18\x00\x79\xD7\x05\x20\x72\xE5\xCE\x26\x9E\x39\xB1\x8B\x56" \
           "\x3F\x73\xDC\xCC\x99\xDF\x8A\xD3\xB0\xA6\x1E\xEE\x69\x6E\xB0\x69" \
           "\xAC\xEB\x8A\x67\xD2\xAE\x63\xC3\xE9\xB7\x69\xE6\x47\xBB\x1A\x93" \
           "\x69\xD7\x17\x76\x99\x8B\xFA\xBD\x9E\xAA\x17\x5D\x00\xAF\x6C\xDE" \
           "\x8A\x15\x46\x18\xF8\x1E\xDF\x2E\xD6\x7E\xA3\x21\x1C\x3B\xFC\x80" \
           "\x4E\x54\xA0\x52\x43\x29\x52\x46\x92\xA4\x9A\x96\xB2\xD7\x44\xCF" \
           "\xC6\x53\x82\x6E\x98\x06\xF0\x81\x13\xF8\x0E\xB3\x17\x60\x51\x1D" \
           "\x16\xCC\x0D\x39\x22\xED\xB9\x98\x8E\xBB\x00\xB4\xED\xEE\x38\xAC" \
           "\xE7\x3C\x3D\x21\xBD\xB1\xA8\xF0\x67\x71\x55\x61\x2D\xB5\x54\xFB" \
           "\xE8\x30\x7C\x44\xAF\x8A\x1C\xED\xBB\x34\xA3\x6B\x2D\xD1\x6E\x34" \
           "\x97\x23\x88\x2D\x2E\x8F\xBA\xC0\x5F\x46\x87\xCB\x62\x3C\x26\x5B" \
           "\xCA\xCD\xB2\x57\xBE\x08\x81\x09\x18\xCE\xF6\x49\x48\x60\xAA\x68" \
           "\x8E\xB0\x71\xCE\xD3\x8E\x2D\x16\x6A\x8D\x4D\x4A\x55\x2E\xBF\x36" \
           "\x1A\xEB\xCA\x94\xA2\x4F\x4A\x3C\x52\x1B\x1E\xD3\x16\x7B\x83\x0B" \
           "\x72\xAB\x81\x39\x7F\x10\x6B\xEE\x8B\x94\xF7\x29\xF9\x02\x12\xB2" \
           "\x6F\x23\x89\x95\x3F\x20\xEB\xE7\x6F\xA1\x46\xCB\x4C\xD3\x73\xF7" \
           "\x60\xB8\x25\x6F\x87\xD1\x44\x78\xC9\xFD\xC0\xAA\x32\x22\x94\x19" \
           "\x82\x78\x80\x2A\xCC\x65\x7A\xE3\x30\x57\x9B\xB5\x30\xA4\xEA\xF9" \
           "\x51\x25\x80\x41\x5B\xF8\xD1\xEA\x59\x0F\xCA\x2B\xB8\x47\x4E\xA5" \
           "\x43\xF0\xEA\x9E\x51\x52\x78\xCB\xA8\x0B\xA9\x7D\x46\x96\x43\xC3" \
           "\xBB\xA5\x20\xC0\xBF\x8C\x7C\xC9\xAC\x82\x2C\x0F\x51\x74\x6C\x04" \
           "\x65\xAA\x9B\xE4\x29\x22\x87\xFE\xD3\xC3\x64\x44\x38\x03\xB0\x4F" \
           "\xAD\xF2\x6F\x01\x8D\xFB\xD2\xA2\x12\x08\xD4\x49\x6C\xC5\x55\xCE" \
           "\xBA\x84\x3C\x0D\xBC\xB9\x5D\x17\x25\xA1\x23\xA3\x84\xF2\x36\xD5" \
           "\xD2\x63\x56\x88\x2D\x3F\xBA\x4B\xD2\x96\xBF\x1D\x8A\x06\x57\xA7" \
           "\x94\xA0\x2E\x2A\x0D\xDD\x7A\x89\xD0\x36\x04\x7A\xF8\xE8\x0C\x82" \
           "\x1C\x35\x5E\x09\x8F\xDC\x8B\xCC\xE3\x62\x17\xB5\xF5\x7B\x59\x4D" \
           "\xB6\xD9\x3E\xD1\x0C\x6A\x62\x4A\x41\x9E\xE5\x84\xAC\x62\x81\x00" \
           "\xCC\x0B\x98\xEC\x61\x47\x04\x96\x49\x21\xC0\x98\x64\x88\x6E\x49" \
           "\x28\xF7\x66\x7F\x0B\x2E\xD0\x98\xE2\x6D\x47\x4A\xBE\xE5\x4B\x28" \
           "\x49\x9D\xE8\xEE\x74\x78\x16\xBC\x76\xA8\x28\x3A\x1C\xDA\x1E\xCF" \
           "\xC9\x84\x1E\xFF\xF4\xDB\x3E\x03\xD5\x77\x87\x8A\x83\x83\x84\x22" \
           "\x16\xF6\x26\xF8\x9F\x55\xBB\x6B\x2F\xF3\xB1\xB9\x18\x40\x75\xE4" \
           "\xF8\xF0\x65\xC4\xF0\x8E\x84\x03\x59\x2F\x0B\x96\xCA\xBE\x1F\xD6" \
           "\xF8\xCA\xD5\x03\x36\x5F\xBC\x26\x24\xB4\x36\x5B\x50\x53\x87\x15" \
           "\xEE\x2E\x50\x0D\xFE\x8F\xD5\x3C\xC6\xD9\xA1\xAF\x02\xF1\xC9\x73" \
           "\xB8\xB4\x87\xBE\x8D\xBE\x4D\xAD\xBD\x2C\x15\x59\x9C\xE0\x57\xF9" \
           "\x52\x93\xC7\xB0\xB8\x01\xBA\x93\x29\x96\x3A\x67\x58\xD0\x0D\x26" \
           "\xD9\x63\xDE\xA5\xDA\xA9\x51\xA4\xEC\x6C\x73\x31\x83\xB0\xD7\xCA" \
           "\x7B\x30\xDF\x7B\xDF\x09\x97\xA6\xFE\x30\x0D\x75\x2B\xB5\x7D\x8E" \
           "\xCA\x53\x2E\xBE\xC4\xB6\xD0\x56\x1F\xE0\x17\xAC\x43\xB9\xD1\xD6" \
           "\xF7\xCB\x4A\x32\x76\xA1\x07\x23\x31\xFA\x6D\xA5\x95\x85\x40\x29" \
           "\x19\x72\x9F\xCF\x0A\xA9\xB8\x11\xA5\x90\xEA\x67\x81\x2A\x2F\x23" \
           "\x17\xBE\xA2\x9C\xFE\x2D\x17\x19\x99\xD0\x86\x46\x99\x4B\x4D\x7E" \
           "\xD4\x53\x7B\xBE\xA7\x6D\x71\x52\x11\x29\x50\x23\xE7\x93\x07\xCA" \
           "\x41\x1F\x9E\x03\x9A\x5B\xDA\x52\xEA\xF1\x47\x07\x38\x09\x6D\x13" \
           "\x9C\xD3\xBB\x27\xB3\x09\xF8\xF7\xD0\xB7\xDB\x0D\x79\x75\xD0\x74" \
           "\x08\xD3\xD7\xF5\x21\x66\x26\x6C\xB0\xA6\x24\x6B\xE5\xD5\xC9\xFC" \
           "\xA0\x98\xBC\xF3\xCD\xD4\xA2\xD5\xE0\x64\x0E\xCC\xB7\x2B\x25\x26" \
           "\x77\x7F\x29\x79\x50\x6E\xBA\x1A\x16\x00\x3F\xB8\xA6\x56\x80\x5F" \
           "\x6C\xA5\x4B\xA7\x12\xDA\xFF\x18\xD5\xFE\xBC\xC1\x20\xAC\xC0\x0F" \
           "\xAB\x06\x23\x89\x5B\xCB\x2C\x9C\x76\xAE\xB1\xFF\xCB\xE4\xAE\xBA" \
           "\x90\xAA\xF3\x36\xD7\xBB\xE2\x5B\x46\x18\xC6\x91\x5F\x51\x27\x89" \
           "\x70\x71\xF0\xEC\x7C\xF3\x32\x29\xB5\x7E\xD0\xE5\x61\x6C\xAF\xCE" \
           "\xC1\xFA\xB2\xF4\xEB\xC9\xA6\x9A\x01\x7F\x95\x37\x85\x71\x88\xAA" \
           "\xB0\x57\xF7\x47\xC4\xF5\x50\x3B\xE7\xFC\x7A\x80\x64\x4A\x0E\xBC" \
           "\xE7\xB4\x57\x29\x18\x3C\x3F\x58\xE5\xE8\xB0\xFC\x98\xD7\xD6\x84" \
           "\xA6\xE3\x1E\x69\x9C\x1F\x9F\x1A\x35\x4F\x05\x43\x2A\x11\x13\x91" \
           "\xCD\xB9\x5E\xE9\x5C\x35\x4E\x66\x01\x6F\x7F\x22\x8D\x35\xF8\x96" \
           "\xBD\xED\x4D\xE9\x8B\x34\x02\x12\x7F\xF9\x5B\xFA\x0A\xAF\xB7\x7A" \
           "\xEC\xF3\x4D\xE3\x8E\x69\x2F\xE4\x7A\xB7\x03\x3D\x7E\xC9\xCC\x81" \
           "\x2E\x6D\x54\xD6\x93\x8E\xDE\xD4\xE8\x72\x3D\x73\x07\xB1\x23\x31" \
           "\xE7\x57\xDA\x35\xA0\x02\x4B\x3B\x2F\x3E\xB4\xBB\x0D\xDE\xFD\x7E" \
           "\x53\xDA\xB8\xB7\x0E\x05\xF2\x24\x01\xED\xBF\x08\xB1\x90\xB7\xE5" \
           , 1024);
    memcpy(&bCryptBlock[2048], \
          "\xDC\x57\xF6\x07\x4D\xEB\xE1\x5A\x44\xC0\xDC\x13\x01\x0A\xBF\xD8" \
          "\x48\xFA\x53\x4C\x14\x93\x42\xE5\xCE\xAC\xDD\x18\x56\xE8\xA9\xD4" \
          "\x45\x2E\x59\xF9\x1B\x17\xF1\x80\x0D\x36\xB3\x31\x2B\x8C\x2C\x93" \
          "\x2F\xD6\x90\xAA\xA5\x92\x9D\x5F\x80\x6E\x25\xFC\xF1\xFC\xF6\x38" \
          "\xDD\x07\x11\x85\x81\x5D\x63\x7A\x7E\x4E\xC7\x90\xD5\x91\x61\x91" \
          "\xED\xB2\xC3\x34\x25\x7B\x06\xE7\x83\x15\xB1\xD3\x04\x4E\xE5\x84" \
          "\x28\x55\xE1\xB2\x40\x8A\x9A\x54\x38\x3A\x34\x68\xAE\xC3\x3D\xCA" \
          "\x9C\xEB\x7D\x09\xE3\xDC\x4B\x38\x85\x72\xC9\xE9\x32\x96\x38\x41" \
          "\xDD\x5F\x45\x3B\xB6\x49\xFE\x0B\x83\xD7\xC7\xA0\xC8\xAF\x8A\xE3" \
          "\x43\x7B\x71\xF3\x97\xEF\x90\x3E\x7E\x1C\xD4\x8B\xA2\x65\x23\x44" \
          "\xCC\x78\xC4\x83\x35\x09\x90\xB7\xA2\x1E\x76\x13\x23\x89\x24\x04" \
          "\x5F\xDE\x0B\x56\x7D\x8B\x42\x79\x4F\xB5\xC1\xFA\x78\x5D\xB2\x5B" \
          "\x0E\x10\x8B\x7D\x27\x47\x41\x2A\xDE\xFB\x5A\x92\x7D\xAE\xC3\xF4" \
          "\x82\xF9\xBA\xD2\x42\x6D\xD1\x90\xF9\x5A\xB3\x1E\x1E\x06\x24\xFE" \
          "\x3F\x8A\x22\xE9\x9D\xFB\x48\x56\x11\x42\x87\xEC\x93\x17\x8C\x80" \
          "\xC2\xBB\x4C\xDA\xDD\x30\x87\xD3\xA9\x52\x3C\x09\x71\xB0\x26\xBE" \
          "\xD6\xB1\xF7\x69\xF8\x42\x31\x31\xA3\x96\xAD\x4C\x53\x62\x21\xD0" \
          "\xC1\x3B\x3E\x78\x7D\x87\x51\x37\xD8\xD1\x57\xE5\xD7\x94\x97\xC8" \
          "\xB9\x8A\x63\xA7\x72\xE3\x9E\x36\x68\x23\xDB\x44\x61\x54\x6F\x13" \
          "\x9D\x93\x55\x68\xE7\x54\xE3\xD3\x96\xEF\x59\x35\x66\xD1\x41\x47" \
          "\x86\x86\x6B\x2F\xE7\x5F\x47\x8E\xB7\x42\x4B\x9F\x78\xA3\x6C\xEF" \
          "\xB6\x56\x27\x69\x20\x6C\x30\x98\x12\x7E\xCA\xCA\xB9\x66\xD0\xDB" \
          "\xAF\xA6\x1A\x11\xAA\xE5\xED\x6A\x26\x54\x43\x80\xF0\x81\x33\xAF" \
          "\x57\x7F\x7C\xD1\xB1\xE1\x90\xB5\xDA\x86\x61\x7B\x17\x48\x1D\xC8" \
          "\x95\xC5\xAB\x00\x3D\x18\x1C\xE5\x8E\x71\xBB\x03\x3A\x0E\x31\xBE" \
          "\xB7\xD0\x6F\xA0\x9D\xD0\xCC\x75\xEF\x13\x22\x4C\x0E\x5A\xFF\xB5" \
          "\x71\xE1\x48\x4C\x9C\x89\xF2\x65\x65\x3B\x3E\xAD\x2C\x1D\x38\x97" \
          "\x62\x6D\xDB\x26\x93\x97\x8A\x53\xAA\x68\x1E\x6E\x5F\x52\x42\xEB" \
          "\xE0\xCB\xEE\xC8\xD0\xAF\x21\x16\x21\x1E\xB3\x62\x20\x4E\xFA\xF2" \
          "\x77\x17\x6A\x15\x64\x4A\xC6\xBF\xB2\x3F\x56\xFD\xAA\x63\x47\xC0" \
          "\x3D\x6A\x65\x64\xCE\x28\x9C\x99\x82\x0A\xB7\x78\xCB\x67\x1E\x34" \
          "\x02\x27\x12\x61\x10\xBB\x5F\xEF\x86\x8D\x9D\x07\x83\xBA\xCA\x0F" \
          "\x83\x1F\xD0\xFB\x38\x61\x2B\x29\xBD\x5F\x8C\xF9\xEE\x5C\x2D\x34" \
          "\xFB\xCB\x2E\xE6\xE9\xF3\x47\xD1\x19\x29\xDC\xF3\x5E\xAF\x48\x52" \
          "\x7B\xF3\x24\x09\x40\x75\x65\x76\x25\x51\x0B\xFF\x83\xC3\xC8\x99" \
          "\xF6\xF0\xE6\xC0\xD4\x09\xD0\x23\xC2\x20\x21\xBA\x70\x49\x56\x66" \
          "\x7B\xA8\x5E\xB3\x0D\xF8\xCE\x89\xF7\xF1\x65\x02\xF7\xA7\x48\x7B" \
          "\xE8\x76\x70\xD3\x96\xB5\xB3\x35\x81\xB1\xE5\x2B\x19\xA2\x06\xB3" \
          "\xEE\xD2\x41\x23\x49\x4C\x39\xEB\x12\x74\x03\x76\xAC\x27\xA2\x6F" \
          "\x4C\xFB\x47\x8F\x4B\x86\x88\x1F\x80\x4B\x19\x66\xC1\x8F\xD4\xEB" \
          "\x44\x85\x66\x87\x8F\xB6\xC3\x41\xB1\x97\xA9\x3E\xA5\x4F\x56\xB3" \
          "\x82\x81\xB8\x15\x67\xFF\x40\xFF\xAB\x60\x9F\x16\x42\x7E\x81\x27" \
          "\x1E\xE9\x06\xCC\x4F\xC6\x1C\x9C\xA6\xF3\xC9\x5D\x1A\x6C\x1A\xFF" \
          "\xC1\x21\x55\xFD\x6E\x7E\x75\x87\x9B\x43\x51\xD1\xF9\x38\x45\x19" \
          "\xDB\xBA\xA6\x87\xC2\xBF\x07\x63\x08\xC8\x64\x8B\xA1\x0B\x59\xC4" \
          "\x6B\xBD\x60\x79\x68\xD8\xBD\x3C\xC2\xF9\x31\x5E\x43\x01\x49\xA6" \
          "\x0E\x5E\xE5\xF9\xEA\xEF\xE9\xCF\x60\xD6\xDA\x8E\x86\xA0\x86\x2E" \
          "\xF8\xE2\xFB\xCA\x1C\xE1\x43\x2E\xE0\xE2\xB8\xB8\x86\xD6\xF0\x82" \
          "\x88\x16\x66\x1C\x3B\x1C\xB0\xEB\x14\x5B\x8A\x1D\xD4\xB7\x7F\xA2" \
          "\x8A\xFD\x03\x1D\x14\x93\x12\xCA\xC3\x88\xDC\x70\x16\x84\xCE\x54" \
          "\x54\x8D\x16\x5A\x37\x06\xDF\x9B\x00\x1C\x79\xFE\x95\x10\x44\xC8" \
          "\xF0\x27\x27\x91\x7C\x64\x15\x1C\x44\x28\xFB\x87\xAE\xA7\x80\xAB" \
          "\x37\x1D\x03\xFC\xF4\x63\xA5\x1D\x3A\x52\x0C\x78\x18\xEB\x8B\x87" \
          "\xDF\x51\xCE\x73\x46\xC7\xAD\xC1\x57\xDB\x75\x64\x1A\x58\x9C\x18" \
          "\x18\xF0\x75\x06\x64\xA7\x64\x42\x4A\x4B\x11\x4C\x15\x5F\x64\xF1" \
          "\xD8\x9B\xD9\xA1\x3E\x97\x40\xE1\x4E\xE8\x2C\x04\xF7\x72\x05\x93" \
          "\x25\xDF\x7A\x96\xFA\xC9\x50\x08\xE0\x72\xF4\xFE\xB0\xE2\x28\xC1" \
          "\x81\x53\xAE\xDE\xFD\x7C\xF9\xD2\xE6\xC3\x74\x0B\xF1\x05\x62\x29" \
          "\x21\x33\x1C\x99\x05\xC5\xCF\xBD\xCA\x18\xD0\x35\x0B\x6E\x9E\xDF" \
          "\x63\x3E\xA6\x2E\xCF\x58\x5B\x66\xD3\xCD\x88\x25\xB7\xC2\x13\x63" \
          "\x1D\x06\x2D\xEE\x9C\x41\x4E\xB2\x9D\xE0\x48\x63\xD5\x26\x18\x79" \
          "\x47\xEB\x2D\xB4\x92\xB8\x1A\x3E\x3B\x7A\x96\x04\x2D\xC4\xEA\xE5" \
          "\xEC\xE9\x5D\xCE\xF8\xC8\x62\x63\x11\x5B\xB8\x81\xAB\x51\x7A\xD4" \
          "\x86\xD6\xFC\x51\xE2\x7D\x87\x81\xDC\x9E\x71\x65\xF2\xA8\x65\x7F" \
          , 1024);
    memcpy(&bCryptBlock[3072], \
          "\x66\x71\x83\x72\x51\x40\x24\x06\x3B\x71\xC6\xB4\x00\xA3\xD4\x32" \
          "\xD8\x10\x90\xB7\x80\x31\x43\x9E\xC7\x34\x2F\xC7\x02\x8A\x64\xB0" \
          "\x2C\xC5\x1D\xA6\x9F\x5D\xE2\x80\x0C\x44\xF5\x16\x6D\xE9\x78\x80" \
          "\x5F\x5D\x96\xF7\x44\xD1\xD4\x08\x6C\xC5\x9F\x64\x7D\x67\xC1\xA9" \
          "\x23\x22\x20\xBE\xDC\x80\x73\x37\x7B\xE1\xB9\x82\x7A\x08\x9D\x15" \
          "\x31\x2F\x6C\x0B\xAF\xBC\x88\xAC\xC9\x0E\x02\xA9\xDD\xD2\x06\x23" \
          "\x01\xAD\x18\xE9\x61\x0C\x3B\x9D\xED\x5D\x84\xFD\x6B\x5C\x96\xB4" \
          "\x00\xEF\xF4\x34\xC7\x4E\x3F\xC6\xD7\x57\xC4\x37\xC4\xB4\x7C\x77" \
          "\x66\xA3\x0C\x17\x7E\x57\xE8\x91\x84\x26\x8C\x7B\x7F\xFF\x8A\xFC" \
          "\xA4\x3F\x82\x6F\x25\xD7\x9C\x4B\x7D\x10\x35\xA4\xC2\x43\x38\x29" \
          "\xDE\x7F\x48\x0E\x21\xF7\x47\x5D\x3F\x34\x64\xB2\x14\xA2\x8A\x38" \
          "\xC0\xAA\xB4\xBE\xE6\x2B\x84\xBD\xDC\x71\x69\xDE\xCC\xFF\xB3\x8D" \
          "\x73\x57\x16\x62\xB5\x54\x1E\xA2\x1F\x25\xC2\xE5\x76\x5A\x62\x68" \
          "\x90\x38\x52\x38\xB7\x45\x6E\x03\xA2\xFD\x57\x04\x33\x1F\xE9\x49" \
          "\x2F\x6A\x63\xE6\x51\x26\x30\x48\x98\x67\xEC\x03\x1E\x01\xDB\xAC" \
          "\x12\xF1\x5F\x22\xC8\xF3\x83\x90\xDD\x4E\xEC\xFB\x8F\x3A\x36\xB2" \
          "\xAC\x0C\xA7\x40\xD0\x8D\x26\xDD\xC9\x74\xFA\xA0\x76\xE6\x8B\x38" \
          "\x6E\x88\xD6\xEA\xAF\x34\x1F\x35\x79\xE2\xDC\xA8\x21\x7F\x2B\xE5" \
          "\x8A\x11\xF1\xE4\x4B\xF4\xAE\xD0\x76\x0A\x76\x8C\x79\xBD\x1B\x71" \
          "\xF0\x09\x3A\x17\xE3\xCF\x7F\xDA\xC0\xC2\x87\x5A\x15\x13\xB6\x29" \
          "\x2B\x80\xE4\x1E\xA7\x96\x6F\x64\x03\xA0\x96\x1A\x9B\xE8\xFB\xE8" \
          "\xB8\xBA\xCC\x49\x3C\x93\x7A\x97\xD9\x6A\x06\xB4\xDF\x25\x40\x11" \
          "\x1D\xBB\x1B\xDA\x21\x5E\xBC\x03\xF1\x74\x59\x3F\x73\x9F\x2D\xB1" \
          "\x77\xA2\xF7\xF2\xFC\xE3\x3B\xFD\x42\x28\x6C\xDF\x30\xAE\x96\xB6" \
          "\x8E\xCC\x91\x40\xE5\x0D\xAA\x36\x82\xFC\x9A\xE5\x8F\xBB\xF6\x73" \
          "\x5E\xE6\x7B\xA7\xD1\x32\xDC\x29\x95\xD9\x17\x10\x58\x09\x7A\x99" \
          "\xBB\x64\x45\x46\xA7\x1B\xA3\x99\xDF\x54\xA0\x0B\x35\x35\x7F\x38" \
          "\x16\xDB\x0A\xBE\xB8\x24\x68\x65\x5A\xF6\x64\xB3\x86\xE1\x8F\x86" \
          "\xDD\x8F\xB5\xE1\xB5\x9C\xDD\x1F\x5E\x31\x63\xB2\x6F\x8E\x6D\x94" \
          "\x5A\x73\xC9\x3E\x13\x5E\x66\xE7\xD1\x97\x88\xF1\xB2\x0D\xAF\x17" \
          "\x55\xE8\x8B\x0C\x0E\x9A\x2D\xD2\x4E\x37\x35\x8E\x58\x7E\xF6\xA3" \
          "\x69\x10\xC5\xD3\x2D\x69\x82\x30\x01\xA7\x0C\xA9\x2B\xDC\xD7\x97" \
          "\x5E\x5E\x9D\xAF\x40\x59\x79\x49\x19\x1C\x6D\x89\x85\x5D\x75\xFB" \
          "\xB4\x6A\x2A\x3F\x58\x17\xA2\xC5\xEF\xBB\x35\xB2\x12\xAE\x66\x96" \
          "\x1D\x16\x8B\xE6\xE8\x3F\xFF\xB2\x31\xEB\x62\xAF\xD2\xF3\x96\x34" \
          "\x0E\x3F\xAE\x23\xA4\xDD\x13\xF1\x79\x88\x60\xAC\x07\x44\xEF\x0D" \
          "\x64\x76\x0E\x21\xF6\x5C\x00\xCA\xC3\xAB\xF7\xAD\xC3\xA5\x9A\x33" \
          "\x6A\xBA\x92\x83\x97\x48\xA0\x67\xB0\x80\x5D\xFE\x89\xB6\x6C\x7A" \
          "\x48\x95\x4F\xAA\x4A\xAF\xC2\x0F\xFD\x75\x1E\xAE\xB1\x55\xDF\xA1" \
          "\xA9\x8F\x96\x51\x98\x13\x2D\xB0\x3B\x70\x11\xCC\xBD\xC0\xCF\x62" \
          "\xDA\x98\x72\xB2\x58\x52\x14\xFE\x6F\x69\x21\x60\x12\x4C\xFB\xB4" \
          "\x16\x36\xC7\xBC\xEA\x0D\xE6\x57\xA0\xD0\x66\x3A\xE7\x12\x14\xB3" \
          "\xCE\x27\x2B\x35\x15\x6B\x64\x23\x71\x0E\x2C\xB5\x4C\x7D\x20\x34" \
          "\x15\xA3\x65\xBC\x35\xCE\xFD\xCC\xF4\x0E\x41\x50\x83\x93\x34\x96" \
          "\x83\xA2\x6A\xB6\xD9\xF0\xE7\x2F\x14\xB4\x71\x5D\x2D\xCD\xD0\xB1" \
          "\x80\x30\x1E\x33\xAA\x29\x5D\x02\x32\x74\x4D\xEB\xC6\x52\xD6\xDE" \
          "\xA3\x12\x45\xE3\x7B\x0C\x9D\xF3\xFB\x57\x26\x77\x87\x54\x9E\xE2" \
          "\x72\xD7\xF0\xCC\xBF\x1E\x00\xDA\x74\xB3\x23\x0C\xE4\x05\xF6\x49" \
          "\x36\x19\xBF\x17\x2E\xCC\xB4\x60\x0C\xD4\xC9\x6A\x58\x16\xB3\xAD" \
          "\x68\x51\x78\xBB\x9A\x12\x73\xA8\xE7\x5E\x8E\xD8\x59\xE0\x31\x17" \
          "\x87\x08\x1A\x7F\x34\x20\x4A\xAB\x64\xEF\x8E\x7D\xD2\x96\xF7\x04" \
          "\x4D\x12\x7F\x2F\x09\x38\x92\x79\x2D\x28\x7D\xF7\x0F\x95\x6A\x53" \
          "\xD6\xDE\x52\x31\x57\x31\x6B\xC9\xE9\xE5\x9F\x89\xDA\x2F\x15\x26" \
          "\x80\x56\xE0\x66\x5C\x88\xCE\x80\xBF\x99\x79\xF3\xCC\x2E\xC4\xAC" \
          "\x11\xE6\x47\x39\x44\x38\xBA\x20\x04\xFF\x08\xB8\x33\xC2\x84\xB6" \
          "\xA3\x5D\x2E\xE6\x06\x8C\xBB\x87\xE7\x57\x07\x95\x99\x65\x2E\x94" \
          "\x97\x49\xC0\x42\x34\xAC\x86\x95\xF2\x02\x1D\xB1\x10\x4E\xDD\x0A" \
          "\x86\x10\x27\xC4\xF3\xA6\x9E\x24\xA1\xE1\xC5\x71\x37\x3E\xF9\x30" \
          "\x63\xD8\x0E\x36\xBC\xB4\x78\x8F\x23\x00\x45\xA0\x58\xC2\x26\x38" \
          "\x22\xCB\x5C\xBC\x32\x6A\xF1\xD8\xAF\x40\xD5\x34\xFE\x45\x14\xAC" \
          "\xD4\x52\xFC\x42\xF2\x90\x22\xAB\x4F\x55\x73\x13\x74\x34\xFE\xE3" \
          "\x24\x49\x65\x32\x91\xF4\xA0\xB9\x09\xBC\x2C\x9E\x48\x98\xB9\x8A" \
          "\x2B\xC5\x0F\xB6\x50\x0A\x01\xF7\x15\xEB\x87\x3B\x39\x91\xF0\xED" \
          "\x17\xA1\xE8\x17\x1F\xAF\x46\x9F\x4F\xC1\x46\xEE\x62\x76\xF7\xD2" \
          , 1024);
    nBlockLen = 4096;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 24);
    DspHex("[IN ]bCryptBlock    =", bCryptBlock, 4096);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    DspHex("[IN ]bIV            =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptCBC(nSock, nAlgo, bKey, bCryptBlock, \
                             nBlockLen, bIV, bPlainBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "算法类型=3，数据长度=4096，空数据测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bPlainBlock    =", bPlainBlock, 4096);
    DspHex("[OUT]bPlainBlockExp =", bPlainBlockExp, 4096);
    ASSERT_OUT_HEX(bPlainBlock, bPlainBlockExp, 4096);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptCBC_Test_08(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bCryptBlock[4104];
    int  nBlockLen;
    BYTE bPlainBlock[4104];
    BYTE bIV[16];
    BYTE bPlainBlockExp[4104];

    bufclr(bKey);
    bufclr(bCryptBlock);
    bufclr(bPlainBlock);
    bufclr(bIV);
    bufclr(bPlainBlockExp);

    nSock = -1;
    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memcpy(bCryptBlock, "\x56\xCC\x09\xE7\xCF\xDC\x4C\xEF", 8);
    nBlockLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bCryptBlock    =", bCryptBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    DspHex("[IN ]bIV            =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptCBC(nSock, nAlgo, bKey, bCryptBlock, \
                             nBlockLen, bIV, bPlainBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void DecryptCBC_Test_09(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bCryptBlock[4104];
    int  nBlockLen;
    BYTE bPlainBlock[4104];
    BYTE bIV[16];
    BYTE bPlainBlockExp[4104];

    bufclr(bKey);
    bufclr(bCryptBlock);
    bufclr(bPlainBlock);
    bufclr(bIV);
    bufclr(bPlainBlockExp);

    nSock = 8;
    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memcpy(bCryptBlock, "\x56\xCC\x09\xE7\xCF\xDC\x4C\xEF", 8);
    nBlockLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bCryptBlock    =", bCryptBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    DspHex("[IN ]bIV            =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptCBC(nSock, nAlgo, bKey, bCryptBlock, \
                             nBlockLen, bIV, bPlainBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[8]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void DecryptCBC_Test_10(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bCryptBlock[4104];
    int  nBlockLen;
    BYTE bPlainBlock[4104];
    BYTE bIV[16];
    BYTE bPlainBlockExp[4104];

    bufclr(bKey);
    bufclr(bCryptBlock);
    bufclr(bPlainBlock);
    bufclr(bIV);
    bufclr(bPlainBlockExp);

    nAlgo = 0;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memcpy(bCryptBlock, "\x56\xCC\x09\xE7\xCF\xDC\x4C\xEF", 8);
    nBlockLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bCryptBlock    =", bCryptBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    DspHex("[IN ]bIV            =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptCBC(nSock, nAlgo, bKey, bCryptBlock, \
                             nBlockLen, bIV, bPlainBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效算法类型[0]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptCBC_Test_11(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bCryptBlock[4104];
    int  nBlockLen;
    BYTE bPlainBlock[4104];
    BYTE bIV[16];
    BYTE bPlainBlockExp[4104];

    bufclr(bKey);
    bufclr(bCryptBlock);
    bufclr(bPlainBlock);
    bufclr(bIV);
    bufclr(bPlainBlockExp);

    nAlgo = 4;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memcpy(bCryptBlock, "\x56\xCC\x09\xE7\xCF\xDC\x4C\xEF", 8);
    nBlockLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bCryptBlock    =", bCryptBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    DspHex("[IN ]bIV            =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptCBC(nSock, nAlgo, bKey, bCryptBlock, \
                             nBlockLen, bIV, bPlainBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效算法类型[4]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptCBC_Test_12(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bCryptBlock[4104];
    int  nBlockLen;
    BYTE bPlainBlock[4104];
    BYTE bIV[16];
    BYTE bPlainBlockExp[4104];

    bufclr(bKey);
    bufclr(bCryptBlock);
    bufclr(bPlainBlock);
    bufclr(bIV);
    bufclr(bPlainBlockExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    nBlockLen = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bCryptBlock    =", bCryptBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    DspHex("[IN ]bIV            =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptCBC(nSock, nAlgo, bKey, bCryptBlock, \
                             nBlockLen, bIV, bPlainBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效数据长度=0测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptCBC_Test_13(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bCryptBlock[4104];
    int  nBlockLen;
    BYTE bPlainBlock[4104];
    BYTE bIV[16];
    BYTE bPlainBlockExp[4104];

    bufclr(bKey);
    bufclr(bCryptBlock);
    bufclr(bPlainBlock);
    bufclr(bIV);
    bufclr(bPlainBlockExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memcpy(bCryptBlock, "\x56\xCC\x09\xE7\xCF\xDC\x4C", 7);
    nBlockLen = 7;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bCryptBlock    =", bCryptBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    DspHex("[IN ]bIV            =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptCBC(nSock, nAlgo, bKey, bCryptBlock, \
                             nBlockLen, bIV, bPlainBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效数据长度=7测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptCBC_Test_14(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bCryptBlock[4104];
    int  nBlockLen;
    BYTE bPlainBlock[4104];
    BYTE bIV[16];
    BYTE bPlainBlockExp[4104];

    bufclr(bKey);
    bufclr(bCryptBlock);
    bufclr(bPlainBlock);
    bufclr(bIV);
    bufclr(bPlainBlockExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memset(bCryptBlock, 0x5C, 4097);
    bCryptBlock[0] = 0x25;
    bCryptBlock[4096] = 0x22;
    nBlockLen = 4097;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bCryptBlock    =", bCryptBlock, 4097);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    DspHex("[IN ]bIV            =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptCBC(nSock, nAlgo, bKey, bCryptBlock, \
                             nBlockLen, bIV, bPlainBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效数据长度=4097测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptCBC_Test_15(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bCryptBlock[4104];
    int  nBlockLen;
    BYTE bPlainBlock[4104];
    BYTE bIV[16];
    BYTE bPlainBlockExp[4104];

    bufclr(bKey);
    bufclr(bCryptBlock);
    bufclr(bPlainBlock);
    bufclr(bIV);
    bufclr(bPlainBlockExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memset(bCryptBlock, 0x5C, 4104);
    bCryptBlock[0] = 0x25;
    bCryptBlock[4103] = 0x22;
    nBlockLen = 4104;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bCryptBlock    =", bCryptBlock, 4104);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    DspHex("[IN ]bIV            =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptCBC(nSock, nAlgo, bKey, bCryptBlock, \
                             nBlockLen, bIV, bPlainBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效数据长度=4104测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptCBC_Test_16(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bCryptBlock[4104];
    int  nBlockLen;
    BYTE bPlainBlock[4104];
    BYTE bIV[16];
    BYTE bPlainBlockExp[4104];

    bufclr(bKey);
    bufclr(bCryptBlock);
    bufclr(bPlainBlock);
    bufclr(bIV);
    bufclr(bPlainBlockExp);

    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21", 8);
    memcpy(bCryptBlock, "\x12\xC6\x26\xAF\x05\x8B\x43\x3B", 8);
    nBlockLen = 8;
    /* 0123 4567 89AB CDEF */
    memcpy(bIV, "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF", 8);
    memcpy(bPlainBlockExp, "\x01\x23\x45\x67\x89\xAB\xCD\xEF", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 8);
    DspHex("[IN ]bCryptBlock    =", bCryptBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    DspHex("[IN ]bIV            =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptCBC(nSock, nAlgo, bKey, bCryptBlock, \
                             nBlockLen, bIV, bPlainBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "算法类型=1，数据长度=8，初始向量=FF，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bPlainBlock    =", bPlainBlock, 8);
    DspHex("[OUT]bPlainBlockExp =", bPlainBlockExp, 8);
    ASSERT_OUT_HEX(bPlainBlock, bPlainBlockExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptCBC_Test_17(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bCryptBlock[4104];
    int  nBlockLen;
    BYTE bPlainBlock[4104];
    BYTE bIV[16];
    BYTE bPlainBlockExp[4104];

    bufclr(bKey);
    bufclr(bCryptBlock);
    bufclr(bPlainBlock);
    bufclr(bIV);
    bufclr(bPlainBlockExp);

    nAlgo = 2;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
                 16);
    memcpy(bCryptBlock, "\x1F\xD1\xB0\x2B\x23\x7A\xF9\xAE", 8);
    nBlockLen = 8;
    memcpy(bIV, "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF", 8);
    /* 0123 4567 89AB CDEF */
    memcpy(bPlainBlockExp, "\x01\x23\x45\x67\x89\xAB\xCD\xEF", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 16);
    DspHex("[IN ]bCryptBlock    =", bCryptBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    DspHex("[IN ]bIV            =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptCBC(nSock, nAlgo, bKey, bCryptBlock, \
                             nBlockLen, bIV, bPlainBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "算法类型=2，数据长度=8，初始向量=FF，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bPlainBlock    =", bPlainBlock, 8);
    DspHex("[OUT]bPlainBlockExp =", bPlainBlockExp, 8);
    ASSERT_OUT_HEX(bPlainBlock, bPlainBlockExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DecryptCBC_Test_18(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i;

    int  nAlgo;
    BYTE bKey[32];
    BYTE bCryptBlock[4104];
    int  nBlockLen;
    BYTE bPlainBlock[4104];
    BYTE bIV[16];
    BYTE bPlainBlockExp[4104];

    bufclr(bKey);
    bufclr(bCryptBlock);
    bufclr(bPlainBlock);
    bufclr(bIV);
    bufclr(bPlainBlockExp);

    nAlgo = 3;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8697 A4B5 C2D3 E0F1 */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\x59\x99\xC3\x06\xAB\x84\x01\xB2",\
                 24);
    memcpy(bCryptBlock, "\x90\x26\x84\x9C\xA0\x1B\x4B\x05", 8);
    nBlockLen = 8;
    memcpy(bIV, "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF", 8);
    /* 0123 4567 89AB CDEF */
    memcpy(bPlainBlockExp, "\x01\x23\x45\x67\x89\xAB\xCD\xEF", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKey           =", bKey, 24);
    DspHex("[IN ]bCryptBlock    =", bCryptBlock, 8);
    printf("[IN ]nBlockLen      = %d\n", nBlockLen);
    DspHex("[IN ]bIV            =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDecryptCBC(nSock, nAlgo, bKey, bCryptBlock, \
                             nBlockLen, bIV, bPlainBlock);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "算法类型=3，数据长度=8，初始向量=FF，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bPlainBlock    =", bPlainBlock, 8);
    DspHex("[OUT]bPlainBlockExp =", bPlainBlockExp, 8);
    ASSERT_OUT_HEX(bPlainBlock, bPlainBlockExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalCVV_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bCVK[32];
    char szPan[24];
    int  nPanLen;
    char szExpireDate[8];
    char szServiceCode[8];
    char szCVV[4];
    char szCVVExp[4];

    bufclr(bCVK);
    bufclr(szPan);
    bufclr(szExpireDate);
    bufclr(szServiceCode);
    bufclr(szCVV);
    bufclr(szCVVExp);

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bCVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 1234567890123456 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36",\
                  16);
    nPanLen = 16;
    /* 1012 */
    memcpy(szExpireDate, "\x31\x30\x31\x32", 4);
    /* 321 */
    memcpy(szServiceCode, "\x33\x32\x31", 3);
    /* 709 */
    memcpy(szCVVExp, "\x37\x30\x39", 3);

    XXX_INPUT_XXX
    printf("[IN ]nSock         = %d\n", nSock);
    DspHex("[IN ]bCVK          =", bCVK, 16);
    DspHex("[IN ]szPan         =", szPan, 16);
    printf("[IN ]nPanLen       = %d\n", nPanLen);
    DspHex("[IN ]szExpireDate  =", szExpireDate, 4);
    DspHex("[IN ]szServiceCode =", szServiceCode, 3);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalCVV(nSock, bCVK, szPan, nPanLen, szExpireDate, \
                       szServiceCode, szCVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "账号长度=16测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szCVV         =", szCVV, 3);
    DspHex("[OUT]szCVVExp      =", szCVVExp, 3);
    ASSERT_OUT_HEX(szCVV, szCVVExp, 3);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalCVV_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bCVK[32];
    char szPan[24];
    int  nPanLen;
    char szExpireDate[8];
    char szServiceCode[8];
    char szCVV[4];
    char szCVVExp[4];

    bufclr(bCVK);
    bufclr(szPan);
    bufclr(szExpireDate);
    bufclr(szServiceCode);
    bufclr(szCVV);
    bufclr(szCVVExp);

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bCVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 1234567890123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 1012 */
    memcpy(szExpireDate, "\x31\x30\x31\x32", 4);
    /* 321 */
    memcpy(szServiceCode, "\x33\x32\x31", 3);
    /* 701 */
    memcpy(szCVVExp, "\x37\x30\x31", 3);

    XXX_INPUT_XXX
    printf("[IN ]nSock         = %d\n", nSock);
    DspHex("[IN ]bCVK          =", bCVK, 16);
    DspHex("[IN ]szPan         =", szPan, 19);
    printf("[IN ]nPanLen       = %d\n", nPanLen);
    DspHex("[IN ]szExpireDate  =", szExpireDate, 4);
    DspHex("[IN ]szServiceCode =", szServiceCode, 3);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalCVV(nSock, bCVK, szPan, nPanLen, szExpireDate, \
                       szServiceCode, szCVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "账号长度=19测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szCVV         =", szCVV, 3);
    DspHex("[OUT]szCVVExp      =", szCVVExp, 3);
    ASSERT_OUT_HEX(szCVV, szCVVExp, 3);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalCVV_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bCVK[32];
    char szPan[24];
    int  nPanLen;
    char szExpireDate[8];
    char szServiceCode[8];
    char szCVV[4];
    char szCVVExp[4];

    bufclr(bCVK);
    bufclr(szPan);
    bufclr(szExpireDate);
    bufclr(szServiceCode);
    bufclr(szCVV);
    bufclr(szCVVExp);

    /* 0101 0101 0101 0101 0101 0101 0101 0101 */
    memcpy(bCVK, "\x7E\xAB\x74\x3A\x23\x64\x7B\xE6" \
                 "\x7E\xAB\x74\x3A\x23\x64\x7B\xE6",\
                 16);
    /* 1234567890123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 1012 */
    memcpy(szExpireDate, "\x31\x30\x31\x32", 4);
    /* 321 */
    memcpy(szServiceCode, "\x33\x32\x31", 3);
    /* 357 */
    memcpy(szCVVExp, "\x33\x35\x37", 3);

    XXX_INPUT_XXX
    printf("[IN ]nSock         = %d\n", nSock);
    DspHex("[IN ]bCVK          =", bCVK, 16);
    DspHex("[IN ]szPan         =", szPan, 19);
    printf("[IN ]nPanLen       = %d\n", nPanLen);
    DspHex("[IN ]szExpireDate  =", szExpireDate, 4);
    DspHex("[IN ]szServiceCode =", szServiceCode, 3);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalCVV(nSock, bCVK, szPan, nPanLen, szExpireDate, \
                       szServiceCode, szCVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "最小CVK测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szCVV         =", szCVV, 3);
    DspHex("[OUT]szCVVExp      =", szCVVExp, 3);
    ASSERT_OUT_HEX(szCVV, szCVVExp, 3);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalCVV_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bCVK[32];
    char szPan[24];
    int  nPanLen;
    char szExpireDate[8];
    char szServiceCode[8];
    char szCVV[4];
    char szCVVExp[4];

    bufclr(bCVK);
    bufclr(szPan);
    bufclr(szExpireDate);
    bufclr(szServiceCode);
    bufclr(szCVV);
    bufclr(szCVVExp);

    /* FEFE FEFE FEFE FEFE FEFE FEFE FEFE FEFE */
    memcpy(bCVK, "\x6B\xAC\x93\xCC\x3A\x9E\x9A\x13" \
                 "\x6B\xAC\x93\xCC\x3A\x9E\x9A\x13",\
                 16);
    /* 1234567890123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 1012 */
    memcpy(szExpireDate, "\x31\x30\x31\x32", 4);
    /* 321 */
    memcpy(szServiceCode, "\x33\x32\x31", 3);
    /* 549 */
    memcpy(szCVVExp, "\x35\x34\x39", 3);

    XXX_INPUT_XXX
    printf("[IN ]nSock         = %d\n", nSock);
    DspHex("[IN ]bCVK          =", bCVK, 16);
    DspHex("[IN ]szPan         =", szPan, 19);
    printf("[IN ]nPanLen       = %d\n", nPanLen);
    DspHex("[IN ]szExpireDate  =", szExpireDate, 4);
    DspHex("[IN ]szServiceCode =", szServiceCode, 3);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalCVV(nSock, bCVK, szPan, nPanLen, szExpireDate, \
                       szServiceCode, szCVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "最大CVK测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szCVV         =", szCVV, 3);
    DspHex("[OUT]szCVVExp      =", szCVVExp, 3);
    ASSERT_OUT_HEX(szCVV, szCVVExp, 3);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalCVV_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bCVK[32];
    char szPan[24];
    int  nPanLen;
    char szExpireDate[8];
    char szServiceCode[8];
    char szCVV[4];
    char szCVVExp[4];

    bufclr(bCVK);
    bufclr(szPan);
    bufclr(szExpireDate);
    bufclr(szServiceCode);
    bufclr(szCVV);
    bufclr(szCVVExp);

    nSock = -1;

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bCVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 1234567890123456 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36",\
                  16);
    nPanLen = 16;
    /* 1012 */
    memcpy(szExpireDate, "\x31\x30\x31\x32", 4);
    /* 321 */
    memcpy(szServiceCode, "\x33\x32\x31", 3);

    XXX_INPUT_XXX
    printf("[IN ]nSock         = %d\n", nSock);
    DspHex("[IN ]bCVK          =", bCVK, 16);
    DspHex("[IN ]szPan         =", szPan, 16);
    printf("[IN ]nPanLen       = %d\n", nPanLen);
    DspHex("[IN ]szExpireDate  =", szExpireDate, 4);
    DspHex("[IN ]szServiceCode =", szServiceCode, 3);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalCVV(nSock, bCVK, szPan, nPanLen, szExpireDate, \
                       szServiceCode, szCVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void CalCVV_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bCVK[32];
    char szPan[24];
    int  nPanLen;
    char szExpireDate[8];
    char szServiceCode[8];
    char szCVV[4];
    char szCVVExp[4];

    bufclr(bCVK);
    bufclr(szPan);
    bufclr(szExpireDate);
    bufclr(szServiceCode);
    bufclr(szCVV);
    bufclr(szCVVExp);

    nSock = 8;

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bCVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 1234567890123456 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36",\
                  16);
    nPanLen = 16;
    /* 1012 */
    memcpy(szExpireDate, "\x31\x30\x31\x32", 4);
    /* 321 */
    memcpy(szServiceCode, "\x33\x32\x31", 3);

    XXX_INPUT_XXX
    printf("[IN ]nSock         = %d\n", nSock);
    DspHex("[IN ]bCVK          =", bCVK, 16);
    DspHex("[IN ]szPan         =", szPan, 16);
    printf("[IN ]nPanLen       = %d\n", nPanLen);
    DspHex("[IN ]szExpireDate  =", szExpireDate, 4);
    DspHex("[IN ]szServiceCode =", szServiceCode, 3);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalCVV(nSock, bCVK, szPan, nPanLen, szExpireDate, \
                       szServiceCode, szCVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[8]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void CalCVV_Test_07(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bCVK[32];
    char szPan[24];
    int  nPanLen;
    char szExpireDate[8];
    char szServiceCode[8];
    char szCVV[4];
    char szCVVExp[4];

    bufclr(bCVK);
    bufclr(szPan);
    bufclr(szExpireDate);
    bufclr(szServiceCode);
    bufclr(szCVV);
    bufclr(szCVVExp);

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bCVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 12345678901abc56 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x61\x62\x63\x35\x36",\
                  16);
    nPanLen = 16;
    /* 1012 */
    memcpy(szExpireDate, "\x31\x30\x31\x32", 4);
    /* 321 */
    memcpy(szServiceCode, "\x33\x32\x31", 3);

    XXX_INPUT_XXX
    printf("[IN ]nSock         = %d\n", nSock);
    DspHex("[IN ]bCVK          =", bCVK, 16);
    DspHex("[IN ]szPan         =", szPan, 16);
    printf("[IN ]nPanLen       = %d\n", nPanLen);
    DspHex("[IN ]szExpireDate  =", szExpireDate, 4);
    DspHex("[IN ]szServiceCode =", szServiceCode, 3);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalCVV(nSock, bCVK, szPan, nPanLen, szExpireDate, \
                       szServiceCode, szCVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效账号[12345678901abc56]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalCVV_Test_08(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bCVK[32];
    char szPan[24];
    int  nPanLen;
    char szExpireDate[8];
    char szServiceCode[8];
    char szCVV[4];
    char szCVVExp[4];

    bufclr(bCVK);
    bufclr(szPan);
    bufclr(szExpireDate);
    bufclr(szServiceCode);
    bufclr(szCVV);
    bufclr(szCVVExp);

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bCVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 12345678XYZ23456 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x58\x59\x5A\x32\x33\x34\x35\x36",\
                  16);
    nPanLen = 16;
    /* 1012 */
    memcpy(szExpireDate, "\x31\x30\x31\x32", 4);
    /* 321 */
    memcpy(szServiceCode, "\x33\x32\x31", 3);

    XXX_INPUT_XXX
    printf("[IN ]nSock         = %d\n", nSock);
    DspHex("[IN ]bCVK          =", bCVK, 16);
    DspHex("[IN ]szPan         =", szPan, 16);
    printf("[IN ]nPanLen       = %d\n", nPanLen);
    DspHex("[IN ]szExpireDate  =", szExpireDate, 4);
    DspHex("[IN ]szServiceCode =", szServiceCode, 3);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalCVV(nSock, bCVK, szPan, nPanLen, szExpireDate, \
                       szServiceCode, szCVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效账号[12345678XYZ23456]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalCVV_Test_09(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bCVK[32];
    char szPan[24];
    int  nPanLen;
    char szExpireDate[8];
    char szServiceCode[8];
    char szCVV[4];
    char szCVVExp[4];

    bufclr(bCVK);
    bufclr(szPan);
    bufclr(szExpireDate);
    bufclr(szServiceCode);
    bufclr(szCVV);
    bufclr(szCVVExp);

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bCVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 12!#%67890123456 */
    memcpy(szPan, "\x31\x32\x21\x23\x25\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36",\
                  16);
    nPanLen = 16;
    /* 1012 */
    memcpy(szExpireDate, "\x31\x30\x31\x32", 4);
    /* 321 */
    memcpy(szServiceCode, "\x33\x32\x31", 3);

    XXX_INPUT_XXX
    printf("[IN ]nSock         = %d\n", nSock);
    DspHex("[IN ]bCVK          =", bCVK, 16);
    DspHex("[IN ]szPan         =", szPan, 16);
    printf("[IN ]nPanLen       = %d\n", nPanLen);
    DspHex("[IN ]szExpireDate  =", szExpireDate, 4);
    DspHex("[IN ]szServiceCode =", szServiceCode, 3);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalCVV(nSock, bCVK, szPan, nPanLen, szExpireDate, \
                       szServiceCode, szCVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效账号[12!#%67890123456]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalCVV_Test_10(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bCVK[32];
    char szPan[24];
    int  nPanLen;
    char szExpireDate[8];
    char szServiceCode[8];
    char szCVV[4];
    char szCVVExp[4];

    bufclr(bCVK);
    bufclr(szPan);
    bufclr(szExpireDate);
    bufclr(szServiceCode);
    bufclr(szCVV);
    bufclr(szCVVExp);

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bCVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 0000000000000000000 */
    memcpy(szPan, "\x30\x30\x30\x30\x30\x30\x30\x30" \
                  "\x30\x30\x30\x30\x30\x30\x30\x30" \
                  "\x30\x30\x30", 19);
    nPanLen = 19;
    /* 1012 */
    memcpy(szExpireDate, "\x31\x30\x31\x32", 4);
    /* 321 */
    memcpy(szServiceCode, "\x33\x32\x31", 3);
    /* 023 */
    memcpy(szCVVExp, "\x30\x32\x33", 3);

    XXX_INPUT_XXX
    printf("[IN ]nSock         = %d\n", nSock);
    DspHex("[IN ]bCVK          =", bCVK, 16);
    DspHex("[IN ]szPan         =", szPan, 19);
    printf("[IN ]nPanLen       = %d\n", nPanLen);
    DspHex("[IN ]szExpireDate  =", szExpireDate, 4);
    DspHex("[IN ]szServiceCode =", szServiceCode, 3);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalCVV(nSock, bCVK, szPan, nPanLen, szExpireDate, \
                       szServiceCode, szCVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "最小账号测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szCVV         =", szCVV, 3);
    DspHex("[OUT]szCVVExp      =", szCVVExp, 3);
    ASSERT_OUT_HEX(szCVV, szCVVExp, 3);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalCVV_Test_11(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bCVK[32];
    char szPan[24];
    int  nPanLen;
    char szExpireDate[8];
    char szServiceCode[8];
    char szCVV[4];
    char szCVVExp[4];

    bufclr(bCVK);
    bufclr(szPan);
    bufclr(szExpireDate);
    bufclr(szServiceCode);
    bufclr(szCVV);
    bufclr(szCVVExp);

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bCVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 9999999999999999999 */
    memcpy(szPan, "\x39\x39\x39\x39\x39\x39\x39\x39" \
                  "\x39\x39\x39\x39\x39\x39\x39\x39" \
                  "\x39\x39\x39", 19);
    nPanLen = 19;
    /* 1012 */
    memcpy(szExpireDate, "\x31\x30\x31\x32", 4);
    /* 321 */
    memcpy(szServiceCode, "\x33\x32\x31", 3);
    /* 858 */
    memcpy(szCVVExp, "\x38\x35\x38", 3);

    XXX_INPUT_XXX
    printf("[IN ]nSock         = %d\n", nSock);
    DspHex("[IN ]bCVK          =", bCVK, 16);
    DspHex("[IN ]szPan         =", szPan, 19);
    printf("[IN ]nPanLen       = %d\n", nPanLen);
    DspHex("[IN ]szExpireDate  =", szExpireDate, 4);
    DspHex("[IN ]szServiceCode =", szServiceCode, 3);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalCVV(nSock, bCVK, szPan, nPanLen, szExpireDate, \
                       szServiceCode, szCVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "最大账号测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szCVV         =", szCVV, 3);
    DspHex("[OUT]szCVVExp      =", szCVVExp, 3);
    ASSERT_OUT_HEX(szCVV, szCVVExp, 3);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalCVV_Test_12(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bCVK[32];
    char szPan[24];
    int  nPanLen;
    char szExpireDate[8];
    char szServiceCode[8];
    char szCVV[4];
    char szCVVExp[4];

    bufclr(bCVK);
    bufclr(szPan);
    bufclr(szExpireDate);
    bufclr(szServiceCode);
    bufclr(szCVV);
    bufclr(szCVVExp);

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bCVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 123456789012345 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35",\
                  15);
    nPanLen = 15;
    /* 1012 */
    memcpy(szExpireDate, "\x31\x30\x31\x32", 4);
    /* 321 */
    memcpy(szServiceCode, "\x33\x32\x31", 3);

    XXX_INPUT_XXX
    printf("[IN ]nSock         = %d\n", nSock);
    DspHex("[IN ]bCVK          =", bCVK, 16);
    DspHex("[IN ]szPan         =", szPan, 15);
    printf("[IN ]nPanLen       = %d\n", nPanLen);
    DspHex("[IN ]szExpireDate  =", szExpireDate, 4);
    DspHex("[IN ]szServiceCode =", szServiceCode, 3);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalCVV(nSock, bCVK, szPan, nPanLen, szExpireDate, \
                       szServiceCode, szCVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效账号长度=15测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalCVV_Test_13(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bCVK[32];
    char szPan[24];
    int  nPanLen;
    char szExpireDate[8];
    char szServiceCode[8];
    char szCVV[4];
    char szCVVExp[4];

    bufclr(bCVK);
    bufclr(szPan);
    bufclr(szExpireDate);
    bufclr(szServiceCode);
    bufclr(szCVV);
    bufclr(szCVVExp);

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bCVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 12345678901234567 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37", 17);
    nPanLen = 17;
    /* 1012 */
    memcpy(szExpireDate, "\x31\x30\x31\x32", 4);
    /* 321 */
    memcpy(szServiceCode, "\x33\x32\x31", 3);
	memcpy(szCVVExp, "\x34\x31\x32", 3);

    XXX_INPUT_XXX
    printf("[IN ]nSock         = %d\n", nSock);
    DspHex("[IN ]bCVK          =", bCVK, 16);
    DspHex("[IN ]szPan         =", szPan, 17);
    printf("[IN ]nPanLen       = %d\n", nPanLen);
    DspHex("[IN ]szExpireDate  =", szExpireDate, 4);
    DspHex("[IN ]szServiceCode =", szServiceCode, 3);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalCVV(nSock, bCVK, szPan, nPanLen, szExpireDate, \
                       szServiceCode, szCVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "无效账号长度=17测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szCVV         =", szCVV, 3);
    DspHex("[OUT]szCVVExp      =", szCVVExp, 3);
    ASSERT_OUT_HEX(szCVV, szCVVExp, 3);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalCVV_Test_14(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bCVK[32];
    char szPan[24];
    int  nPanLen;
    char szExpireDate[8];
    char szServiceCode[8];
    char szCVV[4];
    char szCVVExp[4];

    bufclr(bCVK);
    bufclr(szPan);
    bufclr(szExpireDate);
    bufclr(szServiceCode);
    bufclr(szCVV);
    bufclr(szCVVExp);

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bCVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 123456789012345678 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38", 18);
    nPanLen = 18;
    /* 1012 */
    memcpy(szExpireDate, "\x31\x30\x31\x32", 4);
    /* 321 */
    memcpy(szServiceCode, "\x33\x32\x31", 3);
    memcpy(szCVVExp, "\x33\x37\x38", 3);

    XXX_INPUT_XXX
    printf("[IN ]nSock         = %d\n", nSock);
    DspHex("[IN ]bCVK          =", bCVK, 16);
    DspHex("[IN ]szPan         =", szPan, 18);
    printf("[IN ]nPanLen       = %d\n", nPanLen);
    DspHex("[IN ]szExpireDate  =", szExpireDate, 4);
    DspHex("[IN ]szServiceCode =", szServiceCode, 3);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalCVV(nSock, bCVK, szPan, nPanLen, szExpireDate, \
                       szServiceCode, szCVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "无效账号长度=18测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szCVV         =", szCVV, 3);
    DspHex("[OUT]szCVVExp      =", szCVVExp, 3);
    ASSERT_OUT_HEX(szCVV, szCVVExp, 3);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalCVV_Test_15(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bCVK[32];
    char szPan[24];
    int  nPanLen;
    char szExpireDate[8];
    char szServiceCode[8];
    char szCVV[4];
    char szCVVExp[4];

    bufclr(bCVK);
    bufclr(szPan);
    bufclr(szExpireDate);
    bufclr(szServiceCode);
    bufclr(szCVV);
    bufclr(szCVVExp);

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bCVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 12345678901234567890 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39\x30", 20);
    nPanLen = 20;
    /* 1012 */
    memcpy(szExpireDate, "\x31\x30\x31\x32", 4);
    /* 321 */
    memcpy(szServiceCode, "\x33\x32\x31", 3);

    XXX_INPUT_XXX
    printf("[IN ]nSock         = %d\n", nSock);
    DspHex("[IN ]bCVK          =", bCVK, 16);
    DspHex("[IN ]szPan         =", szPan, 20);
    printf("[IN ]nPanLen       = %d\n", nPanLen);
    DspHex("[IN ]szExpireDate  =", szExpireDate, 4);
    DspHex("[IN ]szServiceCode =", szServiceCode, 3);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalCVV(nSock, bCVK, szPan, nPanLen, szExpireDate, \
                       szServiceCode, szCVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效账号长度=20测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalCVV_Test_16(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bCVK[32];
    char szPan[24];
    int  nPanLen;
    char szExpireDate[8];
    char szServiceCode[8];
    char szCVV[4];
    char szCVVExp[4];

    bufclr(bCVK);
    bufclr(szPan);
    bufclr(szExpireDate);
    bufclr(szServiceCode);
    bufclr(szCVV);
    bufclr(szCVVExp);

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bCVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 1234567890123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 0001 */
    memcpy(szExpireDate, "\x30\x30\x30\x31", 4);
    /* 321 */
    memcpy(szServiceCode, "\x33\x32\x31", 3);
    /* 830 */
    memcpy(szCVVExp, "\x38\x33\x30", 3);

    XXX_INPUT_XXX
    printf("[IN ]nSock         = %d\n", nSock);
    DspHex("[IN ]bCVK          =", bCVK, 16);
    DspHex("[IN ]szPan         =", szPan, 19);
    printf("[IN ]nPanLen       = %d\n", nPanLen);
    DspHex("[IN ]szExpireDate  =", szExpireDate, 4);
    DspHex("[IN ]szServiceCode =", szServiceCode, 3);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalCVV(nSock, bCVK, szPan, nPanLen, szExpireDate, \
                       szServiceCode, szCVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "最小卡有效期测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szCVV         =", szCVV, 3);
    DspHex("[OUT]szCVVExp      =", szCVVExp, 3);
    ASSERT_OUT_HEX(szCVV, szCVVExp, 3);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalCVV_Test_17(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bCVK[32];
    char szPan[24];
    int  nPanLen;
    char szExpireDate[8];
    char szServiceCode[8];
    char szCVV[4];
    char szCVVExp[4];

    bufclr(bCVK);
    bufclr(szPan);
    bufclr(szExpireDate);
    bufclr(szServiceCode);
    bufclr(szCVV);
    bufclr(szCVVExp);

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bCVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 1234567890123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 9912 */
    memcpy(szExpireDate, "\x39\x39\x31\x32", 4);
    /* 321 */
    memcpy(szServiceCode, "\x33\x32\x31", 3);
    /* 253 */
    memcpy(szCVVExp, "\x32\x35\x33", 3);

    XXX_INPUT_XXX
    printf("[IN ]nSock         = %d\n", nSock);
    DspHex("[IN ]bCVK          =", bCVK, 16);
    DspHex("[IN ]szPan         =", szPan, 19);
    printf("[IN ]nPanLen       = %d\n", nPanLen);
    DspHex("[IN ]szExpireDate  =", szExpireDate, 4);
    DspHex("[IN ]szServiceCode =", szServiceCode, 3);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalCVV(nSock, bCVK, szPan, nPanLen, szExpireDate, \
                       szServiceCode, szCVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "最大卡有效期测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szCVV         =", szCVV, 3);
    DspHex("[OUT]szCVVExp      =", szCVVExp, 3);
    ASSERT_OUT_HEX(szCVV, szCVVExp, 3);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalCVV_Test_18(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bCVK[32];
    char szPan[24];
    int  nPanLen;
    char szExpireDate[8];
    char szServiceCode[8];
    char szCVV[4];
    char szCVVExp[4];

    bufclr(bCVK);
    bufclr(szPan);
    bufclr(szExpireDate);
    bufclr(szServiceCode);
    bufclr(szCVV);
    bufclr(szCVVExp);

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bCVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 1234567890123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 101D */
    memcpy(szExpireDate, "\x31\x30\x31\x44", 4);
    /* 321 */
    memcpy(szServiceCode, "\x33\x32\x31", 3);

    XXX_INPUT_XXX
    printf("[IN ]nSock         = %d\n", nSock);
    DspHex("[IN ]bCVK          =", bCVK, 16);
    DspHex("[IN ]szPan         =", szPan, 19);
    printf("[IN ]nPanLen       = %d\n", nPanLen);
    DspHex("[IN ]szExpireDate  =", szExpireDate, 4);
    DspHex("[IN ]szServiceCode =", szServiceCode, 3);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalCVV(nSock, bCVK, szPan, nPanLen, szExpireDate, \
                       szServiceCode, szCVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效卡有效期[101D]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalCVV_Test_19(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bCVK[32];
    char szPan[24];
    int  nPanLen;
    char szExpireDate[8];
    char szServiceCode[8];
    char szCVV[4];
    char szCVVExp[4];

    bufclr(bCVK);
    bufclr(szPan);
    bufclr(szExpireDate);
    bufclr(szServiceCode);
    bufclr(szCVV);
    bufclr(szCVVExp);

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bCVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 1234567890123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 1012 */
    memcpy(szExpireDate, "\x31\x30\x31\x32", 4);
    /* 000 */
    memcpy(szServiceCode, "\x30\x30\x30", 3);
    /* 266 */
    memcpy(szCVVExp, "\x32\x36\x36", 3);

    XXX_INPUT_XXX
    printf("[IN ]nSock         = %d\n", nSock);
    DspHex("[IN ]bCVK          =", bCVK, 16);
    DspHex("[IN ]szPan         =", szPan, 19);
    printf("[IN ]nPanLen       = %d\n", nPanLen);
    DspHex("[IN ]szExpireDate  =", szExpireDate, 4);
    DspHex("[IN ]szServiceCode =", szServiceCode, 3);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalCVV(nSock, bCVK, szPan, nPanLen, szExpireDate, \
                       szServiceCode, szCVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "最小服务代码测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szCVV         =", szCVV, 3);
    DspHex("[OUT]szCVVExp      =", szCVVExp, 3);
    ASSERT_OUT_HEX(szCVV, szCVVExp, 3);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalCVV_Test_20(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bCVK[32];
    char szPan[24];
    int  nPanLen;
    char szExpireDate[8];
    char szServiceCode[8];
    char szCVV[4];
    char szCVVExp[4];

    bufclr(bCVK);
    bufclr(szPan);
    bufclr(szExpireDate);
    bufclr(szServiceCode);
    bufclr(szCVV);
    bufclr(szCVVExp);

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bCVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 1234567890123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 1012 */
    memcpy(szExpireDate, "\x31\x30\x31\x32", 4);
    /* 999 */
    memcpy(szServiceCode, "\x39\x39\x39", 3);
    /* 425 */
    memcpy(szCVVExp, "\x34\x32\x35", 3);

    XXX_INPUT_XXX
    printf("[IN ]nSock         = %d\n", nSock);
    DspHex("[IN ]bCVK          =", bCVK, 16);
    DspHex("[IN ]szPan         =", szPan, 19);
    printf("[IN ]nPanLen       = %d\n", nPanLen);
    DspHex("[IN ]szExpireDate  =", szExpireDate, 4);
    DspHex("[IN ]szServiceCode =", szServiceCode, 3);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalCVV(nSock, bCVK, szPan, nPanLen, szExpireDate, \
                       szServiceCode, szCVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "最大服务代码测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szCVV         =", szCVV, 3);
    DspHex("[OUT]szCVVExp      =", szCVVExp, 3);
    ASSERT_OUT_HEX(szCVV, szCVVExp, 3);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalCVV_Test_21(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bCVK[32];
    char szPan[24];
    int  nPanLen;
    char szExpireDate[8];
    char szServiceCode[8];
    char szCVV[4];
    char szCVVExp[4];

    bufclr(bCVK);
    bufclr(szPan);
    bufclr(szExpireDate);
    bufclr(szServiceCode);
    bufclr(szCVV);
    bufclr(szCVVExp);

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bCVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 1234567890123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 1012 */
    memcpy(szExpireDate, "\x31\x30\x31\x32", 4);
    /* 3E1 */
    memcpy(szServiceCode, "\x33\x45\x31", 3);

    XXX_INPUT_XXX
    printf("[IN ]nSock         = %d\n", nSock);
    DspHex("[IN ]bCVK          =", bCVK, 16);
    DspHex("[IN ]szPan         =", szPan, 19);
    printf("[IN ]nPanLen       = %d\n", nPanLen);
    DspHex("[IN ]szExpireDate  =", szExpireDate, 4);
    DspHex("[IN ]szServiceCode =", szServiceCode, 3);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalCVV(nSock, bCVK, szPan, nPanLen, szExpireDate, \
                       szServiceCode, szCVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效服务代码[3E1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalPVV_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bPVK[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    int  nPVKIndex;
    char szPVV[8];
    char szPVVExp[8];

    bufclr(bPVK);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szPVV);
    bufclr(szPVVExp);

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bPVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 1234567890123456 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36",\
                  16);
    nPanLen = 16;
    /* 1234 */
    memcpy(szPlainPin, "\x31\x32\x33\x34", 4);
    nPVKIndex = 0;
    /* 2136 */
    memcpy(szPVVExp, "2136", 4);

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    DspHex("[IN ]bPVK       =", bPVK, 16);
    DspHex("[IN ]szPan      =", szPan, 16);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin =", szPlainPin, 4);
    printf("[IN ]nPVKIndex  = %d\n", nPVKIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalPVV(nSock, bPVK, szPan, nPanLen, szPlainPin, \
                       nPVKIndex, szPVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "账号长度=16，密码长度=4，密钥索引=0，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szPVV      =", szPVV, 4);
    DspHex("[OUT]szPVVExp   =", szPVVExp, 4);
    ASSERT_OUT_HEX(szPVV, szPVVExp, 4);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalPVV_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bPVK[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    int  nPVKIndex;
    char szPVV[8];
    char szPVVExp[8];

    bufclr(bPVK);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szPVV);
    bufclr(szPVVExp);

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bPVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 1234567890123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 123456789012 */
    memcpy(szPlainPin, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                       "\x39\x30\x31\x32", 12);
    nPVKIndex = 15;
    /* 8403 */
    memcpy(szPVVExp, "8403", 4);
//    memcpy(szPVVExp, "8480", 4); /* VISA */

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    DspHex("[IN ]bPVK       =", bPVK, 16);
    DspHex("[IN ]szPan      =", szPan, 19);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin =", szPlainPin, 12);
    printf("[IN ]nPVKIndex  = %d\n", nPVKIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalPVV(nSock, bPVK, szPan, nPanLen, szPlainPin, \
                       nPVKIndex, szPVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "账号长度=19，密码长度=12，密钥索引=F，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szPVV      =", szPVV, 4);
    DspHex("[OUT]szPVVExp   =", szPVVExp, 4);
    ASSERT_OUT_HEX(szPVV, szPVVExp, 4);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalPVV_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bPVK[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    int  nPVKIndex;
    char szPVV[8];
    char szPVVExp[8];

    bufclr(bPVK);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szPVV);
    bufclr(szPVVExp);

    /* 0101 0101 0101 0101 0101 0101 0101 0101 */
    memcpy(bPVK, "\x7E\xAB\x74\x3A\x23\x64\x7B\xE6" \
                 "\x7E\xAB\x74\x3A\x23\x64\x7B\xE6",\
                 16);
    /* 1234567890123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 123456789012 */
    memcpy(szPlainPin, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                       "\x39\x30\x31\x32", 12);
    nPVKIndex = 1;
    /* 6785 */
    memcpy(szPVVExp, "6785", 4);
//    memcpy(szPVVExp, "9007", 4); /* VISA */

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    DspHex("[IN ]bPVK       =", bPVK, 16);
    DspHex("[IN ]szPan      =", szPan, 19);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin =", szPlainPin, 12);
    printf("[IN ]nPVKIndex  = %d\n", nPVKIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalPVV(nSock, bPVK, szPan, nPanLen, szPlainPin, \
                       nPVKIndex, szPVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "最小PVK,密钥索引=1,测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szPVV      =", szPVV, 4);
    DspHex("[OUT]szPVVExp   =", szPVVExp, 4);
    ASSERT_OUT_HEX(szPVV, szPVVExp, 4);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalPVV_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bPVK[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    int  nPVKIndex;
    char szPVV[8];
    char szPVVExp[8];

    bufclr(bPVK);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szPVV);
    bufclr(szPVVExp);

    /* FEFE FEFE FEFE FEFE FEFE FEFE FEFE FEFE */
    memcpy(bPVK, "\x6B\xAC\x93\xCC\x3A\x9E\x9A\x13" \
                 "\x6B\xAC\x93\xCC\x3A\x9E\x9A\x13",\
                 16);
    /* 1234567890123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 123456789012 */
    memcpy(szPlainPin, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                       "\x39\x30\x31\x32", 12);
    nPVKIndex = 2;
    /* 1478 */
    memcpy(szPVVExp, "1478", 4);
//    memcpy(szPVVExp, "2561", 4);  /* VISA */

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    DspHex("[IN ]bPVK       =", bPVK, 16);
    DspHex("[IN ]szPan      =", szPan, 19);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin =", szPlainPin, 12);
    printf("[IN ]nPVKIndex  = %d\n", nPVKIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalPVV(nSock, bPVK, szPan, nPanLen, szPlainPin, \
                       nPVKIndex, szPVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "最大PVK,密钥索引=2,测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szPVV      =", szPVV, 4);
    DspHex("[OUT]szPVVExp   =", szPVVExp, 4);
    ASSERT_OUT_HEX(szPVV, szPVVExp, 4);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalPVV_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bPVK[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    int  nPVKIndex;
    char szPVV[8];
    char szPVVExp[8];

    bufclr(bPVK);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szPVV);
    bufclr(szPVVExp);

    nSock = -1;
    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bPVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 1234567890123456 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36",\
                  16);
    nPanLen = 16;
    /* 1234 */
    memcpy(szPlainPin, "\x31\x32\x33\x34", 4);
    nPVKIndex = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    DspHex("[IN ]bPVK       =", bPVK, 16);
    DspHex("[IN ]szPan      =", szPan, 16);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin =", szPlainPin, 4);
    printf("[IN ]nPVKIndex  = %d\n", nPVKIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalPVV(nSock, bPVK, szPan, nPanLen, szPlainPin, \
                       nPVKIndex, szPVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void CalPVV_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bPVK[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    int  nPVKIndex;
    char szPVV[8];
    char szPVVExp[8];

    bufclr(bPVK);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szPVV);
    bufclr(szPVVExp);

    nSock = 8;
    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bPVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 1234567890123456 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36",\
                  16);
    nPanLen = 16;
    /* 1234 */
    memcpy(szPlainPin, "\x31\x32\x33\x34", 4);
    nPVKIndex = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    DspHex("[IN ]bPVK       =", bPVK, 16);
    DspHex("[IN ]szPan      =", szPan, 16);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin =", szPlainPin, 4);
    printf("[IN ]nPVKIndex  = %d\n", nPVKIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalPVV(nSock, bPVK, szPan, nPanLen, szPlainPin, \
                       nPVKIndex, szPVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[8]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void CalPVV_Test_07(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bPVK[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    int  nPVKIndex;
    char szPVV[8];
    char szPVVExp[8];

    bufclr(bPVK);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szPVV);
    bufclr(szPVVExp);

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bPVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 1234567890123456xyz */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x78\x79\x7A", 19);
    nPanLen = 19;
    /* 123456789012 */
    memcpy(szPlainPin, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                       "\x39\x30\x31\x32", 12);
    nPVKIndex = 15;

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    DspHex("[IN ]bPVK       =", bPVK, 16);
    DspHex("[IN ]szPan      =", szPan, 19);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin =", szPlainPin, 12);
    printf("[IN ]nPVKIndex  = %d\n", nPVKIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalPVV(nSock, bPVK, szPan, nPanLen, szPlainPin, \
                       nPVKIndex, szPVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效账号[1234567890123456xyz]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalPVV_Test_08(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bPVK[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    int  nPVKIndex;
    char szPVV[8];
    char szPVVExp[8];

    bufclr(bPVK);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szPVV);
    bufclr(szPVVExp);

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bPVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 1234567890ABC456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x41\x42\x43\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 123456789012 */
    memcpy(szPlainPin, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                       "\x39\x30\x31\x32", 12);
    nPVKIndex = 15;

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    DspHex("[IN ]bPVK       =", bPVK, 16);
    DspHex("[IN ]szPan      =", szPan, 19);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin =", szPlainPin, 12);
    printf("[IN ]nPVKIndex  = %d\n", nPVKIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalPVV(nSock, bPVK, szPan, nPanLen, szPlainPin, \
                       nPVKIndex, szPVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效账号[1234567890ABC456789]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalPVV_Test_09(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bPVK[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    int  nPVKIndex;
    char szPVV[8];
    char szPVVExp[8];

    bufclr(bPVK);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szPVV);
    bufclr(szPVVExp);

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bPVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 123456@$^0123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x40\x24" \
                  "\x5E\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 123456789012 */
    memcpy(szPlainPin, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                       "\x39\x30\x31\x32", 12);
    nPVKIndex = 15;

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    DspHex("[IN ]bPVK       =", bPVK, 16);
    DspHex("[IN ]szPan      =", szPan, 19);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin =", szPlainPin, 12);
    printf("[IN ]nPVKIndex  = %d\n", nPVKIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalPVV(nSock, bPVK, szPan, nPanLen, szPlainPin, \
                       nPVKIndex, szPVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效账号[123456@$^0123456789]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalPVV_Test_10(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bPVK[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    int  nPVKIndex;
    char szPVV[8];
    char szPVVExp[8];

    bufclr(bPVK);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szPVV);
    bufclr(szPVVExp);

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bPVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 123456789012345 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35"\
                  , 15);
    nPanLen = 15;
    /* 123456789012 */
    memcpy(szPlainPin, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                       "\x39\x30\x31\x32", 12);
    nPVKIndex = 15;
	memcpy(szPVVExp, "\x37\x35\x39\x30",4);

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    DspHex("[IN ]bPVK       =", bPVK, 16);
    DspHex("[IN ]szPan      =", szPan, 15);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin =", szPlainPin, 12);
    printf("[IN ]nPVKIndex  = %d\n", nPVKIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalPVV(nSock, bPVK, szPan, nPanLen, szPlainPin, \
                       nPVKIndex, szPVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "无效账号长度=15测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szPVV      =", szPVV, 4);
    DspHex("[OUT]szPVVExp   =", szPVVExp, 4);
    ASSERT_OUT_HEX(szPVV, szPVVExp, 4);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalPVV_Test_11(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bPVK[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    int  nPVKIndex;
    char szPVV[8];
    char szPVVExp[8];

    bufclr(bPVK);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szPVV);
    bufclr(szPVVExp);

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bPVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 12345678901234567 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36"\
                  "\x37", 17);
    nPanLen = 17;
    /* 123456789012 */
    memcpy(szPlainPin, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                       "\x39\x30\x31\x32", 12);
    nPVKIndex = 15;
	memcpy(szPVVExp,"\x37\x38\x30\x39",4);

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    DspHex("[IN ]bPVK       =", bPVK, 16);
    DspHex("[IN ]szPan      =", szPan, 17);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin =", szPlainPin, 12);
    printf("[IN ]nPVKIndex  = %d\n", nPVKIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalPVV(nSock, bPVK, szPan, nPanLen, szPlainPin, \
                       nPVKIndex, szPVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "无效账号长度=17测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szPVV      =", szPVV, 4);
    DspHex("[OUT]szPVVExp   =", szPVVExp, 4);
    ASSERT_OUT_HEX(szPVV, szPVVExp, 4);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalPVV_Test_12(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bPVK[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    int  nPVKIndex;
    char szPVV[8];
    char szPVVExp[8];

    bufclr(bPVK);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szPVV);
    bufclr(szPVVExp);

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bPVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 123456789012345678 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36"\
                  "\x37\x38", 18);
    nPanLen = 18;
    /* 123456789012 */
    memcpy(szPlainPin, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                       "\x39\x30\x31\x32", 12);
    nPVKIndex = 15;
	memcpy(szPVVExp,"\x38\x36\x35\x34",4);

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    DspHex("[IN ]bPVK       =", bPVK, 16);
    DspHex("[IN ]szPan      =", szPan, 18);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin =", szPlainPin, 12);
    printf("[IN ]nPVKIndex  = %d\n", nPVKIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalPVV(nSock, bPVK, szPan, nPanLen, szPlainPin, \
                       nPVKIndex, szPVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "无效账号长度=18测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szPVV      =", szPVV, 4);
    DspHex("[OUT]szPVVExp   =", szPVVExp, 4);
    ASSERT_OUT_HEX(szPVV, szPVVExp, 4);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalPVV_Test_13(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bPVK[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    int  nPVKIndex;
    char szPVV[8];
    char szPVVExp[8];

    bufclr(bPVK);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szPVV);
    bufclr(szPVVExp);

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bPVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 12345678901234567890 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36"\
                  "\x37\x38\x39\x30", 20);
    nPanLen = 20;
    /* 123456789012 */
    memcpy(szPlainPin, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                       "\x39\x30\x31\x32", 12);
    nPVKIndex = 15;

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    DspHex("[IN ]bPVK       =", bPVK, 16);
    DspHex("[IN ]szPan      =", szPan, 20);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin =", szPlainPin, 12);
    printf("[IN ]nPVKIndex  = %d\n", nPVKIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalPVV(nSock, bPVK, szPan, nPanLen, szPlainPin, \
                       nPVKIndex, szPVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效账号长度=20测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalPVV_Test_14(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bPVK[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    int  nPVKIndex;
    char szPVV[8];
    char szPVVExp[8];

    bufclr(bPVK);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szPVV);
    bufclr(szPVVExp);

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bPVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 1234567890123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 12345 */
    memcpy(szPlainPin, "\x31\x32\x33\x34\x35", 5);
    nPVKIndex = 3;
    /* 6492 */
    memcpy(szPVVExp, "6492", 4);
//    memcpy(szPVVExp, "8331", 4);  /* VISA */

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    DspHex("[IN ]bPVK       =", bPVK, 16);
    DspHex("[IN ]szPan      =", szPan, 19);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin =", szPlainPin, 12);
    printf("[IN ]nPVKIndex  = %d\n", nPVKIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalPVV(nSock, bPVK, szPan, nPanLen, szPlainPin, \
                       nPVKIndex, szPVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "账号长度=19，密码长度=5，密钥索引=3，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szPVV      =", szPVV, 4);
    DspHex("[OUT]szPVVExp   =", szPVVExp, 4);
    ASSERT_OUT_HEX(szPVV, szPVVExp, 4);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalPVV_Test_15(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bPVK[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    int  nPVKIndex;
    char szPVV[8];
    char szPVVExp[8];

    bufclr(bPVK);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szPVV);
    bufclr(szPVVExp);

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bPVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 1234567890123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 123456 */
    memcpy(szPlainPin, "\x31\x32\x33\x34\x35\x36", 6);
    nPVKIndex = 4;
    /* 1991 */
    memcpy(szPVVExp, "1991", 4);
//    memcpy(szPVVExp, "9112", 4); /* VISA */

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    DspHex("[IN ]bPVK       =", bPVK, 16);
    DspHex("[IN ]szPan      =", szPan, 19);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin =", szPlainPin, 12);
    printf("[IN ]nPVKIndex  = %d\n", nPVKIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalPVV(nSock, bPVK, szPan, nPanLen, szPlainPin, \
                       nPVKIndex, szPVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "账号长度=19，密码长度=6，密钥索引=4，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szPVV      =", szPVV, 4);
    DspHex("[OUT]szPVVExp   =", szPVVExp, 4);
    ASSERT_OUT_HEX(szPVV, szPVVExp, 4);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalPVV_Test_16(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bPVK[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    int  nPVKIndex;
    char szPVV[8];
    char szPVVExp[8];

    bufclr(bPVK);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szPVV);
    bufclr(szPVVExp);

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bPVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 1234567890123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 1234567 */
    memcpy(szPlainPin, "\x31\x32\x33\x34\x35\x36\x37", 7);
    nPVKIndex = 5;
    /* 3324 */
    memcpy(szPVVExp, "3324", 4);
//    memcpy(szPVVExp, "2861", 4);  /* VISA */

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    DspHex("[IN ]bPVK       =", bPVK, 16);
    DspHex("[IN ]szPan      =", szPan, 19);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin =", szPlainPin, 12);
    printf("[IN ]nPVKIndex  = %d\n", nPVKIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalPVV(nSock, bPVK, szPan, nPanLen, szPlainPin, \
                       nPVKIndex, szPVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "账号长度=19，密码长度=7，密钥索引=5，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szPVV      =", szPVV, 4);
    DspHex("[OUT]szPVVExp   =", szPVVExp, 4);
    ASSERT_OUT_HEX(szPVV, szPVVExp, 4);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalPVV_Test_17(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bPVK[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    int  nPVKIndex;
    char szPVV[8];
    char szPVVExp[8];

    bufclr(bPVK);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szPVV);
    bufclr(szPVVExp);

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bPVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 1234567890123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 12345678 */
    memcpy(szPlainPin, "\x31\x32\x33\x34\x35\x36\x37\x38", 8);
    nPVKIndex = 6;
    /* 7717 */
    memcpy(szPVVExp, "7717", 4);
//    memcpy(szPVVExp, "6618", 4);  /* VISA */

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    DspHex("[IN ]bPVK       =", bPVK, 16);
    DspHex("[IN ]szPan      =", szPan, 19);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin =", szPlainPin, 12);
    printf("[IN ]nPVKIndex  = %d\n", nPVKIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalPVV(nSock, bPVK, szPan, nPanLen, szPlainPin, \
                       nPVKIndex, szPVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "账号长度=19，密码长度=8，密钥索引=6，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szPVV      =", szPVV, 4);
    DspHex("[OUT]szPVVExp   =", szPVVExp, 4);
    ASSERT_OUT_HEX(szPVV, szPVVExp, 4);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalPVV_Test_18(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bPVK[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    int  nPVKIndex;
    char szPVV[8];
    char szPVVExp[8];

    bufclr(bPVK);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szPVV);
    bufclr(szPVVExp);

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bPVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 1234567890123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 123456789 */
    memcpy(szPlainPin, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                       "\x39", 9);
    nPVKIndex = 7;
    /* 3457 */
    memcpy(szPVVExp, "3457", 4);
//    memcpy(szPVVExp, "7011", 4); /* VISA */

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    DspHex("[IN ]bPVK       =", bPVK, 16);
    DspHex("[IN ]szPan      =", szPan, 19);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin =", szPlainPin, 12);
    printf("[IN ]nPVKIndex  = %d\n", nPVKIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalPVV(nSock, bPVK, szPan, nPanLen, szPlainPin, \
                       nPVKIndex, szPVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "账号长度=19，密码长度=9，密钥索引=7，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szPVV      =", szPVV, 4);
    DspHex("[OUT]szPVVExp   =", szPVVExp, 4);
    ASSERT_OUT_HEX(szPVV, szPVVExp, 4);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalPVV_Test_19(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bPVK[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    int  nPVKIndex;
    char szPVV[8];
    char szPVVExp[8];

    bufclr(bPVK);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szPVV);
    bufclr(szPVVExp);

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bPVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 1234567890123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 1234567890 */
    memcpy(szPlainPin, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                       "\x39\x30", 10);
    nPVKIndex = 8;
    /* 0756 */
    memcpy(szPVVExp, "0756", 4);
//    memcpy(szPVVExp, "2548", 4); /* VISA */

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    DspHex("[IN ]bPVK       =", bPVK, 16);
    DspHex("[IN ]szPan      =", szPan, 19);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin =", szPlainPin, 12);
    printf("[IN ]nPVKIndex  = %d\n", nPVKIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalPVV(nSock, bPVK, szPan, nPanLen, szPlainPin, \
                       nPVKIndex, szPVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "账号长度=19，密码长度=10，密钥索引=8，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szPVV      =", szPVV, 4);
    DspHex("[OUT]szPVVExp   =", szPVVExp, 4);
    ASSERT_OUT_HEX(szPVV, szPVVExp, 4);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalPVV_Test_20(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bPVK[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    int  nPVKIndex;
    char szPVV[8];
    char szPVVExp[8];

    bufclr(bPVK);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szPVV);
    bufclr(szPVVExp);

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bPVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 1234567890123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 12345678901 */
    memcpy(szPlainPin, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                       "\x39\x30\x31", 11);
    nPVKIndex = 9;
    /* 3266 */
    memcpy(szPVVExp, "3266", 4);
//    memcpy(szPVVExp, "5812", 4); /* VISA */

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    DspHex("[IN ]bPVK       =", bPVK, 16);
    DspHex("[IN ]szPan      =", szPan, 19);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin =", szPlainPin, 12);
    printf("[IN ]nPVKIndex  = %d\n", nPVKIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalPVV(nSock, bPVK, szPan, nPanLen, szPlainPin, \
                       nPVKIndex, szPVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "账号长度=19，密码长度=11，密钥索引=9，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szPVV      =", szPVV, 4);
    DspHex("[OUT]szPVVExp   =", szPVVExp, 4);
    ASSERT_OUT_HEX(szPVV, szPVVExp, 4);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalPVV_Test_21(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bPVK[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    int  nPVKIndex;
    char szPVV[8];
    char szPVVExp[8];

    bufclr(bPVK);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szPVV);
    bufclr(szPVVExp);

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bPVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 1234567890123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 234561 */
    memcpy(szPlainPin, "\x32\x33\x34\x35\x36\x31", 6);
    nPVKIndex = 10;
    /* 2029 */
    memcpy(szPVVExp, "2029", 4);
//    memcpy(szPVVExp, "2523", 4); /* VISA */

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    DspHex("[IN ]bPVK       =", bPVK, 16);
    DspHex("[IN ]szPan      =", szPan, 19);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin =", szPlainPin, 12);
    printf("[IN ]nPVKIndex  = %d\n", nPVKIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalPVV(nSock, bPVK, szPan, nPanLen, szPlainPin, \
                       nPVKIndex, szPVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "账号长度=19，密码长度=6，密钥索引=10，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szPVV      =", szPVV, 4);
    DspHex("[OUT]szPVVExp   =", szPVVExp, 4);
    ASSERT_OUT_HEX(szPVV, szPVVExp, 4);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalPVV_Test_22(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bPVK[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    int  nPVKIndex;
    char szPVV[8];
    char szPVVExp[8];

    bufclr(bPVK);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szPVV);
    bufclr(szPVVExp);

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bPVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 1234567890123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 345612 */
    memcpy(szPlainPin, "\x33\x34\x35\x36\x31\x32", 6);
    nPVKIndex = 11;
    /* 1433 */
    memcpy(szPVVExp, "1433", 4);
//    memcpy(szPVVExp, "6507", 4); /* VISA */

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    DspHex("[IN ]bPVK       =", bPVK, 16);
    DspHex("[IN ]szPan      =", szPan, 19);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin =", szPlainPin, 12);
    printf("[IN ]nPVKIndex  = %d\n", nPVKIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalPVV(nSock, bPVK, szPan, nPanLen, szPlainPin, \
                       nPVKIndex, szPVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "账号长度=19，密码长度=6，密钥索引=11，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szPVV      =", szPVV, 4);
    DspHex("[OUT]szPVVExp   =", szPVVExp, 4);
    ASSERT_OUT_HEX(szPVV, szPVVExp, 4);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalPVV_Test_23(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bPVK[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    int  nPVKIndex;
    char szPVV[8];
    char szPVVExp[8];

    bufclr(bPVK);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szPVV);
    bufclr(szPVVExp);

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bPVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 1234567890123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 456123 */
    memcpy(szPlainPin, "\x34\x35\x36\x31\x32\x33", 6);
    nPVKIndex = 12;
    /* 5976 */
    memcpy(szPVVExp, "5976", 4);
//    memcpy(szPVVExp, "5647", 4); /* VISA */

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    DspHex("[IN ]bPVK       =", bPVK, 16);
    DspHex("[IN ]szPan      =", szPan, 19);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin =", szPlainPin, 12);
    printf("[IN ]nPVKIndex  = %d\n", nPVKIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalPVV(nSock, bPVK, szPan, nPanLen, szPlainPin, \
                       nPVKIndex, szPVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "账号长度=19，密码长度=6，密钥索引=12，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szPVV      =", szPVV, 4);
    DspHex("[OUT]szPVVExp   =", szPVVExp, 4);
    ASSERT_OUT_HEX(szPVV, szPVVExp, 4);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalPVV_Test_24(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bPVK[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    int  nPVKIndex;
    char szPVV[8];
    char szPVVExp[8];

    bufclr(bPVK);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szPVV);
    bufclr(szPVVExp);

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bPVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 1234567890123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 561234 */
    memcpy(szPlainPin, "\x35\x36\x31\x32\x33\x34", 6);
    nPVKIndex = 13;
    /* 1574 */
    memcpy(szPVVExp, "1574", 4);
//    memcpy(szPVVExp, "2244", 4); /* VISA */

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    DspHex("[IN ]bPVK       =", bPVK, 16);
    DspHex("[IN ]szPan      =", szPan, 19);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin =", szPlainPin, 12);
    printf("[IN ]nPVKIndex  = %d\n", nPVKIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalPVV(nSock, bPVK, szPan, nPanLen, szPlainPin, \
                       nPVKIndex, szPVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "账号长度=19，密码长度=6，密钥索引=13，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szPVV      =", szPVV, 4);
    DspHex("[OUT]szPVVExp   =", szPVVExp, 4);
    ASSERT_OUT_HEX(szPVV, szPVVExp, 4);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalPVV_Test_25(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bPVK[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    int  nPVKIndex;
    char szPVV[8];
    char szPVVExp[8];

    bufclr(bPVK);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szPVV);
    bufclr(szPVVExp);

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bPVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 1234567890123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 612345 */
    memcpy(szPlainPin, "\x36\x31\x32\x33\x34\x35", 6);
    nPVKIndex = 14;
    /* 4126 */
    memcpy(szPVVExp, "4126", 4);
//    memcpy(szPVVExp, "6937", 4); /* VISA */

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    DspHex("[IN ]bPVK       =", bPVK, 16);
    DspHex("[IN ]szPan      =", szPan, 19);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin =", szPlainPin, 12);
    printf("[IN ]nPVKIndex  = %d\n", nPVKIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalPVV(nSock, bPVK, szPan, nPanLen, szPlainPin, \
                       nPVKIndex, szPVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "账号长度=19，密码长度=6，密钥索引=14，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szPVV      =", szPVV, 4);
    DspHex("[OUT]szPVVExp   =", szPVVExp, 4);
    ASSERT_OUT_HEX(szPVV, szPVVExp, 4);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalPVV_Test_26(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bPVK[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    int  nPVKIndex;
    char szPVV[8];
    char szPVVExp[8];

    bufclr(bPVK);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szPVV);
    bufclr(szPVVExp);

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bPVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 1234567890123456 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36",\
                  16);
    nPanLen = 16;
    /* 123 */
    memcpy(szPlainPin, "\x31\x32\x33", 3);
    nPVKIndex = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    DspHex("[IN ]bPVK       =", bPVK, 16);
    DspHex("[IN ]szPan      =", szPan, 16);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin =", szPlainPin, 3);
    printf("[IN ]nPVKIndex  = %d\n", nPVKIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalPVV(nSock, bPVK, szPan, nPanLen, szPlainPin, \
                       nPVKIndex, szPVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效密码长度=3测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalPVV_Test_27(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bPVK[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    int  nPVKIndex;
    char szPVV[8];
    char szPVVExp[8];

    bufclr(bPVK);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szPVV);
    bufclr(szPVVExp);

    /* FEDC BA98 7654 3210 0123 4567 89AB CDEF */
    memcpy(bPVK, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                 "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21",\
                 16);
    /* 1234567890123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 1234567890123 */
    memcpy(szPlainPin, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                       "\x39\x30\x31\x32\x33", 13);
    nPVKIndex = 15;

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    DspHex("[IN ]bPVK       =", bPVK, 16);
    DspHex("[IN ]szPan      =", szPan, 19);
    printf("[IN ]nPanLen    = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin =", szPlainPin, 13);
    printf("[IN ]nPVKIndex  = %d\n", nPVKIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalPVV(nSock, bPVK, szPan, nPanLen, szPlainPin, \
                       nPVKIndex, szPVV);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效密码长度=13测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void IBM3624_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    char szOffset[13];
    char szOffsetExp[13];

    bufclr(bKey);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szOffset);
    bufclr(szOffsetExp);

    /* FEDC BA98 7654 3210 */
    memcpy(bKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A", 8);
    /* 1234567890123456 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36",\
                  16);
    nPanLen = 16;
    /* 1234 */
    memcpy(szPlainPin, "\x31\x32\x33\x34", 4);
    /* 6616 */
    memcpy(szOffsetExp, "\x36\x36\x31\x36", 4);

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    DspHex("[IN ]bKey        =", bKey, 8);
    DspHex("[IN ]szPan       =", szPan, 16);
    printf("[IN ]nPanLen     = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin  =", szPlainPin, 4);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIIBM3624(nSock, bKey, szPan, nPanLen, szPlainPin, szOffset);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "账号长度=16，密码长度=4，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szOffset    =", szOffset, 4);
    DspHex("[OUT]szOffsetExp =", szOffsetExp, 4);
    ASSERT_OUT_HEX(szOffset, szOffsetExp, 4);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void IBM3624_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    char szOffset[13];
    char szOffsetExp[13];

    bufclr(bKey);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szOffset);
    bufclr(szOffsetExp);

    /* FEDC BA98 7654 3210 */
    memcpy(bKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A", 8);
    /* 1234567890123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 123456789012 */
    memcpy(szPlainPin, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                       "\x39\x30\x31\x32", 12);
    /*
       No V-bit   101976277971
       Left most  661629498685
       Rignt most 485926947289
     */
    memcpy(szOffsetExp, "485926947289", 12);

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    DspHex("[IN ]bKey        =", bKey, 8);
    DspHex("[IN ]szPan       =", szPan, 19);
    printf("[IN ]nPanLen     = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin  =", szPlainPin, 12);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIIBM3624(nSock, bKey, szPan, nPanLen, szPlainPin, szOffset);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "账号长度=19，密码长度=12，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szOffset    =", szOffset, 12);
    DspHex("[OUT]szOffsetExp =", szOffsetExp, 12);
    ASSERT_OUT_HEX(szOffset, szOffsetExp, 12);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void IBM3624_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    char szOffset[13];
    char szOffsetExp[13];

    bufclr(bKey);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szOffset);
    bufclr(szOffsetExp);

    /* 0101 0101 0101 0101 */
    memcpy(bKey, "\x7E\xAB\x74\x3A\x23\x64\x7B\xE6", 8);
    /* 1234567890123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 123456789012 */
    memcpy(szPlainPin, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                       "\x39\x30\x31\x32", 12);
    /*
       No V-bit   420825585037
       Left most  922390847976
       Rignt most 083256753983
     */
    memcpy(szOffsetExp, "083256753983", 12);

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    DspHex("[IN ]bKey        =", bKey, 8);
    DspHex("[IN ]szPan       =", szPan, 19);
    printf("[IN ]nPanLen     = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin  =", szPlainPin, 12);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIIBM3624(nSock, bKey, szPan, nPanLen, szPlainPin, szOffset);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "最小密钥测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szOffset    =", szOffset, 12);
    DspHex("[OUT]szOffsetExp =", szOffsetExp, 12);
    ASSERT_OUT_HEX(szOffset, szOffsetExp, 12);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void IBM3624_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    char szOffset[13];
    char szOffsetExp[13];

    bufclr(bKey);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szOffset);
    bufclr(szOffsetExp);

    /* FEFE FEFE FEFE FEFE */
    memcpy(bKey, "\x6B\xAC\x93\xCC\x3A\x9E\x9A\x13", 8);
    /* 1234567890123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 123456789012 */
    memcpy(szPlainPin, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                       "\x39\x30\x31\x32", 12);
    /*
       No V-bit   613243744059
       Left most  711274186530
       Rignt most 861473529951
     */
    memcpy(szOffsetExp, "861473529951", 12);

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    DspHex("[IN ]bKey        =", bKey, 8);
    DspHex("[IN ]szPan       =", szPan, 19);
    printf("[IN ]nPanLen     = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin  =", szPlainPin, 12);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIIBM3624(nSock, bKey, szPan, nPanLen, szPlainPin, szOffset);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "最大密钥测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szOffset    =", szOffset, 12);
    DspHex("[OUT]szOffsetExp =", szOffsetExp, 12);
    ASSERT_OUT_HEX(szOffset, szOffsetExp, 12);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void IBM3624_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    char szOffset[13];
    char szOffsetExp[13];

    bufclr(bKey);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szOffset);
    bufclr(szOffsetExp);

    nSock = -1;
    /* FEDC BA98 7654 3210 */
    memcpy(bKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A", 8);
    /* 1234567890123456 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  , 16);
    nPanLen = 16;
    /* 1234 */
    memcpy(szPlainPin, "\x31\x32\x33\x34", 4);

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    DspHex("[IN ]bKey        =", bKey, 8);
    DspHex("[IN ]szPan       =", szPan, 16);
    printf("[IN ]nPanLen     = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin  =", szPlainPin, 4);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIIBM3624(nSock, bKey, szPan, nPanLen, szPlainPin, szOffset);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void IBM3624_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    char szOffset[13];
    char szOffsetExp[13];

    bufclr(bKey);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szOffset);
    bufclr(szOffsetExp);

    nSock = 8;
    /* FEDC BA98 7654 3210 */
    memcpy(bKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A", 8);
    /* 1234567890123456 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  , 16);
    nPanLen = 16;
    /* 1234 */
    memcpy(szPlainPin, "\x31\x32\x33\x34", 4);

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    DspHex("[IN ]bKey        =", bKey, 8);
    DspHex("[IN ]szPan       =", szPan, 16);
    printf("[IN ]nPanLen     = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin  =", szPlainPin, 4);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIIBM3624(nSock, bKey, szPan, nPanLen, szPlainPin, szOffset);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[8]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void IBM3624_Test_07(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    char szOffset[13];
    char szOffsetExp[13];

    bufclr(bKey);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szOffset);
    bufclr(szOffsetExp);

    /* FEDC BA98 7654 3210 */
    memcpy(bKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A", 8);
    /* 1234567890123def */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x64\x65\x66" \
                  , 16);
    nPanLen = 16;
    /* 1234 */
    memcpy(szPlainPin, "\x31\x32\x33\x34", 4);

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    DspHex("[IN ]bKey        =", bKey, 8);
    DspHex("[IN ]szPan       =", szPan, 16);
    printf("[IN ]nPanLen     = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin  =", szPlainPin, 4);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIIBM3624(nSock, bKey, szPan, nPanLen, szPlainPin, szOffset);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效账号[1234567890123def]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void IBM3624_Test_08(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    char szOffset[13];
    char szOffsetExp[13];

    bufclr(bKey);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szOffset);
    bufclr(szOffsetExp);

    /* FEDC BA98 7654 3210 */
    memcpy(bKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A", 8);
    /* 12345678901UVW56 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x55\x56\x57\x35\x36" \
                  , 16);
    nPanLen = 16;
    /* 1234 */
    memcpy(szPlainPin, "\x31\x32\x33\x34", 4);

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    DspHex("[IN ]bKey        =", bKey, 8);
    DspHex("[IN ]szPan       =", szPan, 16);
    printf("[IN ]nPanLen     = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin  =", szPlainPin, 4);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIIBM3624(nSock, bKey, szPan, nPanLen, szPlainPin, szOffset);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效账号[12345678901UVW56]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void IBM3624_Test_09(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    char szOffset[13];
    char szOffsetExp[13];

    bufclr(bKey);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szOffset);
    bufclr(szOffsetExp);

    /* FEDC BA98 7654 3210 */
    memcpy(bKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A", 8);
    /* 123456789+-=3456 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x2B\x2D\x3D\x33\x34\x35\x36" \
                  , 16);
    nPanLen = 16;
    /* 1234 */
    memcpy(szPlainPin, "\x31\x32\x33\x34", 4);

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    DspHex("[IN ]bKey        =", bKey, 8);
    DspHex("[IN ]szPan       =", szPan, 16);
    printf("[IN ]nPanLen     = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin  =", szPlainPin, 4);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIIBM3624(nSock, bKey, szPan, nPanLen, szPlainPin, szOffset);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效账号[123456789+-=3456]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void IBM3624_Test_10(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    char szOffset[13];
    char szOffsetExp[13];

    bufclr(bKey);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szOffset);
    bufclr(szOffsetExp);

    /* FEDC BA98 7654 3210 */
    memcpy(bKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A", 8);
    /* 123456789012345 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35",\
                  15);
    nPanLen = 15;
    /* 1234 */
    memcpy(szPlainPin, "\x31\x32\x33\x34", 4);

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    DspHex("[IN ]bKey        =", bKey, 8);
    DspHex("[IN ]szPan       =", szPan, 15);
    printf("[IN ]nPanLen     = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin  =", szPlainPin, 4);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIIBM3624(nSock, bKey, szPan, nPanLen, szPlainPin, szOffset);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效账号长度=15测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void IBM3624_Test_11(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    char szOffset[13];
    char szOffsetExp[13];

    bufclr(bKey);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szOffset);
    bufclr(szOffsetExp);

    /* FEDC BA98 7654 3210 */
    memcpy(bKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A", 8);
    /* 12345678901234567 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37", 17);
    nPanLen = 17;
    /* 1234 */
    memcpy(szPlainPin, "\x31\x32\x33\x34", 4);

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    DspHex("[IN ]bKey        =", bKey, 8);
    DspHex("[IN ]szPan       =", szPan, 17);
    printf("[IN ]nPanLen     = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin  =", szPlainPin, 4);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIIBM3624(nSock, bKey, szPan, nPanLen, szPlainPin, szOffset);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效账号长度=17测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void IBM3624_Test_12(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    char szOffset[13];
    char szOffsetExp[13];

    bufclr(bKey);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szOffset);
    bufclr(szOffsetExp);

    /* FEDC BA98 7654 3210 */
    memcpy(bKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A", 8);
    /* 123456789012345678 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38", 18);
    nPanLen = 18;
    /* 1234 */
    memcpy(szPlainPin, "\x31\x32\x33\x34", 4);

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    DspHex("[IN ]bKey        =", bKey, 8);
    DspHex("[IN ]szPan       =", szPan, 18);
    printf("[IN ]nPanLen     = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin  =", szPlainPin, 4);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIIBM3624(nSock, bKey, szPan, nPanLen, szPlainPin, szOffset);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效账号长度=18测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void IBM3624_Test_13(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    char szOffset[13];
    char szOffsetExp[13];

    bufclr(bKey);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szOffset);
    bufclr(szOffsetExp);

    /* FEDC BA98 7654 3210 */
    memcpy(bKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A", 8);
    /* 123456789012345678 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39\x30", 20);
    nPanLen = 20;
    /* 1234 */
    memcpy(szPlainPin, "\x31\x32\x33\x34", 4);

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    DspHex("[IN ]bKey        =", bKey, 8);
    DspHex("[IN ]szPan       =", szPan, 20);
    printf("[IN ]nPanLen     = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin  =", szPlainPin, 4);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIIBM3624(nSock, bKey, szPan, nPanLen, szPlainPin, szOffset);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效账号长度=20测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void IBM3624_Test_14(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    char szOffset[13];
    char szOffsetExp[13];

    bufclr(bKey);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szOffset);
    bufclr(szOffsetExp);

    /* FEDC BA98 7654 3210 */
    memcpy(bKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A", 8);
    /* 1234567890123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 12345 */
    memcpy(szPlainPin, "\x31\x32\x33\x34\x35", 5);
    /*
       No V-bit   10197
       Left most  66162
       Rignt most 48592
     */
    memcpy(szOffsetExp, "48592", 5);

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    DspHex("[IN ]bKey        =", bKey, 8);
    DspHex("[IN ]szPan       =", szPan, 19);
    printf("[IN ]nPanLen     = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin  =", szPlainPin, 5);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIIBM3624(nSock, bKey, szPan, nPanLen, szPlainPin, szOffset);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密码长度=5测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szOffset    =", szOffset, 5);
    DspHex("[OUT]szOffsetExp =", szOffsetExp, 5);
    ASSERT_OUT_HEX(szOffset, szOffsetExp, 5);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void IBM3624_Test_15(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    char szOffset[13];
    char szOffsetExp[13];

    bufclr(bKey);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szOffset);
    bufclr(szOffsetExp);

    /* FEDC BA98 7654 3210 */
    memcpy(bKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A", 8);
    /* 1234567890123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 123456 */
    memcpy(szPlainPin, "\x31\x32\x33\x34\x35\x36", 6);
    /*
       No V-bit   101976
       Left most  661629
       Rignt most 485926
     */
    memcpy(szOffsetExp, "485926", 6);

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    DspHex("[IN ]bKey        =", bKey, 8);
    DspHex("[IN ]szPan       =", szPan, 19);
    printf("[IN ]nPanLen     = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin  =", szPlainPin, 6);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIIBM3624(nSock, bKey, szPan, nPanLen, szPlainPin, szOffset);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密码长度=6测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szOffset    =", szOffset, 6);
    DspHex("[OUT]szOffsetExp =", szOffsetExp, 6);
    ASSERT_OUT_HEX(szOffset, szOffsetExp, 6);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void IBM3624_Test_16(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    char szOffset[13];
    char szOffsetExp[13];

    bufclr(bKey);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szOffset);
    bufclr(szOffsetExp);

    /* FEDC BA98 7654 3210 */
    memcpy(bKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A", 8);
    /* 1234567890123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 1234567 */
    memcpy(szPlainPin, "\x31\x32\x33\x34\x35\x36\x37", 7);
    /*
       No V-bit   1019762
       Left most  6616294
       Rignt most 4859269
     */
    memcpy(szOffsetExp, "4859269", 7);

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    DspHex("[IN ]bKey        =", bKey, 8);
    DspHex("[IN ]szPan       =", szPan, 19);
    printf("[IN ]nPanLen     = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin  =", szPlainPin, 7);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIIBM3624(nSock, bKey, szPan, nPanLen, szPlainPin, szOffset);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密码长度=7测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szOffset    =", szOffset, 7);
    DspHex("[OUT]szOffsetExp =", szOffsetExp, 7);
    ASSERT_OUT_HEX(szOffset, szOffsetExp, 7);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void IBM3624_Test_17(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    char szOffset[13];
    char szOffsetExp[13];

    bufclr(bKey);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szOffset);
    bufclr(szOffsetExp);

    /* FEDC BA98 7654 3210 */
    memcpy(bKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A", 8);
    /* 1234567890123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 12345678 */
    memcpy(szPlainPin, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                       , 8);
    /*
       No V-bit   10197627
       Left most  66162949
       Rignt most 48592694
     */
    memcpy(szOffsetExp, "48592694", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    DspHex("[IN ]bKey        =", bKey, 8);
    DspHex("[IN ]szPan       =", szPan, 19);
    printf("[IN ]nPanLen     = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin  =", szPlainPin, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIIBM3624(nSock, bKey, szPan, nPanLen, szPlainPin, szOffset);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密码长度=8测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szOffset    =", szOffset, 8);
    DspHex("[OUT]szOffsetExp =", szOffsetExp, 8);
    ASSERT_OUT_HEX(szOffset, szOffsetExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void IBM3624_Test_18(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    char szOffset[13];
    char szOffsetExp[13];

    bufclr(bKey);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szOffset);
    bufclr(szOffsetExp);

    /* FEDC BA98 7654 3210 */
    memcpy(bKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A", 8);
    /* 1234567890123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 123456789 */
    memcpy(szPlainPin, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                       "\x39", 9);
    /*
       No V-bit   101976277
       Left most  661629498
       Rignt most 485926947
     */
    memcpy(szOffsetExp, "485926947", 9);

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    DspHex("[IN ]bKey        =", bKey, 8);
    DspHex("[IN ]szPan       =", szPan, 19);
    printf("[IN ]nPanLen     = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin  =", szPlainPin, 9);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIIBM3624(nSock, bKey, szPan, nPanLen, szPlainPin, szOffset);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密码长度=9测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szOffset    =", szOffset, 9);
    DspHex("[OUT]szOffsetExp =", szOffsetExp, 9);
    ASSERT_OUT_HEX(szOffset, szOffsetExp, 9);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void IBM3624_Test_19(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    char szOffset[13];
    char szOffsetExp[13];

    bufclr(bKey);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szOffset);
    bufclr(szOffsetExp);

    /* FEDC BA98 7654 3210 */
    memcpy(bKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A", 8);
    /* 1234567890123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 1234567890 */
    memcpy(szPlainPin, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                       "\x39\x30", 10);
    /*
       No V-bit   1019762779
       Left most  6616294986
       Rignt most 4859269472
     */
    memcpy(szOffsetExp, "4859269472", 10);

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    DspHex("[IN ]bKey        =", bKey, 8);
    DspHex("[IN ]szPan       =", szPan, 19);
    printf("[IN ]nPanLen     = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin  =", szPlainPin, 10);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIIBM3624(nSock, bKey, szPan, nPanLen, szPlainPin, szOffset);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密码长度=10测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szOffset    =", szOffset, 10);
    DspHex("[OUT]szOffsetExp =", szOffsetExp, 10);
    ASSERT_OUT_HEX(szOffset, szOffsetExp, 10);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void IBM3624_Test_20(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    char szOffset[13];
    char szOffsetExp[13];

    bufclr(bKey);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szOffset);
    bufclr(szOffsetExp);

    /* FEDC BA98 7654 3210 */
    memcpy(bKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A", 8);
    /* 1234567890123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 12345678901 */
    memcpy(szPlainPin, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                       "\x39\x30\x31", 11);
    /*
       No V-bit   10197627797
       Left most  66162949868
       Rignt most 48592694728
     */
    memcpy(szOffsetExp, "48592694728", 11);

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    DspHex("[IN ]bKey        =", bKey, 8);
    DspHex("[IN ]szPan       =", szPan, 19);
    printf("[IN ]nPanLen     = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin  =", szPlainPin, 11);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIIBM3624(nSock, bKey, szPan, nPanLen, szPlainPin, szOffset);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密码长度=11测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szOffset    =", szOffset, 11);
    DspHex("[OUT]szOffsetExp =", szOffsetExp, 11);
    ASSERT_OUT_HEX(szOffset, szOffsetExp, 11);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void IBM3624_Test_21(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    char szOffset[13];
    char szOffsetExp[13];

    bufclr(bKey);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szOffset);
    bufclr(szOffsetExp);

    /* FEDC BA98 7654 3210 */
    memcpy(bKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A", 8);
    /* 1234567890123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 123 */
    memcpy(szPlainPin, "\x31\x32\x33", 3);

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    DspHex("[IN ]bKey        =", bKey, 8);
    DspHex("[IN ]szPan       =", szPan, 19);
    printf("[IN ]nPanLen     = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin  =", szPlainPin, 3);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIIBM3624(nSock, bKey, szPan, nPanLen, szPlainPin, szOffset);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效密码长度=3测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void IBM3624_Test_22(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    char szOffset[13];
    char szOffsetExp[13];

    bufclr(bKey);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szOffset);
    bufclr(szOffsetExp);

    /* FEDC BA98 7654 3210 */
    memcpy(bKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A", 8);
    /* 1234567890123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 1234567890123 */
    memcpy(szPlainPin, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                       "\x39\x30\x31\x32\x33", 13);

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    DspHex("[IN ]bKey        =", bKey, 8);
    DspHex("[IN ]szPan       =", szPan, 19);
    printf("[IN ]nPanLen     = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin  =", szPlainPin, 13);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIIBM3624(nSock, bKey, szPan, nPanLen, szPlainPin, szOffset);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效密码长度=13测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void IBM3624_Test_23(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    char szOffset[13];
    char szOffsetExp[13];

    bufclr(bKey);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szOffset);
    bufclr(szOffsetExp);

    /* FEDC BA98 7654 3210 */
    memcpy(bKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A", 8);
    /* 1234567890123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 123456789def */
    memcpy(szPlainPin, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                       "\x39\x64\x65\x66", 12);

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    DspHex("[IN ]bKey        =", bKey, 8);
    DspHex("[IN ]szPan       =", szPan, 19);
    printf("[IN ]nPanLen     = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin  =", szPlainPin, 12);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIIBM3624(nSock, bKey, szPan, nPanLen, szPlainPin, szOffset);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效密码[123456789def]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void IBM3624_Test_24(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    char szOffset[13];
    char szOffsetExp[13];

    bufclr(bKey);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szOffset);
    bufclr(szOffsetExp);

    /* FEDC BA98 7654 3210 */
    memcpy(bKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A", 8);
    /* 1234567890123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 1234567UVW12 */
    memcpy(szPlainPin, "\x31\x32\x33\x34\x35\x36\x37\x55" \
                       "\x56\x57\x31\x32", 12);

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    DspHex("[IN ]bKey        =", bKey, 8);
    DspHex("[IN ]szPan       =", szPan, 19);
    printf("[IN ]nPanLen     = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin  =", szPlainPin, 12);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIIBM3624(nSock, bKey, szPan, nPanLen, szPlainPin, szOffset);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效密码[1234567UVW12]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void IBM3624_Test_25(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    char szPan[24];
    int  nPanLen;
    char szPlainPin[16];
    char szOffset[13];
    char szOffsetExp[13];

    bufclr(bKey);
    bufclr(szPan);
    bufclr(szPlainPin);
    bufclr(szOffset);
    bufclr(szOffsetExp);

    /* FEDC BA98 7654 3210 */
    memcpy(bKey, "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A", 8);
    /* 1234567890123456789 */
    memcpy(szPan, "\x31\x32\x33\x34\x35\x36\x37\x38" \
                  "\x39\x30\x31\x32\x33\x34\x35\x36" \
                  "\x37\x38\x39", 19);
    nPanLen = 19;
    /* 12345+-=9012 */
    memcpy(szPlainPin, "\x31\x32\x33\x34\x35\x2B\x2D\x3D" \
                       "\x39\x30\x31\x32", 12);

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    DspHex("[IN ]bKey        =", bKey, 8);
    DspHex("[IN ]szPan       =", szPan, 19);
    printf("[IN ]nPanLen     = %d\n", nPanLen);
    DspHex("[IN ]szPlainPin  =", szPlainPin, 12);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIIBM3624(nSock, bKey, szPan, nPanLen, szPlainPin, szOffset);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效密码[12345+-=9012]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenRandDigits_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nDigitNum;
    char szDigits[4100];

    bufclr(szDigits);

    nDigitNum = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nDigitNum = %d\n", nDigitNum);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenRandDigits(nSock, nDigitNum, szDigits);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "长度=0测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenRandDigits_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nDigitNum;
    char szDigits[4100];

    bufclr(szDigits);

    nDigitNum = 1;

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nDigitNum = %d\n", nDigitNum);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenRandDigits(nSock, nDigitNum, szDigits);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "长度=1测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szDigits  = %s\n", szDigits);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenRandDigits_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nDigitNum;
    char szDigits[4100];

    bufclr(szDigits);

    nDigitNum = 2;

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nDigitNum = %d\n", nDigitNum);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenRandDigits(nSock, nDigitNum, szDigits);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "长度=2测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szDigits  = %s\n", szDigits);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenRandDigits_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nDigitNum;
    char szDigits[4100];

    bufclr(szDigits);

    nDigitNum = 4;

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nDigitNum = %d\n", nDigitNum);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenRandDigits(nSock, nDigitNum, szDigits);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "长度=4测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szDigits  = %s\n", szDigits);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenRandDigits_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nDigitNum;
    char szDigits[4100];

    bufclr(szDigits);

    nDigitNum = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nDigitNum = %d\n", nDigitNum);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenRandDigits(nSock, nDigitNum, szDigits);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "长度=8测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szDigits  = %s\n", szDigits);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenRandDigits_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nDigitNum;
    char szDigits[4100];

    bufclr(szDigits);

    nDigitNum = 16;

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nDigitNum = %d\n", nDigitNum);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenRandDigits(nSock, nDigitNum, szDigits);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "长度=16测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szDigits  = %s\n", szDigits);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenRandDigits_Test_07(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nDigitNum;
    char szDigits[4100];

    bufclr(szDigits);

    nDigitNum = 32;

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nDigitNum = %d\n", nDigitNum);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenRandDigits(nSock, nDigitNum, szDigits);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "长度=32测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szDigits  = %s\n", szDigits);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenRandDigits_Test_08(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nDigitNum;
    char szDigits[4100];

    bufclr(szDigits);

    nDigitNum = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nDigitNum = %d\n", nDigitNum);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenRandDigits(nSock, nDigitNum, szDigits);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "长度=64测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szDigits  = %s\n", szDigits);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenRandDigits_Test_09(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nDigitNum;
    char szDigits[4100];

    bufclr(szDigits);

    nDigitNum = 128;

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nDigitNum = %d\n", nDigitNum);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenRandDigits(nSock, nDigitNum, szDigits);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "长度=128测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szDigits  = %s\n", szDigits);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenRandDigits_Test_10(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nDigitNum;
    char szDigits[4100];

    bufclr(szDigits);

    nDigitNum = 256;

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nDigitNum = %d\n", nDigitNum);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenRandDigits(nSock, nDigitNum, szDigits);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "长度=256测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szDigits  = %s\n", szDigits);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenRandDigits_Test_11(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nDigitNum;
    char szDigits[4100];

    bufclr(szDigits);

    nDigitNum = 512;

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nDigitNum = %d\n", nDigitNum);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenRandDigits(nSock, nDigitNum, szDigits);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "长度=512测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szDigits  = %s\n", szDigits);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenRandDigits_Test_12(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nDigitNum;
    char szDigits[4100];

    bufclr(szDigits);

    nDigitNum = 1024;

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nDigitNum = %d\n", nDigitNum);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenRandDigits(nSock, nDigitNum, szDigits);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "长度=1024测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]szDigits  = %s\n", szDigits);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenRandDigits_Test_13(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nDigitNum;
    char szDigits[4100];

    bufclr(szDigits);

    nDigitNum = 2048;

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nDigitNum = %d\n", nDigitNum);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenRandDigits(nSock, nDigitNum, szDigits);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效长度=2048测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenRandDigits_Test_14(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nDigitNum;
    char szDigits[4100];

    bufclr(szDigits);

    nDigitNum = 4096;

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nDigitNum = %d\n", nDigitNum);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenRandDigits(nSock, nDigitNum, szDigits);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效长度=4096测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenRandDigits_Test_15(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nDigitNum;
    char szDigits[4100];

    bufclr(szDigits);

    nSock = -1;
    nDigitNum = 1;

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nDigitNum = %d\n", nDigitNum);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenRandDigits(nSock, nDigitNum, szDigits);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void GenRandDigits_Test_16(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nDigitNum;
    char szDigits[4100];

    bufclr(szDigits);

    nSock = 8;
    nDigitNum = 1;

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nDigitNum = %d\n", nDigitNum);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenRandDigits(nSock, nDigitNum, szDigits);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[8]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void GenRandDigits_Test_17(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nDigitNum;
    char szDigits[4100];

    bufclr(szDigits);

    nDigitNum = -1;

    XXX_INPUT_XXX
    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nDigitNum = %d\n", nDigitNum);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenRandDigits(nSock, nDigitNum, szDigits);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效长度=-1测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifyCheckValue_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    int  nKeyLen;
    char szCheckValue[16];

    bufclr(bKey);
    bufclr(szCheckValue);

    /* 3210 7654 BA98 FEDC */
    memcpy(bKey, "\x2D\x68\x6F\x97\xFB\xB5\x82\xE1", \
                 8);
    nKeyLen = 8;
    /* C0FF 24F5 6A27 D34A */
    memcpy(szCheckValue, "C0FF24F5", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    DspHex("[IN ]bKey         =", bKey, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifyCheckValue(nSock, bKey, nKeyLen, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密钥长度=8测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifyCheckValue_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    int  nKeyLen;
    char szCheckValue[16];

    bufclr(bKey);
    bufclr(szCheckValue);

    /* 3210 7654 BA98 FEDC 3245 7689 ABDC EF54 */
    memcpy(bKey, "\x2D\x68\x6F\x97\xFB\xB5\x82\xE1\x7E\xBA\xB7\x37\xFA\xA7\x68\xF8", \
                 16);
    nKeyLen = 16;
    /* B790 8895 926B A829 */
    memcpy(szCheckValue, "B7908895", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    DspHex("[IN ]bKey         =", bKey, 16);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifyCheckValue(nSock, bKey, nKeyLen, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密钥长度=16测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifyCheckValue_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    int  nKeyLen;
    char szCheckValue[16];

    bufclr(bKey);
    bufclr(szCheckValue);

    /* 3210 7654 BA98 FEDC 3245 7689 ABDC EF54 2323 6767 ABAB 7676 */
    memcpy(bKey, "\x2D\x68\x6F\x97\xFB\xB5\x82\xE1\x7E\xBA\xB7\x37\xFA\xA7\x68\xF8"  \
                 "\x39\x22\x83\xAB\xA5\x29\x78\x30", \
                 24);
    nKeyLen = 24;
    /* 1648 F7AB 758A 51C3 */
    memcpy(szCheckValue, "1648F7AB", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    DspHex("[IN ]bKey         =", bKey, 24);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifyCheckValue(nSock, bKey, nKeyLen, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密钥长度=24测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifyCheckValue_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    int  nKeyLen;
    char szCheckValue[16];

    bufclr(bKey);
    bufclr(szCheckValue);

    /* 0101 0101 0101 0101 0101 0101 0101 0101 0101 0101 0101 0101 */
    memcpy(bKey, "\x7E\xAB\x74\x3A\x23\x64\x7B\xE6"  \
                 "\x7E\xAB\x74\x3A\x23\x64\x7B\xE6"  \
                 "\x7E\xAB\x74\x3A\x23\x64\x7B\xE6", \
                 24);
    nKeyLen = 24;
    /* 8CA6 4DE9 C1B1 23A7 */
    memcpy(szCheckValue, "8CA64DE9", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    DspHex("[IN ]bKey         =", bKey, 24);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifyCheckValue(nSock, bKey, nKeyLen, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "最小密钥测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifyCheckValue_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    int  nKeyLen;
    char szCheckValue[16];

    bufclr(bKey);
    bufclr(szCheckValue);

    /* FEFE FEFE FEFE FEFE FEFE FEFE FEFE FEFE FEFE FEFE FEFE FEFE */
    memcpy(bKey, "\x6B\xAC\x93\xCC\x3A\x9E\x9A\x13"  \
                 "\x6B\xAC\x93\xCC\x3A\x9E\x9A\x13"  \
                 "\x6B\xAC\x93\xCC\x3A\x9E\x9A\x13", \
                 24);
    nKeyLen = 24;
    /* CAAA AF4D EAF1 DBAE */
    memcpy(szCheckValue, "CAAAAF4D", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    DspHex("[IN ]bKey         =", bKey, 24);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifyCheckValue(nSock, bKey, nKeyLen, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "最大密钥测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifyCheckValue_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    int  nKeyLen;
    char szCheckValue[16];

    bufclr(bKey);
    bufclr(szCheckValue);

    nSock = -1;
    /* 3210 7654 BA98 FEDC */
    memcpy(bKey, "\x2D\x68\x6F\x97\xFB\xB5\x82\xE1", \
                 8);
    nKeyLen = 8;
    /* C0FF 24F5 6A27 D34A */
    memcpy(szCheckValue, "C0FF24F5", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    DspHex("[IN ]bKey         =", bKey, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifyCheckValue(nSock, bKey, nKeyLen, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void VerifyCheckValue_Test_07(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    int  nKeyLen;
    char szCheckValue[16];

    bufclr(bKey);
    bufclr(szCheckValue);

    nSock = 8;
    /* 3210 7654 BA98 FEDC */
    memcpy(bKey, "\x2D\x68\x6F\x97\xFB\xB5\x82\xE1", \
                 8);
    nKeyLen = 8;
    /* C0FF 24F5 6A27 D34A */
    memcpy(szCheckValue, "C0FF24F5", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    DspHex("[IN ]bKey         =", bKey, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifyCheckValue(nSock, bKey, nKeyLen, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[8]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void VerifyCheckValue_Test_08(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    int  nKeyLen;
    char szCheckValue[16];

    bufclr(bKey);
    bufclr(szCheckValue);

    /* 3210 7654 BA98 FEDC */
    memcpy(bKey, "\x2D\x68\x6F\x97\xFB\xB5\x82\xE1", \
                 8);
    nKeyLen = 8;
    /* C0FF 24F5 6A27 D34A */
    memcpy(szCheckValue, "6A27D34A", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    DspHex("[IN ]bKey         =", bKey, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifyCheckValue(nSock, bKey, nKeyLen, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 10, "有效校验值的后半部测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifyCheckValue_Test_09(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    int  nKeyLen;
    char szCheckValue[16];

    bufclr(bKey);
    bufclr(szCheckValue);

    /* 3210 7654 BA98 FEDC */
    memcpy(bKey, "\x2D\x68\x6F\x97\xFB\xB5\x82\xE1", \
                 8);
    nKeyLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    DspHex("[IN ]bKey         =", bKey, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifyCheckValue(nSock, bKey, nKeyLen, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 10, "空校验值测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifyCheckValue_Test_10(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    int  nKeyLen;
    char szCheckValue[16];

    bufclr(bKey);
    bufclr(szCheckValue);

    /* 3210 7654 BA98 FEDC */
    memcpy(bKey, "\x2D\x68\x6F\x97\xFB\xB5\x82\xE1", \
                 8);
    nKeyLen = 8;
    /* 00000000 */
    memcpy(szCheckValue, "00000000", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    DspHex("[IN ]bKey         =", bKey, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifyCheckValue(nSock, bKey, nKeyLen, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 10, "全'0'校验值测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifyCheckValue_Test_11(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    int  nKeyLen;
    char szCheckValue[16];

    bufclr(bKey);
    bufclr(szCheckValue);

    /* 3210 7654 BA98 FEDC */
    memcpy(bKey, "\x2D\x68\x6F\x97\xFB\xB5\x82\xE1", \
                 8);
    nKeyLen = 8;
    /* FFFFFFFF */
    memcpy(szCheckValue, "FFFFFFFF", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    DspHex("[IN ]bKey         =", bKey, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifyCheckValue(nSock, bKey, nKeyLen, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 10, "全'F'校验值测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifyCheckValue_Test_12(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    int  nKeyLen;
    char szCheckValue[16];

    bufclr(bKey);
    bufclr(szCheckValue);

    /* 3210 7654 BA98 FEDC */
    memcpy(bKey, "\x2D\x68\x6F\x97\xFB\xB5\x82\xE1", \
                 8);
    nKeyLen = 8;
    /* C0FF 24F5 6A27 D34A */
    memcpy(szCheckValue, "C0FF34F5", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    DspHex("[IN ]bKey         =", bKey, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifyCheckValue(nSock, bKey, nKeyLen, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 10, "无效校验值测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifyCheckValue_Test_13(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    int  nKeyLen;
    char szCheckValue[16];

    bufclr(bKey);
    bufclr(szCheckValue);

    nKeyLen = 0;
    /* C0FF 24F5 6A27 D34A */
    memcpy(szCheckValue, "C0FF24F5", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    DspHex("[IN ]bKey         =", bKey, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifyCheckValue(nSock, bKey, nKeyLen, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "密钥长度=0测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifyCheckValue_Test_14(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    int  nKeyLen;
    char szCheckValue[16];

    bufclr(bKey);
    bufclr(szCheckValue);

    /* 3210 7654 BA98 FEDC */
    memcpy(bKey, "\x2D\x68\x6F\x97\xFB\xB5\x82", \
                 7);
    nKeyLen = 7;
    /* C0FF 24F5 6A27 D34A */
    memcpy(szCheckValue, "C0FF24F5", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    DspHex("[IN ]bKey         =", bKey, 7);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifyCheckValue(nSock, bKey, nKeyLen, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "密钥长度=7测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifyCheckValue_Test_15(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    int  nKeyLen;
    char szCheckValue[16];

    bufclr(bKey);
    bufclr(szCheckValue);

    /* 3210 7654 BA98 FEDC 3344 7788 AADD EE55 2222 6666 AAAA 7777 */
    memcpy(bKey, "\x2D\x68\x6F\x97\xFB\xB5\x82\xE1"  \
                 "\x75\x79\x35\x84\x27\xF3\x1A\x31"  \
                 "\xE1\x84\xC1\x80", \
                 20);
    nKeyLen = 20;
    /* 1648 F7AB 758A 51C3 */
    memcpy(szCheckValue, "1648F7AB", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    DspHex("[IN ]bKey         =", bKey, 20);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifyCheckValue(nSock, bKey, nKeyLen, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "密钥长度=20测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifyCheckValue_Test_16(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    int  nKeyLen;
    char szCheckValue[16];

    bufclr(bKey);
    bufclr(szCheckValue);

    /* 3210 7654 BA98 FEDC 3344 7788 AADD EE55 2222 6666 AAAA 7777 */
    memcpy(bKey, "\x2D\x68\x6F\x97\xFB\xB5\x82\xE1"  \
                 "\x75\x79\x35\x84\x27\xF3\x1A\x31"  \
                 "\xE1\x84\xC1\x80\x7A\xBB\xDF\xF5" \
                 "\xAA", 25);
    nKeyLen = 25;
    /* 1648 F7AB 758A 51C3 */
    memcpy(szCheckValue, "1648F7AB", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    DspHex("[IN ]bKey         =", bKey, 25);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifyCheckValue(nSock, bKey, nKeyLen, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "密钥长度=25测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifyCheckValue_Test_17(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    int  nKeyLen;
    char szCheckValue[16];

    bufclr(bKey);
    bufclr(szCheckValue);

    /* 3210 7654 BA98 FEDC 3344 7788 AADD EE55 2222 6666 AAAA 7777 */
    memcpy(bKey, "\x2D\x68\x6F\x97\xFB\xB5\x82\xE1"  \
                 "\x75\x79\x35\x84\x27\xF3\x1A\x31"  \
                 "\xE1\x84\xC1\x80\x7A\xBB\xDF\xF5"  \
                 "\x01\x23\x45\x67\x89\xAB\xCD\xEF", \
                 32);
    nKeyLen = 32;
    /* 1648 F7AB 758A 51C3 */
    memcpy(szCheckValue, "1648F7AB", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    DspHex("[IN ]bKey         =", bKey, 32);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifyCheckValue(nSock, bKey, nKeyLen, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "密钥长度=32测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifyCheckValue_Test_18(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    BYTE bKey[32];
    int  nKeyLen;
    char szCheckValue[16];

    bufclr(bKey);
    bufclr(szCheckValue);

    /* 3210 7654 BA98 FEDC */
    memcpy(bKey, "\x2D\x68\x6F\x97\xFB\xB5\x82\xE1", \
                 8);
    nKeyLen = 8;
    /* C0FF 24F5 6A27 D34A */
    memcpy(szCheckValue, "\xC0\xFF\x24\xF5\x6A\x27\xD3\x4A", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    DspHex("[IN ]bKey         =", bKey, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifyCheckValue(nSock, bKey, nKeyLen, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 10, "全校验值测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GetHsmStatus_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    char szStatusCode[2];
    char szStatusMsg[200];

    bufclr(szStatusCode);
    bufclr(szStatusMsg);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGetHsmStatus(nSock, szStatusCode, szStatusMsg);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "正常情况测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]szStatusCode =", szStatusCode, 2);
    printf("[OUT]szStatusMsg  = %s\n", szStatusMsg);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GetHsmStatus_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    char szStatusCode[2];
    char szStatusMsg[200];

    bufclr(szStatusCode);
    bufclr(szStatusMsg);

    nSock = -1;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGetHsmStatus(nSock, szStatusCode, szStatusMsg);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void GetHsmStatus_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    char szStatusCode[2];
    char szStatusMsg[200];

    bufclr(szStatusCode);
    bufclr(szStatusMsg);

    nSock = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGetHsmStatus(nSock, szStatusCode, szStatusMsg);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[8]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void ImportKey_Test_RCKEK(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKekIndex;
    unsigned char   bKeyByKek[32];
    int  nKeyLen;
    char szCheckValue[16];
    int  nDestIndex;

    bufclr(bKeyByKek);
    bufclr(szCheckValue);

    nKekIndex = 257;
    nKeyLen = 16;

    memcpy(bKeyByKek, "\x87\xB4\x43\x34\x10\xDF\x22\x93\x06\x47\xA2\xC0\x57\x05\xB3\x3A" \
                      , 16);
    memcpy(szCheckValue, "4FDBF4DC", 8);
    nDestIndex = 258;
    nRet = SMAPIImportKey(nSock, nKekIndex, bKeyByKek, nKeyLen, \
                          szCheckValue, nDestIndex);
    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密钥长度=16测试未成功");
    XXX_RESULT_XXX

    memcpy(bKeyByKek, "\x13\xB2\xE8\x52\x8A\x7E\x93\xB6\x8C\xDB\xE7\x8C\x1C\xCD\xDF\x28" \
                      , 16);
    memcpy(szCheckValue, "2D9F8A97", 8);
    nDestIndex = 259;
    nRet = SMAPIImportKey(nSock, nKekIndex, bKeyByKek, nKeyLen, \
                          szCheckValue, nDestIndex);
    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密钥长度=16测试未成功");
    XXX_RESULT_XXX

    memcpy(bKeyByKek, "\xFF\xDC\xA7\xD4\xDD\xC9\x0B\x18\x6D\x5F\xD3\x12\x86\x66\xF7\xC0" \
                      , 16);
    memcpy(szCheckValue, "B75CD2B2", 8);
    nDestIndex = 260;
    nRet = SMAPIImportKey(nSock, nKekIndex, bKeyByKek, nKeyLen, \
                          szCheckValue, nDestIndex);
    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密钥长度=16测试未成功");
    XXX_RESULT_XXX

    memcpy(bKeyByKek, "\x1F\x39\xA5\xE1\xE3\x78\xF3\x33\x35\x4A\x01\xDD\xB6\xA3\xB2\x98" \
                      , 16);
    memcpy(szCheckValue, "8E22C74D", 8);
    nDestIndex = 261;
    nRet = SMAPIImportKey(nSock, nKekIndex, bKeyByKek, nKeyLen, \
                          szCheckValue, nDestIndex);
    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密钥长度=16测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ImportKey_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKekIndex;
    BYTE bKey[32];
    BYTE bKeyByKek[32];
    int  nKeyLen;
    char szCheckValue[16];
    int  nDestIndex;

    bufclr(bKey);
    bufclr(bKeyByKek);
    bufclr(szCheckValue);

    nKekIndex = 257;
    /* 0123 4567 89AB CDEF */
    memcpy(bKey, "\x01\x23\x45\x67\x89\xAB\xCD\xEF" \
                 , 8);
    nKeyLen = 8;
    nRet = SMAPIEncryptBlock(nSock, 2, KEK257, bKey, nKeyLen, bKeyByKek);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptBlock NG");

    /* D5D4 4FF7 2068 3D0D */
    memcpy(szCheckValue, "D5D44FF7", 8);
    nDestIndex = 260;

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nKekIndex    = %d\n", nKekIndex);
    DspHex("[IN ]bKeyByKek    =", bKeyByKek, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    printf("[IN ]nDestIndex   = %d\n", nDestIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIImportKey(nSock, nKekIndex, bKeyByKek, nKeyLen, \
                          szCheckValue, nDestIndex);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密钥长度=8测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ImportKey_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKekIndex;
    BYTE bKey[32];
    BYTE bKeyByKek[32];
    int  nKeyLen;
    char szCheckValue[16];
    int  nDestIndex;

    bufclr(bKey);
    bufclr(bKeyByKek);
    bufclr(szCheckValue);

    nKekIndex = 257;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKey, "\x01\x23\x45\x67\x89\xAB\xCD\xEF" \
                 "\xFE\xDC\xBA\x98\x76\x54\x32\x10" \
                 , 16);
    nKeyLen = 16;
    nRet = SMAPIEncryptBlock(nSock, 2, KEK257, bKey, nKeyLen, bKeyByKek);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptBlock NG");

    /* 08D7 B4FB 629D 0885 */
    memcpy(szCheckValue, "08D7B4FB", 8);
    nDestIndex = 371;

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nKekIndex    = %d\n", nKekIndex);
    DspHex("[IN ]bKeyByKek    =", bKeyByKek, 16);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    printf("[IN ]nDestIndex   = %d\n", nDestIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIImportKey(nSock, nKekIndex, bKeyByKek, nKeyLen, \
                          szCheckValue, nDestIndex);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密钥长度=16测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ImportKey_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKekIndex;
    BYTE bKey[32];
    BYTE bKeyByKek[32];
    int  nKeyLen;
    char szCheckValue[16];
    int  nDestIndex;

    bufclr(bKey);
    bufclr(bKeyByKek);
    bufclr(szCheckValue);

    nKekIndex = 257;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8697 A4B5 C2D3 E0F1 */
    memcpy(bKey, "\x01\x23\x45\x67\x89\xAB\xCD\xEF" \
                 "\xFE\xDC\xBA\x98\x76\x54\x32\x10" \
                 "\x86\x97\xA4\xB5\xC2\xD3\xE0\xF1" \
                 , 24);
    nKeyLen = 24;
    nRet = SMAPIEncryptBlock(nSock, 2, KEK257, bKey, nKeyLen, bKeyByKek);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptBlock NG");

    /* BAF9 EF36 AC80 8158 */
    memcpy(szCheckValue, "BAF9EF36", 8);
    nDestIndex = 486;

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nKekIndex    = %d\n", nKekIndex);
    DspHex("[IN ]bKeyByKek    =", bKeyByKek, 24);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    printf("[IN ]nDestIndex   = %d\n", nDestIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIImportKey(nSock, nKekIndex, bKeyByKek, nKeyLen, \
                          szCheckValue, nDestIndex);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密钥长度=24测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ImportKey_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKekIndex;
    BYTE bKey[32];
    BYTE bKeyByKek[32];
    int  nKeyLen;
    char szCheckValue[16];
    int  nDestIndex;

    bufclr(bKey);
    bufclr(bKeyByKek);
    bufclr(szCheckValue);

    nKekIndex = 257;
    /* 0101 0101 0101 0101 0101 0101 0101 0101 0101 0101 0101 0101 */
    memcpy(bKey, "\x01\x01\x01\x01\x01\x01\x01\x01" \
                 "\x01\x01\x01\x01\x01\x01\x01\x01" \
                 "\x01\x01\x01\x01\x01\x01\x01\x01" \
                 , 24);
    nKeyLen = 24;
    nRet = SMAPIEncryptBlock(nSock, 2, KEK257, bKey, nKeyLen, bKeyByKek);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptBlock NG");

    /* 8CA6 4DE9 C1B1 23A7 */
    memcpy(szCheckValue, "8CA64DE9", 8);
    nDestIndex = 258;

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nKekIndex    = %d\n", nKekIndex);
    DspHex("[IN ]bKeyByKek    =", bKeyByKek, 24);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    printf("[IN ]nDestIndex   = %d\n", nDestIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIImportKey(nSock, nKekIndex, bKeyByKek, nKeyLen, \
                          szCheckValue, nDestIndex);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密钥明文=0x01测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ImportKey_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKekIndex;
    BYTE bKey[32];
    BYTE bKeyByKek[32];
    int  nKeyLen;
    char szCheckValue[16];
    int  nDestIndex;

    bufclr(bKey);
    bufclr(bKeyByKek);
    bufclr(szCheckValue);

    nKekIndex = 257;
    /* FEFE FEFE FEFE FEFE FEFE FEFE FEFE FEFE FEFE FEFE FEFE FEFE */
    memcpy(bKey, "\xFE\xFE\xFE\xFE\xFE\xFE\xFE\xFE" \
                 "\xFE\xFE\xFE\xFE\xFE\xFE\xFE\xFE" \
                 "\xFE\xFE\xFE\xFE\xFE\xFE\xFE\xFE" \
                 , 24);
    nKeyLen = 24;
    nRet = SMAPIEncryptBlock(nSock, 2, KEK257, bKey, nKeyLen, bKeyByKek);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptBlock NG");

    /* CAAA AF4D EAF1 DBAE */
    memcpy(szCheckValue, "CAAAAF4D", 8);
    nDestIndex = 261;

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nKekIndex    = %d\n", nKekIndex);
    DspHex("[IN ]bKeyByKek    =", bKeyByKek, 24);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    printf("[IN ]nDestIndex   = %d\n", nDestIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIImportKey(nSock, nKekIndex, bKeyByKek, nKeyLen, \
                          szCheckValue, nDestIndex);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密钥明文=0xFE测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ImportKey_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKekIndex;
    unsigned char   bKeyByKek[32];
    int  nKeyLen;
    char szCheckValue[16];
    int  nDestIndex;

    bufclr(bKeyByKek);
    bufclr(szCheckValue);

    nSock = -1;
    nKekIndex = 257;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByKek, "\xB9\x53\xAC\x4E\x65\xA2\x6D\xB0" \
                      , 8);
    nKeyLen = 8;
    /* D5D4 4FF7 2068 3D0D */
    memcpy(szCheckValue, "D5D44FF7", 8);
    nDestIndex = 257;

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nKekIndex    = %d\n", nKekIndex);
    DspHex("[IN ]bKeyByKek    =", bKeyByKek, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    printf("[IN ]nDestIndex   = %d\n", nDestIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIImportKey(nSock, nKekIndex, bKeyByKek, nKeyLen, \
                          szCheckValue, nDestIndex);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void ImportKey_Test_07(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKekIndex;
    unsigned char   bKeyByKek[32];
    int  nKeyLen;
    char szCheckValue[16];
    int  nDestIndex;

    bufclr(bKeyByKek);
    bufclr(szCheckValue);

    nSock = 8;
    nKekIndex = 257;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByKek, "\xB9\x53\xAC\x4E\x65\xA2\x6D\xB0" \
                      , 8);
    nKeyLen = 8;
    /* D5D4 4FF7 2068 3D0D */
    memcpy(szCheckValue, "D5D44FF7", 8);
    nDestIndex = 257;

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nKekIndex    = %d\n", nKekIndex);
    DspHex("[IN ]bKeyByKek    =", bKeyByKek, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    printf("[IN ]nDestIndex   = %d\n", nDestIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIImportKey(nSock, nKekIndex, bKeyByKek, nKeyLen, \
                          szCheckValue, nDestIndex);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[8]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void ImportKey_Test_08(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKekIndex;
    unsigned char   bKeyByKek[32];
    int  nKeyLen;
    char szCheckValue[16];
    int  nDestIndex;

    bufclr(bKeyByKek);
    bufclr(szCheckValue);

    nKekIndex = 0;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByKek, "\xB9\x53\xAC\x4E\x65\xA2\x6D\xB0" \
                      , 8);
    nKeyLen = 8;
    /* D5D4 4FF7 2068 3D0D */
    memcpy(szCheckValue, "D5D44FF7", 8);
    nDestIndex = 257;

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nKekIndex    = %d\n", nKekIndex);
    DspHex("[IN ]bKeyByKek    =", bKeyByKek, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    printf("[IN ]nDestIndex   = %d\n", nDestIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIImportKey(nSock, nKekIndex, bKeyByKek, nKeyLen, \
                          szCheckValue, nDestIndex);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效密钥索引=0测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ImportKey_Test_09(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKekIndex;
    unsigned char   bKeyByKek[32];
    int  nKeyLen;
    char szCheckValue[16];
    int  nDestIndex;

    bufclr(bKeyByKek);
    bufclr(szCheckValue);

    nKekIndex = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByKek, "\xB9\x53\xAC\x4E\x65\xA2\x6D\xB0" \
                      , 8);
    nKeyLen = 8;
    /* D5D4 4FF7 2068 3D0D */
    memcpy(szCheckValue, "D5D44FF7", 8);
    nDestIndex = 257;

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nKekIndex    = %d\n", nKekIndex);
    DspHex("[IN ]bKeyByKek    =", bKeyByKek, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    printf("[IN ]nDestIndex   = %d\n", nDestIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIImportKey(nSock, nKekIndex, bKeyByKek, nKeyLen, \
                          szCheckValue, nDestIndex);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效密钥索引=1测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ImportKey_Test_10(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKekIndex;
    unsigned char   bKeyByKek[32];
    int  nKeyLen;
    char szCheckValue[16];
    int  nDestIndex;

    bufclr(bKeyByKek);
    bufclr(szCheckValue);

    nKekIndex = 255;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByKek, "\xB9\x53\xAC\x4E\x65\xA2\x6D\xB0" \
                      , 8);
    nKeyLen = 8;
    /* D5D4 4FF7 2068 3D0D */
    memcpy(szCheckValue, "D5D44FF7", 8);
    nDestIndex = 486;

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nKekIndex    = %d\n", nKekIndex);
    DspHex("[IN ]bKeyByKek    =", bKeyByKek, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    printf("[IN ]nDestIndex   = %d\n", nDestIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIImportKey(nSock, nKekIndex, bKeyByKek, nKeyLen, \
                          szCheckValue, nDestIndex);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效密钥索引=255测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ImportKey_Test_11(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKekIndex;
    unsigned char   bKeyByKek[32];
    int  nKeyLen;
    char szCheckValue[16];
    int  nDestIndex;

    bufclr(bKeyByKek);
    bufclr(szCheckValue);

    nKekIndex = 257;
    nKeyLen = 0;
    /* D5D4 4FF7 2068 3D0D */
    memcpy(szCheckValue, "D5D44FF7", 8);
    nDestIndex = 257;

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nKekIndex    = %d\n", nKekIndex);
    DspHex("[IN ]bKeyByKek    =", bKeyByKek, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    printf("[IN ]nDestIndex   = %d\n", nDestIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIImportKey(nSock, nKekIndex, bKeyByKek, nKeyLen, \
                          szCheckValue, nDestIndex);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "密钥长度=0测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ImportKey_Test_12(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKekIndex;
    unsigned char   bKeyByKek[32];
    int  nKeyLen;
    char szCheckValue[16];
    int  nDestIndex;

    bufclr(bKeyByKek);
    bufclr(szCheckValue);

    nKekIndex = 257;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByKek, "\xB9\x53\xAC\x4E\x65\xA2\x6D\xB0" \
                      , 7);
    nKeyLen = 7;
    /* D5D4 4FF7 2068 3D0D */
    memcpy(szCheckValue, "D5D44FF7", 8);
    nDestIndex = 257;

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nKekIndex    = %d\n", nKekIndex);
    DspHex("[IN ]bKeyByKek    =", bKeyByKek, 7);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    printf("[IN ]nDestIndex   = %d\n", nDestIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIImportKey(nSock, nKekIndex, bKeyByKek, nKeyLen, \
                          szCheckValue, nDestIndex);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "密钥长度=7测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ImportKey_Test_13(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKekIndex;
    unsigned char   bKeyByKek[32];
    int  nKeyLen;
    char szCheckValue[16];
    int  nDestIndex;

    bufclr(bKeyByKek);
    bufclr(szCheckValue);

    nKekIndex = 257;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8697 A4B5 C2D3 E0F1 */
    memcpy(bKeyByKek, "\xB9\x53\xAC\x4E\x65\xA2\x6D\xB0" \
                      "\x4A\xB0\x47\x7D\xBF\xEA\xB7\x12" \
                      "\xBD\xFF\x71\x64\x28\xDB\x34\xEA",\
                      20);
    nKeyLen = 20;
    /* BAF9 EF36 AC80 8158 */
    memcpy(szCheckValue, "BAF9EF36", 8);
    nDestIndex = 486;

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nKekIndex    = %d\n", nKekIndex);
    DspHex("[IN ]bKeyByKek    =", bKeyByKek, 20);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    printf("[IN ]nDestIndex   = %d\n", nDestIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIImportKey(nSock, nKekIndex, bKeyByKek, nKeyLen, \
                          szCheckValue, nDestIndex);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "密钥长度=20测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ImportKey_Test_14(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKekIndex;
    unsigned char   bKeyByKek[32];
    int  nKeyLen;
    char szCheckValue[16];
    int  nDestIndex;

    bufclr(bKeyByKek);
    bufclr(szCheckValue);

    nKekIndex = 257;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8697 A4B5 C2D3 E0F1 */
    memcpy(bKeyByKek, "\xB9\x53\xAC\x4E\x65\xA2\x6D\xB0" \
                      "\x4A\xB0\x47\x7D\xBF\xEA\xB7\x12" \
                      "\xBD\xFF\x71\x64\x28\xDB\x34\xEA" \
                      "\xFF", 25);
    nKeyLen = 25;
    /* BAF9 EF36 AC80 8158 */
    memcpy(szCheckValue, "BAF9EF36", 8);
    nDestIndex = 486;

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nKekIndex    = %d\n", nKekIndex);
    DspHex("[IN ]bKeyByKek    =", bKeyByKek, 25);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    printf("[IN ]nDestIndex   = %d\n", nDestIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIImportKey(nSock, nKekIndex, bKeyByKek, nKeyLen, \
                          szCheckValue, nDestIndex);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "密钥长度=25测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ImportKey_Test_15(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKekIndex;
    unsigned char   bKeyByKek[32];
    int  nKeyLen;
    char szCheckValue[16];
    int  nDestIndex;

    bufclr(bKeyByKek);
    bufclr(szCheckValue);

    nKekIndex = 257;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8697 A4B5 C2D3 E0F1 */
    memcpy(bKeyByKek, "\xB9\x53\xAC\x4E\x65\xA2\x6D\xB0" \
                      "\x4A\xB0\x47\x7D\xBF\xEA\xB7\x12" \
                      "\xBD\xFF\x71\x64\x28\xDB\x34\xEA" \
                      "\x17\x8D\xEF\x04\xE1\x34\x02\x9E", 32);
    nKeyLen = 32;
    /* BAF9 EF36 AC80 8158 */
    memcpy(szCheckValue, "BAF9EF36", 8);
    nDestIndex = 486;

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nKekIndex    = %d\n", nKekIndex);
    DspHex("[IN ]bKeyByKek    =", bKeyByKek, 32);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    printf("[IN ]nDestIndex   = %d\n", nDestIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIImportKey(nSock, nKekIndex, bKeyByKek, nKeyLen, \
                          szCheckValue, nDestIndex);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "密钥长度=32测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ImportKey_Test_16(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKekIndex;
    unsigned char   bKeyByKek[32];
    int  nKeyLen;
    char szCheckValue[16];
    int  nDestIndex;

    bufclr(bKeyByKek);
    bufclr(szCheckValue);

    nKekIndex = 257;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByKek, "\xB9\x53\xAC\x4E\x65\xA2\x6D\xB0" \
                      , 8);
    nKeyLen = 8;
    /* 0000 0000 0000 0000 */
    memcpy(szCheckValue, "\x00\x00\x00\x00\x00\x00\x00\x00", 8);
    nDestIndex = 257;

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nKekIndex    = %d\n", nKekIndex);
    DspHex("[IN ]bKeyByKek    =", bKeyByKek, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    printf("[IN ]nDestIndex   = %d\n", nDestIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIImportKey(nSock, nKekIndex, bKeyByKek, nKeyLen, \
                          szCheckValue, nDestIndex);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效密钥校验值[00]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ImportKey_Test_17(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKekIndex;
    unsigned char   bKeyByKek[32];
    int  nKeyLen;
    char szCheckValue[16];
    int  nDestIndex;

    bufclr(bKeyByKek);
    bufclr(szCheckValue);

    nKekIndex = 257;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByKek, "\xB9\x53\xAC\x4E\x65\xA2\x6D\xB0" \
                      , 8);
    nKeyLen = 8;
    /* 3131 3131 3131 3131 */
    memcpy(szCheckValue, "00000000", 8);
    nDestIndex = 257;

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nKekIndex    = %d\n", nKekIndex);
    DspHex("[IN ]bKeyByKek    =", bKeyByKek, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    printf("[IN ]nDestIndex   = %d\n", nDestIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIImportKey(nSock, nKekIndex, bKeyByKek, nKeyLen, \
                          szCheckValue, nDestIndex);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效密钥校验值[31]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ImportKey_Test_18(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKekIndex;
    unsigned char   bKeyByKek[32];
    int  nKeyLen;
    char szCheckValue[16];
    int  nDestIndex;

    bufclr(bKeyByKek);
    bufclr(szCheckValue);

    nKekIndex = 257;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByKek, "\xB9\x53\xAC\x4E\x65\xA2\x6D\xB0" \
                      , 8);
    nKeyLen = 8;
    /* FFFF FFFF FFFF FFFF */
    memcpy(szCheckValue, "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF", 8);
    nDestIndex = 257;

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nKekIndex    = %d\n", nKekIndex);
    DspHex("[IN ]bKeyByKek    =", bKeyByKek, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    printf("[IN ]nDestIndex   = %d\n", nDestIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIImportKey(nSock, nKekIndex, bKeyByKek, nKeyLen, \
                          szCheckValue, nDestIndex);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效密钥校验值[FF]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ImportKey_Test_19(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKekIndex;
    unsigned char   bKeyByKek[32];
    int  nKeyLen;
    char szCheckValue[16];
    int  nDestIndex;

    bufclr(bKeyByKek);
    bufclr(szCheckValue);

    nKekIndex = 257;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByKek, "\xB9\x53\xAC\x4E\x65\xA2\x6D\xB0" \
                      , 8);
    nKeyLen = 8;
    /* 4646 4646 4646 4646 */
    memcpy(szCheckValue, "FFFFFFFF", 8);
    nDestIndex = 257;

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nKekIndex    = %d\n", nKekIndex);
    DspHex("[IN ]bKeyByKek    =", bKeyByKek, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    printf("[IN ]nDestIndex   = %d\n", nDestIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIImportKey(nSock, nKekIndex, bKeyByKek, nKeyLen, \
                          szCheckValue, nDestIndex);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效密钥校验值[46]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ImportKey_Test_20(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKekIndex;
    unsigned char   bKeyByKek[32];
    int  nKeyLen;
    char szCheckValue[16];
    int  nDestIndex;

    bufclr(bKeyByKek);
    bufclr(szCheckValue);

    nKekIndex = 257;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByKek, "\xB9\x53\xAC\x4E\x65\xA2\x6D\xB0" \
                      , 8);
    nKeyLen = 8;
    /* D5D4 4FF7 2068 3D0D */
    memcpy(szCheckValue, "D5D44FF7", 8);
    nDestIndex = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nKekIndex    = %d\n", nKekIndex);
    DspHex("[IN ]bKeyByKek    =", bKeyByKek, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    printf("[IN ]nDestIndex   = %d\n", nDestIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIImportKey(nSock, nKekIndex, bKeyByKek, nKeyLen, \
                          szCheckValue, nDestIndex);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效导入索引位=0测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ImportKey_Test_21(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKekIndex;
    unsigned char   bKeyByKek[32];
    int  nKeyLen;
    char szCheckValue[16];
    int  nDestIndex;

    bufclr(bKeyByKek);
    bufclr(szCheckValue);

    nKekIndex = 257;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByKek, "\xB9\x53\xAC\x4E\x65\xA2\x6D\xB0" \
                      , 8);
    nKeyLen = 8;
    /* D5D4 4FF7 2068 3D0D */
    memcpy(szCheckValue, "D5D44FF7", 8);
    nDestIndex = 1;

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nKekIndex    = %d\n", nKekIndex);
    DspHex("[IN ]bKeyByKek    =", bKeyByKek, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    printf("[IN ]nDestIndex   = %d\n", nDestIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIImportKey(nSock, nKekIndex, bKeyByKek, nKeyLen, \
                          szCheckValue, nDestIndex);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效导入索引位=1测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ImportKey_Test_22(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKekIndex;
    unsigned char   bKeyByKek[32];
    int  nKeyLen;
    char szCheckValue[16];
    int  nDestIndex;

    bufclr(bKeyByKek);
    bufclr(szCheckValue);

    nKekIndex = 257;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByKek, "\xB9\x53\xAC\x4E\x65\xA2\x6D\xB0" \
                      , 8);
    nKeyLen = 8;
    /* D5D4 4FF7 2068 3D0D */
    memcpy(szCheckValue, "D5D44FF7", 8);
    nDestIndex = 256;

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nKekIndex    = %d\n", nKekIndex);
    DspHex("[IN ]bKeyByKek    =", bKeyByKek, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    printf("[IN ]nDestIndex   = %d\n", nDestIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIImportKey(nSock, nKekIndex, bKeyByKek, nKeyLen, \
                          szCheckValue, nDestIndex);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效导入索引位=256测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ImportKey_Test_23(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKekIndex;
    unsigned char   bKeyByKek[32];
    int  nKeyLen;
    char szCheckValue[16];
    int  nDestIndex;

    bufclr(bKeyByKek);
    bufclr(szCheckValue);

    nKekIndex = 257;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByKek, "\xB9\x53\xAC\x4E\x65\xA2\x6D\xB0" \
                      , 8);
    nKeyLen = 8;
    /* D5D4 4FF7 2068 3D0D */
    memcpy(szCheckValue, "D5D44FF7", 8);
    nDestIndex = 487;

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nKekIndex    = %d\n", nKekIndex);
    DspHex("[IN ]bKeyByKek    =", bKeyByKek, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    printf("[IN ]nDestIndex   = %d\n", nDestIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIImportKey(nSock, nKekIndex, bKeyByKek, nKeyLen, \
                          szCheckValue, nDestIndex);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效导入索引位=487测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ImportKey_Test_24(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKekIndex;
    unsigned char   bKeyByKek[32];
    int  nKeyLen;
    char szCheckValue[16];
    int  nDestIndex;

    bufclr(bKeyByKek);
    bufclr(szCheckValue);

    nKekIndex = 257;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByKek, "\xB9\x53\xAC\x4E\x65\xA2\x6D\xB0" \
                      , 8);
    nKeyLen = 8;
    /* D5D4 4FF7 2068 3D0D */
    memcpy(szCheckValue, "D5D44FF7", 8);
    nDestIndex = 511;

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nKekIndex    = %d\n", nKekIndex);
    DspHex("[IN ]bKeyByKek    =", bKeyByKek, 8);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    DspHex("[IN ]szCheckValue =", szCheckValue, 8);
    printf("[IN ]nDestIndex   = %d\n", nDestIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIImportKey(nSock, nKekIndex, bKeyByKek, nKeyLen, \
                          szCheckValue, nDestIndex);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效导入索引位=511测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ExportKey_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIndex;
    unsigned char   bKeyByMfk[32];
    int  nKeyLen;
    char szCheckValue[16];
    unsigned char   bKeyByMfkExp[32];
    int  nKeyLenExp;
    char szCheckValueExp[16];

    bufclr(bKeyByMfk);
    bufclr(szCheckValue);
    nKeyLen = 0;
    bufclr(bKeyByMfkExp);
    bufclr(szCheckValueExp);

    nIndex = 260;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByMfkExp, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                       , 8);
    nKeyLenExp = 8;
    /* D5D4 4FF7 2068 3D0D */
    memcpy(szCheckValueExp, "D5D44FF7", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock  = %d\n", nSock);
    printf("[IN ]nIndex = %d\n", nIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIExportKey(nSock, nIndex, bKeyByMfk, &nKeyLen, \
                          szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密钥索引=258测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bKeyByMfk, bKeyByMfkExp, 24);
    ASSERT_OUT(nKeyLen, nKeyLenExp);
    ASSERT_OUT_HEX(szCheckValue, szCheckValueExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ExportKey_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIndex;
    unsigned char   bKeyByMfk[32];
    int  nKeyLen;
    char szCheckValue[16];
    unsigned char   bKeyByMfkExp[32];
    int  nKeyLenExp;
    char szCheckValueExp[16];

    bufclr(bKeyByMfk);
    bufclr(szCheckValue);
    nKeyLen = 0;
    bufclr(bKeyByMfkExp);
    bufclr(szCheckValueExp);

    nIndex = 371;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKeyByMfkExp, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                         "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                      , 16);
    nKeyLenExp = 16;
    /* 08D7 B4FB 629D 0885 */
    memcpy(szCheckValueExp, "08D7B4FB", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock  = %d\n", nSock);
    printf("[IN ]nIndex = %d\n", nIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIExportKey(nSock, nIndex, bKeyByMfk, &nKeyLen, \
                          szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密钥索引=371测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bKeyByMfk, bKeyByMfkExp, 24);
    ASSERT_OUT(nKeyLen, nKeyLenExp);
    ASSERT_OUT_HEX(szCheckValue, szCheckValueExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ExportKey_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIndex;
    unsigned char   bKeyByMfk[32];
    int  nKeyLen;
    char szCheckValue[16];
    unsigned char   bKeyByMfkExp[32];
    int  nKeyLenExp;
    char szCheckValueExp[16];

    bufclr(bKeyByMfk);
    bufclr(szCheckValue);
    nKeyLen = 0;
    bufclr(bKeyByMfkExp);
    bufclr(szCheckValueExp);

    nIndex = 486;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8697 A4B5 C2D3 E0F1 */
    memcpy(bKeyByMfkExp, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                         "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
                         "\x59\x99\xC3\x06\xAB\x84\x01\xB2" \
                      , 24);
    nKeyLenExp = 24;
    /* BAF9 EF36 AC80 8158 */
    memcpy(szCheckValueExp, "BAF9EF36", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock  = %d\n", nSock);
    printf("[IN ]nIndex = %d\n", nIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIExportKey(nSock, nIndex, bKeyByMfk, &nKeyLen, \
                          szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密钥索引=486测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bKeyByMfk, bKeyByMfkExp, 24);
    ASSERT_OUT(nKeyLen, nKeyLenExp);
    ASSERT_OUT_HEX(szCheckValue, szCheckValueExp, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ExportKey_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIndex;
    unsigned char   bKeyByMfk[32];
    int  nKeyLen;
    char szCheckValue[16];
    unsigned char   bKeyByMfkExp[32];
    int  nKeyLenExp;
    char szCheckValueExp[16];

    bufclr(bKeyByMfk);
    bufclr(szCheckValue);
    nKeyLen = 0;
    bufclr(bKeyByMfkExp);
    bufclr(szCheckValueExp);

    nIndex = 256;

    XXX_INPUT_XXX
    printf("[IN ]nSock  = %d\n", nSock);
    printf("[IN ]nIndex = %d\n", nIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIExportKey(nSock, nIndex, bKeyByMfk, &nKeyLen, \
                          szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效密钥索引=256测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ExportKey_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIndex;
    unsigned char   bKeyByMfk[32];
    int  nKeyLen;
    char szCheckValue[16];
    unsigned char   bKeyByMfkExp[32];
    int  nKeyLenExp;
    char szCheckValueExp[16];

    bufclr(bKeyByMfk);
    bufclr(szCheckValue);
    nKeyLen = 0;
    bufclr(bKeyByMfkExp);
    bufclr(szCheckValueExp);

    nIndex = 487;

    XXX_INPUT_XXX
    printf("[IN ]nSock  = %d\n", nSock);
    printf("[IN ]nIndex = %d\n", nIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIExportKey(nSock, nIndex, bKeyByMfk, &nKeyLen, \
                          szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效密钥索引=487测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ExportKey_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIndex;
    unsigned char   bKeyByMfk[32];
    int  nKeyLen;
    char szCheckValue[16];
    unsigned char   bKeyByMfkExp[32];
    int  nKeyLenExp;
    char szCheckValueExp[16];

    bufclr(bKeyByMfk);
    bufclr(szCheckValue);
    nKeyLen = 0;
    bufclr(bKeyByMfkExp);
    bufclr(szCheckValueExp);

    nIndex = 444;

    XXX_INPUT_XXX
    printf("[IN ]nSock  = %d\n", nSock);
    printf("[IN ]nIndex = %d\n", nIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIExportKey(nSock, nIndex, bKeyByMfk, &nKeyLen, \
                          szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "密钥索引=444，该索引位无密钥测试失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ExportKey_Test_07(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIndex;
    unsigned char   bKeyByMfk[32];
    int  nKeyLen;
    char szCheckValue[16];
    unsigned char   bKeyByMfkExp[32];
    int  nKeyLenExp;
    char szCheckValueExp[16];

    bufclr(bKeyByMfk);
    bufclr(szCheckValue);
    nKeyLen = 0;
    bufclr(bKeyByMfkExp);
    bufclr(szCheckValueExp);

    nIndex = 257;

    XXX_INPUT_XXX
    printf("[IN ]nSock  = %d\n", nSock);
    printf("[IN ]nIndex = %d\n", nIndex);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIExportKey(nSock, nIndex, bKeyByMfk, &nKeyLen, \
                          szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密钥索引=257测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT(nKeyLen, 16);
    ASSERT_OUT_HEX(bKeyByMfk, KEK257, 16);
    ASSERT_OUT_HEX(szCheckValue, KEK257CV, 8);
//    DspHex("[OUT]bKeyByMfk    =", bKeyByMfk, nKeyLen);
//    DspHex("[OUT]szCheckValue =", szCheckValue, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenMasterKey_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKeyLen;
    int  nIndex;
    int  nTag;
    BYTE bKey[32];
    char szCheckValue[16];

    bufclr(bKey);
    bufclr(szCheckValue);

    nKeyLen = 8;
    nIndex = 0;
    nTag = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    printf("[IN ]nIndex       = %d\n", nIndex);
    printf("[IN ]nTag         = %d\n", nTag);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenMasterKey(nSock, nKeyLen, nIndex, nTag, bKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密钥长度=8，索引位=0，密钥类型=0，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKey         =", bKey, 32);
    DspHex("[OUT]szCheckValue =", szCheckValue, 8);
    XXX_OUTPUT_XXX

    bufclr(bKey);
    bufclr(szCheckValue);
    nTag = 1;

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    printf("[IN ]nIndex       = %d\n", nIndex);
    printf("[IN ]nTag         = %d\n", nTag);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenMasterKey(nSock, nKeyLen, nIndex, nTag, bKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密钥长度=8，索引位=0，密钥类型=1，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKey         =", bKey, 32);
    DspHex("[OUT]szCheckValue =", szCheckValue, 8);
    XXX_OUTPUT_XXX

    bufclr(bKey);
    bufclr(szCheckValue);
    nTag = 2;

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    printf("[IN ]nIndex       = %d\n", nIndex);
    printf("[IN ]nTag         = %d\n", nTag);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenMasterKey(nSock, nKeyLen, nIndex, nTag, bKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密钥长度=8，索引位=0，密钥类型=2，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKey         =", bKey, 32);
    DspHex("[OUT]szCheckValue =", szCheckValue, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

BYTE MKEY1[32];
BYTE MKEY1CV[32];
BYTE MKEY2[32];
BYTE MKEY2CV[32];
BYTE MKEY3[32];
BYTE MKEY3CV[32];

void GenMasterKey_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKeyLen;
    int  nIndex;
    int  nTag;
    BYTE bKey[32];
    char szCheckValue[16];

    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(MKEY1);
    bufclr(MKEY1CV);

    nKeyLen = 16;
    nIndex = 1;
    nTag = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    printf("[IN ]nIndex       = %d\n", nIndex);
    printf("[IN ]nTag         = %d\n", nTag);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenMasterKey(nSock, nKeyLen, nIndex, nTag, bKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密钥长度=16，索引位=1，密钥类型=0，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKey         =", bKey, 32);
    DspHex("[OUT]szCheckValue =", szCheckValue, 8);
    XXX_OUTPUT_XXX
    
    memcpy(MKEY1, bKey, 16);
    memcpy(MKEY1CV, szCheckValue, 8);

    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(MKEY2);
    bufclr(MKEY2CV);
    nTag = 1;

    XXX_INPUT_XXX
    printf("[IN ]nTag         = %d\n", nTag);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenMasterKey(nSock, nKeyLen, nIndex, nTag, bKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密钥长度=16，索引位=1，密钥类型=1，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKey         =", bKey, 32);
    DspHex("[OUT]szCheckValue =", szCheckValue, 8);
    XXX_OUTPUT_XXX
    
    memcpy(MKEY2, bKey, 16);
    memcpy(MKEY2CV, szCheckValue, 8);

    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(MKEY3);
    bufclr(MKEY3CV);
    nTag = 2;

    XXX_INPUT_XXX
    printf("[IN ]nTag         = %d\n", nTag);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenMasterKey(nSock, nKeyLen, nIndex, nTag, bKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密钥长度=16，索引位=1，密钥类型=2，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKey         =", bKey, 32);
    DspHex("[OUT]szCheckValue =", szCheckValue, 8);
    XXX_OUTPUT_XXX
    
    memcpy(MKEY3, bKey, 16);
    memcpy(MKEY3CV, szCheckValue, 8);

    XXX_TEST_END_XXX
}

void GenMasterKey_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKeyLen;
    int  nIndex;
    int  nTag;
    BYTE bKey[32];
    char szCheckValue[16];

    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(MKEY1);
    bufclr(MKEY1CV);

    nKeyLen = 24;
    nIndex = 255;
    nTag = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    printf("[IN ]nIndex       = %d\n", nIndex);
    printf("[IN ]nTag         = %d\n", nTag);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenMasterKey(nSock, nKeyLen, nIndex, nTag, bKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密钥长度=24，索引位=255，密钥类型=0，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKey         =", bKey, 32);
    DspHex("[OUT]szCheckValue =", szCheckValue, 8);
    XXX_OUTPUT_XXX

    memcpy(MKEY1, bKey, 24);
    memcpy(MKEY1CV, szCheckValue, 8);

    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(MKEY2);
    bufclr(MKEY2CV);
    nTag = 1;

    XXX_INPUT_XXX
    printf("[IN ]nTag         = %d\n", nTag);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenMasterKey(nSock, nKeyLen, nIndex, nTag, bKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密钥长度=24，索引位=255，密钥类型=1，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKey         =", bKey, 32);
    DspHex("[OUT]szCheckValue =", szCheckValue, 8);
    XXX_OUTPUT_XXX

    memcpy(MKEY2, bKey, 24);
    memcpy(MKEY2CV, szCheckValue, 8);

    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(MKEY3);
    bufclr(MKEY3CV);
    nTag = 2;

    XXX_INPUT_XXX
    printf("[IN ]nTag         = %d\n", nTag);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenMasterKey(nSock, nKeyLen, nIndex, nTag, bKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密钥长度=24，索引位=255，密钥类型=2，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKey         =", bKey, 32);
    DspHex("[OUT]szCheckValue =", szCheckValue, 8);
    XXX_OUTPUT_XXX

    memcpy(MKEY3, bKey, 24);
    memcpy(MKEY3CV, szCheckValue, 8);

    XXX_TEST_END_XXX
}

void GenMasterKey_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKeyLen;
    int  nIndex;
    int  nTag;
    BYTE bKey[32];
    char szCheckValue[16];

    bufclr(bKey);
    bufclr(szCheckValue);

    nSock = -1;
    nKeyLen = 8;
    nIndex = 0;
    nTag = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    printf("[IN ]nIndex       = %d\n", nIndex);
    printf("[IN ]nTag         = %d\n", nTag);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenMasterKey(nSock, nKeyLen, nIndex, nTag, bKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void GenMasterKey_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKeyLen;
    int  nIndex;
    int  nTag;
    BYTE bKey[32];
    char szCheckValue[16];

    bufclr(bKey);
    bufclr(szCheckValue);

    nSock = 8;
    nKeyLen = 8;
    nIndex = 0;
    nTag = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    printf("[IN ]nIndex       = %d\n", nIndex);
    printf("[IN ]nTag         = %d\n", nTag);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenMasterKey(nSock, nKeyLen, nIndex, nTag, bKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[8]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void GenMasterKey_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKeyLen;
    int  nIndex;
    int  nTag;
    BYTE bKey[32];
    char szCheckValue[16];

    bufclr(bKey);
    bufclr(szCheckValue);

    nKeyLen = 0;
    nIndex = 0;
    nTag = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    printf("[IN ]nIndex       = %d\n", nIndex);
    printf("[IN ]nTag         = %d\n", nTag);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenMasterKey(nSock, nKeyLen, nIndex, nTag, bKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效密钥长度=0测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenMasterKey_Test_07(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKeyLen;
    int  nIndex;
    int  nTag;
    BYTE bKey[32];
    char szCheckValue[16];

    bufclr(bKey);
    bufclr(szCheckValue);

    nKeyLen = 7;
    nIndex = 0;
    nTag = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    printf("[IN ]nIndex       = %d\n", nIndex);
    printf("[IN ]nTag         = %d\n", nTag);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenMasterKey(nSock, nKeyLen, nIndex, nTag, bKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效密钥长度=7测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenMasterKey_Test_08(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKeyLen;
    int  nIndex;
    int  nTag;
    BYTE bKey[32];
    char szCheckValue[16];

    bufclr(bKey);
    bufclr(szCheckValue);

    nKeyLen = 20;
    nIndex = 0;
    nTag = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    printf("[IN ]nIndex       = %d\n", nIndex);
    printf("[IN ]nTag         = %d\n", nTag);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenMasterKey(nSock, nKeyLen, nIndex, nTag, bKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效密钥长度=20测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenMasterKey_Test_09(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKeyLen;
    int  nIndex;
    int  nTag;
    BYTE bKey[32];
    char szCheckValue[16];

    bufclr(bKey);
    bufclr(szCheckValue);

    nKeyLen = 25;
    nIndex = 0;
    nTag = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    printf("[IN ]nIndex       = %d\n", nIndex);
    printf("[IN ]nTag         = %d\n", nTag);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenMasterKey(nSock, nKeyLen, nIndex, nTag, bKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效密钥长度=25测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenMasterKey_Test_10(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKeyLen;
    int  nIndex;
    int  nTag;
    BYTE bKey[32];
    char szCheckValue[16];

    bufclr(bKey);
    bufclr(szCheckValue);

    nKeyLen = 32;
    nIndex = 0;
    nTag = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    printf("[IN ]nIndex       = %d\n", nIndex);
    printf("[IN ]nTag         = %d\n", nTag);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenMasterKey(nSock, nKeyLen, nIndex, nTag, bKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效密钥长度=32测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenMasterKey_Test_11(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKeyLen;
    int  nIndex;
    int  nTag;
    BYTE bKey[32];
    char szCheckValue[16];

    bufclr(bKey);
    bufclr(szCheckValue);

    nKeyLen = 8;
    nIndex = 256;
    nTag = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    printf("[IN ]nIndex       = %d\n", nIndex);
    printf("[IN ]nTag         = %d\n", nTag);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenMasterKey(nSock, nKeyLen, nIndex, nTag, bKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效索引位256测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenMasterKey_Test_12(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nKeyLen;
    int  nIndex;
    int  nTag;
    BYTE bKey[32];
    char szCheckValue[16];

    bufclr(bKey);
    bufclr(szCheckValue);

    nKeyLen = 8;
    nIndex = 255;
    nTag = 3;

    XXX_INPUT_XXX
    printf("[IN ]nSock        = %d\n", nSock);
    printf("[IN ]nKeyLen      = %d\n", nKeyLen);
    printf("[IN ]nIndex       = %d\n", nIndex);
    printf("[IN ]nTag         = %d\n", nTag);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenMasterKey(nSock, nKeyLen, nIndex, nTag, bKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效密钥类型[3]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

/* 0索引位无密钥 */
void ExportMasterKey_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIndex;
    int  nTag;
    BYTE bKey[32];
    int  nKeyLen;
    char szCheckValue[16];

    bufclr(bKey);
    bufclr(szCheckValue);

    nIndex = 0;
    nTag = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock           = %d\n", nSock);
    printf("[IN ]nIndex          = %d\n", nIndex);
    printf("[IN ]nTag            = %d\n", nTag);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIExportMasterKey(nSock, nIndex, nTag, bKey, &nKeyLen, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "密钥长度=8，索引位=0，密钥类型=0，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ExportMasterKey_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIndex;
    int  nTag;
    BYTE bKey[32];
    int  nKeyLen;
    char szCheckValue[16];
    char szInput[8];

    printf("\n-=-=-=-=- 备份索引位01密钥，并还原到索引位0 -=-=-=-=- \n");
    printf("准备好后回车 \n");
    fflush(stdout);
    do
    {
        bufclr(szInput);
        gets(szInput);
    } while(strlen(szInput) == 0);

    bufclr(bKey);
    bufclr(szCheckValue);

    nIndex = 0;
    nTag = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock           = %d\n", nSock);
    printf("[IN ]nIndex          = %d\n", nIndex);
    printf("[IN ]nTag            = %d\n", nTag);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIExportMasterKey(nSock, nIndex, nTag, bKey, \
                                &nKeyLen, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密钥长度=16，索引位=0，密钥类型=0，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX( bKey,MKEY1, 16);
    ASSERT_OUT(nKeyLen, 16);
    ASSERT_OUT_HEX(szCheckValue,MKEY1CV, 8);
    XXX_OUTPUT_XXX

    bufclr(bKey);
    bufclr(szCheckValue);

    nTag = 1;

    XXX_INPUT_XXX
    printf("[IN ]nTag            = %d\n", nTag);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIExportMasterKey(nSock, nIndex, nTag, bKey, \
                                &nKeyLen, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密钥长度=16，索引位=0，密钥类型=1，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bKey,MKEY2, 16);
    ASSERT_OUT(nKeyLen, 16);
    ASSERT_OUT_HEX(szCheckValue,MKEY2CV, 8);
    XXX_OUTPUT_XXX

    bufclr(bKey);
    bufclr(szCheckValue);

    nTag = 2;

    XXX_INPUT_XXX
    printf("[IN ]nTag            = %d\n", nTag);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIExportMasterKey(nSock, nIndex, nTag, bKey, \
                                &nKeyLen, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密钥长度=16，索引位=0，密钥类型=2，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bKey, MKEY3,16);
    ASSERT_OUT(nKeyLen, 16);
    ASSERT_OUT_HEX(szCheckValue,MKEY3CV, 8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ExportMasterKey_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIndex;
    int  nTag;
    BYTE bKey[32];
    int  nKeyLen;
    char szCheckValue[16];
    char szInput[8];

    printf("-=-=-=-=- 备份索引位255密钥，并还原到索引位0 -=-=-=-=- \n");
    printf("准备好后回车 \n");
    fflush(stdout);
    do
    {
        bufclr(szInput);
        gets(szInput);
    } while(strlen(szInput) == 0);


    bufclr(bKey);
    bufclr(szCheckValue);

    nIndex = 0;
    nTag = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock           = %d\n", nSock);
    printf("[IN ]nIndex          = %d\n", nIndex);
    printf("[IN ]nTag            = %d\n", nTag);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIExportMasterKey(nSock, nIndex, nTag, bKey, \
                                &nKeyLen, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密钥长度=24，索引位=0，密钥类型=0，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bKey,MKEY1,24);
    ASSERT_OUT(nKeyLen, 24);
    ASSERT_OUT_HEX(szCheckValue, MKEY1CV, 8);
    XXX_OUTPUT_XXX

    bufclr(bKey);
    bufclr(szCheckValue);
    nTag = 1;

    XXX_INPUT_XXX
    printf("[IN ]nTag            = %d\n", nTag);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIExportMasterKey(nSock, nIndex, nTag, bKey, \
                                &nKeyLen, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密钥长度=24，索引位=0，密钥类型=1，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bKey, MKEY2, 24);
    ASSERT_OUT(nKeyLen, 24);
    ASSERT_OUT_HEX(szCheckValue, MKEY2CV, 8);
    XXX_OUTPUT_XXX

    bufclr(bKey);
    bufclr(szCheckValue);
    nTag = 2;

    XXX_INPUT_XXX
    printf("[IN ]nTag            = %d\n", nTag);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIExportMasterKey(nSock, nIndex, nTag, bKey, \
                                &nKeyLen, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "密钥长度=24，索引位=0，密钥类型=2，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX( bKey,MKEY3,24);
    ASSERT_OUT(nKeyLen, 24);
    ASSERT_OUT_HEX(szCheckValue,MKEY3CV,8);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ExportMasterKey_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIndex;
    int  nTag;
    BYTE bKey[32];
    BYTE bKeyExp[32];
    int  nKeyLen;
    char szCheckValue[16];
    char szCheckValueExp[16];

    bufclr(bKey);
    bufclr(bKeyExp);
    bufclr(szCheckValue);
    bufclr(szCheckValueExp);

    nSock = -1;
    nIndex = 0;
    nTag = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock           = %d\n", nSock);
    printf("[IN ]nIndex          = %d\n", nIndex);
    printf("[IN ]nTag            = %d\n", nTag);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIExportMasterKey(nSock, nIndex, nTag, bKey, \
                                &nKeyLen, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void ExportMasterKey_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIndex;
    int  nTag;
    BYTE bKey[32];
    BYTE bKeyExp[32];
    int  nKeyLen;
    char szCheckValue[16];
    char szCheckValueExp[16];

    bufclr(bKey);
    bufclr(bKeyExp);
    bufclr(szCheckValue);
    bufclr(szCheckValueExp);

    nSock = 8;
    nIndex = 0;
    nTag = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock           = %d\n", nSock);
    printf("[IN ]nIndex          = %d\n", nIndex);
    printf("[IN ]nTag            = %d\n", nTag);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIExportMasterKey(nSock, nIndex, nTag, bKey, \
                                &nKeyLen, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[8]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void ExportMasterKey_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIndex;
    int  nTag;
    BYTE bKey[32];
    BYTE bKeyExp[32];
    int  nKeyLen;
    char szCheckValue[16];
    char szCheckValueExp[16];

    bufclr(bKey);
    bufclr(bKeyExp);
    bufclr(szCheckValue);
    bufclr(szCheckValueExp);

    nIndex = 256;
    nTag = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock           = %d\n", nSock);
    printf("[IN ]nIndex          = %d\n", nIndex);
    printf("[IN ]nTag            = %d\n", nTag);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIExportMasterKey(nSock, nIndex, nTag, bKey, \
                                &nKeyLen, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效索引位[256]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void ExportMasterKey_Test_07(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIndex;
    int  nTag;
    BYTE bKey[32];
    BYTE bKeyExp[32];
    int  nKeyLen;
    char szCheckValue[16];
    char szCheckValueExp[16];

    bufclr(bKey);
    bufclr(bKeyExp);
    bufclr(szCheckValue);
    bufclr(szCheckValueExp);

    nIndex = 0;
    nTag = 3;

    XXX_INPUT_XXX
    printf("[IN ]nSock           = %d\n", nSock);
    printf("[IN ]nIndex          = %d\n", nIndex);
    printf("[IN ]nTag            = %d\n", nTag);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIExportMasterKey(nSock, nIndex, nTag, bKey, \
                                &nKeyLen, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效密钥类型[3]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptData_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i = 0;

    int  nEncrypt;
    int  nMode;
    int  nIndex;
    BYTE bIndata[4104];
    int  nDatalen;
    BYTE bOutdata[4104];
    BYTE bOutdataExp[4104];
    BYTE bKey[32];
    BYTE szCheckValue[32];

    bufclr(bIndata);
    bufclr(bOutdata);
    bufclr(bOutdataExp);
    bufclr(bKey);
    bufclr(szCheckValue);

    nEncrypt = 1;
    nMode = 0;
    nIndex = 257;
    memset(bIndata, 0x42, 8);
    bIndata[0] = 0x30;
    bIndata[7] = 0x39;
    nDatalen = 8;

    nRet = SMAPIGenerateKey(nSock, 16, "1234567890", 10, \
                            2, nIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");

    nRet = SMAPIEncryptBlock(nSock, 2, bKey, bIndata, nDatalen, bOutdataExp);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptBlock NG");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nEncrypt   = %d\n", nEncrypt);
    printf("[IN ]nMode      = %d\n", nMode);
    printf("[IN ]index      = %d\n", nIndex);
    DspHex("[IN ]indata     =", bIndata, nDatalen);
    printf("[IN ]datalen    = %d\n", nDatalen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptData(nSock, nEncrypt, nMode, nIndex, \
                            bIndata, nDatalen, bOutdata);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "ECB模式加密，密钥索引=257，数据长度=8，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bOutdata, bOutdataExp, nDatalen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptData_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i = 0;

    int  nEncrypt;
    int  nMode;
    int  nIndex;
    BYTE bIndata[4104];
    int  nDatalen;
    BYTE bOutdata[4104];
    BYTE bOutdataExp[4104];
    BYTE bKey[32];
    BYTE szCheckValue[32];

    bufclr(bIndata);
    bufclr(bOutdata);
    bufclr(bOutdataExp);
    bufclr(bKey);
    bufclr(szCheckValue);

    nEncrypt = 0;
    nMode = 0;
    nIndex = 257;
    memset(bIndata, 0x42, 8);
    bIndata[0] = 0x30;
    bIndata[7] = 0x39;
    nDatalen = 8;

    nRet = SMAPIGenerateKey(nSock, 16, "1234567890", 10, \
                            2, nIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");

    nRet = SMAPIDecryptBlock(nSock, 2, bKey, bIndata, nDatalen, bOutdataExp);
    ASSERT_RESULT(nRet, 0, "SMAPIDecryptBlock NG");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nEncrypt   = %d\n", nEncrypt);
    printf("[IN ]nMode      = %d\n", nMode);
    printf("[IN ]index      = %d\n", nIndex);
    DspHex("[IN ]indata     =", bIndata, nDatalen);
    printf("[IN ]datalen    = %d\n", nDatalen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptData(nSock, nEncrypt, nMode, nIndex, \
                            bIndata, nDatalen, bOutdata);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "ECB模式解密，密钥索引=257，数据长度=8，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bOutdata, bOutdataExp, nDatalen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptData_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i = 0;

    int  nEncrypt;
    int  nMode;
    int  nIndex;
    BYTE bIndata[4104];
    int  nDatalen;
    BYTE bOutdata[4104];
    BYTE bOutdataExp[4104];
    BYTE bKey[32];
    BYTE szCheckValue[32];
    BYTE bIV[16];

    bufclr(bIndata);
    bufclr(bOutdata);
    bufclr(bOutdataExp);
    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(bIV);

    nEncrypt = 1;
    nMode = 1;
    nIndex = 257;
    memset(bIndata, 0x42, 8);
    bIndata[0] = 0x30;
    bIndata[7] = 0x39;
    nDatalen = 8;

    nRet = SMAPIGenerateKey(nSock, 16, "1234567890", 10, \
                            2, nIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");

    nRet = SMAPIEncryptCBC(nSock, 2, bKey, bIndata, nDatalen, bIV, bOutdataExp);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptBlock NG");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nEncrypt   = %d\n", nEncrypt);
    printf("[IN ]nMode      = %d\n", nMode);
    printf("[IN ]index      = %d\n", nIndex);
    DspHex("[IN ]indata     =", bIndata, nDatalen);
    printf("[IN ]datalen    = %d\n", nDatalen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptData(nSock, nEncrypt, nMode, nIndex, \
                            bIndata, nDatalen, bOutdata);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "CBC模式加密，密钥索引=257，数据长度=8，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bOutdata, bOutdataExp, nDatalen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptData_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i = 0;

    int  nEncrypt;
    int  nMode;
    int  nIndex;
    BYTE bIndata[4104];
    int  nDatalen;
    BYTE bOutdata[4104];
    BYTE bOutdataExp[4104];
    BYTE bKey[32];
    BYTE szCheckValue[32];
    BYTE bIV[16];

    bufclr(bIndata);
    bufclr(bOutdata);
    bufclr(bOutdataExp);
    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(bIV);

    nEncrypt = 0;
    nMode = 1;
    nIndex = 257;
    memset(bIndata, 0x42, 8);
    bIndata[0] = 0x30;
    bIndata[7] = 0x39;
    nDatalen = 8;

    nRet = SMAPIGenerateKey(nSock, 16, "1234567890", 10, \
                            2, nIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");

    nRet = SMAPIDecryptCBC(nSock, 2, bKey, bIndata, nDatalen, bIV, bOutdataExp);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptBlock NG");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nEncrypt   = %d\n", nEncrypt);
    printf("[IN ]nMode      = %d\n", nMode);
    printf("[IN ]index      = %d\n", nIndex);
    DspHex("[IN ]indata     =", bIndata, nDatalen);
    printf("[IN ]datalen    = %d\n", nDatalen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptData(nSock, nEncrypt, nMode, nIndex, \
                            bIndata, nDatalen, bOutdata);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "CBC模式解密，密钥索引=257，数据长度=8，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bOutdata, bOutdataExp, nDatalen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptData_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i = 0;

    int  nEncrypt;
    int  nMode;
    int  nIndex;
    BYTE bIndata[4104];
    int  nDatalen;
    BYTE bOutdata[4104];
    BYTE bOutdataExp[4104];
    BYTE bKey[32];
    BYTE szCheckValue[32];

    bufclr(bIndata);
    bufclr(bOutdata);
    bufclr(bOutdataExp);
    bufclr(bKey);
    bufclr(szCheckValue);

    nEncrypt = 1;
    nMode = 0;
    nIndex = 257;
    memset(bIndata, 0x42, 4096);
    bIndata[0] = 0x30;
    bIndata[4095] = 0x39;
    nDatalen = 4096;

    nRet = SMAPIGenerateKey(nSock, 16, "1234567890", 10, \
                            2, nIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");

    nRet = SMAPIEncryptBlock(nSock, 2, bKey, bIndata, nDatalen, bOutdataExp);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptBlock NG");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nEncrypt   = %d\n", nEncrypt);
    printf("[IN ]nMode      = %d\n", nMode);
    printf("[IN ]index      = %d\n", nIndex);
    DspHex("[IN ]indata     =", bIndata, nDatalen);
    printf("[IN ]datalen    = %d\n", nDatalen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptData(nSock, nEncrypt, nMode, nIndex, \
                            bIndata, nDatalen, bOutdata);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "ECB模式加密，密钥索引=257，数据长度=4096，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bOutdata, bOutdataExp, nDatalen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptData_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i = 0;

    int  nEncrypt;
    int  nMode;
    int  nIndex;
    BYTE bIndata[4104];
    int  nDatalen;
    BYTE bOutdata[4104];
    BYTE bOutdataExp[4104];
    BYTE bKey[32];
    BYTE szCheckValue[32];

    bufclr(bIndata);
    bufclr(bOutdata);
    bufclr(bOutdataExp);
    bufclr(bKey);
    bufclr(szCheckValue);

    nEncrypt = 0;
    nMode = 0;
    nIndex = 257;
    memset(bIndata, 0x42, 4096);
    bIndata[0] = 0x30;
    bIndata[4095] = 0x39;
    nDatalen = 4096;

    nRet = SMAPIGenerateKey(nSock, 16, "1234567890", 10, \
                            2, nIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");

    nRet = SMAPIDecryptBlock(nSock, 2, bKey, bIndata, nDatalen, bOutdataExp);
    ASSERT_RESULT(nRet, 0, "SMAPIDecryptBlock NG");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nEncrypt   = %d\n", nEncrypt);
    printf("[IN ]nMode      = %d\n", nMode);
    printf("[IN ]index      = %d\n", nIndex);
    DspHex("[IN ]indata     =", bIndata, nDatalen);
    printf("[IN ]datalen    = %d\n", nDatalen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptData(nSock, nEncrypt, nMode, nIndex, \
                            bIndata, nDatalen, bOutdata);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "ECB模式解密，密钥索引=257，数据长度=4096，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bOutdata, bOutdataExp, nDatalen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptData_Test_07(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i = 0;

    int  nEncrypt;
    int  nMode;
    int  nIndex;
    BYTE bIndata[4104];
    int  nDatalen;
    BYTE bOutdata[4104];
    BYTE bOutdataExp[4104];
    BYTE bKey[32];
    BYTE szCheckValue[32];
    BYTE bIV[16];

    bufclr(bIndata);
    bufclr(bOutdata);
    bufclr(bOutdataExp);
    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(bIV);

    nEncrypt = 1;
    nMode = 1;
    nIndex = 257;
    memset(bIndata, 0x42, 4096);
    bIndata[0] = 0x30;
    bIndata[4095] = 0x39;
    nDatalen = 4096;

    nRet = SMAPIGenerateKey(nSock, 16, "1234567890", 10, \
                            2, nIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");

    nRet = SMAPIEncryptCBC(nSock, 2, bKey, bIndata, nDatalen, bIV, bOutdataExp);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptBlock NG");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nEncrypt   = %d\n", nEncrypt);
    printf("[IN ]nMode      = %d\n", nMode);
    printf("[IN ]index      = %d\n", nIndex);
    DspHex("[IN ]indata     =", bIndata, nDatalen);
    printf("[IN ]datalen    = %d\n", nDatalen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptData(nSock, nEncrypt, nMode, nIndex, \
                            bIndata, nDatalen, bOutdata);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "CBC模式加密，密钥索引=257，数据长度=4096，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bOutdata, bOutdataExp, nDatalen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptData_Test_08(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i = 0;

    int  nEncrypt;
    int  nMode;
    int  nIndex;
    BYTE bIndata[4104];
    int  nDatalen;
    BYTE bOutdata[4104];
    BYTE bOutdataExp[4104];
    BYTE bKey[32];
    BYTE szCheckValue[32];
    BYTE bIV[16];

    bufclr(bIndata);
    bufclr(bOutdata);
    bufclr(bOutdataExp);
    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(bIV);

    nEncrypt = 0;
    nMode = 1;
    nIndex = 257;
    memset(bIndata, 0x42, 4096);
    bIndata[0] = 0x30;
    bIndata[4095] = 0x39;
    nDatalen = 4096;

    nRet = SMAPIGenerateKey(nSock, 16, "1234567890", 10, \
                            2, nIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");

    nRet = SMAPIDecryptCBC(nSock, 2, bKey, bIndata, nDatalen, bIV, bOutdataExp);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptBlock NG");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nEncrypt   = %d\n", nEncrypt);
    printf("[IN ]nMode      = %d\n", nMode);
    printf("[IN ]index      = %d\n", nIndex);
    DspHex("[IN ]indata     =", bIndata, nDatalen);
    printf("[IN ]datalen    = %d\n", nDatalen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptData(nSock, nEncrypt, nMode, nIndex, \
                            bIndata, nDatalen, bOutdata);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "CBC模式解密，密钥索引=257，数据长度=4096，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bOutdata, bOutdataExp, nDatalen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptData_Test_09(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i = 0;

    int  nEncrypt;
    int  nMode;
    int  nIndex;
    BYTE bIndata[4104];
    int  nDatalen;
    BYTE bOutdata[4104];
    BYTE bOutdataExp[4104];
    BYTE bKey[32];
    BYTE szCheckValue[32];

    bufclr(bIndata);
    bufclr(bOutdata);
    bufclr(bOutdataExp);
    bufclr(bKey);
    bufclr(szCheckValue);

    nEncrypt = 1;
    nMode = 0;
    nIndex = 258;
    memset(bIndata, 0x42, 8);
    bIndata[0] = 0x30;
    bIndata[7] = 0x39;
    nDatalen = 8;

    nRet = SMAPIGenerateKey(nSock, 8, "1234567890", 10, \
                            2, nIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");

    nRet = SMAPIEncryptBlock(nSock, 1, bKey, bIndata, nDatalen, bOutdataExp);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptBlock NG");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nEncrypt   = %d\n", nEncrypt);
    printf("[IN ]nMode      = %d\n", nMode);
    printf("[IN ]index      = %d\n", nIndex);
    DspHex("[IN ]indata     =", bIndata, nDatalen);
    printf("[IN ]datalen    = %d\n", nDatalen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptData(nSock, nEncrypt, nMode, nIndex, \
                            bIndata, nDatalen, bOutdata);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "ECB模式加密，密钥索引=258，数据长度=8，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bOutdata, bOutdataExp, nDatalen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptData_Test_10(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i = 0;

    int  nEncrypt;
    int  nMode;
    int  nIndex;
    BYTE bIndata[4104];
    int  nDatalen;
    BYTE bOutdata[4104];
    BYTE bOutdataExp[4104];
    BYTE bKey[32];
    BYTE szCheckValue[32];

    bufclr(bIndata);
    bufclr(bOutdata);
    bufclr(bOutdataExp);
    bufclr(bKey);
    bufclr(szCheckValue);

    nEncrypt = 0;
    nMode = 0;
    nIndex = 258;
    memset(bIndata, 0x42, 8);
    bIndata[0] = 0x30;
    bIndata[7] = 0x39;
    nDatalen = 8;

    nRet = SMAPIGenerateKey(nSock, 8, "1234567890", 10, \
                            2, nIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");

    nRet = SMAPIDecryptBlock(nSock, 1, bKey, bIndata, nDatalen, bOutdataExp);
    ASSERT_RESULT(nRet, 0, "SMAPIDecryptBlock NG");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nEncrypt   = %d\n", nEncrypt);
    printf("[IN ]nMode      = %d\n", nMode);
    printf("[IN ]index      = %d\n", nIndex);
    DspHex("[IN ]indata     =", bIndata, nDatalen);
    printf("[IN ]datalen    = %d\n", nDatalen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptData(nSock, nEncrypt, nMode, nIndex, \
                            bIndata, nDatalen, bOutdata);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "ECB模式解密，密钥索引=258，数据长度=8，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bOutdata, bOutdataExp, nDatalen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptData_Test_11(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i = 0;

    int  nEncrypt;
    int  nMode;
    int  nIndex;
    BYTE bIndata[4104];
    int  nDatalen;
    BYTE bOutdata[4104];
    BYTE bOutdataExp[4104];
    BYTE bKey[32];
    BYTE szCheckValue[32];
    BYTE bIV[16];

    bufclr(bIndata);
    bufclr(bOutdata);
    bufclr(bOutdataExp);
    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(bIV);

    nEncrypt = 1;
    nMode = 1;
    nIndex = 486;
    memset(bIndata, 0x42, 8);
    bIndata[0] = 0x30;
    bIndata[7] = 0x39;
    nDatalen = 8;

    nRet = SMAPIGenerateKey(nSock, 24, "1234567890", 10, \
                            2, nIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");

    nRet = SMAPIEncryptCBC(nSock, 3, bKey, bIndata, nDatalen, bIV, bOutdataExp);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptBlock NG");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nEncrypt   = %d\n", nEncrypt);
    printf("[IN ]nMode      = %d\n", nMode);
    printf("[IN ]index      = %d\n", nIndex);
    DspHex("[IN ]indata     =", bIndata, nDatalen);
    printf("[IN ]datalen    = %d\n", nDatalen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptData(nSock, nEncrypt, nMode, nIndex, \
                            bIndata, nDatalen, bOutdata);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "CBC模式加密，密钥索引=486，数据长度=8，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bOutdata, bOutdataExp, nDatalen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptData_Test_12(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i = 0;

    int  nEncrypt;
    int  nMode;
    int  nIndex;
    BYTE bIndata[4104];
    int  nDatalen;
    BYTE bOutdata[4104];
    BYTE bOutdataExp[4104];
    BYTE bKey[32];
    BYTE szCheckValue[32];
    BYTE bIV[16];

    bufclr(bIndata);
    bufclr(bOutdata);
    bufclr(bOutdataExp);
    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(bIV);

    nEncrypt = 0;
    nMode = 1;
    nIndex = 486;
    memset(bIndata, 0x42, 8);
    bIndata[0] = 0x30;
    bIndata[7] = 0x39;
    nDatalen = 8;

    nRet = SMAPIGenerateKey(nSock, 24, "1234567890", 10, \
                            2, nIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");

    nRet = SMAPIDecryptCBC(nSock, 3, bKey, bIndata, nDatalen, bIV, bOutdataExp);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptBlock NG");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nEncrypt   = %d\n", nEncrypt);
    printf("[IN ]nMode      = %d\n", nMode);
    printf("[IN ]index      = %d\n", nIndex);
    DspHex("[IN ]indata     =", bIndata, nDatalen);
    printf("[IN ]datalen    = %d\n", nDatalen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptData(nSock, nEncrypt, nMode, nIndex, \
                            bIndata, nDatalen, bOutdata);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "CBC模式解密，密钥索引=486，数据长度=8，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bOutdata, bOutdataExp, nDatalen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptData_Test_13(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i = 0;

    int  nEncrypt;
    int  nMode;
    int  nIndex;
    BYTE bIndata[4104];
    int  nDatalen;
    BYTE bOutdata[4104];
    BYTE bOutdataExp[4104];
    BYTE bKey[32];
    BYTE szCheckValue[32];

    bufclr(bIndata);
    bufclr(bOutdata);
    bufclr(bOutdataExp);
    bufclr(bKey);
    bufclr(szCheckValue);

    nEncrypt = 1;
    nMode = 0;
    nIndex = 258;
    memset(bIndata, 0x42, 4096);
    bIndata[0] = 0x30;
    bIndata[4095] = 0x39;
    nDatalen = 4096;

    nRet = SMAPIGenerateKey(nSock, 8, "1234567890", 10, \
                            2, nIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");

    nRet = SMAPIEncryptBlock(nSock, 1, bKey, bIndata, nDatalen, bOutdataExp);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptBlock NG");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nEncrypt   = %d\n", nEncrypt);
    printf("[IN ]nMode      = %d\n", nMode);
    printf("[IN ]index      = %d\n", nIndex);
    DspHex("[IN ]indata     =", bIndata, nDatalen);
    printf("[IN ]datalen    = %d\n", nDatalen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptData(nSock, nEncrypt, nMode, nIndex, \
                            bIndata, nDatalen, bOutdata);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "ECB模式加密，密钥索引=258，数据长度=4096，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bOutdata, bOutdataExp, nDatalen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptData_Test_14(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i = 0;

    int  nEncrypt;
    int  nMode;
    int  nIndex;
    BYTE bIndata[4104];
    int  nDatalen;
    BYTE bOutdata[4104];
    BYTE bOutdataExp[4104];
    BYTE bKey[32];
    BYTE szCheckValue[32];

    bufclr(bIndata);
    bufclr(bOutdata);
    bufclr(bOutdataExp);
    bufclr(bKey);
    bufclr(szCheckValue);

    nEncrypt = 0;
    nMode = 0;
    nIndex = 258;
    memset(bIndata, 0x42, 4096);
    bIndata[0] = 0x30;
    bIndata[4095] = 0x39;
    nDatalen = 4096;

    nRet = SMAPIGenerateKey(nSock, 8, "1234567890", 10, \
                            2, nIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");

    nRet = SMAPIDecryptBlock(nSock, 1, bKey, bIndata, nDatalen, bOutdataExp);
    ASSERT_RESULT(nRet, 0, "SMAPIDecryptBlock NG");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nEncrypt   = %d\n", nEncrypt);
    printf("[IN ]nMode      = %d\n", nMode);
    printf("[IN ]index      = %d\n", nIndex);
    DspHex("[IN ]indata     =", bIndata, nDatalen);
    printf("[IN ]datalen    = %d\n", nDatalen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptData(nSock, nEncrypt, nMode, nIndex, \
                            bIndata, nDatalen, bOutdata);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "ECB模式解密，密钥索引=258，数据长度=4096，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bOutdata, bOutdataExp, nDatalen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptData_Test_15(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i = 0;

    int  nEncrypt;
    int  nMode;
    int  nIndex;
    BYTE bIndata[4104];
    int  nDatalen;
    BYTE bOutdata[4104];
    BYTE bOutdataExp[4104];
    BYTE bKey[32];
    BYTE szCheckValue[32];
    BYTE bIV[16];

    bufclr(bIndata);
    bufclr(bOutdata);
    bufclr(bOutdataExp);
    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(bIV);

    nEncrypt = 1;
    nMode = 1;
    nIndex = 486;
    memset(bIndata, 0x42, 4096);
    bIndata[0] = 0x30;
    bIndata[4095] = 0x39;
    nDatalen = 4096;

    nRet = SMAPIGenerateKey(nSock, 24, "1234567890", 10, \
                            2, nIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");

    nRet = SMAPIEncryptCBC(nSock, 3, bKey, bIndata, nDatalen, bIV, bOutdataExp);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptBlock NG");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nEncrypt   = %d\n", nEncrypt);
    printf("[IN ]nMode      = %d\n", nMode);
    printf("[IN ]index      = %d\n", nIndex);
    DspHex("[IN ]indata     =", bIndata, nDatalen);
    printf("[IN ]datalen    = %d\n", nDatalen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptData(nSock, nEncrypt, nMode, nIndex, \
                            bIndata, nDatalen, bOutdata);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "CBC模式加密，密钥索引=486，数据长度=4096，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bOutdata, bOutdataExp, nDatalen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptData_Test_16(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i = 0;

    int  nEncrypt;
    int  nMode;
    int  nIndex;
    BYTE bIndata[4104];
    int  nDatalen;
    BYTE bOutdata[4104];
    BYTE bOutdataExp[4104];
    BYTE bKey[32];
    BYTE szCheckValue[32];
    BYTE bIV[16];

    bufclr(bIndata);
    bufclr(bOutdata);
    bufclr(bOutdataExp);
    bufclr(bKey);
    bufclr(szCheckValue);
    bufclr(bIV);

    nEncrypt = 0;
    nMode = 1;
    nIndex = 486;
    memset(bIndata, 0x42, 4096);
    bIndata[0] = 0x30;
    bIndata[4095] = 0x39;
    nDatalen = 4096;

    nRet = SMAPIGenerateKey(nSock, 24, "1234567890", 10, \
                            2, nIndex, bKey, szCheckValue);
    ASSERT_RESULT(nRet, 0, "SMAPIGenerateKey NG");

    nRet = SMAPIDecryptCBC(nSock, 3, bKey, bIndata, nDatalen, bIV, bOutdataExp);
    ASSERT_RESULT(nRet, 0, "SMAPIEncryptBlock NG");

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nEncrypt   = %d\n", nEncrypt);
    printf("[IN ]nMode      = %d\n", nMode);
    printf("[IN ]index      = %d\n", nIndex);
    DspHex("[IN ]indata     =", bIndata, nDatalen);
    printf("[IN ]datalen    = %d\n", nDatalen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptData(nSock, nEncrypt, nMode, nIndex, \
                            bIndata, nDatalen, bOutdata);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "CBC模式解密，密钥索引=486，数据长度=4096，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bOutdata, bOutdataExp, nDatalen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptData_Test_17(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i = 0;

    int  nEncrypt;
    int  nMode;
    int  nIndex;
    BYTE bIndata[4104];
    int  nDatalen;
    BYTE bOutdata[4104];
    BYTE bOutdataExp[4104];

    bufclr(bIndata);
    bufclr(bOutdata);
    bufclr(bOutdataExp);

    nSock = -1;
    nEncrypt = 1;
    nMode = 0;
    nIndex = 257;
    memset(bIndata, 0x42, 8);
    bIndata[0] = 0x30;
    bIndata[7] = 0x39;
    nDatalen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nEncrypt   = %d\n", nEncrypt);
    printf("[IN ]nMode      = %d\n", nMode);
    printf("[IN ]index      = %d\n", nIndex);
    DspHex("[IN ]indata     =", bIndata, 8);
    printf("[IN ]datalen    = %d\n", nDatalen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptData(nSock, nEncrypt, nMode, nIndex, \
                            bIndata, nDatalen, bOutdata);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void EncryptData_Test_18(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i = 0;

    int  nEncrypt;
    int  nMode;
    int  nIndex;
    BYTE bIndata[4104];
    int  nDatalen;
    BYTE bOutdata[4104];
    BYTE bOutdataExp[4104];

    bufclr(bIndata);
    bufclr(bOutdata);
    bufclr(bOutdataExp);

    nSock = 8;
    nEncrypt = 1;
    nMode = 0;
    nIndex = 257;
    memset(bIndata, 0x42, 8);
    bIndata[0] = 0x30;
    bIndata[7] = 0x39;
    nDatalen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nEncrypt   = %d\n", nEncrypt);
    printf("[IN ]nMode      = %d\n", nMode);
    printf("[IN ]index      = %d\n", nIndex);
    DspHex("[IN ]indata     =", bIndata, 8);
    printf("[IN ]datalen    = %d\n", nDatalen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptData(nSock, nEncrypt, nMode, nIndex, \
                            bIndata, nDatalen, bOutdata);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[8]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void EncryptData_Test_19(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i = 0;

    int  nEncrypt;
    int  nMode;
    int  nIndex;
    BYTE bIndata[4104];
    int  nDatalen;
    BYTE bOutdata[4104];
    BYTE bOutdataExp[4104];

    bufclr(bIndata);
    bufclr(bOutdata);
    bufclr(bOutdataExp);

    nEncrypt = -1;
    nMode = 0;
    nIndex = 257;
    memset(bIndata, 0x42, 8);
    bIndata[0] = 0x30;
    bIndata[7] = 0x39;
    nDatalen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nEncrypt   = %d\n", nEncrypt);
    printf("[IN ]nMode      = %d\n", nMode);
    printf("[IN ]index      = %d\n", nIndex);
    DspHex("[IN ]indata     =", bIndata, 8);
    printf("[IN ]datalen    = %d\n", nDatalen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptData(nSock, nEncrypt, nMode, nIndex, \
                            bIndata, nDatalen, bOutdata);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效加解密标志[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptData_Test_20(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i = 0;

    int  nEncrypt;
    int  nMode;
    int  nIndex;
    BYTE bIndata[4104];
    int  nDatalen;
    BYTE bOutdata[4104];
    BYTE bOutdataExp[4104];

    bufclr(bIndata);
    bufclr(bOutdata);
    bufclr(bOutdataExp);

    nEncrypt = 2;
    nMode = 0;
    nIndex = 257;
    memset(bIndata, 0x42, 8);
    bIndata[0] = 0x30;
    bIndata[7] = 0x39;
    nDatalen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nEncrypt   = %d\n", nEncrypt);
    printf("[IN ]nMode      = %d\n", nMode);
    printf("[IN ]index      = %d\n", nIndex);
    DspHex("[IN ]indata     =", bIndata, 8);
    printf("[IN ]datalen    = %d\n", nDatalen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptData(nSock, nEncrypt, nMode, nIndex, \
                            bIndata, nDatalen, bOutdata);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效加解密标志[2]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptData_Test_21(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i = 0;

    int  nEncrypt;
    int  nMode;
    int  nIndex;
    BYTE bIndata[4104];
    int  nDatalen;
    BYTE bOutdata[4104];
    BYTE bOutdataExp[4104];

    bufclr(bIndata);
    bufclr(bOutdata);
    bufclr(bOutdataExp);

    nEncrypt = 1;
    nMode = -1;
    nIndex = 257;
    memset(bIndata, 0x42, 8);
    bIndata[0] = 0x30;
    bIndata[7] = 0x39;
    nDatalen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nEncrypt   = %d\n", nEncrypt);
    printf("[IN ]nMode      = %d\n", nMode);
    printf("[IN ]index      = %d\n", nIndex);
    DspHex("[IN ]indata     =", bIndata, 8);
    printf("[IN ]datalen    = %d\n", nDatalen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptData(nSock, nEncrypt, nMode, nIndex, \
                            bIndata, nDatalen, bOutdata);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效算法标志[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptData_Test_22(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i = 0;

    int  nEncrypt;
    int  nMode;
    int  nIndex;
    BYTE bIndata[4104];
    int  nDatalen;
    BYTE bOutdata[4104];
    BYTE bOutdataExp[4104];

    bufclr(bIndata);
    bufclr(bOutdata);
    bufclr(bOutdataExp);

    nEncrypt = 1;
    nMode = 2;
    nIndex = 257;
    memset(bIndata, 0x42, 8);
    bIndata[0] = 0x30;
    bIndata[7] = 0x39;
    nDatalen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nEncrypt   = %d\n", nEncrypt);
    printf("[IN ]nMode      = %d\n", nMode);
    printf("[IN ]index      = %d\n", nIndex);
    DspHex("[IN ]indata     =", bIndata, 8);
    printf("[IN ]datalen    = %d\n", nDatalen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptData(nSock, nEncrypt, nMode, nIndex, \
                            bIndata, nDatalen, bOutdata);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效算法标志[2]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptData_Test_23(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i = 0;

    int  nEncrypt;
    int  nMode;
    int  nIndex;
    BYTE bIndata[4104];
    int  nDatalen;
    BYTE bOutdata[4104];
    BYTE bOutdataExp[4104];

    bufclr(bIndata);
    bufclr(bOutdata);
    bufclr(bOutdataExp);

    nEncrypt = 1;
    nMode = 0;
    nIndex = 256;
    memset(bIndata, 0x42, 8);
    bIndata[0] = 0x30;
    bIndata[7] = 0x39;
    nDatalen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nEncrypt   = %d\n", nEncrypt);
    printf("[IN ]nMode      = %d\n", nMode);
    printf("[IN ]index      = %d\n", nIndex);
    DspHex("[IN ]indata     =", bIndata, 8);
    printf("[IN ]datalen    = %d\n", nDatalen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptData(nSock, nEncrypt, nMode, nIndex, \
                            bIndata, nDatalen, bOutdata);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效索引值[256]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptData_Test_24(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i = 0;

    int  nEncrypt;
    int  nMode;
    int  nIndex;
    BYTE bIndata[4104];
    int  nDatalen;
    BYTE bOutdata[4104];
    BYTE bOutdataExp[4104];

    bufclr(bIndata);
    bufclr(bOutdata);
    bufclr(bOutdataExp);

    nEncrypt = 1;
    nMode = 0;
    nIndex = 487;
    memset(bIndata, 0x42, 8);
    bIndata[0] = 0x30;
    bIndata[7] = 0x39;
    nDatalen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nEncrypt   = %d\n", nEncrypt);
    printf("[IN ]nMode      = %d\n", nMode);
    printf("[IN ]index      = %d\n", nIndex);
    DspHex("[IN ]indata     =", bIndata, 8);
    printf("[IN ]datalen    = %d\n", nDatalen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptData(nSock, nEncrypt, nMode, nIndex, \
                            bIndata, nDatalen, bOutdata);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效索引值[487]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptData_Test_25(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i = 0;

    int  nEncrypt;
    int  nMode;
    int  nIndex;
    BYTE bIndata[4104];
    int  nDatalen;
    BYTE bOutdata[4104];
    BYTE bOutdataExp[4104];

    bufclr(bIndata);
    bufclr(bOutdata);
    bufclr(bOutdataExp);

    nEncrypt = 1;
    nMode = 0;
    nIndex = 487;
    memset(bIndata, 0x42, 8);
    bIndata[0] = 0x30;
    bIndata[7] = 0x39;
    nDatalen = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nEncrypt   = %d\n", nEncrypt);
    printf("[IN ]nMode      = %d\n", nMode);
    printf("[IN ]index      = %d\n", nIndex);
    DspHex("[IN ]indata     =", bIndata, 8);
    printf("[IN ]datalen    = %d\n", nDatalen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptData(nSock, nEncrypt, nMode, nIndex, \
                            bIndata, nDatalen, bOutdata);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效数据长度[0]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptData_Test_26(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i = 0;

    int  nEncrypt;
    int  nMode;
    int  nIndex;
    BYTE bIndata[4104];
    int  nDatalen;
    BYTE bOutdata[4104];
    BYTE bOutdataExp[4104];

    bufclr(bIndata);
    bufclr(bOutdata);
    bufclr(bOutdataExp);

    nEncrypt = 1;
    nMode = 0;
    nIndex = 487;
    memset(bIndata, 0x42, 8);
    bIndata[0] = 0x30;
    bIndata[7] = 0x39;
    nDatalen = 17;

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nEncrypt   = %d\n", nEncrypt);
    printf("[IN ]nMode      = %d\n", nMode);
    printf("[IN ]index      = %d\n", nIndex);
    DspHex("[IN ]indata     =", bIndata, 8);
    printf("[IN ]datalen    = %d\n", nDatalen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptData(nSock, nEncrypt, nMode, nIndex, \
                            bIndata, nDatalen, bOutdata);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效数据长度[17]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptData_Test_27(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;
    int  i = 0;

    int  nEncrypt;
    int  nMode;
    int  nIndex;
    BYTE bIndata[4104];
    int  nDatalen;
    BYTE bOutdata[4104];
    BYTE bOutdataExp[4104];

    bufclr(bIndata);
    bufclr(bOutdata);
    bufclr(bOutdataExp);

    nEncrypt = 1;
    nMode = 0;
    nIndex = 487;
    memset(bIndata, 0x42, 8);
    bIndata[0] = 0x30;
    bIndata[7] = 0x39;
    nDatalen = 4104;

    XXX_INPUT_XXX
    printf("[IN ]nSock      = %d\n", nSock);
    printf("[IN ]nEncrypt   = %d\n", nEncrypt);
    printf("[IN ]nMode      = %d\n", nMode);
    printf("[IN ]index      = %d\n", nIndex);
    DspHex("[IN ]indata     =", bIndata, 8);
    printf("[IN ]datalen    = %d\n", nDatalen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptData(nSock, nEncrypt, nMode, nIndex, \
                            bIndata, nDatalen, bOutdata);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效数据长度[4104]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenRsaKey_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIndex;
    int  nModLen;
    char szExp[10];
    BYTE bPK[2048];
    int  nPKLen;
    BYTE bSK[2048];
    int  nSKLen;

    bufclr(szExp);
    bufclr(bPK);
    bufclr(bSK);
    nPKLen = 0;
    nSKLen = 0;

    nIndex = 0;
    nModLen = 512;
    memcpy(szExp, "03", 2);

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nIndex  = %d\n", nIndex);
    printf("[IN ]nModLen = %d\n", nModLen);
    printf("[IN ]szExp   = %s\n", szExp);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenRsaKey(nSock, nIndex, nModLen, szExp, bPK, &nPKLen, bSK, &nSKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "索引号=0，密钥模长=512，公钥指数=03，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHex("[OUT]bPK     =", bPK, nPKLen + 8);
    printf("[OUT]nPKLen  = %d\n", nPKLen);
    DspHex("[OUT]bSK     =", bSK, nSKLen + 8);
    printf("[OUT]nSKLen  = %d\n", nSKLen);
    DspHexExt("[OUT]bPK     =", bPK, nPKLen);
    DspHexExt("[OUT]bSK     =", bSK, nSKLen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenRsaKey_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIndex;
    int  nModLen;
    char szExp[10];
    BYTE bPK[2048];
    int  nPKLen;
    BYTE bSK[2048];
    int  nSKLen;

    bufclr(szExp);
    bufclr(bPK);
    bufclr(bSK);
    nPKLen = 0;
    nSKLen = 0;

    nIndex = 0;
    nModLen = 1024;
    memcpy(szExp, "065537", 6);

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nIndex  = %d\n", nIndex);
    printf("[IN ]nModLen = %d\n", nModLen);
    printf("[IN ]szExp   = %s\n", szExp);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenRsaKey(nSock, nIndex, nModLen, szExp, bPK, &nPKLen, bSK, &nSKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "索引号=0，密钥模长=1024，公钥指数=065537，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHex("[OUT]bPK     =", bPK, nPKLen + 8);
    printf("[OUT]nPKLen  = %d\n", nPKLen);
    DspHex("[OUT]bSK     =", bSK, nSKLen + 8);
    printf("[OUT]nSKLen  = %d\n", nSKLen);
    DspHexExt("[OUT]bPK     =", bPK, nPKLen);
    DspHexExt("[OUT]bSK     =", bSK, nSKLen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenRsaKey_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIndex;
    int  nModLen;
    char szExp[10];
    BYTE bPK[3072];
    int  nPKLen;
    BYTE bSK[3072];
    int  nSKLen;

    bufclr(szExp);
    bufclr(bPK);
    bufclr(bSK);
    nPKLen = 0;
    nSKLen = 0;

    nIndex = 19;
    nModLen = 2048;
    memcpy(szExp, "03", 2);

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nIndex  = %d\n", nIndex);
    printf("[IN ]nModLen = %d\n", nModLen);
    printf("[IN ]szExp   = %s\n", szExp);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenRsaKey(nSock, nIndex, nModLen, szExp, bPK, &nPKLen, bSK, &nSKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "索引号=19，密钥模长=2048，公钥指数=03，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHex("[OUT]bPK     =", bPK, nPKLen + 8);
    printf("[OUT]nPKLen  = %d\n", nPKLen);
    DspHex("[OUT]bSK     =", bSK, nSKLen + 8);
    printf("[OUT]nSKLen  = %d\n", nSKLen);
    DspHexExt("[OUT]bPK     =", bPK, nPKLen);
    DspHexExt("[OUT]bSK     =", bSK, nSKLen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenRsaKey_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIndex;
    int  nModLen;
    char szExp[10];
    BYTE bPK[3072];
    int  nPKLen;
    BYTE bSK[3072];
    int  nSKLen;

    bufclr(szExp);
    bufclr(bPK);
    bufclr(bSK);
    nPKLen = 0;
    nSKLen = 0;

    nIndex = 0;
    nModLen = 1152;
    memcpy(szExp, "03", 2);

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nIndex  = %d\n", nIndex);
    printf("[IN ]nModLen = %d\n", nModLen);
    printf("[IN ]szExp   = %s\n", szExp);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenRsaKey(nSock, nIndex, nModLen, szExp, bPK, &nPKLen, bSK, &nSKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "索引号=0，密钥模长=1152，公钥指数=03，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHex("[OUT]bPK     =", bPK, nPKLen + 8);
    printf("[OUT]nPKLen  = %d\n", nPKLen);
    DspHex("[OUT]bSK     =", bSK, nSKLen + 8);
    printf("[OUT]nSKLen  = %d\n", nSKLen);
    DspHexExt("[OUT]bPK     =", bPK, nPKLen);
    DspHexExt("[OUT]bSK     =", bSK, nSKLen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenRsaKey_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIndex;
    int  nModLen;
    char szExp[10];
    BYTE bPK[3072];
    int  nPKLen;
    BYTE bSK[3072];
    int  nSKLen;

    bufclr(szExp);
    bufclr(bPK);
    bufclr(bSK);
    nPKLen = 0;
    nSKLen = 0;

    nIndex = 1;
    nModLen = 1408;
    memcpy(szExp, "03", 2);

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nIndex  = %d\n", nIndex);
    printf("[IN ]nModLen = %d\n", nModLen);
    printf("[IN ]szExp   = %s\n", szExp);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenRsaKey(nSock, nIndex, nModLen, szExp, bPK, &nPKLen, bSK, &nSKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "索引号=1，密钥模长=1408，公钥指数=03，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHex("[OUT]bPK     =", bPK, nPKLen + 8);
    printf("[OUT]nPKLen  = %d\n", nPKLen);
    DspHex("[OUT]bSK     =", bSK, nSKLen + 8);
    printf("[OUT]nSKLen  = %d\n", nSKLen);
    DspHexExt("[OUT]bPK     =", bPK, nPKLen);
    DspHexExt("[OUT]bSK     =", bSK, nSKLen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenRsaKey_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIndex;
    int  nModLen;
    char szExp[10];
    BYTE bPK[3072];
    int  nPKLen;
    BYTE bSK[3072];
    int  nSKLen;

    bufclr(szExp);
    bufclr(bPK);
    bufclr(bSK);
    nPKLen = 0;
    nSKLen = 0;

    nIndex = 4;
    nModLen = 1984;
    memcpy(szExp, "03", 2);

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nIndex  = %d\n", nIndex);
    printf("[IN ]nModLen = %d\n", nModLen);
    printf("[IN ]szExp   = %s\n", szExp);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenRsaKey(nSock, nIndex, nModLen, szExp, bPK, &nPKLen, bSK, &nSKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "索引号=4，密钥模长=1984，公钥指数=03，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHex("[OUT]bPK     =", bPK, nPKLen + 8);
    printf("[OUT]nPKLen  = %d\n", nPKLen);
    DspHex("[OUT]bSK     =", bSK, nSKLen + 8);
    printf("[OUT]nSKLen  = %d\n", nSKLen);
    DspHexExt("[OUT]bPK     =", bPK, nPKLen);
    DspHexExt("[OUT]bSK     =", bSK, nSKLen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenRsaKey_Test_07(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIndex;
    int  nModLen;
    char szExp[10];
    BYTE bPK[2048];
    int  nPKLen;
    BYTE bSK[2048];
    int  nSKLen;

    bufclr(szExp);
    bufclr(bPK);
    bufclr(bSK);
    nPKLen = 0;
    nSKLen = 0;

    nSock = -1;
    nIndex = 0;
    nModLen = 512;
    memcpy(szExp, "03", 2);

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nIndex  = %d\n", nIndex);
    printf("[IN ]nModLen = %d\n", nModLen);
    printf("[IN ]szExp   = %s\n", szExp);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenRsaKey(nSock, nIndex, nModLen, szExp, bPK, &nPKLen, bSK, &nSKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void GenRsaKey_Test_08(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIndex;
    int  nModLen;
    char szExp[10];
    BYTE bPK[2048];
    int  nPKLen;
    BYTE bSK[2048];
    int  nSKLen;

    bufclr(szExp);
    bufclr(bPK);
    bufclr(bSK);
    nPKLen = 0;
    nSKLen = 0;

    nSock = 8;
    nIndex = 0;
    nModLen = 512;
    memcpy(szExp, "03", 2);

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nIndex  = %d\n", nIndex);
    printf("[IN ]nModLen = %d\n", nModLen);
    printf("[IN ]szExp   = %s\n", szExp);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenRsaKey(nSock, nIndex, nModLen, szExp, bPK, &nPKLen, bSK, &nSKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[8]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void GenRsaKey_Test_09(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIndex;
    int  nModLen;
    char szExp[10];
    BYTE bPK[2048];
    int  nPKLen;
    BYTE bSK[2048];
    int  nSKLen;

    bufclr(szExp);
    bufclr(bPK);
    bufclr(bSK);
    nPKLen = 0;
    nSKLen = 0;

    nIndex = 20;
    nModLen = 512;
    memcpy(szExp, "03", 2);

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nIndex  = %d\n", nIndex);
    printf("[IN ]nModLen = %d\n", nModLen);
    printf("[IN ]szExp   = %s\n", szExp);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenRsaKey(nSock, nIndex, nModLen, szExp, bPK, &nPKLen, bSK, &nSKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效索引号[20]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenRsaKey_Test_10(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIndex;
    int  nModLen;
    char szExp[10];
    BYTE bPK[2048];
    int  nPKLen;
    BYTE bSK[2048];
    int  nSKLen;

    bufclr(szExp);
    bufclr(bPK);
    bufclr(bSK);
    nPKLen = 0;
    nSKLen = 0;

    nIndex = 0;
    nModLen = 2176;
    memcpy(szExp, "03", 2);

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nIndex  = %d\n", nIndex);
    printf("[IN ]nModLen = %d\n", nModLen);
    printf("[IN ]szExp   = %s\n", szExp);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenRsaKey(nSock, nIndex, nModLen, szExp, bPK, &nPKLen, bSK, &nSKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效模长[2178]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenRsaKey_Test_11(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIndex;
    int  nModLen;
    char szExp[10];
    BYTE bPK[2048];
    int  nPKLen;
    BYTE bSK[2048];
    int  nSKLen;

    bufclr(szExp);
    bufclr(bPK);
    bufclr(bSK);
    nPKLen = 0;
    nSKLen = 0;

    nIndex = 0;
    nModLen = 512;
    memcpy(szExp, "0", 1);

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nIndex  = %d\n", nIndex);
    printf("[IN ]nModLen = %d\n", nModLen);
    printf("[IN ]szExp   = %s\n", szExp);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenRsaKey(nSock, nIndex, nModLen, szExp, bPK, &nPKLen, bSK, &nSKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效公钥指数='0'，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenRsaKey_Test_12(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIndex;
    int  nModLen;
    char szExp[10];
    BYTE bPK[2048];
    int  nPKLen;
    BYTE bSK[2048];
    int  nSKLen;

    bufclr(szExp);
    bufclr(bPK);
    bufclr(bSK);
    nPKLen = 0;
    nSKLen = 0;

    nIndex = 0;
    nModLen = 512;
    memcpy(szExp, "00", 2);

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nIndex  = %d\n", nIndex);
    printf("[IN ]nModLen = %d\n", nModLen);
    printf("[IN ]szExp   = %s\n", szExp);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenRsaKey(nSock, nIndex, nModLen, szExp, bPK, &nPKLen, bSK, &nSKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效公钥指数='00'，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenRsaKey_Test_13(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIndex;
    int  nModLen;
    char szExp[10];
    BYTE bPK[2048];
    int  nPKLen;
    BYTE bSK[2048];
    int  nSKLen;

    bufclr(szExp);
    bufclr(bPK);
    bufclr(bSK);
    nPKLen = 0;
    nSKLen = 0;

    nIndex = 0;
    nModLen = 512;

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nIndex  = %d\n", nIndex);
    printf("[IN ]nModLen = %d\n", nModLen);
    printf("[IN ]szExp   = %s\n", szExp);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenRsaKey(nSock, nIndex, nModLen, szExp, bPK, &nPKLen, bSK, &nSKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效公钥指数=''，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenRsaKey_Test_14(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIndex;
    int  nModLen;
    char szExp[10];
    BYTE bPK[2048];
    int  nPKLen;
    BYTE bSK[2048];
    int  nSKLen;

    bufclr(szExp);
    bufclr(bPK);
    bufclr(bSK);
    nPKLen = 0;
    nSKLen = 0;

    nIndex = 0;
    nModLen = 512;
    memcpy(szExp, "01", 2);

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nIndex  = %d\n", nIndex);
    printf("[IN ]nModLen = %d\n", nModLen);
    printf("[IN ]szExp   = %s\n", szExp);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenRsaKey(nSock, nIndex, nModLen, szExp, bPK, &nPKLen, bSK, &nSKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效公钥指数='01'，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void Digest_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bData[4096];
    int  nDataLen;
    BYTE bDigest[72];
    BYTE bDigestExp[72];

    bufclr(bData);
    bufclr(bDigest);
    bufclr(bDigestExp);

    nAlgo = 0;
    memset(bData, 0x42, 512);
    bData[0] = 0x30;
    bData[511] = 0x39;
    nDataLen = 512;
    memcpy(bDigestExp,
           "\x6A\x27\x87\x3C\xB6\x09\x26\x7D"
           "\xF9\xED\xF4\x56\x9B\x83\x5B\x15"
           , 16);

    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bData    =", bData, 512);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDigest(nSock, nAlgo, bData, nDataLen, bDigest);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "MD5测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bDigest    =", bDigest, 16);
    DspHex("[OUT]bDigestExp =", bDigestExp, 16);
    ASSERT_OUT_HEX(bDigest, bDigestExp, 16);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void Digest_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bData[4096];
    int  nDataLen;
    BYTE bDigest[72];
    BYTE bDigestExp[72];

    bufclr(bData);
    bufclr(bDigest);
    bufclr(bDigestExp);

    nAlgo = 1;
    memset(bData, 0x42, 1024);
    bData[0] = 0x30;
    bData[1023] = 0x39;
    nDataLen = 1024;
    memcpy(bDigestExp,
           "\x31\xD0\x21\xFA\x86\xE8\x69\xBB"
           "\x95\x03\x71\xCF\x14\xD0\xBF\xF5"
           "\xA6\x31\x20\x83"
           , 20);

    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bData    =", bData, 1024);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDigest(nSock, nAlgo, bData, nDataLen, bDigest);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "SHA-1测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bDigest    =", bDigest, 20);
    DspHex("[OUT]bDigestExp =", bDigestExp, 20);
    ASSERT_OUT_HEX(bDigest, bDigestExp, 20);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void Digest_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bData[4096];
    int  nDataLen;
    BYTE bDigest[72];
    BYTE bDigestExp[72];

    bufclr(bData);
    bufclr(bDigest);
    bufclr(bDigestExp);

    nAlgo = 2;
    memset(bData, 0x42, 1152);
    bData[0] = 0x30;
    bData[1151] = 0x39;
    nDataLen = 1152;
    memcpy(bDigestExp,
           "\x6C\xC3\x64\x60\x56\x19\x03\xDC\x4B\xD4\x66\xC7\x15\x9B\xBF\x76"
           "\x3C\x46\xB3\x51\xFE\x53\x4C\x2C\xBE\x43\x7C\x86"
           , 28);

    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bData    =", bData, 1152);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDigest(nSock, nAlgo, bData, nDataLen, bDigest);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "SHA-224测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bDigest    =", bDigest, 28);
    DspHex("[OUT]bDigestExp =", bDigestExp, 28);
    ASSERT_OUT_HEX(bDigest, bDigestExp, 28);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void Digest_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bData[4096];
    int  nDataLen;
    BYTE bDigest[72];
    BYTE bDigestExp[72];

    bufclr(bData);
    bufclr(bDigest);
    bufclr(bDigestExp);

    nAlgo = 3;
    memset(bData, 0x42, 1408);
    bData[0] = 0x30;
    bData[1407] = 0x39;
    nDataLen = 1408;
    memcpy(bDigestExp,
           "\xD1\x50\x43\x1F\x1F\xC6\x25\x2E"
           "\x9F\x48\x35\xC2\xFF\x38\xF6\xF2"
           "\x15\xC1\x08\xD9\xB8\x4F\x45\x89"
           "\x33\x43\x5D\xA4\x9E\xBD\x1F\x27"
           , 32);

    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bData    =", bData, 1408);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDigest(nSock, nAlgo, bData, nDataLen, bDigest);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "SHA-256测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bDigest    =", bDigest, 32);
    DspHex("[OUT]bDigestExp =", bDigestExp, 32);
    ASSERT_OUT_HEX(bDigest, bDigestExp, 32);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void Digest_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bData[4096];
    int  nDataLen;
    BYTE bDigest[72];
    BYTE bDigestExp[72];

    bufclr(bData);
    bufclr(bDigest);
    bufclr(bDigestExp);

    nAlgo = 4;
    memset(bData, 0x42, 1984);
    bData[0] = 0x30;
    bData[1983] = 0x39;
    nDataLen = 1984;
    memcpy(bDigestExp,
           "\x37\x54\x6C\xC1\x57\xA6\x9A\xFE\xCB\x79\xA6\xB8\x44\x4B\xCC\x94"
           "\x82\x97\xD8\x32\xE7\x22\xCC\xC0\x1A\x93\x63\xDD\xEA\x6B\x6C\x47"
           "\x6E\xFF\xBE\xCC\x82\xB6\xA8\xE0\xA8\xD5\x3F\x32\x3B\xC1\x30\x20"
           , 48);

    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bData    =", bData, 1984);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDigest(nSock, nAlgo, bData, nDataLen, bDigest);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "SHA-384测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bDigest    =", bDigest, 48);
    DspHex("[OUT]bDigestExp =", bDigestExp, 48);
    ASSERT_OUT_HEX(bDigest, bDigestExp, 48);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void Digest_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bData[4096];
    int  nDataLen;
    BYTE bDigest[72];
    BYTE bDigestExp[72];

    bufclr(bData);
    bufclr(bDigest);
    bufclr(bDigestExp);

    nAlgo = 5;
    memset(bData, 0x42, 2048);
    bData[0] = 0x30;
    bData[2047] = 0x39;
    nDataLen = 2048;
    memcpy(bDigestExp,
           "\xD2\xFF\xFD\x39\x07\xDB\x80\xF7"
           "\x15\x4F\xAA\x2F\x56\xCA\x72\x25"
           "\x53\x2C\x3A\x26\x9B\xE2\xCB\xEB"
           "\x57\xB6\x7A\x50\x67\xEF\x2A\xD4"
           "\x3A\x8D\x02\x68\xFE\xB9\x93\xBF"
           "\x51\x44\x22\xCA\x70\xE9\x66\x5F"
           "\xF7\xD2\xCF\x92\xAA\xBE\xFE\x44"
           "\xE1\x77\xAB\xF6\xB0\x10\x8C\x8A"
           , 64);

    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bData    =", bData, 2048);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDigest(nSock, nAlgo, bData, nDataLen, bDigest);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "SHA-512测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bDigest    =", bDigest, 64);
    DspHex("[OUT]bDigestExp =", bDigestExp, 64);
    ASSERT_OUT_HEX(bDigest, bDigestExp, 64);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void Digest_Test_07(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bData[4096];
    int  nDataLen;
    BYTE bDigest[72];
    BYTE bDigestExp[72];

    bufclr(bData);
    bufclr(bDigest);
    bufclr(bDigestExp);

    nSock = -1;
    nAlgo = 0;
    memset(bData, 0x42, 512);
    bData[0] = 0x30;
    bData[511] = 0x39;
    nDataLen = 512;

    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bData    =", bData, 512);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDigest(nSock, nAlgo, bData, nDataLen, bDigest);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void Digest_Test_08(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bData[4096];
    int  nDataLen;
    BYTE bDigest[72];
    BYTE bDigestExp[72];

    bufclr(bData);
    bufclr(bDigest);
    bufclr(bDigestExp);

    nSock = 8;
    nAlgo = 0;
    memset(bData, 0x42, 512);
    bData[0] = 0x30;
    bData[511] = 0x39;
    nDataLen = 512;

    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bData    =", bData, 512);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDigest(nSock, nAlgo, bData, nDataLen, bDigest);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[8]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void Digest_Test_09(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bData[4096];
    int  nDataLen;
    BYTE bDigest[72];
    BYTE bDigestExp[72];

    bufclr(bData);
    bufclr(bDigest);
    bufclr(bDigestExp);

    nAlgo = 6;
    memset(bData, 0x42, 512);
    bData[0] = 0x30;
    bData[511] = 0x39;
    nDataLen = 512;

    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bData    =", bData, 512);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDigest(nSock, nAlgo, bData, nDataLen, bDigest);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效算法类型[6]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void Digest_Test_10(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bData[4096];
    int  nDataLen;
    BYTE bDigest[72];
    BYTE bDigestExp[72];

    bufclr(bData);
    bufclr(bDigest);
    bufclr(bDigestExp);

    nAlgo = -1;
    memset(bData, 0x42, 512);
    bData[0] = 0x30;
    bData[511] = 0x39;
    nDataLen = 512;

    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bData    =", bData, 512);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDigest(nSock, nAlgo, bData, nDataLen, bDigest);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效算法类型[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void Digest_Test_11(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bData[4096];
    int  nDataLen;
    BYTE bDigest[72];
    BYTE bDigestExp[72];

    bufclr(bData);
    bufclr(bDigest);
    bufclr(bDigestExp);

    nAlgo = 0;
    nDataLen = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bData    =", bData, 8);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDigest(nSock, nAlgo, bData, nDataLen, bDigest);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "数据长度=0测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void Digest_Test_12(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bData[4096];
    int  nDataLen;
    BYTE bDigest[72];
    BYTE bDigestExp[72];

    bufclr(bData);
    bufclr(bDigest);
    bufclr(bDigestExp);

    nAlgo = 1;
    nDataLen = 1024;
    memcpy(bDigestExp,
           "\x60\xCA\xCB\xF3\xD7\x2E\x1E\x78"
           "\x34\x20\x3D\xA6\x08\x03\x7B\x1B"
           "\xF8\x3B\x40\xE8"
           , 20);

    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bData    =", bData, 1024);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDigest(nSock, nAlgo, bData, nDataLen, bDigest);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "空数据测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bDigest    =", bDigest, 20);
    DspHex("[OUT]bDigestExp =", bDigestExp, 20);
    ASSERT_OUT_HEX(bDigest, bDigestExp, 20);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void Digest_Test_13(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bData[4096];
    int  nDataLen;
    BYTE bDigest[72];
    BYTE bDigestExp[72];

    bufclr(bData);
    bufclr(bDigest);
    bufclr(bDigestExp);

    nAlgo = 0;
    memset(bData, 0x42, 8);
    bData[0] = 0x30;
    bData[7] = 0x39;
    nDataLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bData    =", bData, 8);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDigest(nSock, nAlgo, bData, nDataLen, bDigest);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效数据长度=8测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void Digest_Test_14(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bData[4096];
    int  nDataLen;
    BYTE bDigest[72];
    BYTE bDigestExp[72];

    bufclr(bData);
    bufclr(bDigest);
    bufclr(bDigestExp);

    nAlgo = 1;
    memset(bData, 0x42, 16);
    bData[0] = 0x30;
    bData[15] = 0x39;
    nDataLen = 16;
    memcpy(bDigestExp,
           "\x80\xCF\x95\x55\xA5\x5E\x62\x43\x17\xC2\x99\xE7\x3F\x27\x9D\x89"
           "\x4C\x01\x63\xE7"
           , 20);

    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bData    =", bData, 16);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDigest(nSock, nAlgo, bData, nDataLen, bDigest);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "数据长度小于摘要[SHA-1]长度测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bDigest    =", bDigest, 20);
    DspHex("[OUT]bDigestExp =", bDigestExp, 20);
    ASSERT_OUT_HEX(bDigest, bDigestExp, 20);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void Digest_Test_15(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bData[4096];
    int  nDataLen;
    BYTE bDigest[72];
    BYTE bDigestExp[72];

    bufclr(bData);
    bufclr(bDigest);
    bufclr(bDigestExp);

    nAlgo = 2;
    memset(bData, 0x42, 16);
    bData[0] = 0x30;
    bData[15] = 0x39;
    nDataLen = 16;
    memcpy(bDigestExp,
           "\x12\x8E\x9E\x9C\xE7\xEA\xC3\x72\x3D\x78\xFD\xB0\xBC\x52\xF7\xB3"
           "\xE8\xC8\x9D\x8C\x1D\x3E\x0A\x2F\x18\x1B\x78\x55"
           , 28);

    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bData    =", bData, 16);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDigest(nSock, nAlgo, bData, nDataLen, bDigest);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "数据长度小于摘要[SHA-224]长度测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bDigest    =", bDigest, 28);
    DspHex("[OUT]bDigestExp =", bDigestExp, 28);
    ASSERT_OUT_HEX(bDigest, bDigestExp, 28);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void Digest_Test_16(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bData[4096];
    int  nDataLen;
    BYTE bDigest[72];
    BYTE bDigestExp[72];

    bufclr(bData);
    bufclr(bDigest);
    bufclr(bDigestExp);

    nAlgo = 3;
    memset(bData, 0x42, 16);
    bData[0] = 0x30;
    bData[15] = 0x39;
    nDataLen = 16;
    memcpy(bDigestExp,
           "\x3C\x94\x02\x62\xD3\x75\x11\x16\x54\x7E\xF4\x1E\x5D\xF9\x16\xE5"
           "\x18\x3C\x87\xF4\x98\xB9\x1D\x3C\x06\xD3\xA9\xF4\x0B\x93\x38\x35"
           , 32);

    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bData    =", bData, 16);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDigest(nSock, nAlgo, bData, nDataLen, bDigest);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "数据长度小于摘要[SHA-256]长度测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bDigest    =", bDigest, 32);
    DspHex("[OUT]bDigestExp =", bDigestExp, 32);
    ASSERT_OUT_HEX(bDigest, bDigestExp, 32);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void Digest_Test_17(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bData[4096];
    int  nDataLen;
    BYTE bDigest[72];
    BYTE bDigestExp[72];

    bufclr(bData);
    bufclr(bDigest);
    bufclr(bDigestExp);

    nAlgo = 4;
    memset(bData, 0x42, 16);
    bData[0] = 0x30;
    bData[15] = 0x39;
    nDataLen = 16;
    memcpy(bDigestExp,
           "\x47\xB0\x67\xB3\xB1\x93\x49\x57\x21\x44\x5A\x6B\x9C\xCF\xD8\xF2"
           "\x37\x4C\xFE\x3B\x06\xBB\xC8\x4F\x4E\x5F\x12\x9E\x23\x0A\x2E\x89"
           "\x3A\xF0\xF0\x2A\xC7\x67\xD1\xB7\xE3\x13\x16\x68\xF3\xD3\x7C\xA8"
           , 48);

    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bData    =", bData, 8);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDigest(nSock, nAlgo, bData, nDataLen, bDigest);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "数据长度小于摘要[SHA-386]长度测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bDigest    =", bDigest, 48);
    DspHex("[OUT]bDigestExp =", bDigestExp, 48);
    ASSERT_OUT_HEX(bDigest, bDigestExp, 48);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void Digest_Test_18(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bData[4096];
    int  nDataLen;
    BYTE bDigest[72];
    BYTE bDigestExp[72];

    bufclr(bData);
    bufclr(bDigest);
    bufclr(bDigestExp);

    nAlgo = 5;
    memset(bData, 0x42, 16);
    bData[0] = 0x30;
    bData[15] = 0x39;
    nDataLen = 16;
    memcpy(bDigestExp,
           "\x4B\x52\x53\x30\x73\x02\x1A\xED\xD0\x31\x0D\xC2\x6D\x73\x39\x9D"
           "\x2D\x53\x88\x7E\x75\xFD\x92\x79\x93\xBF\xE7\x8F\xB9\xCB\x38\xEE"
           "\x7D\x06\xC9\x53\x0F\xD1\x21\x2F\x5E\xD4\x4F\x4D\x3A\x3F\x91\xF8"
           "\xAE\xD8\x1F\x5C\x3D\x49\x35\x62\x85\xD4\x0D\x5E\x1A\xA4\x7F\x79"
           , 64);

    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bData    =", bData, 8);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDigest(nSock, nAlgo, bData, nDataLen, bDigest);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "数据长度小于摘要[SHA-512]长度测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bDigest    =", bDigest, 64);
    DspHex("[OUT]bDigestExp =", bDigestExp, 64);
    ASSERT_OUT_HEX(bDigest, bDigestExp, 64);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void Digest_Test_19(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bData[4096];
    int  nDataLen;
    BYTE bDigest[40];
    BYTE bDigestExp[40];

    bufclr(bData);
    bufclr(bDigest);
    bufclr(bDigestExp);

    nAlgo = 7;
    memset(bData, 0x42, 2048);
    bData[0] = 0x30;
    bData[2047] = 0x39;
    nDataLen = 2048;
    memcpy(bDigestExp,
           "\xE8\xF1\x27\x99\x99\xD0\x8C\x2F" \
           "\xB5\xB1\x42\x99\x93\x81\x15\xC2" \
           "\x42\xC4\x94\x36\x5A\x6C\x3D\xCF" \
           "\xC8\xC6\x09\x20\xC9\xAF\x5B\xD5" \
           , 32);

    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bData    =", bData, 2048);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDigest(nSock, nAlgo, bData, nDataLen, bDigest);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "SM3测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
//    DspHex("[OUT]bDigest    =", bDigest, 40);
//    DspHex("[OUT]bDigestExp =", bDigestExp, 40);
    ASSERT_OUT_HEX(bDigest, bDigestExp, 40);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void Digest_Test_20(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nAlgo;
    BYTE bData[4096];
    int  nDataLen;
    BYTE bDigest[40];
    BYTE bDigestExp[40];

    bufclr(bData);
    bufclr(bDigest);
    bufclr(bDigestExp);

    nAlgo = 7;
    memset(bData, 0x42, 16);
    bData[0] = 0x30;
    bData[15] = 0x39;
    nDataLen = 16;
    memcpy(bDigestExp,
           "\xAC\x47\xCB\xAF\x80\xCB\x66\x68" \
           "\xC2\x5A\x5F\x3E\x63\x95\xDB\xAB" \
           "\xFD\x9F\x5E\x22\xC0\x19\xF9\x83" \
           "\x3C\xAD\xAD\xF8\x88\xC2\xCD\x3B" \
           , 32);

    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bData    =", bData, 16);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDigest(nSock, nAlgo, bData, nDataLen, bDigest);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "数据长度小于摘要[SM3]长度测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
//    DspHex("[OUT]bDigest    =", bDigest, 40);
//    DspHex("[OUT]bDigestExp =", bDigestExp, 40);
    ASSERT_OUT_HEX(bDigest, bDigestExp, 40);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    nOutDataLen = 0;
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 0;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    memset(bInData, 0x42, 64);
    bInData[0] = 0x30;
    bInData[63] = 0x39;
    nInDataLen = 64;
    memcpy(bOutDataExp,
           "\x71\x27\xCA\xBD\x0D\x27\x32\x45\x0F\x69\x2E\x77\x47\x36\x02\x5C"
           "\xD9\x12\x9A\xFB\xCA\x7F\xDC\x08\x47\xC9\xC4\xDB\xE2\x74\x57\x7E"
           "\x28\x3D\x79\x40\xA0\x54\xC6\xA3\xEF\x46\xCE\xD0\x10\xD2\xDB\x88"
           "\x50\x56\x0A\x7C\x9D\x92\x78\xC5\x1E\xC6\x18\xA7\x95\xEA\xBD\x82"
           , 64);
    nOutDataLenExp = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 72);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bInData =", bInData, 64);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-512，无填充，加密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 64);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 64);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 64);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    nOutDataLen = 0;
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 0;
    memcpy(bPK,
           "\x30\x81\x87\x02\x81\x81\x00\xA6\xF5\x8A\x17\x12\x3F\x46\x59\x92"
           "\xC0\x92\x01\x7E\xD3\xA9\x67\x2A\x6A\x42\x8E\xDA\x6A\xC2\x53\x91"
           "\x83\x77\x1E\x25\xA2\xA8\x74\x9B\xF3\x49\xF6\x6C\x5B\xA7\xDA\xC6"
           "\x18\x4B\x49\x42\x80\x20\x7F\xD9\xBB\x29\xC0\xF0\xD8\x81\xDC\x0A"
           "\x95\x53\x80\xF5\xA7\x52\x7E\x1E\x1E\x16\xB9\x5B\x79\xEE\x1F\x33"
           "\x50\x3A\xCC\x4E\xA1\x01\xC4\x55\xA8\x3B\xCB\x2B\xC8\xEB\xC5\x27"
           "\x5C\x21\xE3\x5B\xA1\x33\x60\xC6\x82\x76\xDD\x7C\x5F\xF0\x03\x24"
           "\xA7\x8E\x9B\x50\x8C\x46\xD5\xEB\xF5\x37\x81\x9B\xCD\x38\x01\x10"
           "\x1F\x9F\x0F\xBD\x78\x37\xC7\x02\x01\x03"
           , 138);
    nPKLen = 138;
    memset(bInData, 0x42, 128);
    bInData[0] = 0x30;
    bInData[127] = 0x39;
    nInDataLen = 128;
    memcpy(bOutDataExp,
           "\x41\x6B\x36\x4E\x51\x5E\xD1\xEB\x1D\x61\xC5\xB2\x0E\x60\x1B\xE6"
           "\xF7\x97\x20\x2D\x07\x8C\xEB\x3A\x72\x35\xE8\xE1\x28\xAE\x4E\xAF"
           "\xFA\x25\x1E\xB7\x75\x00\x80\x98\xD2\xB9\x95\xF7\xA3\x44\xBA\x29"
           "\xE9\xDB\x8C\x14\x0F\x42\x9D\x90\x7C\xEC\x14\x9A\xEC\xD7\x55\x01"
           "\x02\x93\x0B\xBF\x76\xBB\x10\x57\x13\xD1\x5D\x11\xE3\x1E\x88\xB9"
           "\x20\x13\xD5\x9B\x3F\x50\x20\x8D\xA3\x11\xAE\x32\x6B\xB6\x68\x0C"
           "\xBD\xB2\xB0\xB3\xC7\xF1\x06\x90\x40\x20\x77\x48\x1B\x30\xDC\xE3"
           "\x50\xBD\x48\xE1\xEE\xEA\xF1\x31\xE1\x49\xB9\x6A\x12\x5F\x76\xA0"
           , 128);
    nOutDataLenExp = 128;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 138);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bInData =", bInData, 128);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1024，无填充，加密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 128);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 128);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 128);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    nOutDataLen = 0;
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 0;
    memcpy(bPK,
           "\x30\x81\x97\x02\x81\x91\x00\xB4\xD4\xCD\x27\x2B\x0C\x7A\xBA\xA9"
           "\x32\x54\xA6\x0A\xD3\xDD\xAE\x80\x31\x47\x07\xC8\x48\x4F\x76\x03"
           "\x7C\x24\x4A\x59\x54\x0E\x99\x25\xD1\x3C\xB6\xE0\x20\xDB\xCB\x20"
           "\xB5\x23\x8F\x55\xDE\xF4\x31\xCD\x51\xE2\x1B\x07\xDC\xCC\x41\x6A"
           "\xAA\xBB\x0C\x5E\x3A\x61\x11\xA0\x90\xE0\xA9\x38\x86\x1C\x78\xE9"
           "\xAA\x75\xF2\x02\x38\x36\x19\x53\x4C\xE9\x21\x88\x43\x05\x8C\x7D"
           "\xDB\x60\x26\x36\x87\x24\xA7\xD5\x36\x39\x14\xD1\xEF\x66\x78\x1C"
           "\xBE\xD1\x56\xF9\x70\x77\xF7\xE0\xF1\x1B\x9D\x8D\x9C\xB6\x26\x5A"
           "\xE6\x3A\xC8\x18\x9F\x48\x03\x3D\x85\x06\x21\x71\xB2\x2C\x70\x98"
           "\x40\xA5\x39\xA0\xBD\x8D\xDB\x02\x01\x03"
           , 154);
    nPKLen = 154;
    memset(bInData, 0x42, 144);
    bInData[0] = 0x30;
    bInData[143] = 0x39;
    nInDataLen = 144;
    memcpy(bOutDataExp,
           "\x91\x47\x46\x39\xF0\x23\xEE\x94\x89\x82\x1C\x8E\x56\x6F\x56\x85"
           "\x5D\xA4\xA3\xD8\xE8\x68\xF4\xDC\x0F\xA7\x12\x39\xE4\xBB\x28\xBE"
           "\xD8\x3F\x69\xCB\xC7\xCE\x02\x43\x7C\x4D\x5E\x91\x19\xD1\x64\xF8"
           "\x20\x00\x68\x75\x5F\xC2\x77\x53\x1A\x7E\x3E\x95\x93\x3E\xC5\xC8"
           "\x8F\xB4\x1C\x38\x6C\x3B\xDD\x21\x35\x93\xEF\xDA\xDC\x1C\xF9\xD4"
           "\x4F\x7D\x16\x01\xE2\xAB\x4C\xB1\x08\x81\xCA\x90\x6A\x16\x21\x15"
           "\x2C\xB6\x5F\x1F\x56\x0A\xA3\xA4\x63\x4F\x66\x5A\x90\x88\xE4\xBB"
           "\xE7\x97\x34\xB5\xAA\x2D\x46\x6D\x86\x74\x64\x99\x82\xA1\xAC\xFD"
           "\xC5\xE8\x60\x09\x16\x18\x30\xD4\x82\x15\x87\xE9\xC4\x86\xB5\xD9"
           , 144);
    nOutDataLenExp = 144;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 154);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bInData =", bInData, 144);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1152，无填充，加密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 144);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 144);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 144);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    nOutDataLen = 0;
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 0;
    memcpy(bPK,
           "\x30\x81\xB7\x02\x81\xB1\x00\x9C\xDB\xEA\x10\x4A\xEE\x30\xD8\x58"
           "\xE1\xC7\x10\x81\xC8\x32\x40\x80\x1C\x94\x1E\xF6\xE9\x05\xC8\x0E"
           "\x41\x94\xE8\x88\x59\x72\xA8\x21\x22\x0C\x7B\x5F\x52\x8D\x65\xF0"
           "\xDD\x09\x56\x01\x71\xB6\x43\x64\x9A\x6E\x1F\xE3\x85\x7D\x2A\x27"
           "\xF7\x5A\xA3\xDB\x73\xA2\x99\xD6\x85\xAF\x86\x91\x7F\x19\xF5\x65"
           "\x7C\xA9\x71\xC1\x72\x38\x03\x8B\xDD\x83\x62\x79\x60\xB2\xB3\xE2"
           "\x7E\x41\x0D\x36\x50\x7C\xFA\xB0\x6E\xAE\x9E\x05\x5A\x55\xF8\x9C"
           "\x69\x71\x90\x77\x4C\xA3\x95\x29\x7D\xC1\x79\xFE\x7C\xD7\x96\x84"
           "\x0D\xC6\x30\x3F\x14\xDA\x88\xCF\x4A\xED\x5A\x7A\x71\x91\x5D\x25"
           "\x93\xDA\x0C\xB6\xCC\xB6\xD8\xE7\xF0\x54\x55\xA3\x93\xBD\xC0\xE7"
           "\x3E\xF8\x26\xFC\x5B\x37\xA5\x91\x01\x4B\xA2\x58\xBB\x59\xC2\x1E"
           "\xC8\x32\x3B\x85\x16\x8E\xF3\x02\x01\x03"
           , 186);
    nPKLen = 186;
    memset(bInData, 0x42, 176);
    bInData[0] = 0x30;
    bInData[175] = 0x39;
    nInDataLen = 176;
    memcpy(bOutDataExp,
           "\x45\xE6\x5A\x5E\xCC\xF1\x27\x02\xA9\x63\x2E\x6B\x07\xF9\xB4\x8E"
           "\xA6\x54\x64\x1B\x55\x21\x99\x90\xEA\xA0\x58\x9A\x15\x1F\x41\x51"
           "\x6C\xEE\x05\x20\x92\x9B\x24\xA6\x67\xBD\x58\x53\x85\x05\x99\x5D"
           "\xD2\x37\x16\x00\x2F\x1E\x71\x40\x9E\xC2\x8A\x2F\xED\x80\x30\x6E"
           "\x1E\x3E\x65\xE1\x58\x19\xA3\xF8\x7D\x66\x2C\x4B\x6A\xB2\x36\xE2"
           "\x3E\x39\xB7\x6D\x81\x89\x9E\x9C\x00\xD5\x57\xFE\x23\xF4\x29\x9D"
           "\xE4\x26\x12\x5C\x35\xBD\x58\x0A\x00\x17\x30\x4F\x86\xEE\x28\xC0"
           "\x22\xDE\x1D\xE1\x59\xCD\xD9\x24\xED\x30\xC8\xCC\x0F\x5E\x3F\x45"
           "\x7A\xD4\xCA\xDF\x85\x8C\x4C\x66\xEE\x89\x41\x48\xAE\x08\x7B\xBA"
           "\xCA\xD0\xA2\x02\x81\xB6\x91\x1F\xD5\xE7\xA1\x6A\xCB\x59\x33\x13"
           "\x0F\x4D\x2D\xC0\xBF\x87\xFF\x5E\xDF\x4E\xB2\x1C\x6F\x48\xD5\xF8"
           , 176);
    nOutDataLenExp = 176;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 186);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bInData =", bInData, 176);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1408，无填充，加密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 176);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 176);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 176);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 0;
    memcpy(bPK,
           "\x30\x81\xFF\x02\x81\xF9\x00\xBE\xF9\x74\x44\x9A\xC3\x01\x48\x0B"
           "\x0A\xCD\xE1\xE5\x52\xE7\x55\x60\x91\x64\x8A\x46\x34\xEA\x1D\xDA"
           "\xEE\x52\x7B\x13\x92\x5F\x27\xAE\xA2\x66\xB5\xA5\xBB\x79\x4B\x09"
           "\x81\x7E\x7D\x95\x29\x16\xC5\xEF\xE0\x42\xF7\x7D\x5E\xE1\x72\x88"
           "\x0C\x1F\xDC\x76\x48\xA5\xB0\x26\x41\x8D\x4F\x70\x41\xB2\xAA\x70"
           "\x84\xC0\xAB\xFA\x95\xE9\x07\x6F\x73\x89\xE9\xD5\xAC\xD3\xBF\x72"
           "\x31\xA3\x30\x1E\xCA\x13\xDB\x1F\x1F\x44\xD1\x08\xD2\xFB\xF2\xB1"
           "\x6C\xF4\xBA\xAB\xF3\xBA\x36\x18\x25\x39\xD6\x0E\x3B\x4E\xBA\x93"
           "\xB2\xB4\xFA\x40\x7D\xCA\xE3\x96\x64\x05\x24\x79\x57\x95\xC6\x9D"
           "\xC7\x48\xB7\xFF\x55\x42\x07\x8A\x48\x84\x99\x61\x29\x52\x73\x0D"
           "\x8A\x97\x42\x6E\x67\x7C\x0A\xB3\x8B\xA9\x7C\x9C\x21\x67\x27\xD8"
           "\xB9\xDD\x14\x2C\x10\x65\xB8\x6F\x78\xBB\x64\x8A\x24\xAA\x78\x45"
           "\x7A\xB3\x54\xE6\xDF\x62\xE8\x71\xE3\x3C\x0C\x74\xD1\xFF\x02\x93"
           "\xDC\xB0\x01\x26\xEC\xAE\xCD\x4A\x3D\x22\xF7\x74\x42\xA6\xA0\xF2"
           "\xA1\x22\x72\x1E\x9C\x0F\x8C\xAF\xA2\x51\x2A\x23\xFF\x22\x49\xDD"
           "\x6C\x20\x4A\xEE\x7A\xCE\x81\xFB\xD1\x94\xAA\xF6\x5B\xC0\xDB\x02"
           "\x01\x03"
           , 258);
    nPKLen = 258;
    memset(bInData, 0x42, 248);
    bInData[0] = 0x30;
    bInData[247] = 0x39;
    nInDataLen = 248;
    memcpy(bOutDataExp,
           "\xAC\xDA\x06\x75\x3E\x48\x32\x18\x60\x3D\x06\xBD\x1A\x06\xD3\xD4"
           "\x44\xDB\x40\x7A\x89\x53\x33\x52\x41\xBC\xE3\x88\xA0\x3A\xB5\x73"
           "\x73\x05\x21\x32\xE6\x61\xCF\x40\xAB\x4D\x18\x16\x4C\x47\x26\x8D"
           "\x07\xC4\xD6\x0E\x74\xE2\xCA\x0A\x98\xA4\x74\x95\x48\x66\x25\x1B"
           "\xB9\xD8\xDD\x10\x03\x44\xE4\x5A\xA3\xC7\xE4\x2B\x6C\x0C\x8C\x5F"
           "\x6D\x49\x00\x89\x2F\xBF\x34\x66\x14\x28\x77\x72\x43\x15\xEC\x14"
           "\xEE\x57\xC5\x04\xD7\x17\x81\xEC\xAC\x5C\xAC\x6D\x85\x3E\xF7\x90"
           "\xA6\x75\xE3\x6A\xFD\x41\xB4\x58\xBF\x3A\xBF\x58\xB0\xA6\x7A\x7E"
           "\xCE\x92\x9C\xCC\x3D\xEC\xFB\x21\xF1\xE2\xCC\x2F\x3A\xE4\xB9\x97"
           "\x67\xE9\x39\xA1\xF2\xE5\xA1\x86\x83\x01\x6A\x23\xCA\x0A\xDF\xBC"
           "\x75\x4F\x0C\x4E\xD4\x3D\xA9\xCC\x37\x5B\x9D\x49\x6F\x6D\xB3\x71"
           "\x0C\x18\x18\x5C\xE6\x77\x54\xCA\xD7\x1C\x67\xAF\xA7\xAA\x57\x24"
           "\xA0\x94\xC0\x5F\x19\xC5\x65\x9A\xB4\x22\x22\xBB\x8B\x66\xCE\xFF"
           "\x31\xDA\xF4\xDF\x22\xA6\x13\xC0\xF6\xD9\x4F\x57\x41\x7F\xF6\x5C"
           "\x19\xC7\xAA\xF8\x38\x8E\x8C\x9E\x51\x7A\xC3\x97\x6D\x97\x06\x62"
           "\x80\x50\x23\x32\xCF\x50\x2B\x27"
           , 248);
    nOutDataLenExp = 248;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 258);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bInData =", bInData, 248);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1984，无填充，加密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 248);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 248);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 248);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 0;
    memcpy(bPK,
           "\x30\x82\x01\x08\x02\x82\x01\x01\x00\xC9\xD5\xA7\x6F\x4E\x62\xAD"
           "\x7A\xD8\x19\x85\x19\xB4\xDC\xE8\x88\xBB\x00\x10\xFF\x54\xA8\xC9"
           "\x61\xB5\x44\x2E\x53\x7D\xA4\x98\x7F\x27\xD6\x8A\x3E\x64\x92\x73"
           "\x59\x49\xFA\x81\x61\x8E\xD6\x66\x3C\x7E\xC0\xB3\x5D\x4E\xBB\x11"
           "\x01\x5B\xEE\x25\x53\x92\x33\x75\xA0\x3F\xBD\x02\xAB\x69\xE8\x0E"
           "\xF8\xC1\x98\x76\xDA\x81\x32\x66\x16\xEF\x7A\x0D\x6E\x4D\xB1\x74"
           "\xC8\xE8\x93\xE8\x1F\x00\x29\x7F\x46\x3C\x7C\x37\x0C\x7B\xF0\x78"
           "\xBA\x7D\x5D\xF9\x88\x9A\x86\x1E\xB8\x13\x59\xAA\x55\x1E\x5C\xBD"
           "\x2B\x7C\x36\xD8\xE5\x49\x83\xB5\xCB\x14\x4B\x1F\xEA\x02\x93\x07"
           "\xF0\x40\x24\xCD\x51\x96\x71\x22\xF0\x4A\x68\x2C\xCD\xDE\xF5\x0F"
           "\xFC\x34\x4A\x64\xA3\x52\xA1\xBE\xEE\x2C\xE7\x5C\x1A\x95\x8E\xFC"
           "\xA4\xAB\x65\xEB\x96\xBE\x43\x0F\xBD\x78\xFE\x6A\xDF\x48\xB9\x68"
           "\x66\x69\x6C\x68\xCC\xA4\x35\xD3\x2B\xA4\x2C\xDD\xBD\xC3\x65\x7B"
           "\x5C\xD9\x56\x67\xB9\x2E\x40\xFE\xEF\x02\xEF\xBD\x91\xFC\x88\x61"
           "\xCA\x82\x3D\xCA\x59\x1F\xD7\x8E\xAC\xCF\x2E\xD5\xB2\x95\xB8\x73"
           "\x20\xC4\x0A\xD0\xA5\x87\xE4\xD0\x8F\x77\x1B\xDC\x05\xE1\x7A\x54"
           "\x7D\xB8\xA6\x8E\x1B\xA9\xF0\xF4\xED\x02\x01\x03"
           , 268);
    nPKLen = 268;
    memset(bInData, 0x42, 256);
    bInData[0] = 0x30;
    bInData[255] = 0x39;
    nInDataLen = 256;
    memcpy(bOutDataExp,
           "\xB2\xC8\xAC\xF5\xBD\x59\xF7\x13\x0D\xEA\xBB\xE9\x2A\xEA\x28\xF2"
           "\x1A\x72\xC7\x20\x92\xB7\xB8\xB7\xA4\xF5\x26\x8F\x2B\x9F\x6B\x37"
           "\x88\x4C\x7E\xE5\xAF\x87\x63\x41\x34\xB5\x4D\x15\xA6\x66\xAB\x62"
           "\xD3\xB3\x0E\x7A\x4D\x5E\x82\x76\x5E\x83\x22\x68\x13\x07\x0C\xB1"
           "\x8B\x03\x40\x44\xAA\x53\x25\x17\x26\xE1\xCB\x24\x31\xD7\xEC\x83"
           "\x85\x89\x9A\x8E\x13\xAB\xED\xF5\x5C\xF0\x6B\xD4\x79\x70\x13\xAD"
           "\xF2\x01\x0B\xD5\xA3\xD9\x57\x06\x0B\x76\x46\xF3\x4C\xBB\x2D\x2A"
           "\xEF\x6F\x1F\xBD\xA8\xDE\xD1\xEF\xF2\x1F\x61\xD5\xBD\x6E\xE0\x40"
           "\xB3\x2A\x7F\xED\x1D\xF9\x19\x1D\xC8\x16\xB4\x82\xB1\xC8\x4B\xD0"
           "\x91\x53\x8D\x99\xDB\x74\xDC\xB4\x04\x78\x0D\x19\xF5\x1A\xCD\x13"
           "\x2E\x63\x00\x81\x9F\x79\x4D\xD6\x3C\x7A\x36\x4F\x4A\xA9\x08\xDB"
           "\xE9\x6E\x23\xB6\xC1\xA9\x41\x39\xB1\x36\x45\x42\xBC\x38\x5C\xB6"
           "\x11\x22\x3A\x38\x45\x63\x8F\x2D\x9F\x36\x03\x2A\xCC\xB0\x1E\x55"
           "\xBC\x74\x4B\xA0\xEE\x05\x68\x25\x1A\x29\x77\x12\x84\x1A\x32\x71"
           "\xB2\xA8\x91\x82\xEB\x0F\x73\xB5\xA7\x53\x0A\x3F\x3E\x9A\xFA\xFA"
           "\xC4\xB6\x13\x58\x95\x75\x5F\x51\x9F\xA9\x89\x23\xA5\x19\x0F\xB0"
           , 256);
    nOutDataLenExp = 256;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 268);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bInData =", bInData, 256);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-2048，无填充，加密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 256);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 256);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 256);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_07(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 0;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    memcpy(bInData,
           "\x6B\x4B\x53\xB4\x68\xCA\x92\x3D\x8D\x4C\xC1\xDC\x50\x7C\x52\x3A"
           "\x5C\x28\x63\xBB\xA7\x37\x1A\x04\x8B\x73\xC5\x14\x5F\xB0\x1C\xFC"
           "\x3C\xB9\xD0\x83\x79\x8C\xC1\x3F\xA8\xD4\xD5\xD5\x03\x29\x7E\x87"
           "\x0F\xA2\xC5\x05\xA5\xEE\x41\x01\xFE\xFB\x77\x9E\x15\x1F\xE6\x23"
           , 64);
    nInDataLen = 64;
    memset(bOutDataExp, 0x42, 64);
    bOutDataExp[0] = 0x30;
    bOutDataExp[63] = 0x39;
    nOutDataLenExp = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 72);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bInData =", bInData, 64);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-512，无填充，解密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 64);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 64);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 64);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_08(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 0;
    memcpy(bPK,
           "\x30\x81\x87\x02\x81\x81\x00\xA6\xF5\x8A\x17\x12\x3F\x46\x59\x92"
           "\xC0\x92\x01\x7E\xD3\xA9\x67\x2A\x6A\x42\x8E\xDA\x6A\xC2\x53\x91"
           "\x83\x77\x1E\x25\xA2\xA8\x74\x9B\xF3\x49\xF6\x6C\x5B\xA7\xDA\xC6"
           "\x18\x4B\x49\x42\x80\x20\x7F\xD9\xBB\x29\xC0\xF0\xD8\x81\xDC\x0A"
           "\x95\x53\x80\xF5\xA7\x52\x7E\x1E\x1E\x16\xB9\x5B\x79\xEE\x1F\x33"
           "\x50\x3A\xCC\x4E\xA1\x01\xC4\x55\xA8\x3B\xCB\x2B\xC8\xEB\xC5\x27"
           "\x5C\x21\xE3\x5B\xA1\x33\x60\xC6\x82\x76\xDD\x7C\x5F\xF0\x03\x24"
           "\xA7\x8E\x9B\x50\x8C\x46\xD5\xEB\xF5\x37\x81\x9B\xCD\x38\x01\x10"
           "\x1F\x9F\x0F\xBD\x78\x37\xC7\x02\x01\x03"
           , 138);
    nPKLen = 138;
    memcpy(bInData,
           "\x49\xF1\x26\x3D\x02\xD3\x72\x5C\x05\xD8\x02\xBB\x5D\x28\x69\xD1"
           "\x8A\xAC\xF9\x9A\xBF\x7B\x58\xF3\xB3\xED\xBF\xBF\x2F\xF2\xA1\x6F"
           "\xF2\x19\x08\x99\xEE\x1C\x84\xB6\x09\xB3\x6E\xA8\x40\xE6\xC1\x0D"
           "\xBE\xF1\x86\xB7\xFF\xA3\x60\xB8\x73\x57\xCF\xC1\x5E\xB4\x5D\xA7"
           "\xA8\x77\x40\x52\x43\x65\xB0\x7E\x03\xDB\x26\x82\x58\x1A\xEC\x77"
           "\xF2\x8E\x08\xAA\xF8\x30\x9C\x39\x37\x40\xC0\xFE\xD9\x72\xAA\x73"
           "\x43\x6D\x57\xF2\x93\x40\x4E\xDF\xE5\x0C\xFD\x4C\x9A\x09\x73\x8A"
           "\x55\x33\xD1\xA2\x50\xE3\xBD\xB7\x59\x1F\xBE\xAA\x44\xFF\xB6\xC2"
           , 128);
    nInDataLen = 128;
    memset(bOutDataExp, 0x42, 128);
    bOutDataExp[0] = 0x30;
    bOutDataExp[127] = 0x39;
    nOutDataLenExp = 128;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 138);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bInData =", bInData, 128);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1024，无填充，解密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 128);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 128);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 128);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_09(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 0;
    memcpy(bPK,
           "\x30\x81\x97\x02\x81\x91\x00\xB4\xD4\xCD\x27\x2B\x0C\x7A\xBA\xA9"
           "\x32\x54\xA6\x0A\xD3\xDD\xAE\x80\x31\x47\x07\xC8\x48\x4F\x76\x03"
           "\x7C\x24\x4A\x59\x54\x0E\x99\x25\xD1\x3C\xB6\xE0\x20\xDB\xCB\x20"
           "\xB5\x23\x8F\x55\xDE\xF4\x31\xCD\x51\xE2\x1B\x07\xDC\xCC\x41\x6A"
           "\xAA\xBB\x0C\x5E\x3A\x61\x11\xA0\x90\xE0\xA9\x38\x86\x1C\x78\xE9"
           "\xAA\x75\xF2\x02\x38\x36\x19\x53\x4C\xE9\x21\x88\x43\x05\x8C\x7D"
           "\xDB\x60\x26\x36\x87\x24\xA7\xD5\x36\x39\x14\xD1\xEF\x66\x78\x1C"
           "\xBE\xD1\x56\xF9\x70\x77\xF7\xE0\xF1\x1B\x9D\x8D\x9C\xB6\x26\x5A"
           "\xE6\x3A\xC8\x18\x9F\x48\x03\x3D\x85\x06\x21\x71\xB2\x2C\x70\x98"
           "\x40\xA5\x39\xA0\xBD\x8D\xDB\x02\x01\x03"
           , 154);
    nPKLen = 154;
    memcpy(bInData,
           "\xB0\xA9\x44\xA4\x66\x2A\x0C\x24\x8E\x7A\x5F\xF9\x0E\xE1\x47\x6B"
           "\x47\x06\xAB\x46\x19\x35\xFB\x46\x8E\xFD\x8F\x2C\xC0\xF7\x67\x8A"
           "\x2A\x96\x3B\x64\x9F\xE8\xFF\x03\x8D\x56\x80\x5B\x2A\xAB\xB2\x41"
           "\x0F\xC0\xB5\xD9\x1C\x46\xBE\x25\xFD\xD9\x1A\xF9\xAA\x37\x91\xCC"
           "\xD6\x37\x84\xF3\x53\x03\xFB\xDB\x33\xB7\x25\x22\xB6\x74\x8A\xAC"
           "\xD6\x7F\xB7\x36\xD2\xE9\x07\xFF\x45\x88\xE2\xEE\x82\x36\x75\xDA"
           "\xC3\xC1\xE6\x63\xF4\xAD\x63\x6D\x5C\x52\x2E\x18\xC5\xE4\xDA\x2D"
           "\x39\xC2\x41\x59\x5B\x06\xED\x86\xBA\x1A\xFC\x09\xEA\x8D\x26\x0E"
           "\x5B\x74\xBA\x40\x8D\x0F\xDE\xF7\x44\x30\x04\xC6\xD2\x79\x92\xD1"
           , 144);
    nInDataLen = 144;
    memset(bOutDataExp, 0x42, 144);
    bOutDataExp[0] = 0x30;
    bOutDataExp[143] = 0x39;
    nOutDataLenExp = 144;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 154);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bInData =", bInData, 144);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1152，无填充，解密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 144);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 144);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 144);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_10(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 0;
    memcpy(bPK,
           "\x30\x81\xB7\x02\x81\xB1\x00\x9C\xDB\xEA\x10\x4A\xEE\x30\xD8\x58"
           "\xE1\xC7\x10\x81\xC8\x32\x40\x80\x1C\x94\x1E\xF6\xE9\x05\xC8\x0E"
           "\x41\x94\xE8\x88\x59\x72\xA8\x21\x22\x0C\x7B\x5F\x52\x8D\x65\xF0"
           "\xDD\x09\x56\x01\x71\xB6\x43\x64\x9A\x6E\x1F\xE3\x85\x7D\x2A\x27"
           "\xF7\x5A\xA3\xDB\x73\xA2\x99\xD6\x85\xAF\x86\x91\x7F\x19\xF5\x65"
           "\x7C\xA9\x71\xC1\x72\x38\x03\x8B\xDD\x83\x62\x79\x60\xB2\xB3\xE2"
           "\x7E\x41\x0D\x36\x50\x7C\xFA\xB0\x6E\xAE\x9E\x05\x5A\x55\xF8\x9C"
           "\x69\x71\x90\x77\x4C\xA3\x95\x29\x7D\xC1\x79\xFE\x7C\xD7\x96\x84"
           "\x0D\xC6\x30\x3F\x14\xDA\x88\xCF\x4A\xED\x5A\x7A\x71\x91\x5D\x25"
           "\x93\xDA\x0C\xB6\xCC\xB6\xD8\xE7\xF0\x54\x55\xA3\x93\xBD\xC0\xE7"
           "\x3E\xF8\x26\xFC\x5B\x37\xA5\x91\x01\x4B\xA2\x58\xBB\x59\xC2\x1E"
           "\xC8\x32\x3B\x85\x16\x8E\xF3\x02\x01\x03"
           , 186);
    nPKLen = 186;
    memcpy(bInData,
           "\x70\xDB\xFE\xCC\x0E\xBC\x43\x62\x17\xA5\x29\x65\xE3\x3F\xB7\x04"
           "\x39\x4D\xD8\x69\x8F\x51\x59\xC8\x26\x9A\x62\x46\xCC\xC5\x81\x35"
           "\x3A\x86\x95\x2C\x4C\xCB\x35\x54\x6E\x6C\xF6\x09\x00\x5F\xF3\x80"
           "\x57\xF9\x71\x71\x1A\xC0\xE9\x79\x89\x7C\xEB\x2D\x0D\x84\x33\x24"
           "\x9D\x04\x70\x4A\x78\xB7\xAC\x91\x7D\xE7\x3E\x7B\x34\xB8\x2C\x4C"
           "\x36\x4D\xF7\x0E\xAE\xAC\xC8\x52\x31\xE1\x81\x53\x39\xFE\x43\x7F"
           "\x91\x51\x8B\x5E\x3A\x3F\xFC\x0F\xB8\x30\x94\xE4\xBC\x19\x3B\xA3"
           "\x40\x2C\xAD\x4A\x59\xD5\x69\x99\x42\xFA\x59\x27\xDF\xE0\x15\xF7"
           "\xA5\x1E\xB4\xC1\xB9\xD9\xA9\xB6\x0B\xC2\x79\x0A\x2F\x41\x56\x7D"
           "\x69\x1B\x67\x05\x1E\xE1\x50\xF2\xAD\x47\x90\x51\xA3\x81\xF9\x09"
           "\x9C\xCE\x76\x11\x9B\xD4\x0C\x9A\x78\xEC\x31\x67\xBB\xA9\x26\xC5"
           , 176);
    nInDataLen = 176;
    memset(bOutDataExp, 0x42, 176);
    bOutDataExp[0] = 0x30;
    bOutDataExp[175] = 0x39;
    nOutDataLenExp = 176;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 186);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bInData =", bInData, 176);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1408，无填充，解密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 176);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 176);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 176);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_11(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 0;
    memcpy(bPK,
           "\x30\x81\xFF\x02\x81\xF9\x00\xBE\xF9\x74\x44\x9A\xC3\x01\x48\x0B"
           "\x0A\xCD\xE1\xE5\x52\xE7\x55\x60\x91\x64\x8A\x46\x34\xEA\x1D\xDA"
           "\xEE\x52\x7B\x13\x92\x5F\x27\xAE\xA2\x66\xB5\xA5\xBB\x79\x4B\x09"
           "\x81\x7E\x7D\x95\x29\x16\xC5\xEF\xE0\x42\xF7\x7D\x5E\xE1\x72\x88"
           "\x0C\x1F\xDC\x76\x48\xA5\xB0\x26\x41\x8D\x4F\x70\x41\xB2\xAA\x70"
           "\x84\xC0\xAB\xFA\x95\xE9\x07\x6F\x73\x89\xE9\xD5\xAC\xD3\xBF\x72"
           "\x31\xA3\x30\x1E\xCA\x13\xDB\x1F\x1F\x44\xD1\x08\xD2\xFB\xF2\xB1"
           "\x6C\xF4\xBA\xAB\xF3\xBA\x36\x18\x25\x39\xD6\x0E\x3B\x4E\xBA\x93"
           "\xB2\xB4\xFA\x40\x7D\xCA\xE3\x96\x64\x05\x24\x79\x57\x95\xC6\x9D"
           "\xC7\x48\xB7\xFF\x55\x42\x07\x8A\x48\x84\x99\x61\x29\x52\x73\x0D"
           "\x8A\x97\x42\x6E\x67\x7C\x0A\xB3\x8B\xA9\x7C\x9C\x21\x67\x27\xD8"
           "\xB9\xDD\x14\x2C\x10\x65\xB8\x6F\x78\xBB\x64\x8A\x24\xAA\x78\x45"
           "\x7A\xB3\x54\xE6\xDF\x62\xE8\x71\xE3\x3C\x0C\x74\xD1\xFF\x02\x93"
           "\xDC\xB0\x01\x26\xEC\xAE\xCD\x4A\x3D\x22\xF7\x74\x42\xA6\xA0\xF2"
           "\xA1\x22\x72\x1E\x9C\x0F\x8C\xAF\xA2\x51\x2A\x23\xFF\x22\x49\xDD"
           "\x6C\x20\x4A\xEE\x7A\xCE\x81\xFB\xD1\x94\xAA\xF6\x5B\xC0\xDB\x02"
           "\x01\x03"
           , 258);
    nPKLen = 258;
    memcpy(bInData,
           "\x80\x53\x6B\xC0\x3E\x28\x0B\x6A\x05\x1E\x61\x1B\x16\xB6\x0E\xB1"
           "\x76\x55\x38\x95\x7E\xDA\x4E\xC5\x18\xE9\xC1\xBC\x34\xAE\xCC\xA5"
           "\x1E\x26\x4B\xC3\xEA\xA6\x5E\xC6\x3E\x77\x4C\x7E\x26\x60\x06\x2E"
           "\x8E\xDD\xF7\xC9\xC1\x5D\xF2\x7A\xD2\x9B\x1A\x47\x0F\x4B\x9B\xC6"
           "\x3A\xD5\x18\x33\x39\x0D\xBB\xFB\x85\xF0\x4F\x35\x86\x45\x0E\x09"
           "\xDE\xC8\xDC\xF8\xB3\x3D\x62\x13\x77\xC5\x14\x15\xB1\xA3\xC5\xC1"
           "\x81\x8B\xCC\xC6\xAA\x43\xA1\x60\x05\x46\x4A\x97\x16\xF3\xEC\xA9"
           "\xD2\x82\xA0\x01\xCF\x05\xB9\x13\x6A\xA3\x18\xD1\x30\xE0\x75\xEF"
           "\x43\x81\x76\xF6\x38\x2D\xAC\x56\xE6\x15\x1F\x68\xB7\xFE\x18\xC8"
           "\xA4\x6D\x98\x17\x76\x12\xAA\x1C\x4B\x3C\x34\x03\x2E\xC8\xC0\xCC"
           "\x04\x34\x33\x3A\xCD\x77\xAB\x62\x3F\x14\x1B\x1F\xA3\xF8\x43\x00"
           "\x53\x96\xBC\xEB\x03\xEC\x51\xA7\xEC\x67\x8A\xC5\x72\x06\x1A\x0B"
           "\x87\x98\xDA\xAF\xE5\x5A\x7F\x79\xA9\x28\x67\x6B\xBF\x09\x76\x52"
           "\xD8\xE2\xC9\x09\x64\xD1\x5B\xEA\xEF\x7E\xD0\x5F\x20\x6F\x88\x4C"
           "\xDB\x27\x16\x1B\xEA\x19\xF7\x07\x18\xDF\xD6\x75\x59\x08\x80\x89"
           "\x48\x2E\x50\x39\xDF\x53\x6F\x36"
           , 248);
    nInDataLen = 248;
    memset(bOutDataExp, 0x42, 248);
    bOutDataExp[0] = 0x30;
    bOutDataExp[247] = 0x39;
    nOutDataLenExp = 248;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 258);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bInData =", bInData, 248);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1984，无填充，解密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 248);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 248);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 248);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_12(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 0;
    memcpy(bPK,
           "\x30\x82\x01\x08\x02\x82\x01\x01\x00\xC9\xD5\xA7\x6F\x4E\x62\xAD"
           "\x7A\xD8\x19\x85\x19\xB4\xDC\xE8\x88\xBB\x00\x10\xFF\x54\xA8\xC9"
           "\x61\xB5\x44\x2E\x53\x7D\xA4\x98\x7F\x27\xD6\x8A\x3E\x64\x92\x73"
           "\x59\x49\xFA\x81\x61\x8E\xD6\x66\x3C\x7E\xC0\xB3\x5D\x4E\xBB\x11"
           "\x01\x5B\xEE\x25\x53\x92\x33\x75\xA0\x3F\xBD\x02\xAB\x69\xE8\x0E"
           "\xF8\xC1\x98\x76\xDA\x81\x32\x66\x16\xEF\x7A\x0D\x6E\x4D\xB1\x74"
           "\xC8\xE8\x93\xE8\x1F\x00\x29\x7F\x46\x3C\x7C\x37\x0C\x7B\xF0\x78"
           "\xBA\x7D\x5D\xF9\x88\x9A\x86\x1E\xB8\x13\x59\xAA\x55\x1E\x5C\xBD"
           "\x2B\x7C\x36\xD8\xE5\x49\x83\xB5\xCB\x14\x4B\x1F\xEA\x02\x93\x07"
           "\xF0\x40\x24\xCD\x51\x96\x71\x22\xF0\x4A\x68\x2C\xCD\xDE\xF5\x0F"
           "\xFC\x34\x4A\x64\xA3\x52\xA1\xBE\xEE\x2C\xE7\x5C\x1A\x95\x8E\xFC"
           "\xA4\xAB\x65\xEB\x96\xBE\x43\x0F\xBD\x78\xFE\x6A\xDF\x48\xB9\x68"
           "\x66\x69\x6C\x68\xCC\xA4\x35\xD3\x2B\xA4\x2C\xDD\xBD\xC3\x65\x7B"
           "\x5C\xD9\x56\x67\xB9\x2E\x40\xFE\xEF\x02\xEF\xBD\x91\xFC\x88\x61"
           "\xCA\x82\x3D\xCA\x59\x1F\xD7\x8E\xAC\xCF\x2E\xD5\xB2\x95\xB8\x73"
           "\x20\xC4\x0A\xD0\xA5\x87\xE4\xD0\x8F\x77\x1B\xDC\x05\xE1\x7A\x54"
           "\x7D\xB8\xA6\x8E\x1B\xA9\xF0\xF4\xED\x02\x01\x03"
           , 268);
    nPKLen = 268;
    memcpy(bInData,
           "\x0F\x7C\xAA\xF9\x55\xEB\xBD\x31\xF6\xC2\xA1\xAF\x97\x0F\x9A\xC0"
           "\x4B\x6B\xA3\x65\x77\x59\x63\x95\xA6\x12\x15\xE8\xC4\x8A\xBB\xB9"
           "\x2C\x52\x61\x73\xBA\x17\xFE\x7A\x50\x00\xE9\x37\x66\x55\x15\xE4"
           "\x5F\x3C\x81\x22\x78\xCB\x3D\xF1\x96\x74\x89\x19\x5D\x65\xF3\x5E"
           "\xC5\x49\xC8\x19\xBC\x1A\x3C\xD5\x4D\x4F\xDD\xDD\xB9\x18\x51\x9E"
           "\x85\x3E\x6F\xD2\x4E\xB2\x67\x15\x00\x5A\x44\x8E\xB5\x83\xD6\x04"
           "\x95\xF1\xC5\x13\xA3\xDD\x1F\xC1\x37\x5D\xC1\x15\x64\xD1\x6E\x13"
           "\x44\x0A\xFD\xC2\xF2\xAA\x2B\x62\x63\x39\x88\x24\xB5\xAB\x85\x6F"
           "\x91\x13\x94\xF9\xDA\x7C\x93\xC1\x95\xB1\x39\x34\xE8\x50\x64\x6D"
           "\xC8\x28\x63\xE2\x01\x51\x86\x79\xF0\x67\x46\x0C\x33\x38\x12\xF0"
           "\xA3\xB6\xA9\xA8\x23\x5B\x1C\x13\x3C\xA1\x01\x39\x5F\x80\x93\x67"
           "\x6C\x01\x21\xFB\xB0\x20\x13\x37\x69\x05\x9F\x7A\x76\xD5\xF3\x09"
           "\x91\x12\x78\x47\x4D\x8E\xE0\x8B\x39\x86\x2B\xD7\xEB\x45\xAC\xA1"
           "\xBB\x96\xD6\x73\xBD\x39\x1F\x81\x82\x91\x34\x4F\x17\xA8\xAC\x01"
           "\x2B\x75\x02\xAB\xFE\x7A\x0F\xBB\x75\x66\x25\x95\x2C\x3B\x90\x94"
           "\x1B\xF4\xFF\xCE\x9D\xE1\x69\xB1\xA2\xDC\xF0\x22\xED\xE4\xEC\x64"
           , 256);
    nInDataLen = 256;
    memset(bOutDataExp, 0x42, 256);
    bOutDataExp[0] = 0x30;
    bOutDataExp[255] = 0x39;
    nOutDataLenExp = 256;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 268);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bInData =", bInData, 256);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-2048，无填充，解密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 256);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 256);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 256);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_13(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

/* SK = 3082013B020100024100D2951E7328AF7A32F606610A0E5B2BE9031F0BDAE65595AD6FC7F6529418DE5AAF54E4758354081D09CE3F41C52EDB2DE2098B8219F1ED1B9E52DE2CEBFB3FB30201030241008C6369A21B1FA6CCA40440B15EE7729B576A07E744390E739FDAA4370D65E99093E77B9ABC66E82BC54E74A0919A598D5356914F772EC5522239C96C4EF9CAFB022100F8CA4EB4E54889179399A3559FDBEEF88F47F9CE5CABFF8AB7A15040EB5E52D5022100D8AF5C58837122C3CE3EECFB4AEB65E155BFB7BC8A7FC595B35ADFC98A263C67022100A5DC347898DB060FB7BBC239153D49FB0A2FFBDEE872AA5C7A6B8AD5F23EE1E30221009074E83B024B6C82897F48A787479940E3D525285C552E63CCE73FDBB16ED2EF0221009DB47ACDC43551F8C12D38E7CC2877B9C1760C71F0DB003E643B85B442F833B5 */

    nFlag = 1;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    memset(bInData, 0x42, 53);
    bInData[0] = 0x30;
    bInData[52] = 0x39;
    nInDataLen = 53;
    nOutDataLenExp = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 72);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHexExt("[IN ]bInData =", bInData, 53);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-512，PKCS#1填充，加密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bOutData    =", bOutData, 64);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_14(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

/* SK = 3082025C02010002818100A6F58A17123F465992C092017ED3A9672A6A428EDA6AC2539183771E25A2A8749BF349F66C5BA7DAC6184B494280207FD9BB29C0F0D881DC0A955380F5A7527E1E1E16B95B79EE1F33503ACC4EA101C455A83BCB2BC8EBC5275C21E35BA13360C68276DD7C5FF00324A78E9B508C46D5EBF537819BCD3801101F9F0FBD7837C70201030281806F4E5C0F617F843BB72B0C00FF37C644C6F181B4919C818D0BACFA1419171AF867F786A4483D1A91D96587862C556AFFE67CC680A0905692B1B8E255F91A36FDAAF67E1C1BB21FAB66E1C28A72252EC09803FDC7FA725837FFFDD974C2503543D9B0623BD4629B7338C7AED6038D7ED27C02793C90966F3A4B23AD92B4F1DFBB024100D52630080701099658F465F8916E6FF51FCDCA1C42E297E747D8FD88CF54558C695D6B2410FED8425B84A291BB74A64369AA3C5C0EE8349C5F4C277BCEFDA323024100C88629872AEDB507C009310411FACBAE51D47502F13ACF89DF865E2B68D48DEE969C785FACCD2E93F3F765C88FC36256C847454AB4035C8D401DF337DF0FC50D0241008E19755AAF5606643B4D995060F44AA36A8931682C970FEF853B53B08A383908463E476D60A9E58192586C6127A3198246717D92B49ACDBD94DD6FA7DF53C21702410085AEC65A1C9E78AFD55B7602B6A73274368DA3574B7C8A5BEA59941CF08DB3F46468503FC888C9B7F7FA43DB0A82418F302F838722ACE85E2ABEA2253F5FD8B302410084E4DACDBDAA7209075B4D7BA8213D660095FE435F97F5081E2983B55D11D3F1978A5D26145FB40AE63F5BC9F7DB7AE4005CE77F410827C4662D5058DA914419 */

    nFlag = 1;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\x87\x02\x81\x81\x00\xA6\xF5\x8A\x17\x12\x3F\x46\x59\x92"
           "\xC0\x92\x01\x7E\xD3\xA9\x67\x2A\x6A\x42\x8E\xDA\x6A\xC2\x53\x91"
           "\x83\x77\x1E\x25\xA2\xA8\x74\x9B\xF3\x49\xF6\x6C\x5B\xA7\xDA\xC6"
           "\x18\x4B\x49\x42\x80\x20\x7F\xD9\xBB\x29\xC0\xF0\xD8\x81\xDC\x0A"
           "\x95\x53\x80\xF5\xA7\x52\x7E\x1E\x1E\x16\xB9\x5B\x79\xEE\x1F\x33"
           "\x50\x3A\xCC\x4E\xA1\x01\xC4\x55\xA8\x3B\xCB\x2B\xC8\xEB\xC5\x27"
           "\x5C\x21\xE3\x5B\xA1\x33\x60\xC6\x82\x76\xDD\x7C\x5F\xF0\x03\x24"
           "\xA7\x8E\x9B\x50\x8C\x46\xD5\xEB\xF5\x37\x81\x9B\xCD\x38\x01\x10"
           "\x1F\x9F\x0F\xBD\x78\x37\xC7\x02\x01\x03"
           , 138);
    nPKLen = 138;
    memset(bInData, 0x42, 64);
    bInData[0] = 0x30;
    bInData[63] = 0x39;
    nInDataLen = 64;
    nOutDataLenExp = 128;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 138);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHexExt("[IN ]bInData =", bInData, 64);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1024，PKCS#1填充，加密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bOutData    =", bOutData, 128);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_15(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

/* SK = 308202A302010002819100B4D4CD272B0C7ABAA93254A60AD3DDAE80314707C8484F76037C244A59540E9925D13CB6E020DBCB20B5238F55DEF431CD51E21B07DCCC416AAABB0C5E3A6111A090E0A938861C78E9AA75F202383619534CE9218843058C7DDB6026368724A7D5363914D1EF66781CBED156F97077F7E0F11B9D8D9CB6265AE63AC8189F48033D85062171B22C709840A539A0BD8DDB020103028190788DDE1A1CB2FC7C70CC386EB1E293C9AACB84AFDADADFA40252C2DC3B8D5F10C3E0D324956B3D3215CE17B4E3E9F821338BEC12053DDD80F1C7275D9426EB6115B5EB1B7B0412FA278565A096C71252C59356BEE0E87DB91237AD01573650BD374EBFAA976898BDA2D75238285F26F560359CDDC107A6AAEA08E5A6C56C96F8417A01846D7CE3CCA95B7A2F1D9354CB024900DB0B988EE4CA3DF927EBA611645F5A8E4FCAF7DA4BC336E74C1D838C2A02707D2C87B02A1A2EDD028717F519C4E574717130942C54A663F14B61278278C57E32BACD7B0EA05FC6D3024900D356C4F23B435CA4030440F1D286EE6892BCE4C9E7F274A4B6229608C4D010DE7BF425D8A2B2E0854988BB37272BC7B48AA84E219BD6019D8FECDC5854B1588ADF69F2E45400C7D90249009207BB09EDDC2950C547C40B983F91B43531FA9187D779EF8813AD081C01A0537305201C1174935704BAA3668343A2F64B75B81D8DC442A0DCEB6FAC5083A9772733A75F15952F370249008CE4834C27823DC2ACAD80A137049EF061D34331454C4DC324170EB08335609452A2C3E5C1CC95AE3105D224C4C7DA785C70341667E40113B54892E58DCB905C94F14C983800853B0248465FAB1DD004115AD3346F0A0520CF4C68BA3C22434B580CBAD4BF33FA501925752BACDB5C0F23F874C4A6F0902FD763E9E02B7926E4923EE8894883DFE3A859A616871D62150A67 */

    nFlag = 1;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\x97\x02\x81\x91\x00\xB4\xD4\xCD\x27\x2B\x0C\x7A\xBA\xA9"
           "\x32\x54\xA6\x0A\xD3\xDD\xAE\x80\x31\x47\x07\xC8\x48\x4F\x76\x03"
           "\x7C\x24\x4A\x59\x54\x0E\x99\x25\xD1\x3C\xB6\xE0\x20\xDB\xCB\x20"
           "\xB5\x23\x8F\x55\xDE\xF4\x31\xCD\x51\xE2\x1B\x07\xDC\xCC\x41\x6A"
           "\xAA\xBB\x0C\x5E\x3A\x61\x11\xA0\x90\xE0\xA9\x38\x86\x1C\x78\xE9"
           "\xAA\x75\xF2\x02\x38\x36\x19\x53\x4C\xE9\x21\x88\x43\x05\x8C\x7D"
           "\xDB\x60\x26\x36\x87\x24\xA7\xD5\x36\x39\x14\xD1\xEF\x66\x78\x1C"
           "\xBE\xD1\x56\xF9\x70\x77\xF7\xE0\xF1\x1B\x9D\x8D\x9C\xB6\x26\x5A"
           "\xE6\x3A\xC8\x18\x9F\x48\x03\x3D\x85\x06\x21\x71\xB2\x2C\x70\x98"
           "\x40\xA5\x39\xA0\xBD\x8D\xDB\x02\x01\x03"
           , 154);
    nPKLen = 154;
    memset(bInData, 0x42, 72);
    bInData[0] = 0x30;
    bInData[71] = 0x39;
    nInDataLen = 72;
    nOutDataLenExp = 144;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 154);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHexExt("[IN ]bInData =", bInData, 72);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1152，PKCS#1填充，加密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bOutData    =", bOutData, 144);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_16(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);
/* SK = 308203330201000281B1009CDBEA104AEE30D858E1C71081C83240801C941EF6E905C80E4194E8885972A821220C7B5F528D65F0DD09560171B643649A6E1FE3857D2A27F75AA3DB73A299D685AF86917F19F5657CA971C17238038BDD83627960B2B3E27E410D36507CFAB06EAE9E055A55F89C697190774CA395297DC179FE7CD796840DC6303F14DA88CF4AED5A7A71915D2593DA0CB6CCB6D8E7F05455A393BDC0E73EF826FC5B37A591014BA258BB59C21EC8323B85168EF30201030281B068929C0ADC9ECB3AE5EBDA0B01302180556862BF4F4603DAB42BB89B0590F71AC0C15DA794E1B3994B3E0639564BCED79866F4154258FE1C1AA4E717E7A26C668F03CA59B654BBF8EE531BA12BA17AAD07E90241A64077218BCB7B3F3768674204BC06A549C7522C99955EA3E3A53AE9175632F222653EA7D64760C8586023DD3F090FA47F9263709B3FBEB68D23C41DAD07279861C3830FE3022515B7F8404892E395A2B425FFB894F611541417581B025900CA812AE20747987EC65BE0BA57B4478EBA2A0E8F3CBB076DDD4109BF2D59025568F1FDA07B0C26E943D4EB787E7627AB80C72E08C80B15B2BA344E8BFBEE5469AA1FD5552EA9F33260B0258050993D7A50D7D5DDE9B78E1F025900C64BDD4C5BEC4998E2F8C3EBBEFB1326FBDF550B6519C3C9A93B6B4F9D8BF74559B0B7633F787DD3ACE86A6B3C9FD488BBED0DF21B0BFAF9AA314A65150024BF689BEB3139BCE40653FBC5ADF9E91CB2EE7F425F7D3BFCAD0259008700C7415A2FBAFF2EE7EB26E522DA5F26C6B45F7DD204F3E8D6067F7390AC38F0A153C0520819F0D7E347A5A9A41A7255DA1EB0855CB921D178345D529EE2F11C1538E374714CCC40756E558B10D3A6E08FE3E9467A5EBF025900843293883D4831109750829D29FCB76F5294E35CEE112D311B7CF23513B2A4D8E675CF977FA5A937C89AF19CD315385B27F35EA1675D51FBC6CB86EE0E00187F9B129CCB7BD342AEE2A7D91EA69B687749AA2C3FA8D2A8730258338E0DADED9C6637F8E678CF084D129764D70B01F64AB050F1FBFEDBA0DB9EFAA51F1D6929BC0A697BD02E287D3194D6AC47CCF79E6B414F5A9DA26B5D95D22477C7B25FB7D2FA2E72DB4F27FFCCCFC8AA51FA1D5C49C56C */
    nFlag = 1;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\xB7\x02\x81\xB1\x00\x9C\xDB\xEA\x10\x4A\xEE\x30\xD8\x58"
           "\xE1\xC7\x10\x81\xC8\x32\x40\x80\x1C\x94\x1E\xF6\xE9\x05\xC8\x0E"
           "\x41\x94\xE8\x88\x59\x72\xA8\x21\x22\x0C\x7B\x5F\x52\x8D\x65\xF0"
           "\xDD\x09\x56\x01\x71\xB6\x43\x64\x9A\x6E\x1F\xE3\x85\x7D\x2A\x27"
           "\xF7\x5A\xA3\xDB\x73\xA2\x99\xD6\x85\xAF\x86\x91\x7F\x19\xF5\x65"
           "\x7C\xA9\x71\xC1\x72\x38\x03\x8B\xDD\x83\x62\x79\x60\xB2\xB3\xE2"
           "\x7E\x41\x0D\x36\x50\x7C\xFA\xB0\x6E\xAE\x9E\x05\x5A\x55\xF8\x9C"
           "\x69\x71\x90\x77\x4C\xA3\x95\x29\x7D\xC1\x79\xFE\x7C\xD7\x96\x84"
           "\x0D\xC6\x30\x3F\x14\xDA\x88\xCF\x4A\xED\x5A\x7A\x71\x91\x5D\x25"
           "\x93\xDA\x0C\xB6\xCC\xB6\xD8\xE7\xF0\x54\x55\xA3\x93\xBD\xC0\xE7"
           "\x3E\xF8\x26\xFC\x5B\x37\xA5\x91\x01\x4B\xA2\x58\xBB\x59\xC2\x1E"
           "\xC8\x32\x3B\x85\x16\x8E\xF3\x02\x01\x03"
           , 186);
    nPKLen = 186;
    memset(bInData, 0x42, 88);
    bInData[0] = 0x30;
    bInData[87] = 0x39;
    nInDataLen = 88;
    nOutDataLenExp = 176;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 186);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHexExt("[IN ]bInData =", bInData, 88);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1408，PKCS#1填充，加密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bOutData    =", bOutData, 176);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_17(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);
/* SK = 308204780201000281F900BEF974449AC301480B0ACDE1E552E7556091648A4634EA1DDAEE527B13925F27AEA266B5A5BB794B09817E7D952916C5EFE042F77D5EE172880C1FDC7648A5B026418D4F7041B2AA7084C0ABFA95E9076F7389E9D5ACD3BF7231A3301ECA13DB1F1F44D108D2FBF2B16CF4BAABF3BA36182539D60E3B4EBA93B2B4FA407DCAE396640524795795C69DC748B7FF5542078A488499612952730D8A97426E677C0AB38BA97C9C216727D8B9DD142C1065B86F78BB648A24AA78457AB354E6DF62E871E33C0C74D1FF0293DCB00126ECAECD4A3D22F77442A6A0F2A122721E9C0F8CAFA2512A23FF2249DD6C204AEE7ACE81FBD194AAF65BC0DB0201030281F87F50F82DBC8200DAB20733EBEE3744E395B64306D9789C13E7498C520D0C3F6FC9C199CE6E7CFB875BABA9A90E1B6483F5402CA4FE3F40F7055D6A92F985C3CAC42BB38A4AD6771C4B032B1D51B94604F4F7B1468E7337D4F6CBC2201486B7E76A14D88B5B3752A1CB9DF87C72A27C241018D1395ED2347C62772350590DABF05F5F5FFA56EBEC35492741EDC5BB1EFA8DE65D8238312979D2BBC975903B89E77AB47877267C9FCAA8DBEE047A7D3A8214845F833FAB8FA2C8FB26C64EB376EC926DE3B0EF3267D1F1D29E22E78A8C9E9CC748206DCD44014DDD9ABED699E27C897F6DD2A65D88C26AE44516F04151A394229FAB3A5F558B027D00E9D4AD9AD5B646A73A9E492CDFF8914BA7E582439D47618D352623B7570B965AE3AE2E37BE3750AACECB72CAE6149CAFA54A0BF3CA66A51EE45FDDB8B4281A409A59BF24254F5D7B9366F3687B98893DACD326019E3566A19E99B1D3EA4E3A5D10AD29D2170DA798B4F81B2409D437BB6360E542335F91BDA18F92A9027D00D1149B60319EAE85BC576A49D013D487AED7114C182796C8D7B97084FA6552B7325FFEF7BD45A41F139B04ACF55B5B5DCF0A8201864B8700C643754B63D9DEEAD678716170EF09077A9F6FDF2D88398F1EC9B5DDC0DCD02530F50ECB13867FF6CC0811FFCA5584D5757ABA02334180ED22B7EECA6A3E136C7D3D2DE3027D009BE31E6739242F1A271430C8955060DD1A99018268DA4108CE196D24E4B2643C97C97425297A35C73487A1DC9963131FC386B2A286EF18BF42EA93D0781ABC2B11912A1818DF93A7B799F79AFD105B7E73376EABBECE446BBF112137F1897C3E0B1E1BE164B3C51078A5676D5BE2CFD2424098D6CCEA6129165FB71B027D008B63124021147459283A46DBE00D385A748F60DD656FB9DB3A7BA058A6EE3724CC3FFF4FD383C2BF626758734E3CE793DF5C56ABAEDD04AB2ED7A38797E6949C8EFAF640F5F4B0AFA714F53F73B0265F69DBCE93D5E88AC375F8B4876259AAA488056155318E588E4E51D156CCD655F36C7A9F319C296248537E1E97027D00D4F6E9573499CF759897B809205ECA44DCC5149443495D134EFDDEDFD2282F0B2D08D7A975968856AC367A60CBC27153FCA6AECBD50CF26726606D8F15FDB33B69CF07461ECE571A198B23425B4C5FE6E0CE37B7CA216779B362BAC5E2AFD36CEBBD3038AEFA1B0C0FAAA458AED4004B2BD2653038135E3DC25DE82A */
    nFlag = 1;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\xFF\x02\x81\xF9\x00\xBE\xF9\x74\x44\x9A\xC3\x01\x48\x0B"
           "\x0A\xCD\xE1\xE5\x52\xE7\x55\x60\x91\x64\x8A\x46\x34\xEA\x1D\xDA"
           "\xEE\x52\x7B\x13\x92\x5F\x27\xAE\xA2\x66\xB5\xA5\xBB\x79\x4B\x09"
           "\x81\x7E\x7D\x95\x29\x16\xC5\xEF\xE0\x42\xF7\x7D\x5E\xE1\x72\x88"
           "\x0C\x1F\xDC\x76\x48\xA5\xB0\x26\x41\x8D\x4F\x70\x41\xB2\xAA\x70"
           "\x84\xC0\xAB\xFA\x95\xE9\x07\x6F\x73\x89\xE9\xD5\xAC\xD3\xBF\x72"
           "\x31\xA3\x30\x1E\xCA\x13\xDB\x1F\x1F\x44\xD1\x08\xD2\xFB\xF2\xB1"
           "\x6C\xF4\xBA\xAB\xF3\xBA\x36\x18\x25\x39\xD6\x0E\x3B\x4E\xBA\x93"
           "\xB2\xB4\xFA\x40\x7D\xCA\xE3\x96\x64\x05\x24\x79\x57\x95\xC6\x9D"
           "\xC7\x48\xB7\xFF\x55\x42\x07\x8A\x48\x84\x99\x61\x29\x52\x73\x0D"
           "\x8A\x97\x42\x6E\x67\x7C\x0A\xB3\x8B\xA9\x7C\x9C\x21\x67\x27\xD8"
           "\xB9\xDD\x14\x2C\x10\x65\xB8\x6F\x78\xBB\x64\x8A\x24\xAA\x78\x45"
           "\x7A\xB3\x54\xE6\xDF\x62\xE8\x71\xE3\x3C\x0C\x74\xD1\xFF\x02\x93"
           "\xDC\xB0\x01\x26\xEC\xAE\xCD\x4A\x3D\x22\xF7\x74\x42\xA6\xA0\xF2"
           "\xA1\x22\x72\x1E\x9C\x0F\x8C\xAF\xA2\x51\x2A\x23\xFF\x22\x49\xDD"
           "\x6C\x20\x4A\xEE\x7A\xCE\x81\xFB\xD1\x94\xAA\xF6\x5B\xC0\xDB\x02"
           "\x01\x03"
           , 258);
    nPKLen = 258;
    memset(bInData, 0x42, 124);
    bInData[0] = 0x30;
    bInData[123] = 0x39;
    nInDataLen = 124;
    nOutDataLenExp = 248;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 258);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHexExt("[IN ]bInData =", bInData, 124);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1984，PKCS#1填充，加密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bOutData    =", bOutData, 248);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_18(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);
/* SK = 308204A40201000282010100C9D5A76F4E62AD7AD8198519B4DCE888BB0010FF54A8C961B5442E537DA4987F27D68A3E6492735949FA81618ED6663C7EC0B35D4EBB11015BEE2553923375A03FBD02AB69E80EF8C19876DA81326616EF7A0D6E4DB174C8E893E81F00297F463C7C370C7BF078BA7D5DF9889A861EB81359AA551E5CBD2B7C36D8E54983B5CB144B1FEA029307F04024CD51967122F04A682CCDDEF50FFC344A64A352A1BEEE2CE75C1A958EFCA4AB65EB96BE430FBD78FE6ADF48B96866696C68CCA435D32BA42CDDBDC3657B5CD95667B92E40FEEF02EFBD91FC8861CA823DCA591FD78EACCF2ED5B295B87320C40AD0A587E4D08F771BDC05E17A547DB8A68E1BA9F0F4ED0201030282010100868E6F9F89971E51E56658BBCDE89B05D2000B54E31B30EBCE2D7437A91865AA1A8F06D4430C4CE63151AB965F39997DA9D5CCE8DF2760AB929EC38D0C224E6AD528AC72469AB4A5D665A491AB76EEB9F4FC08F433CBA3309B0D456A001BAA2ED2FD7A0852A0507C5393FBB06704147AB7911C38BEE87E1CFD79E5EE31027930DE56EE44EDF022767634351475831EC32D83052D05CDB02087FCC812A4E412687CA334E6618A38BD357F6BB6EF7370AF3AC11CC2B11633B6D7A57924D39AFC1ACE343A4080DF6C1AEDB7B3A86A9E1BF0F35FA193FDEE99238908D61B16C4E40F605EC74F6A84942860C5FB23FCF47B9E6103FBACE51D365DA35BB94C5173A42B02818100E983D11BBB4E45DF32E955501B65DCF0C952CC3929CAE59E8B8474734C20E34CC93042DB6EEF39DA3F8EB9FA2F83071A0D4BEA53AA3A1E3F2AB4CBADFEBC1FF769D801EB727381C8B348583F77D8D813C636974B3A0E25BBB67BA0EC208506B73D3A560EB63E4C2FFB455CCA061C402AAC25F0AE925F6FB56CCD7D66BD07357102818100DD44E966E25C8E5F5BED2862CAC697DABCD0D8D12C75A22CDCCAC4140F2AC004A8C249E594506DAE9B98100A2792DF9C9390D56794DDFC94FB3F67676811390C050684718FA2D76BC17A81FD167AFCF1CFA9B3E8C59456597E34E8445D2B31DE816654ACBFB348B4379C7B258659D6F7396FF1D3F76F133BD6CF7AC272BC493D028181009BAD36127CDED93F774638E01243E8A0863732D0C68743BF07ADA2F78815ECDDDB7581E79F4A26917FB47BFC1FACAF66B387F18D1C26BED4C7233273FF28154F9BE5569CF6F7ABDB22303AD4FA90900D2ECF0F877C096E7D24526B4815AE047A28D18EB4797EDD75522E3DDC0412D571C8194B1F0C3F9FCE4888FE447E04CE4B028181009383464496E85EEA3D48C59731D9BA91D335E5E0C84E6C1DE8872D62B4C72AADC5D6DBEE62E0491F12656006C50C95130D0B38EFB893FDB8A77F9A44F00B7B5D58AF02F65FC1E4F280FC56A8B9A7534BDFC677F083B83990FECDF02D9372213F00EEE31DD52230782512FCC3AEE68F4F7B9FF68D4F9F6227E48A51D6F72830D302818100BDB74027F783F89EE428CC88C4056090BA49A306720C284E02FC12857F7FE6B8150C2C0CA920AA25A02D9118EF283FA7DE0860CF57B170D9BC8967AB983C61E402F7E918ABDA491BED7565B3589F36A197C79020DB7CB144D3AE1EFB5CAB23267025F005343F09FE02C670EDFB5E058E9CD8A152AE0986EA7404981148FA14F5 */
    nFlag = 1;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x82\x01\x08\x02\x82\x01\x01\x00\xC9\xD5\xA7\x6F\x4E\x62\xAD"
           "\x7A\xD8\x19\x85\x19\xB4\xDC\xE8\x88\xBB\x00\x10\xFF\x54\xA8\xC9"
           "\x61\xB5\x44\x2E\x53\x7D\xA4\x98\x7F\x27\xD6\x8A\x3E\x64\x92\x73"
           "\x59\x49\xFA\x81\x61\x8E\xD6\x66\x3C\x7E\xC0\xB3\x5D\x4E\xBB\x11"
           "\x01\x5B\xEE\x25\x53\x92\x33\x75\xA0\x3F\xBD\x02\xAB\x69\xE8\x0E"
           "\xF8\xC1\x98\x76\xDA\x81\x32\x66\x16\xEF\x7A\x0D\x6E\x4D\xB1\x74"
           "\xC8\xE8\x93\xE8\x1F\x00\x29\x7F\x46\x3C\x7C\x37\x0C\x7B\xF0\x78"
           "\xBA\x7D\x5D\xF9\x88\x9A\x86\x1E\xB8\x13\x59\xAA\x55\x1E\x5C\xBD"
           "\x2B\x7C\x36\xD8\xE5\x49\x83\xB5\xCB\x14\x4B\x1F\xEA\x02\x93\x07"
           "\xF0\x40\x24\xCD\x51\x96\x71\x22\xF0\x4A\x68\x2C\xCD\xDE\xF5\x0F"
           "\xFC\x34\x4A\x64\xA3\x52\xA1\xBE\xEE\x2C\xE7\x5C\x1A\x95\x8E\xFC"
           "\xA4\xAB\x65\xEB\x96\xBE\x43\x0F\xBD\x78\xFE\x6A\xDF\x48\xB9\x68"
           "\x66\x69\x6C\x68\xCC\xA4\x35\xD3\x2B\xA4\x2C\xDD\xBD\xC3\x65\x7B"
           "\x5C\xD9\x56\x67\xB9\x2E\x40\xFE\xEF\x02\xEF\xBD\x91\xFC\x88\x61"
           "\xCA\x82\x3D\xCA\x59\x1F\xD7\x8E\xAC\xCF\x2E\xD5\xB2\x95\xB8\x73"
           "\x20\xC4\x0A\xD0\xA5\x87\xE4\xD0\x8F\x77\x1B\xDC\x05\xE1\x7A\x54"
           "\x7D\xB8\xA6\x8E\x1B\xA9\xF0\xF4\xED\x02\x01\x03"
           , 268);
    nPKLen = 268;
    memset(bInData, 0x42, 1);
    nInDataLen = 1;
    nOutDataLenExp = 256;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 268);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHexExt("[IN ]bInData =", bInData, 1);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-2048，PKCS#1填充，加密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bOutData    =", bOutData, 256);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_19(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    memcpy(bInData,
           "\xAC\xFE\x6C\xA5\x13\x16\x5C\xDB\x11\xD7\x54\x0E\x5F\x83\x98\xCD"
           "\xEC\x7B\x75\x16\x3B\x01\xD0\x24\x8C\x04\x04\x1B\x15\xB4\x87\xA8"
           "\xE9\xCE\x8C\x13\x65\xC1\x64\x8F\x81\xAC\x1F\x96\xFA\x97\xEC\xCE"
           "\x6C\x66\x99\xB9\x63\xB0\x37\xB3\xFE\x25\x2E\xED\x49\xC6\x1B\x00"
           , 64);
    nInDataLen = 64;
    memset(bOutDataExp, 0x42, 53);
    bOutDataExp[0] = 0x30;
    bOutDataExp[52] = 0x39;
    nOutDataLenExp = 53;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 72);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bInData =", bInData, 64);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-512，PKCS#1填充，解密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 53);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 53);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 53);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_20(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\x87\x02\x81\x81\x00\xA6\xF5\x8A\x17\x12\x3F\x46\x59\x92"
           "\xC0\x92\x01\x7E\xD3\xA9\x67\x2A\x6A\x42\x8E\xDA\x6A\xC2\x53\x91"
           "\x83\x77\x1E\x25\xA2\xA8\x74\x9B\xF3\x49\xF6\x6C\x5B\xA7\xDA\xC6"
           "\x18\x4B\x49\x42\x80\x20\x7F\xD9\xBB\x29\xC0\xF0\xD8\x81\xDC\x0A"
           "\x95\x53\x80\xF5\xA7\x52\x7E\x1E\x1E\x16\xB9\x5B\x79\xEE\x1F\x33"
           "\x50\x3A\xCC\x4E\xA1\x01\xC4\x55\xA8\x3B\xCB\x2B\xC8\xEB\xC5\x27"
           "\x5C\x21\xE3\x5B\xA1\x33\x60\xC6\x82\x76\xDD\x7C\x5F\xF0\x03\x24"
           "\xA7\x8E\x9B\x50\x8C\x46\xD5\xEB\xF5\x37\x81\x9B\xCD\x38\x01\x10"
           "\x1F\x9F\x0F\xBD\x78\x37\xC7\x02\x01\x03"
           , 138);
    nPKLen = 138;
    memcpy(bInData,
           "\x45\x13\xD8\xF1\xEA\x82\xEA\x34\x9F\x82\x04\x9E\x15\x76\x89\x50"
           "\x5E\x47\x6B\xC7\x53\x8F\xB1\x1F\x88\xAA\x17\xCE\x71\x9C\x6D\x48"
           "\xF0\x60\x36\x56\x21\x80\xFA\x6E\x68\xCE\xF2\xF7\x32\x87\xFB\xB9"
           "\x13\xAF\xFD\x87\x37\x44\x38\xAB\x34\x15\xBF\x70\xB0\xD2\x4F\x73"
           "\xE7\x31\xD1\x1D\x3A\x58\x68\xFE\x84\x48\xAE\xE5\xAB\xDA\xF7\x2E"
           "\xC0\xBB\x12\xAD\x06\x6E\x9D\x27\xA6\x68\x28\x6F\xDB\xE3\x2D\xA8"
           "\x1C\x7E\x62\xD8\x9C\x1B\x7E\xE6\x24\xC7\x5B\xB5\x2F\xCC\x40\xE3"
           "\xCF\x22\x3E\xEC\xE6\x87\x31\x52\xCC\x60\x74\xEE\x30\x2C\x36\x2F"
           , 128);
    nInDataLen = 128;
    memset(bOutDataExp, 0x42, 64);
    bOutDataExp[0] = 0x30;
    bOutDataExp[63] = 0x39;
    nOutDataLenExp = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 138);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bInData =", bInData, 128);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1024，PKCS#1填充，解密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 64);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 64);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 64);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_21(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\x97\x02\x81\x91\x00\xB4\xD4\xCD\x27\x2B\x0C\x7A\xBA\xA9"
           "\x32\x54\xA6\x0A\xD3\xDD\xAE\x80\x31\x47\x07\xC8\x48\x4F\x76\x03"
           "\x7C\x24\x4A\x59\x54\x0E\x99\x25\xD1\x3C\xB6\xE0\x20\xDB\xCB\x20"
           "\xB5\x23\x8F\x55\xDE\xF4\x31\xCD\x51\xE2\x1B\x07\xDC\xCC\x41\x6A"
           "\xAA\xBB\x0C\x5E\x3A\x61\x11\xA0\x90\xE0\xA9\x38\x86\x1C\x78\xE9"
           "\xAA\x75\xF2\x02\x38\x36\x19\x53\x4C\xE9\x21\x88\x43\x05\x8C\x7D"
           "\xDB\x60\x26\x36\x87\x24\xA7\xD5\x36\x39\x14\xD1\xEF\x66\x78\x1C"
           "\xBE\xD1\x56\xF9\x70\x77\xF7\xE0\xF1\x1B\x9D\x8D\x9C\xB6\x26\x5A"
           "\xE6\x3A\xC8\x18\x9F\x48\x03\x3D\x85\x06\x21\x71\xB2\x2C\x70\x98"
           "\x40\xA5\x39\xA0\xBD\x8D\xDB\x02\x01\x03"
           , 154);
    nPKLen = 154;
    memcpy(bInData,
           "\x0C\xBC\xF6\x9A\xE4\xAA\xAA\xC5\xBC\x07\xD3\x59\xA2\x07\xF9\xFD"
           "\x3B\xC4\xD6\xB5\x42\x08\x96\x97\x86\xE2\xC8\xD1\xD9\x20\x9A\x1A"
           "\xA1\x27\xDE\xEB\x59\x5B\x3A\x04\xE1\xA6\x0D\xC9\x19\x7A\xF8\x58"
           "\x1F\x1B\x17\x2D\xF2\x13\x5B\xBD\x2C\x58\x5C\xAB\x17\x6E\xBA\xFD"
           "\xD6\x83\x63\x08\xA4\xD9\x91\xBF\x84\x74\xB3\xAE\x27\x58\xD9\xE4"
           "\x0D\xC4\xF1\x1A\x2F\xDE\x3A\x68\x2A\x6B\xAA\xD5\x96\xDE\x14\xCB"
           "\xBF\x11\x4A\xE7\x15\x91\xBA\x9F\xF3\x1D\xB4\x78\x24\xEA\x5E\x9A"
           "\x0A\xCF\xF9\xDF\x7C\x7F\xDC\x27\x6E\x89\x14\xB5\xF3\x89\xE0\xAF"
           "\xD7\x31\x6F\xB1\x02\x2C\x18\xEF\xA6\x77\x1D\x07\x97\xF9\x1A\x06"
           , 144);
    nInDataLen = 144;
    memset(bOutDataExp, 0x42, 72);
    bOutDataExp[0] = 0x30;
    bOutDataExp[71] = 0x39;
    nOutDataLenExp = 72;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 154);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bInData =", bInData, 144);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1152，PKCS#1填充，解密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 72);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 72);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 72);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_22(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\xB7\x02\x81\xB1\x00\x9C\xDB\xEA\x10\x4A\xEE\x30\xD8\x58"
           "\xE1\xC7\x10\x81\xC8\x32\x40\x80\x1C\x94\x1E\xF6\xE9\x05\xC8\x0E"
           "\x41\x94\xE8\x88\x59\x72\xA8\x21\x22\x0C\x7B\x5F\x52\x8D\x65\xF0"
           "\xDD\x09\x56\x01\x71\xB6\x43\x64\x9A\x6E\x1F\xE3\x85\x7D\x2A\x27"
           "\xF7\x5A\xA3\xDB\x73\xA2\x99\xD6\x85\xAF\x86\x91\x7F\x19\xF5\x65"
           "\x7C\xA9\x71\xC1\x72\x38\x03\x8B\xDD\x83\x62\x79\x60\xB2\xB3\xE2"
           "\x7E\x41\x0D\x36\x50\x7C\xFA\xB0\x6E\xAE\x9E\x05\x5A\x55\xF8\x9C"
           "\x69\x71\x90\x77\x4C\xA3\x95\x29\x7D\xC1\x79\xFE\x7C\xD7\x96\x84"
           "\x0D\xC6\x30\x3F\x14\xDA\x88\xCF\x4A\xED\x5A\x7A\x71\x91\x5D\x25"
           "\x93\xDA\x0C\xB6\xCC\xB6\xD8\xE7\xF0\x54\x55\xA3\x93\xBD\xC0\xE7"
           "\x3E\xF8\x26\xFC\x5B\x37\xA5\x91\x01\x4B\xA2\x58\xBB\x59\xC2\x1E"
           "\xC8\x32\x3B\x85\x16\x8E\xF3\x02\x01\x03"
           , 186);
    nPKLen = 186;
    memcpy(bInData,
           "\x94\xAB\x1D\x36\x2F\xCF\x6B\xAB\x6A\x42\xD7\xF7\xFC\xA1\xFD\x79"
           "\x17\xFF\x37\x54\x1C\x40\xCB\x69\x1F\xA0\xF1\x8A\xF9\x0B\x64\x0D"
           "\x8D\xD6\xA9\x6D\xD4\x71\x25\x90\x6A\xB0\xE4\xFA\xED\x39\x94\x27"
           "\x18\x02\x54\x5D\x97\xEB\x02\x71\x39\x90\xB4\x33\x4F\xDF\x89\xF8"
           "\x89\xCA\x78\x21\xE7\xA1\xEB\x8E\x5E\xD7\x71\x16\xDC\xCD\x43\xDD"
           "\x9C\xD0\xE1\x86\xB0\x1F\x7B\xE5\xFF\xF5\xA5\x32\xD9\x7E\x50\x44"
           "\xF8\x45\xEA\xD0\x53\xE0\x6B\xBA\x45\x52\x36\x9D\x57\xB8\xD7\x28"
           "\x24\xFC\xFE\x2F\xF3\xBF\x78\x80\x1F\x0B\x63\x67\x69\xC2\xDA\x52"
           "\x0C\x76\x8A\xBA\xE0\xE5\x9E\x61\x78\xA0\x4D\xD6\xD5\x92\x9B\x05"
           "\xE0\x7E\x26\xE1\xE5\xC1\x42\x70\x0A\x66\x13\x8B\x91\x65\x35\xC6"
           "\xAB\xB2\xE1\x40\xB7\xAC\x75\x5F\xF1\x86\x86\x75\x55\xAB\x5E\x8E"
           , 176);
    nInDataLen = 176;
    memset(bOutDataExp, 0x42, 88);
    bOutDataExp[0] = 0x30;
    bOutDataExp[87] = 0x39;
    nOutDataLenExp = 88;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 186);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bInData =", bInData, 176);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1408，PKCS#1填充，解密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 88);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 88);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 88);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_23(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\xFF\x02\x81\xF9\x00\xBE\xF9\x74\x44\x9A\xC3\x01\x48\x0B"
           "\x0A\xCD\xE1\xE5\x52\xE7\x55\x60\x91\x64\x8A\x46\x34\xEA\x1D\xDA"
           "\xEE\x52\x7B\x13\x92\x5F\x27\xAE\xA2\x66\xB5\xA5\xBB\x79\x4B\x09"
           "\x81\x7E\x7D\x95\x29\x16\xC5\xEF\xE0\x42\xF7\x7D\x5E\xE1\x72\x88"
           "\x0C\x1F\xDC\x76\x48\xA5\xB0\x26\x41\x8D\x4F\x70\x41\xB2\xAA\x70"
           "\x84\xC0\xAB\xFA\x95\xE9\x07\x6F\x73\x89\xE9\xD5\xAC\xD3\xBF\x72"
           "\x31\xA3\x30\x1E\xCA\x13\xDB\x1F\x1F\x44\xD1\x08\xD2\xFB\xF2\xB1"
           "\x6C\xF4\xBA\xAB\xF3\xBA\x36\x18\x25\x39\xD6\x0E\x3B\x4E\xBA\x93"
           "\xB2\xB4\xFA\x40\x7D\xCA\xE3\x96\x64\x05\x24\x79\x57\x95\xC6\x9D"
           "\xC7\x48\xB7\xFF\x55\x42\x07\x8A\x48\x84\x99\x61\x29\x52\x73\x0D"
           "\x8A\x97\x42\x6E\x67\x7C\x0A\xB3\x8B\xA9\x7C\x9C\x21\x67\x27\xD8"
           "\xB9\xDD\x14\x2C\x10\x65\xB8\x6F\x78\xBB\x64\x8A\x24\xAA\x78\x45"
           "\x7A\xB3\x54\xE6\xDF\x62\xE8\x71\xE3\x3C\x0C\x74\xD1\xFF\x02\x93"
           "\xDC\xB0\x01\x26\xEC\xAE\xCD\x4A\x3D\x22\xF7\x74\x42\xA6\xA0\xF2"
           "\xA1\x22\x72\x1E\x9C\x0F\x8C\xAF\xA2\x51\x2A\x23\xFF\x22\x49\xDD"
           "\x6C\x20\x4A\xEE\x7A\xCE\x81\xFB\xD1\x94\xAA\xF6\x5B\xC0\xDB\x02"
           "\x01\x03"
           , 258);
    nPKLen = 258;
    memcpy(bInData,
           "\x82\x05\x88\x30\xA8\x60\x00\xF5\x23\x6F\xDC\xB7\x44\x7B\x94\x4B"
           "\x9C\xF6\x82\xC4\xDF\xE1\xE4\x94\x4B\xD5\xBA\xC4\x58\xE4\x91\x41"
           "\x37\xA1\x46\x17\x67\x4D\xE8\xFB\x1B\x8A\x63\x3C\x50\x91\x30\x7B"
           "\x20\x8C\xC4\x88\x61\xDC\xCC\x4E\x2F\x2C\x78\x31\xF2\x75\x6B\x82"
           "\xA5\xCF\x4E\xFF\x1E\x2D\x3C\x24\xD5\xDA\x71\xF1\x7E\x7A\x41\xFF"
           "\xA2\xB6\x79\x2E\x13\x77\xED\x45\x89\x99\xBD\xAF\x08\xA2\x9C\x10"
           "\x9E\xA2\x7D\x1D\x17\xE8\xCB\x4B\x23\xE9\x33\xC6\xBF\x1A\x35\xA2"
           "\xE3\x73\x72\xDB\x39\xF7\xB8\x31\x5E\x5A\x7A\x04\x03\x13\x85\x65"
           "\x49\xBF\x06\xFB\x5A\x9F\xC2\x19\x05\xF5\xD7\x1E\x69\x30\xBB\x67"
           "\x47\x7E\xF1\x2E\x6B\xCB\x99\xD8\x45\xCE\xD6\xD3\xCA\x87\x94\x73"
           "\x44\xF5\xDF\x1F\xD3\xC1\xFA\x05\x7A\xDB\xE4\x5C\x6E\x94\x6B\x97"
           "\x12\xC6\xDB\x4F\x98\x4C\x17\xEB\x20\xDC\xE5\x6C\x02\xA7\x2D\xB1"
           "\xE2\x3D\xAC\x50\x57\x3E\x66\x0B\xB6\x80\x89\x4F\xC5\x83\xFA\x6F"
           "\x48\xF6\x7F\x3B\xD5\xE1\xAD\x8D\x47\xA5\xA2\x62\x33\x77\x43\xC3"
           "\x0E\xD4\x14\x2E\x46\x62\xA8\x43\x39\x5E\x7E\x26\x42\xB9\xF7\x22"
           "\x1A\x20\x01\x30\x2C\x6A\x24\x48"
           , 248);
    nInDataLen = 248;
    memset(bOutDataExp, 0x42, 124);
    bOutDataExp[0] = 0x30;
    bOutDataExp[123] = 0x39;
    nOutDataLenExp = 124;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 258);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bInData =", bInData, 248);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1984，PKCS#1填充，解密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 124);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 124);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 124);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_24(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x82\x01\x08\x02\x82\x01\x01\x00\xC9\xD5\xA7\x6F\x4E\x62\xAD"
           "\x7A\xD8\x19\x85\x19\xB4\xDC\xE8\x88\xBB\x00\x10\xFF\x54\xA8\xC9"
           "\x61\xB5\x44\x2E\x53\x7D\xA4\x98\x7F\x27\xD6\x8A\x3E\x64\x92\x73"
           "\x59\x49\xFA\x81\x61\x8E\xD6\x66\x3C\x7E\xC0\xB3\x5D\x4E\xBB\x11"
           "\x01\x5B\xEE\x25\x53\x92\x33\x75\xA0\x3F\xBD\x02\xAB\x69\xE8\x0E"
           "\xF8\xC1\x98\x76\xDA\x81\x32\x66\x16\xEF\x7A\x0D\x6E\x4D\xB1\x74"
           "\xC8\xE8\x93\xE8\x1F\x00\x29\x7F\x46\x3C\x7C\x37\x0C\x7B\xF0\x78"
           "\xBA\x7D\x5D\xF9\x88\x9A\x86\x1E\xB8\x13\x59\xAA\x55\x1E\x5C\xBD"
           "\x2B\x7C\x36\xD8\xE5\x49\x83\xB5\xCB\x14\x4B\x1F\xEA\x02\x93\x07"
           "\xF0\x40\x24\xCD\x51\x96\x71\x22\xF0\x4A\x68\x2C\xCD\xDE\xF5\x0F"
           "\xFC\x34\x4A\x64\xA3\x52\xA1\xBE\xEE\x2C\xE7\x5C\x1A\x95\x8E\xFC"
           "\xA4\xAB\x65\xEB\x96\xBE\x43\x0F\xBD\x78\xFE\x6A\xDF\x48\xB9\x68"
           "\x66\x69\x6C\x68\xCC\xA4\x35\xD3\x2B\xA4\x2C\xDD\xBD\xC3\x65\x7B"
           "\x5C\xD9\x56\x67\xB9\x2E\x40\xFE\xEF\x02\xEF\xBD\x91\xFC\x88\x61"
           "\xCA\x82\x3D\xCA\x59\x1F\xD7\x8E\xAC\xCF\x2E\xD5\xB2\x95\xB8\x73"
           "\x20\xC4\x0A\xD0\xA5\x87\xE4\xD0\x8F\x77\x1B\xDC\x05\xE1\x7A\x54"
           "\x7D\xB8\xA6\x8E\x1B\xA9\xF0\xF4\xED\x02\x01\x03"
           , 268);
    nPKLen = 268;
    memcpy(bInData,
           "\xAC\x87\x17\x34\x90\x4B\x52\x08\x55\xBA\x3B\x60\xF6\x49\xFE\x62"
           "\xEA\x8C\xE9\x0A\xCD\x14\xF5\x3E\xF4\x6A\x3D\x00\x78\xDF\xE2\x83"
           "\x20\x22\xD0\x60\x3B\x31\xC9\x06\x37\xFB\x17\xBF\x75\xFA\x0F\x6F"
           "\x75\x94\x66\x02\x71\x83\x40\x9E\xA1\xF9\x35\x96\x18\xA0\x35\xFD"
           "\xCC\x83\x63\xE3\x8B\x06\xFF\x04\x18\x56\x16\x69\xDF\x9A\xD1\xAD"
           "\x4E\x2D\xCD\xF7\xB2\x0D\x80\x36\x46\xC4\xB7\x6B\xC7\xCF\x61\x9D"
           "\x1A\xAE\x95\x45\x35\x54\xB9\x71\x4D\xB3\xA1\xBF\x89\x8C\x07\x9C"
           "\x61\x94\x93\x8B\xC7\xCC\xDC\x8F\x9E\x0C\xF7\x7E\x9C\x09\x9C\x92"
           "\x81\x88\x82\x09\x5A\x64\xA5\x4F\x3B\xBE\x38\xCD\xEE\x67\xB0\x2C"
           "\x02\xBA\xEF\x49\x66\x8E\xE4\x31\x25\xCB\xB3\x6D\xA6\xD3\x77\xE5"
           "\xF4\xBA\x86\x0D\xD9\xA7\x81\x62\x1E\xB3\x97\x94\x5C\x17\x95\x3B"
           "\xEA\x89\x4E\x76\x00\x79\xBB\x8C\x7F\xA9\x2D\x5C\xEB\x59\xA3\x46"
           "\xFE\xFF\x27\x3A\xF2\x44\x80\x4C\x96\x18\x0B\xF5\x42\xF2\x8A\x97"
           "\x65\x2C\xC1\xC3\xF1\x4E\x7E\x94\x17\x34\x0C\x00\xB7\x8C\x72\xE5"
           "\xD1\x3E\xD4\x14\xA5\x03\x1B\x1E\x43\x25\xC8\x2A\x41\x7F\x2C\x90"
           "\xC3\x20\x1E\x1F\x5F\xDA\x16\x11\x95\xF4\x96\xF0\x1E\x1F\xF8\x2E"
           , 256);
    nInDataLen = 256;
    memset(bOutDataExp, 0x42, 1);
    nOutDataLenExp = 1;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 268);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bInData =", bInData, 256);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-2048，PKCS#1填充，解密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 1);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 1);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 1);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_25(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 2;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    memset(bInData, 0x42, 22);
    bInData[0] = 0x30;
    bInData[21] = 0x39;
    nInDataLen = 22;
    nOutDataLenExp = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 72);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHexExt("[IN ]bInData =", bInData, 22);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-512，OAEP填充，加密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bOutData    =", bOutData, 64);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_26(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 2;
    memcpy(bPK,
           "\x30\x81\x87\x02\x81\x81\x00\xA6\xF5\x8A\x17\x12\x3F\x46\x59\x92"
           "\xC0\x92\x01\x7E\xD3\xA9\x67\x2A\x6A\x42\x8E\xDA\x6A\xC2\x53\x91"
           "\x83\x77\x1E\x25\xA2\xA8\x74\x9B\xF3\x49\xF6\x6C\x5B\xA7\xDA\xC6"
           "\x18\x4B\x49\x42\x80\x20\x7F\xD9\xBB\x29\xC0\xF0\xD8\x81\xDC\x0A"
           "\x95\x53\x80\xF5\xA7\x52\x7E\x1E\x1E\x16\xB9\x5B\x79\xEE\x1F\x33"
           "\x50\x3A\xCC\x4E\xA1\x01\xC4\x55\xA8\x3B\xCB\x2B\xC8\xEB\xC5\x27"
           "\x5C\x21\xE3\x5B\xA1\x33\x60\xC6\x82\x76\xDD\x7C\x5F\xF0\x03\x24"
           "\xA7\x8E\x9B\x50\x8C\x46\xD5\xEB\xF5\x37\x81\x9B\xCD\x38\x01\x10"
           "\x1F\x9F\x0F\xBD\x78\x37\xC7\x02\x01\x03"
           , 138);
    nPKLen = 138;
    memset(bInData, 0x42, 64);
    bInData[0] = 0x30;
    bInData[63] = 0x39;
    nInDataLen = 64;
    nOutDataLenExp = 128;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 138);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHexExt("[IN ]bInData =", bInData, 64);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1024，OAEP填充，加密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bOutData    =", bOutData, 128);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_27(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 2;
    memcpy(bPK,
           "\x30\x81\x97\x02\x81\x91\x00\xB4\xD4\xCD\x27\x2B\x0C\x7A\xBA\xA9"
           "\x32\x54\xA6\x0A\xD3\xDD\xAE\x80\x31\x47\x07\xC8\x48\x4F\x76\x03"
           "\x7C\x24\x4A\x59\x54\x0E\x99\x25\xD1\x3C\xB6\xE0\x20\xDB\xCB\x20"
           "\xB5\x23\x8F\x55\xDE\xF4\x31\xCD\x51\xE2\x1B\x07\xDC\xCC\x41\x6A"
           "\xAA\xBB\x0C\x5E\x3A\x61\x11\xA0\x90\xE0\xA9\x38\x86\x1C\x78\xE9"
           "\xAA\x75\xF2\x02\x38\x36\x19\x53\x4C\xE9\x21\x88\x43\x05\x8C\x7D"
           "\xDB\x60\x26\x36\x87\x24\xA7\xD5\x36\x39\x14\xD1\xEF\x66\x78\x1C"
           "\xBE\xD1\x56\xF9\x70\x77\xF7\xE0\xF1\x1B\x9D\x8D\x9C\xB6\x26\x5A"
           "\xE6\x3A\xC8\x18\x9F\x48\x03\x3D\x85\x06\x21\x71\xB2\x2C\x70\x98"
           "\x40\xA5\x39\xA0\xBD\x8D\xDB\x02\x01\x03"
           , 154);
    nPKLen = 154;
    memset(bInData, 0x42, 72);
    bInData[0] = 0x30;
    bInData[71] = 0x39;
    nInDataLen = 72;
    nOutDataLenExp = 144;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 154);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHexExt("[IN ]bInData =", bInData, 72);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1152，OAEP填充，加密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bOutData    =", bOutData, 144);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_28(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 2;
    memcpy(bPK,
           "\x30\x81\xB7\x02\x81\xB1\x00\x9C\xDB\xEA\x10\x4A\xEE\x30\xD8\x58"
           "\xE1\xC7\x10\x81\xC8\x32\x40\x80\x1C\x94\x1E\xF6\xE9\x05\xC8\x0E"
           "\x41\x94\xE8\x88\x59\x72\xA8\x21\x22\x0C\x7B\x5F\x52\x8D\x65\xF0"
           "\xDD\x09\x56\x01\x71\xB6\x43\x64\x9A\x6E\x1F\xE3\x85\x7D\x2A\x27"
           "\xF7\x5A\xA3\xDB\x73\xA2\x99\xD6\x85\xAF\x86\x91\x7F\x19\xF5\x65"
           "\x7C\xA9\x71\xC1\x72\x38\x03\x8B\xDD\x83\x62\x79\x60\xB2\xB3\xE2"
           "\x7E\x41\x0D\x36\x50\x7C\xFA\xB0\x6E\xAE\x9E\x05\x5A\x55\xF8\x9C"
           "\x69\x71\x90\x77\x4C\xA3\x95\x29\x7D\xC1\x79\xFE\x7C\xD7\x96\x84"
           "\x0D\xC6\x30\x3F\x14\xDA\x88\xCF\x4A\xED\x5A\x7A\x71\x91\x5D\x25"
           "\x93\xDA\x0C\xB6\xCC\xB6\xD8\xE7\xF0\x54\x55\xA3\x93\xBD\xC0\xE7"
           "\x3E\xF8\x26\xFC\x5B\x37\xA5\x91\x01\x4B\xA2\x58\xBB\x59\xC2\x1E"
           "\xC8\x32\x3B\x85\x16\x8E\xF3\x02\x01\x03"
           , 186);
    nPKLen = 186;
    memset(bInData, 0x42, 88);
    bInData[0] = 0x30;
    bInData[87] = 0x39;
    nInDataLen = 88;
    nOutDataLenExp = 176;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 186);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHexExt("[IN ]bInData =", bInData, 88);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1408，OAEP填充，加密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bOutData    =", bOutData, 176);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_29(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 2;
    memcpy(bPK,
           "\x30\x81\xFF\x02\x81\xF9\x00\xBE\xF9\x74\x44\x9A\xC3\x01\x48\x0B"
           "\x0A\xCD\xE1\xE5\x52\xE7\x55\x60\x91\x64\x8A\x46\x34\xEA\x1D\xDA"
           "\xEE\x52\x7B\x13\x92\x5F\x27\xAE\xA2\x66\xB5\xA5\xBB\x79\x4B\x09"
           "\x81\x7E\x7D\x95\x29\x16\xC5\xEF\xE0\x42\xF7\x7D\x5E\xE1\x72\x88"
           "\x0C\x1F\xDC\x76\x48\xA5\xB0\x26\x41\x8D\x4F\x70\x41\xB2\xAA\x70"
           "\x84\xC0\xAB\xFA\x95\xE9\x07\x6F\x73\x89\xE9\xD5\xAC\xD3\xBF\x72"
           "\x31\xA3\x30\x1E\xCA\x13\xDB\x1F\x1F\x44\xD1\x08\xD2\xFB\xF2\xB1"
           "\x6C\xF4\xBA\xAB\xF3\xBA\x36\x18\x25\x39\xD6\x0E\x3B\x4E\xBA\x93"
           "\xB2\xB4\xFA\x40\x7D\xCA\xE3\x96\x64\x05\x24\x79\x57\x95\xC6\x9D"
           "\xC7\x48\xB7\xFF\x55\x42\x07\x8A\x48\x84\x99\x61\x29\x52\x73\x0D"
           "\x8A\x97\x42\x6E\x67\x7C\x0A\xB3\x8B\xA9\x7C\x9C\x21\x67\x27\xD8"
           "\xB9\xDD\x14\x2C\x10\x65\xB8\x6F\x78\xBB\x64\x8A\x24\xAA\x78\x45"
           "\x7A\xB3\x54\xE6\xDF\x62\xE8\x71\xE3\x3C\x0C\x74\xD1\xFF\x02\x93"
           "\xDC\xB0\x01\x26\xEC\xAE\xCD\x4A\x3D\x22\xF7\x74\x42\xA6\xA0\xF2"
           "\xA1\x22\x72\x1E\x9C\x0F\x8C\xAF\xA2\x51\x2A\x23\xFF\x22\x49\xDD"
           "\x6C\x20\x4A\xEE\x7A\xCE\x81\xFB\xD1\x94\xAA\xF6\x5B\xC0\xDB\x02"
           "\x01\x03"
           , 258);
    nPKLen = 258;
    memset(bInData, 0x42, 124);
    bInData[0] = 0x30;
    bInData[123] = 0x39;
    nInDataLen = 124;
    nOutDataLenExp = 248;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 258);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHexExt("[IN ]bInData =", bInData, 124);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1984，OAEP填充，加密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bOutData    =", bOutData, 248);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_30(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 2;
    memcpy(bPK,
           "\x30\x82\x01\x08\x02\x82\x01\x01\x00\xC9\xD5\xA7\x6F\x4E\x62\xAD"
           "\x7A\xD8\x19\x85\x19\xB4\xDC\xE8\x88\xBB\x00\x10\xFF\x54\xA8\xC9"
           "\x61\xB5\x44\x2E\x53\x7D\xA4\x98\x7F\x27\xD6\x8A\x3E\x64\x92\x73"
           "\x59\x49\xFA\x81\x61\x8E\xD6\x66\x3C\x7E\xC0\xB3\x5D\x4E\xBB\x11"
           "\x01\x5B\xEE\x25\x53\x92\x33\x75\xA0\x3F\xBD\x02\xAB\x69\xE8\x0E"
           "\xF8\xC1\x98\x76\xDA\x81\x32\x66\x16\xEF\x7A\x0D\x6E\x4D\xB1\x74"
           "\xC8\xE8\x93\xE8\x1F\x00\x29\x7F\x46\x3C\x7C\x37\x0C\x7B\xF0\x78"
           "\xBA\x7D\x5D\xF9\x88\x9A\x86\x1E\xB8\x13\x59\xAA\x55\x1E\x5C\xBD"
           "\x2B\x7C\x36\xD8\xE5\x49\x83\xB5\xCB\x14\x4B\x1F\xEA\x02\x93\x07"
           "\xF0\x40\x24\xCD\x51\x96\x71\x22\xF0\x4A\x68\x2C\xCD\xDE\xF5\x0F"
           "\xFC\x34\x4A\x64\xA3\x52\xA1\xBE\xEE\x2C\xE7\x5C\x1A\x95\x8E\xFC"
           "\xA4\xAB\x65\xEB\x96\xBE\x43\x0F\xBD\x78\xFE\x6A\xDF\x48\xB9\x68"
           "\x66\x69\x6C\x68\xCC\xA4\x35\xD3\x2B\xA4\x2C\xDD\xBD\xC3\x65\x7B"
           "\x5C\xD9\x56\x67\xB9\x2E\x40\xFE\xEF\x02\xEF\xBD\x91\xFC\x88\x61"
           "\xCA\x82\x3D\xCA\x59\x1F\xD7\x8E\xAC\xCF\x2E\xD5\xB2\x95\xB8\x73"
           "\x20\xC4\x0A\xD0\xA5\x87\xE4\xD0\x8F\x77\x1B\xDC\x05\xE1\x7A\x54"
           "\x7D\xB8\xA6\x8E\x1B\xA9\xF0\xF4\xED\x02\x01\x03"
           , 268);
    nPKLen = 268;
    memset(bInData, 0x42, 1);
    nInDataLen = 1;
    nOutDataLenExp = 256;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 268);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHexExt("[IN ]bInData =", bInData, 1);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-2048，OAEP填充，加密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bOutData    =", bOutData, 256);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_31(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nSock = -1;
    nFlag = 1;
    nPadMode = 0;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    memset(bInData, 0x42, 64);
    bInData[0] = 0x30;
    bInData[63] = 0x39;
    nInDataLen = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 72);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bInData =", bInData, 64);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void PublicCalc_Test_32(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nSock = 8;
    nFlag = 1;
    nPadMode = 0;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    memset(bInData, 0x42, 64);
    bInData[0] = 0x30;
    bInData[63] = 0x39;
    nInDataLen = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 72);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bInData =", bInData, 64);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[8]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void PublicCalc_Test_33(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = -1;
    nPadMode = 0;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    memset(bInData, 0x42, 64);
    bInData[0] = 0x30;
    bInData[63] = 0x39;
    nInDataLen = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 72);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bInData =", bInData, 64);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效加解密标志[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_34(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 2;
    nPadMode = 0;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    memset(bInData, 0x42, 64);
    bInData[0] = 0x30;
    bInData[63] = 0x39;
    nInDataLen = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 72);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bInData =", bInData, 64);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效加解密标志[2]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_35(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = -1;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    memset(bInData, 0x42, 64);
    bInData[0] = 0x30;
    bInData[63] = 0x39;
    nInDataLen = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 72);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bInData =", bInData, 64);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效填充模式[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_36(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 3;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    memset(bInData, 0x42, 64);
    bInData[0] = 0x30;
    bInData[63] = 0x39;
    nInDataLen = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 72);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bInData =", bInData, 64);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效填充模式[3]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_37(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 0;
    nPKLen = 0;
    memset(bInData, 0x42, 64);
    bInData[0] = 0x30;
    bInData[63] = 0x39;
    nInDataLen = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 0);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bInData =", bInData, 64);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效公钥长度=0测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_38(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 0;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    nInDataLen = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 72);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bInData =", bInData, 0);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无填充，无效数据长度=0，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_39(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 0;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    memset(bInData, 0x42, 63);
    bInData[0] = 0x30;
    bInData[62] = 0x39;
    nInDataLen = 63;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 72);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bInData =", bInData, 63);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无填充，无效数据长度=63，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_40(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 0;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    memset(bInData, 0x42, 65);
    bInData[0] = 0x30;
    bInData[64] = 0x39;
    nInDataLen = 65;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 72);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bInData =", bInData, 65);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无填充，无效数据长度=65，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_41(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 0;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    memset(bInData, 0x42, 72);
    bInData[0] = 0x30;
    bInData[71] = 0x39;
    nInDataLen = 72;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 72);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bInData =", bInData, 72);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无填充，无效数据长度=72，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_42(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    nInDataLen = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 72);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bInData =", bInData, 0);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "PKCS#1填充，无效数据长度=0，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_43(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    memset(bInData, 0x42, 54);
    bInData[0] = 0x30;
    bInData[53] = 0x39;
    nInDataLen = 54;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 72);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bInData =", bInData, 54);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "PKCS#1填充，无效数据长度=54，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_44(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    memset(bInData, 0x42, 64);
    bInData[0] = 0x30;
    bInData[63] = 0x39;
    nInDataLen = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 72);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bInData =", bInData, 64);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "PKCS#1填充，无效数据长度=64，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_45(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 2;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    nInDataLen = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 72);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bInData =", bInData, 0);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "OAEP填充，无效数据长度=0，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_46(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 2;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    memset(bInData, 0x42, 23);
    bInData[0] = 0x30;
    bInData[22] = 0x39;
    nInDataLen = 23;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 72);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bInData =", bInData, 23);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "OAEP填充，无效数据长度=23，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_47(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 2;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    memset(bInData, 0x42, 64);
    bInData[0] = 0x30;
    bInData[63] = 0x39;
    nInDataLen = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 72);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bInData =", bInData, 64);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "OAEP填充，无效数据长度=64，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_48(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 0;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    nInDataLen = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 72);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bInData =", bInData, 0);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "解密，无填充，无效数据长度=0，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_49(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 0;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    memset(bInData, 0x42, 63);
    bInData[0] = 0x30;
    bInData[62] = 0x39;
    nInDataLen = 63;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 72);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bInData =", bInData, 63);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "解密，无填充，无效数据长度=63，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_50(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    nInDataLen = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 72);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bInData =", bInData, 0);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "解密，PKCS#1填充，无效数据长度=0，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PublicCalc_Test_51(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    memset(bInData, 0x42, 63);
    bInData[0] = 0x30;
    bInData[62] = 0x39;
    nInDataLen = 63;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 72);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bInData =", bInData, 63);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "解密，PKCS#1填充，无效数据长度=63，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 0;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    memset(bInData, 0x42, 64);
    bInData[0] = 0x30;
    bInData[63] = 0x39;
    nInDataLen = 64;
    memcpy(bOutDataExp,
           "\x6B\x4B\x53\xB4\x68\xCA\x92\x3D\x8D\x4C\xC1\xDC\x50\x7C\x52\x3A"
           "\x5C\x28\x63\xBB\xA7\x37\x1A\x04\x8B\x73\xC5\x14\x5F\xB0\x1C\xFC"
           "\x3C\xB9\xD0\x83\x79\x8C\xC1\x3F\xA8\xD4\xD5\xD5\x03\x29\x7E\x87"
           "\x0F\xA2\xC5\x05\xA5\xEE\x41\x01\xFE\xFB\x77\x9E\x15\x1F\xE6\x23"
           , 64);
    nOutDataLenExp = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 320);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 64);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                            nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-512，无填充，加密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 64);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 64);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 64);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 0;
    memcpy(bSK,
           "\x3B\xD4\x50\x5C\x7E\x86\x10\xCE\x25\x5C\xB9\x39\xC2\xD4\x61\x5C"
           "\x7F\xC2\xC4\x74\xE5\x22\x06\xCD\x50\x53\xAF\x84\x02\xF7\xE6\x54"
           "\x85\x44\x18\x4D\xE9\x05\x89\xF5\x5D\x0E\xC0\x55\x6A\xD2\x53\xA5"
           "\x36\x71\x2D\xD5\xFD\xEA\x8A\x45\x4C\xC6\x00\x3B\xE7\x01\x70\x1C"
           "\xEC\xA6\xD1\xF4\x7D\xF0\xD5\xF5\xB6\x5A\x00\x43\xBC\xF0\x6A\x79"
           "\xFF\xD3\x30\xB8\x5F\xFA\xEA\xE0\xD1\x9E\x6C\x02\xAE\x9A\x13\xF0"
           "\x09\xED\xB1\x9C\x0A\xBE\xA9\xB7\x93\x66\xBB\x08\xC6\x0A\xA2\xFD"
           "\xFE\x19\xBF\x9E\x9E\x7C\x1C\xCF\xBB\xF6\x3F\x4D\x1A\x35\xF9\x26"
           "\x2A\xF4\x84\x29\x43\x79\xE7\x3D\x9B\x58\xF9\x30\xE1\x27\x3B\xC0"
           "\xD7\xE7\xEF\xF8\x52\x50\x2C\x85\x65\x1B\x1C\x3D\x2D\xA9\x73\x8F"
           "\xCA\x54\xF3\x60\xE4\x84\x67\xAC\xEB\xAA\x24\x30\xC9\x98\x9D\x4B"
           "\x2E\xF3\xD7\xE1\x93\xCA\xC0\x63\x3F\xD1\xE4\xAF\x08\x37\x63\xB5"
           "\x8A\xDB\x3E\x66\x44\x4E\x01\x7F\x75\x92\xB4\x5D\x79\x6C\x94\x9B"
           "\x4C\x55\x2F\x9A\x26\xD9\x54\x65\x67\x41\x4A\xAC\x1F\x7C\x4A\xFE"
           "\x1E\xDD\xDD\xE1\x51\x3A\xB2\xE2\x92\xFA\x3F\x8D\xFF\xEE\x78\x0A"
           "\xBB\xFB\xD6\x94\xE3\x39\x48\xF8\xF1\xC0\x3A\x36\xF4\x65\xF6\xB9"
           "\x2A\x2C\xEE\x71\x11\xAA\x7B\x55\xBF\x9D\x13\x0F\x74\x47\x05\x87"
           "\x27\xF0\x9F\x65\x6E\xED\xAF\x2B\x78\x69\xFE\x3A\x40\xA3\xDB\x58"
           "\xCC\x5C\x83\xC5\x0E\x9B\xF3\xB5\x8B\x6D\xA8\xBE\x0C\x5E\x38\x2A"
           "\x12\x8C\x3E\x40\xA1\x03\x43\x20\x6B\x4B\x3D\x65\x8C\x96\x13\x5F"
           "\x58\x56\x87\x88\x20\x0A\x12\xD8\x42\x95\x55\x5D\xDD\x74\x23\xF3"
           "\x05\x77\x04\x02\xBC\x97\x6E\xED\xEB\x33\x10\x4B\x8C\x58\x0C\xDF"
           "\x9A\x54\xCD\xB9\x69\xAA\x0B\x15\x13\x8B\x95\x87\x55\xFC\x05\x0A"
           "\x81\x5E\x00\x9D\x50\x9D\x7D\x73\x94\x6B\x78\x30\x40\xC7\xF4\x89"
           "\x76\x9F\x1D\x3B\x69\xAE\x65\x5C\xF5\xAB\xF8\xC0\x33\x0F\xA3\x02"
           "\xA4\x41\x96\x86\x47\x75\x2F\x3B\xC4\x3D\xE8\x5A\x88\xAB\xB9\x74"
           "\xB9\x8F\xA7\xDC\xBE\x35\xE0\xA1\x31\xA1\xEE\xAC\xD3\x01\x97\x67"
           "\x65\x1D\x81\x74\x38\x11\xEF\xC5\x0F\xDD\x6B\x70\x98\xF8\xDC\x91"
           "\xFA\x20\xDD\x34\x9F\xB4\xB2\x09\x6B\x90\xD7\x81\xBA\xD4\x34\xEA"
           "\x24\x83\x49\x86\x3C\xDF\x51\x98\xDB\xA2\x68\x53\xC3\x41\x47\x3B"
           "\x70\x13\x1B\xC7\xB1\x4B\x64\xD3\xD1\x46\xF6\x97\x04\x65\x8C\x24"
           "\x13\xD0\xE5\x85\x7D\xBF\x31\x3A\xB5\x49\x14\xF1\x3F\xFA\xB5\xC1"
           "\x47\x61\x69\x76\x6E\xD2\x9D\x84\xA0\x88\xD6\x65\x35\x6E\xD4\xEB"
           "\x57\x1D\x9F\xF5\xB5\x10\x5D\x12\x05\xA1\xF2\x5A\x37\x4D\x9A\x65"
           "\xBA\xE8\x69\x9B\x02\x93\xAD\x7A\x84\xB0\x6E\xF2\xB6\xB3\x86\x11"
           "\x8F\xF8\xB2\x23\x4E\xD4\x33\x74\x9C\xB4\x91\xD8\x57\x01\x18\x14"
           "\x8A\x63\x13\xFB\x17\x1B\x91\x0E\x35\x71\xD2\x0A\x73\xCD\x99\xA9"
           "\x5C\x10\xD3\xDE\x93\xF4\x5A\x63\xCB\x08\x1E\x8F\x38\x0E\x1A\xB1"
           "\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78"
           , 616);
    nSKLen = 616;
    memset(bInData, 0x42, 128);
    bInData[0] = 0x30;
    bInData[127] = 0x39;
    nInDataLen = 128;
    memcpy(bOutDataExp,
           "\x49\xF1\x26\x3D\x02\xD3\x72\x5C\x05\xD8\x02\xBB\x5D\x28\x69\xD1"
           "\x8A\xAC\xF9\x9A\xBF\x7B\x58\xF3\xB3\xED\xBF\xBF\x2F\xF2\xA1\x6F"
           "\xF2\x19\x08\x99\xEE\x1C\x84\xB6\x09\xB3\x6E\xA8\x40\xE6\xC1\x0D"
           "\xBE\xF1\x86\xB7\xFF\xA3\x60\xB8\x73\x57\xCF\xC1\x5E\xB4\x5D\xA7"
           "\xA8\x77\x40\x52\x43\x65\xB0\x7E\x03\xDB\x26\x82\x58\x1A\xEC\x77"
           "\xF2\x8E\x08\xAA\xF8\x30\x9C\x39\x37\x40\xC0\xFE\xD9\x72\xAA\x73"
           "\x43\x6D\x57\xF2\x93\x40\x4E\xDF\xE5\x0C\xFD\x4C\x9A\x09\x73\x8A"
           "\x55\x33\xD1\xA2\x50\xE3\xBD\xB7\x59\x1F\xBE\xAA\x44\xFF\xB6\xC2"
           , 128);
    nOutDataLenExp = 128;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 616);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 128);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1024，无填充，加密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 128);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 128);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 128);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 0;
    memcpy(bSK,
           "\xDF\x00\x50\x67\x45\x67\xCB\xA9\xF3\x62\x34\x84\x08\x05\xEE\x96"
           "\x70\x77\x07\xC3\x71\x70\xAD\xC0\xE9\x02\xE7\x50\x58\xCB\x00\xCF"
           "\x55\xAA\xB9\xE0\x3D\x47\x8D\xC8\x38\x3A\x78\x92\xB2\x54\x98\xEF"
           "\x5A\x46\x80\x77\x58\x05\x1E\x94\xA8\x62\xE6\xFA\x5C\x54\x15\x48"
           "\x2D\xDB\x8C\x41\x31\x90\x9F\xE9\x4D\x87\x7A\x21\xB9\xA3\x13\xE5"
           "\xE0\xED\x09\x27\x17\xB6\xB1\xAA\x23\xBE\x5F\x80\x9F\x25\xF2\xE1"
           "\x7A\xB2\xCB\x36\xF2\xE5\x2A\x6F\x63\xD1\x4C\xD6\x53\x07\xBF\x83"
           "\x4F\x59\xE1\x20\x63\x9C\x33\x38\x88\xD3\x79\x7D\xF1\x47\x6E\x16"
           "\x3F\x38\xF3\xCF\x0D\x25\xF4\xD5\x28\x76\x55\x5C\x22\x54\x1B\xAD"
           "\xCC\xB6\x21\x81\xFC\x32\xE0\xCF\x8C\x30\x3A\x96\x31\x48\x02\x7E"
           "\x0E\x2A\x4B\x99\x46\x5C\xCA\x23\x82\x41\xA6\x9B\x8A\x71\xF4\x4E"
           "\x7A\xCF\xBE\x9D\xEC\x18\x90\x04\xF2\x6F\x9F\xD9\x76\xFD\x43\x17"
           "\x81\xF0\xD7\xB8\x1B\xE6\x7C\xBB\x5F\xB9\x9D\x8E\x96\x4D\xC5\xE3"
           "\x7A\x98\xBA\x11\x2B\x52\x62\xA3\x48\x6F\x9C\x8F\x3F\x4A\x88\xF4"
           "\xEA\x82\x59\xBD\x2D\x55\x06\x8F\x51\x8D\x37\xA0\xB0\xF4\xA7\x23"
           "\x76\x86\xFF\x68\xEA\x6C\x64\xFE\xC0\xCD\x6C\x48\x20\xCB\xD2\x77"
           "\x31\x73\xD8\x50\x5A\x13\x84\x98\x8D\x0A\xF1\xB9\x8A\xD8\x87\x54"
           "\xDC\xB4\xBA\x6A\x0E\x7D\x04\x4D\x7C\x6C\xF6\xE3\x50\x65\xEF\xC2"
           "\x9C\x70\x39\x70\x99\x60\x53\x70\x88\x1D\xA2\x56\x1A\x78\xB8\x15"
           "\x17\x81\x3F\xEC\x07\x0A\xE0\x33\x7A\x82\x0B\xE2\x21\x53\x1B\x27"
           "\x7C\x06\x69\x00\x82\xB3\xAB\x74\xE9\x43\xDD\xCC\x69\x2C\xF8\x51"
           "\xAF\xEB\xEE\x15\x6E\xE0\x35\xA8\x6A\x0D\x35\x8A\x01\x98\x68\x8A"
           "\xC5\x71\xAA\x8C\xDB\x31\xC7\x04\x5D\xEF\x33\x50\x1A\x66\xC9\xBF"
           "\x85\xE8\x30\xBF\x8E\x36\x86\xA3\xB0\xBF\x18\x8E\xA0\x93\xB3\x5C"
           "\xD2\xD3\x6E\x57\x86\x14\x30\x5D\xC5\x29\x0B\x5A\xEF\xEA\xA3\x9C"
           "\xC0\xDD\x9B\xDF\x67\xB9\xAF\x01\xC4\x0C\x83\xE1\x36\x95\x4E\xB6"
           "\xF2\x61\x4F\xB8\x09\x8E\x66\x90\x23\xE7\x6D\xD1\x71\xF4\xF4\xE7"
           "\xF4\x3B\x54\x8D\x91\x05\x89\xB5\xFE\x78\xBA\x30\x87\xF5\xB5\xE6"
           "\xE8\x55\x5B\xCA\x64\xAF\x89\x59\xA0\x50\x8A\x7D\x19\x40\xDF\x49"
           "\x31\xEA\xEF\x76\x70\x2E\x1F\xC7\x05\x7E\xA0\x2A\x42\x17\xA2\x0A"
           "\x32\xAC\x36\x7F\x31\xFF\x11\xED\x06\x13\x03\xC6\xDF\xEF\xC4\x27"
           "\x8C\x29\xE3\x36\xE6\xDE\xBC\xE8\x7B\xB5\x7B\x9A\xCB\x93\xF1\x21"
           "\x26\x38\x94\xDA\xF5\x1B\xD7\x2F\xA9\x3C\xEC\xE3\xDC\xD6\xD8\xFC"
           "\x03\x4D\xE1\x49\xA2\x22\x6E\xFD\x57\x80\xAB\xF4\xFA\xD5\xC2\x53"
           "\xCE\x6D\xB2\x61\xE3\xA8\x22\xD8\xD2\x9C\xFE\x85\xE2\x80\xA0\x9D"
           "\x1E\xAF\x00\x3F\xF2\x36\xE1\xE5\xBC\x32\x73\x7E\xD0\x6E\x18\x66"
           "\x48\x64\x91\x0E\xB6\x70\x82\xAA\x40\xFA\x2D\xB5\x27\x0A\x71\x17"
           "\x15\x96\xD4\x2B\xEF\xB4\x82\xA2\x4C\x7C\x08\x2B\x9E\xD6\x99\x56"
           "\x20\x08\xCD\x7D\x6B\x5E\x38\x53\x67\x13\x38\xED\x16\x44\x71\x12"
           "\x97\x4B\x84\xE7\xCE\x12\x53\x70\x46\x6A\x71\x51\xAD\x8B\x71\x2D"
           "\xE5\x4C\xF7\xFF\xCE\x39\xB3\xA0\xB1\x46\x26\x4F\x1A\x63\x0C\xB9"
           "\xEE\x8F\xC7\x8E\x61\x24\xD0\xFB\xD4\x33\x00\xFD\x85\x23\x8B\x12"
           "\x09\x49\x7D\xA8\xE2\x9D\x2E\xFD"
           , 680);
    nSKLen = 680;
    memset(bInData, 0x42, 144);
    bInData[0] = 0x30;
    bInData[143] = 0x39;
    nInDataLen = 144;
    memcpy(bOutDataExp,
           "\xB0\xA9\x44\xA4\x66\x2A\x0C\x24\x8E\x7A\x5F\xF9\x0E\xE1\x47\x6B"
           "\x47\x06\xAB\x46\x19\x35\xFB\x46\x8E\xFD\x8F\x2C\xC0\xF7\x67\x8A"
           "\x2A\x96\x3B\x64\x9F\xE8\xFF\x03\x8D\x56\x80\x5B\x2A\xAB\xB2\x41"
           "\x0F\xC0\xB5\xD9\x1C\x46\xBE\x25\xFD\xD9\x1A\xF9\xAA\x37\x91\xCC"
           "\xD6\x37\x84\xF3\x53\x03\xFB\xDB\x33\xB7\x25\x22\xB6\x74\x8A\xAC"
           "\xD6\x7F\xB7\x36\xD2\xE9\x07\xFF\x45\x88\xE2\xEE\x82\x36\x75\xDA"
           "\xC3\xC1\xE6\x63\xF4\xAD\x63\x6D\x5C\x52\x2E\x18\xC5\xE4\xDA\x2D"
           "\x39\xC2\x41\x59\x5B\x06\xED\x86\xBA\x1A\xFC\x09\xEA\x8D\x26\x0E"
           "\x5B\x74\xBA\x40\x8D\x0F\xDE\xF7\x44\x30\x04\xC6\xD2\x79\x92\xD1"
           , 144);
    nOutDataLenExp = 144;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 680);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 144);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1152，无填充，加密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 144);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 144);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 144);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 0;
    memcpy(bSK,
           "\x21\xE5\x82\xE3\xD4\x2B\x83\xA7\x68\x16\x92\xEF\x49\x12\x6D\x45"
           "\xC5\x11\xC5\x1E\x9E\x67\x6F\xF9\x04\x47\x04\x31\x37\x69\xFD\x3D"
           "\x6C\x60\x8F\x08\xC7\xF3\xF1\x69\xDF\xCC\x66\x75\xEA\xB0\x61\x33"
           "\xAF\x7A\x12\x41\x94\x5A\x51\x39\xB5\xBE\xE7\x4C\x9D\x98\x77\x80"
           "\x6C\xB9\x2B\x98\x4E\x55\xEC\x57\x0E\x8A\x1F\xA8\x52\xDE\x44\xC5"
           "\x08\x2F\x21\xD9\x0E\xDD\xB5\x5E\xF3\xA1\x8C\xF1\xC3\xCB\x0A\x18"
           "\xD3\x80\x83\x10\xEB\x2E\x99\x59\x45\x7D\x2B\x92\xF5\x22\x7B\x49"
           "\x67\x02\x84\x5F\x56\x56\xBC\x95\x04\xA4\xB7\xB7\x53\xAE\x19\xF1"
           "\xF8\x7C\x3D\xEA\xDA\xDF\x52\x99\xF5\xB4\x15\xAB\x03\x8B\xBD\x6B"
           "\xC0\x8C\x86\xFC\x56\xCC\x3C\x0C\x38\x31\xBD\xB7\x28\x29\xAC\x0E"
           "\x24\xF2\x12\x6E\x6A\xFC\x01\x1C\x18\xC6\x3A\xCD\xD8\x0A\x64\x27"
           "\x93\x9D\x76\xAA\x27\x42\x7E\xEF\xFB\x83\x2A\xB5\xF3\xD0\x15\xC8"
           "\xEF\xF4\x3E\x5B\x5F\x3B\x4F\x96\x2C\x76\x6A\xD6\x69\xD7\x57\xC1"
           "\xF6\x40\xDF\x49\x7B\x4A\x9B\xE2\x7A\xE3\x09\x8B\xC9\x47\xA9\x14"
           "\x5F\x1D\xC1\x4A\x7F\x9D\xCF\xEF\x7D\x1A\x91\x6F\xC7\xA0\x41\x7F"
           "\x7B\xC3\x15\x00\xEC\x53\x34\x22\x95\xEE\xE7\x08\x39\x63\xF5\x54"
           "\xB6\xAD\x39\x45\xB5\x21\x5C\x34\x5E\x67\x7B\xD8\x97\x50\x91\x75"
           "\x6F\x68\x0A\x95\x8F\x24\xBE\x83\xDB\x44\x91\xE0\xD2\x99\x24\x99"
           "\xBD\x11\x2E\x15\xA9\xCC\xCD\x14\xD9\xBB\x5E\x56\x0F\x69\x9A\x18"
           "\x5A\x42\x25\xB1\x3F\x6B\x03\x18\x51\x9C\x36\x8F\xDB\x1E\xB9\x11"
           "\x3A\xEF\x24\xDB\x9B\x2E\xA2\x1B\x11\x73\x86\x5A\x4C\x12\x4F\xD8"
           "\xCB\x07\xEE\x99\xAC\x04\x10\x2B\x1C\xD7\xB8\xEB\xE7\x56\x2C\x8A"
           "\x12\x36\xDD\xA0\x11\x9D\xC8\x26\x37\x66\x0B\x21\x89\xC3\x7D\xA1"
           "\x40\x85\x91\xFF\x5E\x80\x70\xFB\x68\x28\x03\x8A\x6F\x09\xBC\xD6"
           "\xAC\xAF\xF4\x60\x67\x8D\xA8\x3E\x17\x5B\x5A\xE9\x3E\x17\xA9\x34"
           "\xA9\xD7\x29\xBE\xBE\xE3\xCD\x09\x74\x23\xC7\x21\xEE\xA2\x63\xA2"
           "\x33\x64\x92\x53\x31\x74\xF2\x96\x0C\xD0\x11\x30\xB6\x9F\xE0\xBA"
           "\x5B\x4C\xFA\xA0\xBB\x83\x1C\x74\xD8\x70\xE0\x4B\x2A\xAA\xBD\x88"
           "\x4A\x1E\xB5\x22\x63\xD7\x2E\xBD\xA4\x8E\x6C\xA3\x10\x29\xE8\x29"
           "\xA8\x43\x89\x66\xB7\x7E\x3D\xBE\x8C\xE3\xFC\x5A\xBF\x06\x0B\xCC"
           "\x34\x91\x9D\xE3\x85\x1D\xB7\x39\x03\xC3\x0C\x05\x17\xA4\x8D\xE0"
           "\xB3\x9E\x01\xF7\x80\xF4\xBB\xF0\x22\x23\xDA\xBD\xC4\x14\xBB\x78"
           "\x58\xC5\x7F\xC6\x09\x41\x54\xBB\x11\x96\xE6\xA3\x1A\xC9\x55\xBD"
           "\x0F\xF0\x3F\xBE\x61\x83\xCE\x26\x82\xA2\x8E\xD5\x0D\x2D\xB7\x66"
           "\xBC\x2E\xF0\xEB\xC3\x2F\x6A\x2A\xF5\xB9\x8B\xF0\x42\x4F\x65\x8B"
           "\xD1\x6E\x76\x88\x8C\x29\x34\xCF\x26\x27\x84\x8E\x6B\xA2\xEB\x16"
           "\x77\x2D\x21\x7E\xEC\x18\x4D\x04\xDA\xEF\x95\x1C\x29\x75\x18\x1C"
           "\x83\xCA\xB6\x72\xC3\x77\x46\x29\xBB\xFC\xDE\x1D\x78\x72\x76\x47"
           "\x20\x40\x90\xDC\xBC\xA3\x72\x33\x64\x7E\x18\xD9\xA4\xD2\x46\x9C"
           "\x77\x8B\xF9\x6D\x97\xB0\xD6\xA1\x20\x2C\x0D\xB6\xE3\x2C\x09\x8F"
           "\x07\xB6\x5F\xD3\xDB\x3B\xFD\x77\x69\x7D\x56\xE4\x35\x18\x3A\x9B"
           "\xF6\x22\x3A\x01\x35\x71\xBE\xA4\x48\x97\x8B\x45\x90\x46\x07\x0E"
           "\x17\x68\x9E\x00\x11\x6F\x4A\x25\x55\xA0\x9C\x74\xD9\x15\xFF\xF5"
           "\xE0\x59\xD6\x86\xA0\x91\xD8\x7F\x9A\xFF\xE4\xBD\xAB\xE3\xF0\x94"
           "\x49\x66\x36\x7F\xD3\xD3\x8E\x13\xB7\xFC\x89\xB7\xA9\x3C\x7B\x0E"
           "\x11\xAC\x66\xCE\x34\x34\xAE\x67\x70\xE0\x3A\xB6\x0E\x78\xFD\x94"
           "\xF1\xB5\x74\xD3\x47\x2A\x74\x40\x51\x39\xD1\x49\x73\x94\xB4\xF9"
           "\x4C\xB6\x4B\x11\x19\x2F\x7E\x34\x3E\x6B\x4F\x34\x5B\x83\x52\x47"
           "\x99\x0C\xD6\xDF\x7B\xA3\x95\xE2\xCC\x39\x2F\xC4\x92\x43\x38\x2F"
           "\xCB\xE6\x8C\x2D\xAD\xD0\x5E\xE9\xD5\x3D\x5E\x70\x2E\xA8\x66\xB0"
           "\xA6\xB8\x7C\xA4\x3A\x9E\x28\x3B\x0E\x46\x20\x84\xF8\x5E\x53\x9E"
           "\xCF\xDE\xF3\x0F\x1F\xE3\x8D\x51"
           , 824);
    nSKLen = 824;
    memset(bInData, 0x42, 176);
    bInData[0] = 0x30;
    bInData[175] = 0x39;
    nInDataLen = 176;
    memcpy(bOutDataExp,
           "\x70\xDB\xFE\xCC\x0E\xBC\x43\x62\x17\xA5\x29\x65\xE3\x3F\xB7\x04"
           "\x39\x4D\xD8\x69\x8F\x51\x59\xC8\x26\x9A\x62\x46\xCC\xC5\x81\x35"
           "\x3A\x86\x95\x2C\x4C\xCB\x35\x54\x6E\x6C\xF6\x09\x00\x5F\xF3\x80"
           "\x57\xF9\x71\x71\x1A\xC0\xE9\x79\x89\x7C\xEB\x2D\x0D\x84\x33\x24"
           "\x9D\x04\x70\x4A\x78\xB7\xAC\x91\x7D\xE7\x3E\x7B\x34\xB8\x2C\x4C"
           "\x36\x4D\xF7\x0E\xAE\xAC\xC8\x52\x31\xE1\x81\x53\x39\xFE\x43\x7F"
           "\x91\x51\x8B\x5E\x3A\x3F\xFC\x0F\xB8\x30\x94\xE4\xBC\x19\x3B\xA3"
           "\x40\x2C\xAD\x4A\x59\xD5\x69\x99\x42\xFA\x59\x27\xDF\xE0\x15\xF7"
           "\xA5\x1E\xB4\xC1\xB9\xD9\xA9\xB6\x0B\xC2\x79\x0A\x2F\x41\x56\x7D"
           "\x69\x1B\x67\x05\x1E\xE1\x50\xF2\xAD\x47\x90\x51\xA3\x81\xF9\x09"
           "\x9C\xCE\x76\x11\x9B\xD4\x0C\x9A\x78\xEC\x31\x67\xBB\xA9\x26\xC5"
           , 176);
    nOutDataLenExp = 176;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 824);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 176);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1408，无填充，加密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 176);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 176);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 176);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 0;
    memcpy(bSK,
           "\x6C\x18\x21\x1D\x3D\xDC\x38\xA8\xBA\x10\x33\x70\x83\x41\xB5\x37"
           "\xFE\x97\x6F\xB1\xF4\x21\x1A\xAD\x35\x77\xBD\x28\xB2\x57\x20\x10"
           "\x16\x13\x93\x89\x47\xC3\x73\xFC\xB9\x76\x48\x3A\x77\xCD\xA7\x0C"
           "\x17\xE9\xF1\x4C\xD0\xA7\xE1\xAA\x0D\x9A\x8C\x38\xD1\xE6\x83\xA6"
           "\x93\xD4\x55\x28\x6B\xB9\x0F\x81\x02\x7A\x78\x54\x00\x84\x94\xFB"
           "\x82\xCC\x8A\x78\xFC\x93\x45\x6E\xD3\x13\xD3\x1F\x18\x69\x73\x2A"
           "\x70\x86\x1F\xFB\x25\xE6\x2A\x64\xCC\x6F\x1F\x18\x26\x0D\x1C\x40"
           "\xAA\x5E\x52\x50\x22\x5A\xE4\x3C\xBC\x29\xFA\xCA\x30\xE3\x53\x40"
           "\x34\x35\xF1\xD0\xE2\x69\x1D\x34\x8E\x83\x96\xAC\xAA\xCF\x6C\x98"
           "\x3F\x4F\x8C\xEF\x8C\xB3\x3A\x04\xF5\x7C\xB1\x76\xA3\x32\x1B\xC1"
           "\x83\xAD\x70\xA5\xF9\x08\xB8\xD9\x2E\xED\x15\x65\xB0\x33\x30\x04"
           "\x1F\x69\x87\x1D\xFF\xBF\x0F\x59\xE3\x62\xE1\xE8\x2C\x03\x4B\x72"
           "\xB6\xAA\x8F\x73\xBA\xFE\xEE\xCC\xAF\x50\x87\x3D\xA0\x5F\x66\xA0"
           "\x88\x3A\x7F\xDF\xA1\x8E\x06\x08\x18\x2C\x1A\x16\xCE\x0C\x6E\x13"
           "\x4F\x2E\x26\x3B\xB8\xAF\x70\x5E\x70\x48\xED\xCE\x8D\x6C\x9B\x26"
           "\xD7\xFE\x95\x5F\xC6\x91\xB6\x81\x3F\x7C\x9A\xF1\x6D\x1B\xAB\x6E"
           "\x84\x10\x94\x5A\x07\x38\x56\x75\xF0\xEB\x3C\x5E\xA3\x0E\x85\x17"
           "\xFB\x5B\xD0\xFA\x84\x3D\x58\x4C\xFD\xF0\xE5\x37\x77\x29\xE2\x5A"
           "\x7C\x74\x87\x04\x9C\xF0\x7A\x2C\xE4\xD2\x0A\x1C\xD8\x8B\x37\x8C"
           "\x7F\x1C\x10\x6E\x73\xB2\x69\x4C\xBE\x1A\x84\x3C\xC8\xA7\xA3\x68"
           "\x48\x7E\x2F\xFD\x9B\x5F\x12\xAD\x15\x49\x3F\xC4\x10\x86\xAF\x56"
           "\x4D\xCB\xC6\xE8\xAD\x35\x72\x21\x24\xD9\xC3\xA3\x82\xF1\xB2\xAF"
           "\xD9\x88\xBF\xFB\xCB\x81\xF9\xF6\x3B\xC6\x1C\x34\xF0\x5A\x33\xE5"
           "\x41\x9B\xC2\xF9\xE2\x23\x0E\x2D\x11\xC5\xBF\x41\x91\x7B\xE9\x36"
           "\x07\xD8\x60\x00\x09\xDD\xD5\x86\xD7\x65\x50\x98\xBC\x5C\x0E\x60"
           "\xA0\xE5\x53\xEC\xA6\x9D\x11\x99\xEA\x25\x44\xF4\x50\x76\x0D\x4D"
           "\xE7\x72\x87\xCF\x6F\x7C\xF2\x27\xED\x73\xD7\xEF\x53\x6D\x0B\x99"
           "\x6B\x38\x44\xBC\xC0\x12\xF5\xD6\x92\x3F\x64\x81\x54\xC1\xEF\x04"
           "\x5C\x1F\x23\x7E\xF5\x38\xA7\x80\xFC\x17\xEF\x00\x3C\x8D\x09\xAB"
           "\xAA\xD0\x40\x14\xD7\xCB\xAC\xA1\x29\xE0\x12\xD5\xD4\xFF\x1B\xDD"
           "\xCA\x78\x2B\x1D\xEC\x9F\xA5\xAC\x67\x74\x31\x8C\xF6\x8F\x9A\x59"
           "\x7D\x84\xF1\x7E\x5D\xA4\xC9\x53\xEF\x58\x2D\x1F\x0F\x3A\x6D\x66"
           "\xFF\x06\x61\x1A\xDC\xDB\x19\x0C\xE6\x43\xC4\x4A\x2B\x3D\x8E\x79"
           "\xD4\x93\xA8\x9A\x1A\xF7\x91\x45\x77\x78\xAB\xE1\x77\x33\x26\xFF"
           "\x92\x0B\x96\xD5\xF3\xAF\x05\x0B\xC4\x53\x1B\x89\xEC\xDC\xD0\x12"
           "\x4A\x65\xF3\xAD\x43\x8C\x23\x35\x13\x79\x4E\xD8\x0D\x21\xC9\x61"
           "\x49\xCA\x48\x53\x48\xC6\xA1\x7E\xF0\x28\xA5\x97\x11\xB8\x18\x33"
           "\xAD\xEC\xEF\x6B\x5C\x71\x4A\xBE\x9F\x31\xB8\xA3\x98\xC5\x0C\x0B"
           "\x46\x51\xA2\xAE\x02\x6F\x98\x35\xF7\x4D\x21\x5E\xC3\xED\x61\xB0"
           "\x6B\x59\x79\x5A\xB9\xA8\x1C\xB0\xBA\x82\x67\xB9\x97\xBB\xD4\x4D"
           "\xF1\xA1\x56\x5C\x7D\xCB\x77\xD0\x28\xE0\xFF\x1C\xAA\x22\x07\x68"
           "\x9B\xF3\x80\xDE\x96\x1D\x03\xDD\x97\x8A\x69\xDA\x5C\x54\xD4\x80"
           "\x93\xB2\x0D\xCD\x43\xBA\xFC\xDF\x11\xCF\xFE\xCE\x3B\x74\x8E\x67"
           "\x17\x74\x8E\x29\xF9\x64\x97\x52\x8C\x7B\xC9\x71\xB3\x5E\x59\x86"
           "\x63\x38\xF6\x9E\x79\x43\x56\xD6\x6F\xE6\x26\x45\x62\x64\x26\xE0"
           "\xA7\xDC\x70\xCA\x5B\xCD\xE7\xC6\xE1\x1F\xFC\x97\x57\xA1\x2B\xC5"
           "\x12\xB6\x9E\x85\x37\x9E\x58\x48\x2F\x9A\x91\xB7\xB6\x7C\x28\x47"
           "\x1A\x73\x45\x41\xD4\x6E\xBE\xB5\xB7\x60\x1A\xF2\x8B\x04\x78\x38"
           "\x4B\xB6\x45\x8C\xA9\x3E\xE5\x7A\xBF\x1F\xC4\x86\x30\xB4\x0C\xB1"
           "\xC6\x9D\x80\x88\xD2\x49\xD9\x89\xD9\x50\xA8\xDE\xEC\xA5\x04\x7F"
           "\xFF\xEA\xC0\x2F\xCB\x37\x7A\xB6\x97\x59\xAD\x53\x29\x34\xB3\x79"
           "\x16\x3B\x3E\xF5\x7F\x14\xB3\x77\xF9\x2E\xE8\x3F\x04\xAE\xDE\x89"
           "\x73\x04\x32\xA7\x4C\xC0\x4D\x43\x0D\xC1\xE5\x21\x48\x32\xAA\xE1"
           "\x5E\x81\xB6\x23\x6A\x80\xCA\x17\x23\xFC\x5F\x47\xE1\x57\x14\x59"
           "\x46\x67\x0F\xBF\x6A\x57\x53\x10\x8E\xAB\xAA\x9C\x8A\xDD\xE0\x9D"
           "\xA2\xAC\x94\x87\x6A\x71\xD0\xAF\xE4\x8A\xCF\xEB\x23\x27\x00\xC2"
           "\x8B\x11\xA9\x2C\x02\xB5\x05\x03\x30\x7A\x0C\xEF\x7F\x5B\x1C\xE7"
           "\x64\xFF\x1E\x68\x78\x28\x1C\x6D\xA0\x16\x75\x36\x7F\x9F\xF9\xCD"
           "\x15\x3B\x8E\x26\xC3\xF1\x7A\xBC\x17\x42\x92\x7D\xA8\x4E\x22\x5F"
           "\xB9\x55\xF5\xB7\x2C\x10\x5E\x79\xBB\x81\x54\x32\xDC\x8D\xE7\x4B"
           "\xE3\xCB\xDB\x1D\x34\xA4\xBA\x5F\x1A\xFE\x43\x48\x46\xEF\x88\x67"
           "\xD5\xB6\xDD\x06\x99\x5C\xB3\x38\x45\xED\xD0\x21\x77\x22\xF4\xF3"
           "\x68\xD6\x90\x53\xB5\x1E\x36\x3C\x35\x08\xCF\xBE\x53\x8F\x59\xDB"
           "\x4D\xAA\xA2\xB4\xF9\x93\xAC\x4C\x0C\xE4\x5D\xDF\x79\x57\x3C\x8F"
           "\x42\x44\xEC\x0C\x09\xA9\xC6\xE8\xF9\xF0\x80\x2E\x76\x25\x2E\xC1"
           "\x72\x0E\x55\xD6\xB9\x78\x9A\xAE\x56\xFE\x8B\x35\x38\xAF\xE3\x80"
           "\x78\x57\x55\x15\xC9\xEC\xCC\xCB\x42\xC3\xC5\xDF\x8A\xAE\x67\xB0"
           "\xCD\x63\x8E\xFC\x28\x77\x7F\xD1\x31\xFD\x9D\xD2\x79\xC8\x0A\xE0"
           "\x1A\x86\x0D\xEB\x3B\xB4\x64\x49\xAA\x6B\x7B\x73\x27\xEC\x7D\x66"
           "\x6A\x4C\x37\xB3\xCD\x4E\x97\x97\x3C\xEF\x7E\x13\x45\x36\xAA\xFE"
           "\x2E\x16\x48\x90\x5F\x53\x63\x62\xC7\xAB\xC9\xC7\xB5\x9E\xFD\xA5"
           "\x8B\x0C\xCA\xD0\x1E\xBD\x51\x67\x98\x94\x63\x08\x13\xCC\x05\xB9"
           , 1152);
    nSKLen = 1152;
    memset(bInData, 0x42, 248);
    bInData[0] = 0x30;
    bInData[247] = 0x39;
    nInDataLen = 248;
    memcpy(bOutDataExp,
           "\x80\x53\x6B\xC0\x3E\x28\x0B\x6A\x05\x1E\x61\x1B\x16\xB6\x0E\xB1"
           "\x76\x55\x38\x95\x7E\xDA\x4E\xC5\x18\xE9\xC1\xBC\x34\xAE\xCC\xA5"
           "\x1E\x26\x4B\xC3\xEA\xA6\x5E\xC6\x3E\x77\x4C\x7E\x26\x60\x06\x2E"
           "\x8E\xDD\xF7\xC9\xC1\x5D\xF2\x7A\xD2\x9B\x1A\x47\x0F\x4B\x9B\xC6"
           "\x3A\xD5\x18\x33\x39\x0D\xBB\xFB\x85\xF0\x4F\x35\x86\x45\x0E\x09"
           "\xDE\xC8\xDC\xF8\xB3\x3D\x62\x13\x77\xC5\x14\x15\xB1\xA3\xC5\xC1"
           "\x81\x8B\xCC\xC6\xAA\x43\xA1\x60\x05\x46\x4A\x97\x16\xF3\xEC\xA9"
           "\xD2\x82\xA0\x01\xCF\x05\xB9\x13\x6A\xA3\x18\xD1\x30\xE0\x75\xEF"
           "\x43\x81\x76\xF6\x38\x2D\xAC\x56\xE6\x15\x1F\x68\xB7\xFE\x18\xC8"
           "\xA4\x6D\x98\x17\x76\x12\xAA\x1C\x4B\x3C\x34\x03\x2E\xC8\xC0\xCC"
           "\x04\x34\x33\x3A\xCD\x77\xAB\x62\x3F\x14\x1B\x1F\xA3\xF8\x43\x00"
           "\x53\x96\xBC\xEB\x03\xEC\x51\xA7\xEC\x67\x8A\xC5\x72\x06\x1A\x0B"
           "\x87\x98\xDA\xAF\xE5\x5A\x7F\x79\xA9\x28\x67\x6B\xBF\x09\x76\x52"
           "\xD8\xE2\xC9\x09\x64\xD1\x5B\xEA\xEF\x7E\xD0\x5F\x20\x6F\x88\x4C"
           "\xDB\x27\x16\x1B\xEA\x19\xF7\x07\x18\xDF\xD6\x75\x59\x08\x80\x89"
           "\x48\x2E\x50\x39\xDF\x53\x6F\x36"
           , 248);
    nOutDataLenExp = 248;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 1152);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 248);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1984，无填充，加密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 248);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 248);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 248);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 0;
    memcpy(bSK,
           "\xB6\xF8\xDC\x3E\x12\x98\x52\xB8\xB1\x84\xC0\x51\x97\xD1\xBE\x87"
           "\x70\x24\xD7\xE1\x4A\x71\xC3\x20\xA9\xEE\x78\x93\xF8\x99\x5C\x1A"
           "\xE5\x32\x78\x65\x85\x07\xEB\x5E\x26\x79\x2F\x1E\xE1\x6E\x6E\xB9"
           "\xF7\x6A\x23\x46\x09\x92\xD0\x54\xD2\xCA\x6C\xB6\xCE\xB0\x0B\x1C"
           "\x83\xD3\xEB\x1B\x6F\x47\x05\x82\xBF\x68\x23\x24\x90\xDD\xA0\x4C"
           "\xAD\x00\xC2\xD6\xBE\x7D\x8C\x5C\xBF\x1B\xF6\xE1\x73\x51\x9E\x6D"
           "\x62\x46\xBF\x62\xD5\xA6\xD6\x93\x17\x5D\xEE\xEF\x03\x82\x5E\x89"
           "\xA5\x42\xF3\x09\xB1\x20\x11\x48\x39\x90\x8A\xBD\xAA\xE3\xA8\x12"
           "\x4E\xD2\x36\x25\x16\x60\x73\x35\x44\x99\x56\xFE\xED\xF1\xC7\x48"
           "\x57\x57\x56\x27\x7C\x94\xC5\x2D\x6B\x77\xFB\xDC\x82\xD8\xD0\xE0"
           "\x2D\x0E\x4D\x64\x5B\x98\x07\x49\x8A\x29\x70\xD9\xDE\xA9\x44\xC5"
           "\xDE\x71\xCE\xF5\xE0\x63\x40\x28\xF4\xD6\x6D\x86\x14\xCF\x70\x24"
           "\x5B\x05\xAE\xC7\xE9\x69\x7B\x42\xAB\xF6\x53\xA3\x97\x1C\x93\x61"
           "\xCE\x7E\x8F\x38\xF1\x85\xC6\xB8\x2C\x6F\x11\x3E\xA6\xF1\x18\xF8"
           "\x85\xAD\xF2\xE3\x32\x82\x51\x0D\xEB\x12\x68\xC0\x1B\xCD\xF2\x3A"
           "\xB5\x55\xCD\x1A\x92\x9D\x31\xDF\xA6\xB2\x7A\xEE\x99\xA1\x39\x62"
           "\xC9\xE5\xFD\x47\xD0\x37\xCE\x6C\x08\x33\x31\x58\x38\x7B\x3F\x77"
           "\xFF\x4B\x01\xFC\x24\x58\x33\x24\xEB\xA6\xE2\xEE\x33\x1B\x67\x52"
           "\x81\x19\x16\x3A\xFA\x23\x82\x1B\x61\xEE\x5B\xDD\x08\x83\xA4\x5D"
           "\xCC\x57\x5A\xBF\xA5\x5C\x6E\xD7\xB0\xA2\xB6\x73\x52\x92\x9E\x5C"
           "\x46\x8D\x3E\xFB\x15\x1C\xB2\x7E\xD0\x90\x09\x61\x4F\x98\xFF\xEE"
           "\x8C\x40\x99\x83\x62\x1C\x2A\x29\xA9\x35\x58\x08\xF7\x97\xE6\xC7"
           "\x74\x50\xC9\x7D\xBF\xA2\x61\x51\x57\xD2\xDB\xDD\xE7\x19\xEF\x75"
           "\x26\xC0\x48\x56\xD9\x38\xFC\xF6\xF1\xEC\x6E\x96\x72\xCE\x2F\x19"
           "\xCA\x17\x76\x25\xFA\xDB\x0A\xBF\x4E\xD3\x6F\x65\xE2\xA3\x53\x9F"
           "\x0F\x91\xCF\xA8\x32\x9D\x83\xF1\x62\x54\xA3\x3E\x89\xF9\xD3\x20"
           "\xE8\x10\xE5\xE8\x6A\x73\x40\x90\x9A\x9D\x21\xD0\x9E\xEE\xFA\x44"
           "\x29\x42\x36\x61\xF0\x89\x9E\xE2\xFA\xBE\x06\x74\x7A\xAC\x2A\xF6"
           "\xA6\xFE\xE0\x7E\x17\x7C\xDA\xA7\x4B\xA3\x33\xD0\x66\x40\x56\x07"
           "\xB5\x21\x1A\x1E\x17\x3B\x43\x62\x9C\x0D\x16\xFA\xF3\x09\x93\x99"
           "\x56\x6C\xFD\x6A\xB7\x64\x04\x77\x33\x61\x13\x13\xD0\x93\x30\xD7"
           "\x78\xAE\xD3\x91\x30\xC2\x2C\x81\x39\x88\x9F\xE3\x9B\x4F\xF0\xC8"
           "\xFF\xA0\xA7\xED\x5F\xC3\xD7\xFE\x9C\xA7\x85\x7D\x1E\x7E\xA6\x7C"
           "\xD7\x6C\xEF\x3A\xAD\xE2\xFE\x2E\xAD\x45\x17\x9E\xC8\xA9\x71\xAB"
           "\xBF\xB6\xE3\x16\xEC\x4B\xF5\xA7\x9D\x20\x72\x87\xB4\x7E\x80\x89"
           "\xD6\xEF\x8C\xEA\x5D\xD5\xD2\x26\x9B\x3E\x58\x2C\xEB\xE6\x07\x1A"
           "\x05\x01\xD6\xBB\xFB\xA4\x2C\x31\x7A\xC0\x03\xB2\x14\x3D\x95\x41"
           "\xB5\xE3\x35\xA8\x86\xCF\x8C\x68\xFE\x01\x75\x0F\x3B\x77\x56\xA2"
           "\xCF\x29\x24\xFE\x99\x37\x02\x75\x65\x0E\xD6\xD2\x82\x9A\x93\x74"
           "\xAD\xBE\x1E\x56\x13\xC4\x29\x53\x35\x57\x4B\x46\x22\x4B\xB8\x50"
           "\x53\x71\x44\x27\xA8\xBC\x5B\x31\x0A\x32\xD4\x0F\xFF\xB2\x32\x5F"
           "\x39\xCD\xB1\x90\x77\x70\x23\xF9\xF4\x85\xDA\xE9\x16\x9D\xD5\xA0"
           "\x2A\x71\xF9\xF4\x40\x7D\xD1\x24\x5D\xBF\x93\xB3\x7F\x0D\x95\x67"
           "\x19\x51\x18\xA0\x99\x7A\x84\x44\x71\x9A\x08\x0D\x98\x25\x2E\xA6"
           "\x55\x6B\xEC\xA9\xA0\x72\xA4\xEF\x41\xC4\x20\x67\xA8\x86\xC9\x82"
           "\x86\xE8\x58\x5B\xA6\x8B\xCB\x30\xED\xF7\x7B\x0E\x6A\x6F\x6C\x39"
           "\x7A\x48\xA8\xE1\x9C\xEE\xC5\xDF\x08\x4B\xC9\x0A\x5D\xA0\x34\x42"
           "\xB5\x79\x5C\x29\xAF\xA9\xF8\x84\x31\xBE\x94\x21\x29\x17\x82\x99"
           "\x81\xB4\x9E\x2B\xC9\x78\xC5\xA6\x25\xD7\x28\xEE\x3A\xD2\x3B\xD8"
           "\x05\xCE\xEA\x07\x92\xD4\x8B\x4D\x64\xB4\x7F\x57\x9D\x2A\xFB\x80"
           "\xFF\x16\x09\xE2\x9A\xAC\x7E\x32\x2D\x2B\xE7\xA2\x9F\x9F\x63\xAF"
           "\x59\x62\xC6\x8D\x51\xD9\x2F\x6B\xF2\xB8\xEA\x9B\xAE\x30\x7A\xBB"
           "\x76\xC7\xDE\xB7\xF8\xF0\x33\x2E\x69\x65\xC0\x89\x2B\x82\x72\xAE"
           "\x8B\x65\x53\xEF\x96\xA4\xCC\xE6\xAB\x80\x9D\x23\x51\xCB\x77\x5B"
           "\xAB\x75\x5A\x70\x7B\x9C\xBE\xD6\x44\xCD\x0A\x3A\x1C\xF8\xD7\xC8"
           "\x9E\x68\x2B\xA2\xB6\x30\xC4\xE7\x3A\xF2\xDA\xE4\x15\xDE\x80\xD5"
           "\x03\xF6\x06\x3E\x19\x0B\x09\xF5\xE1\xED\xE9\x82\x79\x02\xD7\x21"
           "\x5C\x71\xFE\x15\xCB\xB5\x85\xB1\x12\x75\xF2\x94\xFC\xB7\x24\x14"
           "\xFF\xDE\xA6\x49\x7D\x61\xF8\xAE\x83\x40\x97\xC6\x13\x8F\xD6\xE2"
           "\xDA\xE8\x9D\x66\x71\x4A\x22\x1F\xF9\x55\x79\xAA\xE0\xE6\xD7\x29"
           "\x3D\x44\x2E\xC0\xB9\x4D\x64\x65\x2A\x0E\x4A\xB8\x62\xC1\x84\x2E"
           "\x3F\x6F\xEB\x79\xDF\xCF\xAA\x83\xB9\x7C\x73\x7E\x48\x88\x44\x03"
           "\xEA\x4F\x09\xCD\x72\x37\xA7\x49\x37\x6E\x52\x57\xFC\x64\x17\xE5"
           "\x9E\x36\x4D\xD7\x33\x82\xA5\x42\x3F\x37\x96\xE9\x00\x70\x91\x7E"
           "\x1F\xFF\xCD\xD3\x39\xD8\x27\x8F\x67\x81\x51\xF8\x03\xB5\x3A\xB9"
           "\x57\x64\x16\xBF\x7F\x0C\xD6\x74\xE7\x37\xB2\xFD\xF4\x20\x1B\x4C"
           "\xFD\xFC\x5C\xEF\x78\x30\x05\x38\xD7\x51\xE8\xD3\x16\x0A\x7D\x8C"
           "\xBA\x84\x9D\x1F\xF5\x6F\xE7\x15\x41\x1D\x3E\x40\x4D\x98\x64\x46"
           "\x43\x35\xA6\xBB\x0B\x0D\xF3\x39\x1D\xF9\x2B\x8C\x8E\xBD\x43\x9B"
           "\x39\x39\x10\x04\x06\x0B\x31\x7C\xF0\x1E\xE1\x70\xB1\x55\xD1\x59"
           "\xBE\x38\x24\xC8\x3E\x53\x30\xF7\x0F\xCE\x37\xCD\x5C\xF7\x90\x33"
           "\x85\x7F\x4D\x02\xAB\xEA\x50\x12\x18\xF3\x6E\x56\xA8\xEE\x38\x08"
           "\x8F\x94\x95\xAE\xE3\x74\x54\xCF\x0B\x88\x16\x7D\x2E\xBA\xAB\xCE"
           "\xCD\x7B\xA5\x62\x51\x84\x6A\x30\x0E\xF6\x44\x6C\x62\xDB\x9B\x21"
           "\xCA\x09\x0C\xBD\xE5\x09\x1C\xFA\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78"
           , 1200);
    nSKLen = 1200;
    memset(bInData, 0x42, 256);
    bInData[0] = 0x30;
    bInData[255] = 0x39;
    nInDataLen = 256;
    memcpy(bOutDataExp,
           "\x0F\x7C\xAA\xF9\x55\xEB\xBD\x31\xF6\xC2\xA1\xAF\x97\x0F\x9A\xC0"
           "\x4B\x6B\xA3\x65\x77\x59\x63\x95\xA6\x12\x15\xE8\xC4\x8A\xBB\xB9"
           "\x2C\x52\x61\x73\xBA\x17\xFE\x7A\x50\x00\xE9\x37\x66\x55\x15\xE4"
           "\x5F\x3C\x81\x22\x78\xCB\x3D\xF1\x96\x74\x89\x19\x5D\x65\xF3\x5E"
           "\xC5\x49\xC8\x19\xBC\x1A\x3C\xD5\x4D\x4F\xDD\xDD\xB9\x18\x51\x9E"
           "\x85\x3E\x6F\xD2\x4E\xB2\x67\x15\x00\x5A\x44\x8E\xB5\x83\xD6\x04"
           "\x95\xF1\xC5\x13\xA3\xDD\x1F\xC1\x37\x5D\xC1\x15\x64\xD1\x6E\x13"
           "\x44\x0A\xFD\xC2\xF2\xAA\x2B\x62\x63\x39\x88\x24\xB5\xAB\x85\x6F"
           "\x91\x13\x94\xF9\xDA\x7C\x93\xC1\x95\xB1\x39\x34\xE8\x50\x64\x6D"
           "\xC8\x28\x63\xE2\x01\x51\x86\x79\xF0\x67\x46\x0C\x33\x38\x12\xF0"
           "\xA3\xB6\xA9\xA8\x23\x5B\x1C\x13\x3C\xA1\x01\x39\x5F\x80\x93\x67"
           "\x6C\x01\x21\xFB\xB0\x20\x13\x37\x69\x05\x9F\x7A\x76\xD5\xF3\x09"
           "\x91\x12\x78\x47\x4D\x8E\xE0\x8B\x39\x86\x2B\xD7\xEB\x45\xAC\xA1"
           "\xBB\x96\xD6\x73\xBD\x39\x1F\x81\x82\x91\x34\x4F\x17\xA8\xAC\x01"
           "\x2B\x75\x02\xAB\xFE\x7A\x0F\xBB\x75\x66\x25\x95\x2C\x3B\x90\x94"
           "\x1B\xF4\xFF\xCE\x9D\xE1\x69\xB1\xA2\xDC\xF0\x22\xED\xE4\xEC\x64"
           , 256);
    nOutDataLenExp = 256;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 1200);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 256);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-2048，无填充，加密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 256);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 256);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 256);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_07(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 0;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    memcpy(bInData,
           "\x71\x27\xCA\xBD\x0D\x27\x32\x45\x0F\x69\x2E\x77\x47\x36\x02\x5C"
           "\xD9\x12\x9A\xFB\xCA\x7F\xDC\x08\x47\xC9\xC4\xDB\xE2\x74\x57\x7E"
           "\x28\x3D\x79\x40\xA0\x54\xC6\xA3\xEF\x46\xCE\xD0\x10\xD2\xDB\x88"
           "\x50\x56\x0A\x7C\x9D\x92\x78\xC5\x1E\xC6\x18\xA7\x95\xEA\xBD\x82"
           , 64);
    nInDataLen = 64;
    memset(bOutDataExp, 0x42, 64);
    bOutDataExp[0] = 0x30;
    bOutDataExp[63] = 0x39;
    nOutDataLenExp = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 320);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 64);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-512，无填充，解密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 64);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 64);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 64);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_08(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 0;
    memcpy(bSK,
           "\x3B\xD4\x50\x5C\x7E\x86\x10\xCE\x25\x5C\xB9\x39\xC2\xD4\x61\x5C"
           "\x7F\xC2\xC4\x74\xE5\x22\x06\xCD\x50\x53\xAF\x84\x02\xF7\xE6\x54"
           "\x85\x44\x18\x4D\xE9\x05\x89\xF5\x5D\x0E\xC0\x55\x6A\xD2\x53\xA5"
           "\x36\x71\x2D\xD5\xFD\xEA\x8A\x45\x4C\xC6\x00\x3B\xE7\x01\x70\x1C"
           "\xEC\xA6\xD1\xF4\x7D\xF0\xD5\xF5\xB6\x5A\x00\x43\xBC\xF0\x6A\x79"
           "\xFF\xD3\x30\xB8\x5F\xFA\xEA\xE0\xD1\x9E\x6C\x02\xAE\x9A\x13\xF0"
           "\x09\xED\xB1\x9C\x0A\xBE\xA9\xB7\x93\x66\xBB\x08\xC6\x0A\xA2\xFD"
           "\xFE\x19\xBF\x9E\x9E\x7C\x1C\xCF\xBB\xF6\x3F\x4D\x1A\x35\xF9\x26"
           "\x2A\xF4\x84\x29\x43\x79\xE7\x3D\x9B\x58\xF9\x30\xE1\x27\x3B\xC0"
           "\xD7\xE7\xEF\xF8\x52\x50\x2C\x85\x65\x1B\x1C\x3D\x2D\xA9\x73\x8F"
           "\xCA\x54\xF3\x60\xE4\x84\x67\xAC\xEB\xAA\x24\x30\xC9\x98\x9D\x4B"
           "\x2E\xF3\xD7\xE1\x93\xCA\xC0\x63\x3F\xD1\xE4\xAF\x08\x37\x63\xB5"
           "\x8A\xDB\x3E\x66\x44\x4E\x01\x7F\x75\x92\xB4\x5D\x79\x6C\x94\x9B"
           "\x4C\x55\x2F\x9A\x26\xD9\x54\x65\x67\x41\x4A\xAC\x1F\x7C\x4A\xFE"
           "\x1E\xDD\xDD\xE1\x51\x3A\xB2\xE2\x92\xFA\x3F\x8D\xFF\xEE\x78\x0A"
           "\xBB\xFB\xD6\x94\xE3\x39\x48\xF8\xF1\xC0\x3A\x36\xF4\x65\xF6\xB9"
           "\x2A\x2C\xEE\x71\x11\xAA\x7B\x55\xBF\x9D\x13\x0F\x74\x47\x05\x87"
           "\x27\xF0\x9F\x65\x6E\xED\xAF\x2B\x78\x69\xFE\x3A\x40\xA3\xDB\x58"
           "\xCC\x5C\x83\xC5\x0E\x9B\xF3\xB5\x8B\x6D\xA8\xBE\x0C\x5E\x38\x2A"
           "\x12\x8C\x3E\x40\xA1\x03\x43\x20\x6B\x4B\x3D\x65\x8C\x96\x13\x5F"
           "\x58\x56\x87\x88\x20\x0A\x12\xD8\x42\x95\x55\x5D\xDD\x74\x23\xF3"
           "\x05\x77\x04\x02\xBC\x97\x6E\xED\xEB\x33\x10\x4B\x8C\x58\x0C\xDF"
           "\x9A\x54\xCD\xB9\x69\xAA\x0B\x15\x13\x8B\x95\x87\x55\xFC\x05\x0A"
           "\x81\x5E\x00\x9D\x50\x9D\x7D\x73\x94\x6B\x78\x30\x40\xC7\xF4\x89"
           "\x76\x9F\x1D\x3B\x69\xAE\x65\x5C\xF5\xAB\xF8\xC0\x33\x0F\xA3\x02"
           "\xA4\x41\x96\x86\x47\x75\x2F\x3B\xC4\x3D\xE8\x5A\x88\xAB\xB9\x74"
           "\xB9\x8F\xA7\xDC\xBE\x35\xE0\xA1\x31\xA1\xEE\xAC\xD3\x01\x97\x67"
           "\x65\x1D\x81\x74\x38\x11\xEF\xC5\x0F\xDD\x6B\x70\x98\xF8\xDC\x91"
           "\xFA\x20\xDD\x34\x9F\xB4\xB2\x09\x6B\x90\xD7\x81\xBA\xD4\x34\xEA"
           "\x24\x83\x49\x86\x3C\xDF\x51\x98\xDB\xA2\x68\x53\xC3\x41\x47\x3B"
           "\x70\x13\x1B\xC7\xB1\x4B\x64\xD3\xD1\x46\xF6\x97\x04\x65\x8C\x24"
           "\x13\xD0\xE5\x85\x7D\xBF\x31\x3A\xB5\x49\x14\xF1\x3F\xFA\xB5\xC1"
           "\x47\x61\x69\x76\x6E\xD2\x9D\x84\xA0\x88\xD6\x65\x35\x6E\xD4\xEB"
           "\x57\x1D\x9F\xF5\xB5\x10\x5D\x12\x05\xA1\xF2\x5A\x37\x4D\x9A\x65"
           "\xBA\xE8\x69\x9B\x02\x93\xAD\x7A\x84\xB0\x6E\xF2\xB6\xB3\x86\x11"
           "\x8F\xF8\xB2\x23\x4E\xD4\x33\x74\x9C\xB4\x91\xD8\x57\x01\x18\x14"
           "\x8A\x63\x13\xFB\x17\x1B\x91\x0E\x35\x71\xD2\x0A\x73\xCD\x99\xA9"
           "\x5C\x10\xD3\xDE\x93\xF4\x5A\x63\xCB\x08\x1E\x8F\x38\x0E\x1A\xB1"
           "\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78"
           , 616);
    nSKLen = 616;
    memcpy(bInData,
           "\x41\x6B\x36\x4E\x51\x5E\xD1\xEB\x1D\x61\xC5\xB2\x0E\x60\x1B\xE6"
           "\xF7\x97\x20\x2D\x07\x8C\xEB\x3A\x72\x35\xE8\xE1\x28\xAE\x4E\xAF"
           "\xFA\x25\x1E\xB7\x75\x00\x80\x98\xD2\xB9\x95\xF7\xA3\x44\xBA\x29"
           "\xE9\xDB\x8C\x14\x0F\x42\x9D\x90\x7C\xEC\x14\x9A\xEC\xD7\x55\x01"
           "\x02\x93\x0B\xBF\x76\xBB\x10\x57\x13\xD1\x5D\x11\xE3\x1E\x88\xB9"
           "\x20\x13\xD5\x9B\x3F\x50\x20\x8D\xA3\x11\xAE\x32\x6B\xB6\x68\x0C"
           "\xBD\xB2\xB0\xB3\xC7\xF1\x06\x90\x40\x20\x77\x48\x1B\x30\xDC\xE3"
           "\x50\xBD\x48\xE1\xEE\xEA\xF1\x31\xE1\x49\xB9\x6A\x12\x5F\x76\xA0"
           , 128);
    nInDataLen = 128;
    memset(bOutDataExp, 0x42, 128);
    bOutDataExp[0] = 0x30;
    bOutDataExp[127] = 0x39;
    nOutDataLenExp = 128;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 616);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 128);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1024，无填充，解密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 128);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 128);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 128);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_09(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 0;
    memcpy(bSK,
           "\xDF\x00\x50\x67\x45\x67\xCB\xA9\xF3\x62\x34\x84\x08\x05\xEE\x96"
           "\x70\x77\x07\xC3\x71\x70\xAD\xC0\xE9\x02\xE7\x50\x58\xCB\x00\xCF"
           "\x55\xAA\xB9\xE0\x3D\x47\x8D\xC8\x38\x3A\x78\x92\xB2\x54\x98\xEF"
           "\x5A\x46\x80\x77\x58\x05\x1E\x94\xA8\x62\xE6\xFA\x5C\x54\x15\x48"
           "\x2D\xDB\x8C\x41\x31\x90\x9F\xE9\x4D\x87\x7A\x21\xB9\xA3\x13\xE5"
           "\xE0\xED\x09\x27\x17\xB6\xB1\xAA\x23\xBE\x5F\x80\x9F\x25\xF2\xE1"
           "\x7A\xB2\xCB\x36\xF2\xE5\x2A\x6F\x63\xD1\x4C\xD6\x53\x07\xBF\x83"
           "\x4F\x59\xE1\x20\x63\x9C\x33\x38\x88\xD3\x79\x7D\xF1\x47\x6E\x16"
           "\x3F\x38\xF3\xCF\x0D\x25\xF4\xD5\x28\x76\x55\x5C\x22\x54\x1B\xAD"
           "\xCC\xB6\x21\x81\xFC\x32\xE0\xCF\x8C\x30\x3A\x96\x31\x48\x02\x7E"
           "\x0E\x2A\x4B\x99\x46\x5C\xCA\x23\x82\x41\xA6\x9B\x8A\x71\xF4\x4E"
           "\x7A\xCF\xBE\x9D\xEC\x18\x90\x04\xF2\x6F\x9F\xD9\x76\xFD\x43\x17"
           "\x81\xF0\xD7\xB8\x1B\xE6\x7C\xBB\x5F\xB9\x9D\x8E\x96\x4D\xC5\xE3"
           "\x7A\x98\xBA\x11\x2B\x52\x62\xA3\x48\x6F\x9C\x8F\x3F\x4A\x88\xF4"
           "\xEA\x82\x59\xBD\x2D\x55\x06\x8F\x51\x8D\x37\xA0\xB0\xF4\xA7\x23"
           "\x76\x86\xFF\x68\xEA\x6C\x64\xFE\xC0\xCD\x6C\x48\x20\xCB\xD2\x77"
           "\x31\x73\xD8\x50\x5A\x13\x84\x98\x8D\x0A\xF1\xB9\x8A\xD8\x87\x54"
           "\xDC\xB4\xBA\x6A\x0E\x7D\x04\x4D\x7C\x6C\xF6\xE3\x50\x65\xEF\xC2"
           "\x9C\x70\x39\x70\x99\x60\x53\x70\x88\x1D\xA2\x56\x1A\x78\xB8\x15"
           "\x17\x81\x3F\xEC\x07\x0A\xE0\x33\x7A\x82\x0B\xE2\x21\x53\x1B\x27"
           "\x7C\x06\x69\x00\x82\xB3\xAB\x74\xE9\x43\xDD\xCC\x69\x2C\xF8\x51"
           "\xAF\xEB\xEE\x15\x6E\xE0\x35\xA8\x6A\x0D\x35\x8A\x01\x98\x68\x8A"
           "\xC5\x71\xAA\x8C\xDB\x31\xC7\x04\x5D\xEF\x33\x50\x1A\x66\xC9\xBF"
           "\x85\xE8\x30\xBF\x8E\x36\x86\xA3\xB0\xBF\x18\x8E\xA0\x93\xB3\x5C"
           "\xD2\xD3\x6E\x57\x86\x14\x30\x5D\xC5\x29\x0B\x5A\xEF\xEA\xA3\x9C"
           "\xC0\xDD\x9B\xDF\x67\xB9\xAF\x01\xC4\x0C\x83\xE1\x36\x95\x4E\xB6"
           "\xF2\x61\x4F\xB8\x09\x8E\x66\x90\x23\xE7\x6D\xD1\x71\xF4\xF4\xE7"
           "\xF4\x3B\x54\x8D\x91\x05\x89\xB5\xFE\x78\xBA\x30\x87\xF5\xB5\xE6"
           "\xE8\x55\x5B\xCA\x64\xAF\x89\x59\xA0\x50\x8A\x7D\x19\x40\xDF\x49"
           "\x31\xEA\xEF\x76\x70\x2E\x1F\xC7\x05\x7E\xA0\x2A\x42\x17\xA2\x0A"
           "\x32\xAC\x36\x7F\x31\xFF\x11\xED\x06\x13\x03\xC6\xDF\xEF\xC4\x27"
           "\x8C\x29\xE3\x36\xE6\xDE\xBC\xE8\x7B\xB5\x7B\x9A\xCB\x93\xF1\x21"
           "\x26\x38\x94\xDA\xF5\x1B\xD7\x2F\xA9\x3C\xEC\xE3\xDC\xD6\xD8\xFC"
           "\x03\x4D\xE1\x49\xA2\x22\x6E\xFD\x57\x80\xAB\xF4\xFA\xD5\xC2\x53"
           "\xCE\x6D\xB2\x61\xE3\xA8\x22\xD8\xD2\x9C\xFE\x85\xE2\x80\xA0\x9D"
           "\x1E\xAF\x00\x3F\xF2\x36\xE1\xE5\xBC\x32\x73\x7E\xD0\x6E\x18\x66"
           "\x48\x64\x91\x0E\xB6\x70\x82\xAA\x40\xFA\x2D\xB5\x27\x0A\x71\x17"
           "\x15\x96\xD4\x2B\xEF\xB4\x82\xA2\x4C\x7C\x08\x2B\x9E\xD6\x99\x56"
           "\x20\x08\xCD\x7D\x6B\x5E\x38\x53\x67\x13\x38\xED\x16\x44\x71\x12"
           "\x97\x4B\x84\xE7\xCE\x12\x53\x70\x46\x6A\x71\x51\xAD\x8B\x71\x2D"
           "\xE5\x4C\xF7\xFF\xCE\x39\xB3\xA0\xB1\x46\x26\x4F\x1A\x63\x0C\xB9"
           "\xEE\x8F\xC7\x8E\x61\x24\xD0\xFB\xD4\x33\x00\xFD\x85\x23\x8B\x12"
           "\x09\x49\x7D\xA8\xE2\x9D\x2E\xFD"
           , 680);
    nSKLen = 680;
    memcpy(bInData,
           "\x91\x47\x46\x39\xF0\x23\xEE\x94\x89\x82\x1C\x8E\x56\x6F\x56\x85"
           "\x5D\xA4\xA3\xD8\xE8\x68\xF4\xDC\x0F\xA7\x12\x39\xE4\xBB\x28\xBE"
           "\xD8\x3F\x69\xCB\xC7\xCE\x02\x43\x7C\x4D\x5E\x91\x19\xD1\x64\xF8"
           "\x20\x00\x68\x75\x5F\xC2\x77\x53\x1A\x7E\x3E\x95\x93\x3E\xC5\xC8"
           "\x8F\xB4\x1C\x38\x6C\x3B\xDD\x21\x35\x93\xEF\xDA\xDC\x1C\xF9\xD4"
           "\x4F\x7D\x16\x01\xE2\xAB\x4C\xB1\x08\x81\xCA\x90\x6A\x16\x21\x15"
           "\x2C\xB6\x5F\x1F\x56\x0A\xA3\xA4\x63\x4F\x66\x5A\x90\x88\xE4\xBB"
           "\xE7\x97\x34\xB5\xAA\x2D\x46\x6D\x86\x74\x64\x99\x82\xA1\xAC\xFD"
           "\xC5\xE8\x60\x09\x16\x18\x30\xD4\x82\x15\x87\xE9\xC4\x86\xB5\xD9"
           , 144);
    nInDataLen = 144;
    memset(bOutDataExp, 0x42, 144);
    bOutDataExp[0] = 0x30;
    bOutDataExp[143] = 0x39;
    nOutDataLenExp = 144;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 680);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 144);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1152，无填充，解密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 144);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 144);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 144);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_10(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 0;
    memcpy(bSK,
           "\x21\xE5\x82\xE3\xD4\x2B\x83\xA7\x68\x16\x92\xEF\x49\x12\x6D\x45"
           "\xC5\x11\xC5\x1E\x9E\x67\x6F\xF9\x04\x47\x04\x31\x37\x69\xFD\x3D"
           "\x6C\x60\x8F\x08\xC7\xF3\xF1\x69\xDF\xCC\x66\x75\xEA\xB0\x61\x33"
           "\xAF\x7A\x12\x41\x94\x5A\x51\x39\xB5\xBE\xE7\x4C\x9D\x98\x77\x80"
           "\x6C\xB9\x2B\x98\x4E\x55\xEC\x57\x0E\x8A\x1F\xA8\x52\xDE\x44\xC5"
           "\x08\x2F\x21\xD9\x0E\xDD\xB5\x5E\xF3\xA1\x8C\xF1\xC3\xCB\x0A\x18"
           "\xD3\x80\x83\x10\xEB\x2E\x99\x59\x45\x7D\x2B\x92\xF5\x22\x7B\x49"
           "\x67\x02\x84\x5F\x56\x56\xBC\x95\x04\xA4\xB7\xB7\x53\xAE\x19\xF1"
           "\xF8\x7C\x3D\xEA\xDA\xDF\x52\x99\xF5\xB4\x15\xAB\x03\x8B\xBD\x6B"
           "\xC0\x8C\x86\xFC\x56\xCC\x3C\x0C\x38\x31\xBD\xB7\x28\x29\xAC\x0E"
           "\x24\xF2\x12\x6E\x6A\xFC\x01\x1C\x18\xC6\x3A\xCD\xD8\x0A\x64\x27"
           "\x93\x9D\x76\xAA\x27\x42\x7E\xEF\xFB\x83\x2A\xB5\xF3\xD0\x15\xC8"
           "\xEF\xF4\x3E\x5B\x5F\x3B\x4F\x96\x2C\x76\x6A\xD6\x69\xD7\x57\xC1"
           "\xF6\x40\xDF\x49\x7B\x4A\x9B\xE2\x7A\xE3\x09\x8B\xC9\x47\xA9\x14"
           "\x5F\x1D\xC1\x4A\x7F\x9D\xCF\xEF\x7D\x1A\x91\x6F\xC7\xA0\x41\x7F"
           "\x7B\xC3\x15\x00\xEC\x53\x34\x22\x95\xEE\xE7\x08\x39\x63\xF5\x54"
           "\xB6\xAD\x39\x45\xB5\x21\x5C\x34\x5E\x67\x7B\xD8\x97\x50\x91\x75"
           "\x6F\x68\x0A\x95\x8F\x24\xBE\x83\xDB\x44\x91\xE0\xD2\x99\x24\x99"
           "\xBD\x11\x2E\x15\xA9\xCC\xCD\x14\xD9\xBB\x5E\x56\x0F\x69\x9A\x18"
           "\x5A\x42\x25\xB1\x3F\x6B\x03\x18\x51\x9C\x36\x8F\xDB\x1E\xB9\x11"
           "\x3A\xEF\x24\xDB\x9B\x2E\xA2\x1B\x11\x73\x86\x5A\x4C\x12\x4F\xD8"
           "\xCB\x07\xEE\x99\xAC\x04\x10\x2B\x1C\xD7\xB8\xEB\xE7\x56\x2C\x8A"
           "\x12\x36\xDD\xA0\x11\x9D\xC8\x26\x37\x66\x0B\x21\x89\xC3\x7D\xA1"
           "\x40\x85\x91\xFF\x5E\x80\x70\xFB\x68\x28\x03\x8A\x6F\x09\xBC\xD6"
           "\xAC\xAF\xF4\x60\x67\x8D\xA8\x3E\x17\x5B\x5A\xE9\x3E\x17\xA9\x34"
           "\xA9\xD7\x29\xBE\xBE\xE3\xCD\x09\x74\x23\xC7\x21\xEE\xA2\x63\xA2"
           "\x33\x64\x92\x53\x31\x74\xF2\x96\x0C\xD0\x11\x30\xB6\x9F\xE0\xBA"
           "\x5B\x4C\xFA\xA0\xBB\x83\x1C\x74\xD8\x70\xE0\x4B\x2A\xAA\xBD\x88"
           "\x4A\x1E\xB5\x22\x63\xD7\x2E\xBD\xA4\x8E\x6C\xA3\x10\x29\xE8\x29"
           "\xA8\x43\x89\x66\xB7\x7E\x3D\xBE\x8C\xE3\xFC\x5A\xBF\x06\x0B\xCC"
           "\x34\x91\x9D\xE3\x85\x1D\xB7\x39\x03\xC3\x0C\x05\x17\xA4\x8D\xE0"
           "\xB3\x9E\x01\xF7\x80\xF4\xBB\xF0\x22\x23\xDA\xBD\xC4\x14\xBB\x78"
           "\x58\xC5\x7F\xC6\x09\x41\x54\xBB\x11\x96\xE6\xA3\x1A\xC9\x55\xBD"
           "\x0F\xF0\x3F\xBE\x61\x83\xCE\x26\x82\xA2\x8E\xD5\x0D\x2D\xB7\x66"
           "\xBC\x2E\xF0\xEB\xC3\x2F\x6A\x2A\xF5\xB9\x8B\xF0\x42\x4F\x65\x8B"
           "\xD1\x6E\x76\x88\x8C\x29\x34\xCF\x26\x27\x84\x8E\x6B\xA2\xEB\x16"
           "\x77\x2D\x21\x7E\xEC\x18\x4D\x04\xDA\xEF\x95\x1C\x29\x75\x18\x1C"
           "\x83\xCA\xB6\x72\xC3\x77\x46\x29\xBB\xFC\xDE\x1D\x78\x72\x76\x47"
           "\x20\x40\x90\xDC\xBC\xA3\x72\x33\x64\x7E\x18\xD9\xA4\xD2\x46\x9C"
           "\x77\x8B\xF9\x6D\x97\xB0\xD6\xA1\x20\x2C\x0D\xB6\xE3\x2C\x09\x8F"
           "\x07\xB6\x5F\xD3\xDB\x3B\xFD\x77\x69\x7D\x56\xE4\x35\x18\x3A\x9B"
           "\xF6\x22\x3A\x01\x35\x71\xBE\xA4\x48\x97\x8B\x45\x90\x46\x07\x0E"
           "\x17\x68\x9E\x00\x11\x6F\x4A\x25\x55\xA0\x9C\x74\xD9\x15\xFF\xF5"
           "\xE0\x59\xD6\x86\xA0\x91\xD8\x7F\x9A\xFF\xE4\xBD\xAB\xE3\xF0\x94"
           "\x49\x66\x36\x7F\xD3\xD3\x8E\x13\xB7\xFC\x89\xB7\xA9\x3C\x7B\x0E"
           "\x11\xAC\x66\xCE\x34\x34\xAE\x67\x70\xE0\x3A\xB6\x0E\x78\xFD\x94"
           "\xF1\xB5\x74\xD3\x47\x2A\x74\x40\x51\x39\xD1\x49\x73\x94\xB4\xF9"
           "\x4C\xB6\x4B\x11\x19\x2F\x7E\x34\x3E\x6B\x4F\x34\x5B\x83\x52\x47"
           "\x99\x0C\xD6\xDF\x7B\xA3\x95\xE2\xCC\x39\x2F\xC4\x92\x43\x38\x2F"
           "\xCB\xE6\x8C\x2D\xAD\xD0\x5E\xE9\xD5\x3D\x5E\x70\x2E\xA8\x66\xB0"
           "\xA6\xB8\x7C\xA4\x3A\x9E\x28\x3B\x0E\x46\x20\x84\xF8\x5E\x53\x9E"
           "\xCF\xDE\xF3\x0F\x1F\xE3\x8D\x51"
           , 824);
    nSKLen = 824;
    memcpy(bInData,
           "\x45\xE6\x5A\x5E\xCC\xF1\x27\x02\xA9\x63\x2E\x6B\x07\xF9\xB4\x8E"
           "\xA6\x54\x64\x1B\x55\x21\x99\x90\xEA\xA0\x58\x9A\x15\x1F\x41\x51"
           "\x6C\xEE\x05\x20\x92\x9B\x24\xA6\x67\xBD\x58\x53\x85\x05\x99\x5D"
           "\xD2\x37\x16\x00\x2F\x1E\x71\x40\x9E\xC2\x8A\x2F\xED\x80\x30\x6E"
           "\x1E\x3E\x65\xE1\x58\x19\xA3\xF8\x7D\x66\x2C\x4B\x6A\xB2\x36\xE2"
           "\x3E\x39\xB7\x6D\x81\x89\x9E\x9C\x00\xD5\x57\xFE\x23\xF4\x29\x9D"
           "\xE4\x26\x12\x5C\x35\xBD\x58\x0A\x00\x17\x30\x4F\x86\xEE\x28\xC0"
           "\x22\xDE\x1D\xE1\x59\xCD\xD9\x24\xED\x30\xC8\xCC\x0F\x5E\x3F\x45"
           "\x7A\xD4\xCA\xDF\x85\x8C\x4C\x66\xEE\x89\x41\x48\xAE\x08\x7B\xBA"
           "\xCA\xD0\xA2\x02\x81\xB6\x91\x1F\xD5\xE7\xA1\x6A\xCB\x59\x33\x13"
           "\x0F\x4D\x2D\xC0\xBF\x87\xFF\x5E\xDF\x4E\xB2\x1C\x6F\x48\xD5\xF8"
           , 176);
    nInDataLen = 176;
    memset(bOutDataExp, 0x42, 176);
    bOutDataExp[0] = 0x30;
    bOutDataExp[175] = 0x39;
    nOutDataLenExp = 176;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 824);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 176);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1408，无填充，解密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 176);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 176);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 176);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_11(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 0;
    memcpy(bSK,
           "\x6C\x18\x21\x1D\x3D\xDC\x38\xA8\xBA\x10\x33\x70\x83\x41\xB5\x37"
           "\xFE\x97\x6F\xB1\xF4\x21\x1A\xAD\x35\x77\xBD\x28\xB2\x57\x20\x10"
           "\x16\x13\x93\x89\x47\xC3\x73\xFC\xB9\x76\x48\x3A\x77\xCD\xA7\x0C"
           "\x17\xE9\xF1\x4C\xD0\xA7\xE1\xAA\x0D\x9A\x8C\x38\xD1\xE6\x83\xA6"
           "\x93\xD4\x55\x28\x6B\xB9\x0F\x81\x02\x7A\x78\x54\x00\x84\x94\xFB"
           "\x82\xCC\x8A\x78\xFC\x93\x45\x6E\xD3\x13\xD3\x1F\x18\x69\x73\x2A"
           "\x70\x86\x1F\xFB\x25\xE6\x2A\x64\xCC\x6F\x1F\x18\x26\x0D\x1C\x40"
           "\xAA\x5E\x52\x50\x22\x5A\xE4\x3C\xBC\x29\xFA\xCA\x30\xE3\x53\x40"
           "\x34\x35\xF1\xD0\xE2\x69\x1D\x34\x8E\x83\x96\xAC\xAA\xCF\x6C\x98"
           "\x3F\x4F\x8C\xEF\x8C\xB3\x3A\x04\xF5\x7C\xB1\x76\xA3\x32\x1B\xC1"
           "\x83\xAD\x70\xA5\xF9\x08\xB8\xD9\x2E\xED\x15\x65\xB0\x33\x30\x04"
           "\x1F\x69\x87\x1D\xFF\xBF\x0F\x59\xE3\x62\xE1\xE8\x2C\x03\x4B\x72"
           "\xB6\xAA\x8F\x73\xBA\xFE\xEE\xCC\xAF\x50\x87\x3D\xA0\x5F\x66\xA0"
           "\x88\x3A\x7F\xDF\xA1\x8E\x06\x08\x18\x2C\x1A\x16\xCE\x0C\x6E\x13"
           "\x4F\x2E\x26\x3B\xB8\xAF\x70\x5E\x70\x48\xED\xCE\x8D\x6C\x9B\x26"
           "\xD7\xFE\x95\x5F\xC6\x91\xB6\x81\x3F\x7C\x9A\xF1\x6D\x1B\xAB\x6E"
           "\x84\x10\x94\x5A\x07\x38\x56\x75\xF0\xEB\x3C\x5E\xA3\x0E\x85\x17"
           "\xFB\x5B\xD0\xFA\x84\x3D\x58\x4C\xFD\xF0\xE5\x37\x77\x29\xE2\x5A"
           "\x7C\x74\x87\x04\x9C\xF0\x7A\x2C\xE4\xD2\x0A\x1C\xD8\x8B\x37\x8C"
           "\x7F\x1C\x10\x6E\x73\xB2\x69\x4C\xBE\x1A\x84\x3C\xC8\xA7\xA3\x68"
           "\x48\x7E\x2F\xFD\x9B\x5F\x12\xAD\x15\x49\x3F\xC4\x10\x86\xAF\x56"
           "\x4D\xCB\xC6\xE8\xAD\x35\x72\x21\x24\xD9\xC3\xA3\x82\xF1\xB2\xAF"
           "\xD9\x88\xBF\xFB\xCB\x81\xF9\xF6\x3B\xC6\x1C\x34\xF0\x5A\x33\xE5"
           "\x41\x9B\xC2\xF9\xE2\x23\x0E\x2D\x11\xC5\xBF\x41\x91\x7B\xE9\x36"
           "\x07\xD8\x60\x00\x09\xDD\xD5\x86\xD7\x65\x50\x98\xBC\x5C\x0E\x60"
           "\xA0\xE5\x53\xEC\xA6\x9D\x11\x99\xEA\x25\x44\xF4\x50\x76\x0D\x4D"
           "\xE7\x72\x87\xCF\x6F\x7C\xF2\x27\xED\x73\xD7\xEF\x53\x6D\x0B\x99"
           "\x6B\x38\x44\xBC\xC0\x12\xF5\xD6\x92\x3F\x64\x81\x54\xC1\xEF\x04"
           "\x5C\x1F\x23\x7E\xF5\x38\xA7\x80\xFC\x17\xEF\x00\x3C\x8D\x09\xAB"
           "\xAA\xD0\x40\x14\xD7\xCB\xAC\xA1\x29\xE0\x12\xD5\xD4\xFF\x1B\xDD"
           "\xCA\x78\x2B\x1D\xEC\x9F\xA5\xAC\x67\x74\x31\x8C\xF6\x8F\x9A\x59"
           "\x7D\x84\xF1\x7E\x5D\xA4\xC9\x53\xEF\x58\x2D\x1F\x0F\x3A\x6D\x66"
           "\xFF\x06\x61\x1A\xDC\xDB\x19\x0C\xE6\x43\xC4\x4A\x2B\x3D\x8E\x79"
           "\xD4\x93\xA8\x9A\x1A\xF7\x91\x45\x77\x78\xAB\xE1\x77\x33\x26\xFF"
           "\x92\x0B\x96\xD5\xF3\xAF\x05\x0B\xC4\x53\x1B\x89\xEC\xDC\xD0\x12"
           "\x4A\x65\xF3\xAD\x43\x8C\x23\x35\x13\x79\x4E\xD8\x0D\x21\xC9\x61"
           "\x49\xCA\x48\x53\x48\xC6\xA1\x7E\xF0\x28\xA5\x97\x11\xB8\x18\x33"
           "\xAD\xEC\xEF\x6B\x5C\x71\x4A\xBE\x9F\x31\xB8\xA3\x98\xC5\x0C\x0B"
           "\x46\x51\xA2\xAE\x02\x6F\x98\x35\xF7\x4D\x21\x5E\xC3\xED\x61\xB0"
           "\x6B\x59\x79\x5A\xB9\xA8\x1C\xB0\xBA\x82\x67\xB9\x97\xBB\xD4\x4D"
           "\xF1\xA1\x56\x5C\x7D\xCB\x77\xD0\x28\xE0\xFF\x1C\xAA\x22\x07\x68"
           "\x9B\xF3\x80\xDE\x96\x1D\x03\xDD\x97\x8A\x69\xDA\x5C\x54\xD4\x80"
           "\x93\xB2\x0D\xCD\x43\xBA\xFC\xDF\x11\xCF\xFE\xCE\x3B\x74\x8E\x67"
           "\x17\x74\x8E\x29\xF9\x64\x97\x52\x8C\x7B\xC9\x71\xB3\x5E\x59\x86"
           "\x63\x38\xF6\x9E\x79\x43\x56\xD6\x6F\xE6\x26\x45\x62\x64\x26\xE0"
           "\xA7\xDC\x70\xCA\x5B\xCD\xE7\xC6\xE1\x1F\xFC\x97\x57\xA1\x2B\xC5"
           "\x12\xB6\x9E\x85\x37\x9E\x58\x48\x2F\x9A\x91\xB7\xB6\x7C\x28\x47"
           "\x1A\x73\x45\x41\xD4\x6E\xBE\xB5\xB7\x60\x1A\xF2\x8B\x04\x78\x38"
           "\x4B\xB6\x45\x8C\xA9\x3E\xE5\x7A\xBF\x1F\xC4\x86\x30\xB4\x0C\xB1"
           "\xC6\x9D\x80\x88\xD2\x49\xD9\x89\xD9\x50\xA8\xDE\xEC\xA5\x04\x7F"
           "\xFF\xEA\xC0\x2F\xCB\x37\x7A\xB6\x97\x59\xAD\x53\x29\x34\xB3\x79"
           "\x16\x3B\x3E\xF5\x7F\x14\xB3\x77\xF9\x2E\xE8\x3F\x04\xAE\xDE\x89"
           "\x73\x04\x32\xA7\x4C\xC0\x4D\x43\x0D\xC1\xE5\x21\x48\x32\xAA\xE1"
           "\x5E\x81\xB6\x23\x6A\x80\xCA\x17\x23\xFC\x5F\x47\xE1\x57\x14\x59"
           "\x46\x67\x0F\xBF\x6A\x57\x53\x10\x8E\xAB\xAA\x9C\x8A\xDD\xE0\x9D"
           "\xA2\xAC\x94\x87\x6A\x71\xD0\xAF\xE4\x8A\xCF\xEB\x23\x27\x00\xC2"
           "\x8B\x11\xA9\x2C\x02\xB5\x05\x03\x30\x7A\x0C\xEF\x7F\x5B\x1C\xE7"
           "\x64\xFF\x1E\x68\x78\x28\x1C\x6D\xA0\x16\x75\x36\x7F\x9F\xF9\xCD"
           "\x15\x3B\x8E\x26\xC3\xF1\x7A\xBC\x17\x42\x92\x7D\xA8\x4E\x22\x5F"
           "\xB9\x55\xF5\xB7\x2C\x10\x5E\x79\xBB\x81\x54\x32\xDC\x8D\xE7\x4B"
           "\xE3\xCB\xDB\x1D\x34\xA4\xBA\x5F\x1A\xFE\x43\x48\x46\xEF\x88\x67"
           "\xD5\xB6\xDD\x06\x99\x5C\xB3\x38\x45\xED\xD0\x21\x77\x22\xF4\xF3"
           "\x68\xD6\x90\x53\xB5\x1E\x36\x3C\x35\x08\xCF\xBE\x53\x8F\x59\xDB"
           "\x4D\xAA\xA2\xB4\xF9\x93\xAC\x4C\x0C\xE4\x5D\xDF\x79\x57\x3C\x8F"
           "\x42\x44\xEC\x0C\x09\xA9\xC6\xE8\xF9\xF0\x80\x2E\x76\x25\x2E\xC1"
           "\x72\x0E\x55\xD6\xB9\x78\x9A\xAE\x56\xFE\x8B\x35\x38\xAF\xE3\x80"
           "\x78\x57\x55\x15\xC9\xEC\xCC\xCB\x42\xC3\xC5\xDF\x8A\xAE\x67\xB0"
           "\xCD\x63\x8E\xFC\x28\x77\x7F\xD1\x31\xFD\x9D\xD2\x79\xC8\x0A\xE0"
           "\x1A\x86\x0D\xEB\x3B\xB4\x64\x49\xAA\x6B\x7B\x73\x27\xEC\x7D\x66"
           "\x6A\x4C\x37\xB3\xCD\x4E\x97\x97\x3C\xEF\x7E\x13\x45\x36\xAA\xFE"
           "\x2E\x16\x48\x90\x5F\x53\x63\x62\xC7\xAB\xC9\xC7\xB5\x9E\xFD\xA5"
           "\x8B\x0C\xCA\xD0\x1E\xBD\x51\x67\x98\x94\x63\x08\x13\xCC\x05\xB9"
           , 1152);
    nSKLen = 1152;
    memcpy(bInData,
           "\xAC\xDA\x06\x75\x3E\x48\x32\x18\x60\x3D\x06\xBD\x1A\x06\xD3\xD4"
           "\x44\xDB\x40\x7A\x89\x53\x33\x52\x41\xBC\xE3\x88\xA0\x3A\xB5\x73"
           "\x73\x05\x21\x32\xE6\x61\xCF\x40\xAB\x4D\x18\x16\x4C\x47\x26\x8D"
           "\x07\xC4\xD6\x0E\x74\xE2\xCA\x0A\x98\xA4\x74\x95\x48\x66\x25\x1B"
           "\xB9\xD8\xDD\x10\x03\x44\xE4\x5A\xA3\xC7\xE4\x2B\x6C\x0C\x8C\x5F"
           "\x6D\x49\x00\x89\x2F\xBF\x34\x66\x14\x28\x77\x72\x43\x15\xEC\x14"
           "\xEE\x57\xC5\x04\xD7\x17\x81\xEC\xAC\x5C\xAC\x6D\x85\x3E\xF7\x90"
           "\xA6\x75\xE3\x6A\xFD\x41\xB4\x58\xBF\x3A\xBF\x58\xB0\xA6\x7A\x7E"
           "\xCE\x92\x9C\xCC\x3D\xEC\xFB\x21\xF1\xE2\xCC\x2F\x3A\xE4\xB9\x97"
           "\x67\xE9\x39\xA1\xF2\xE5\xA1\x86\x83\x01\x6A\x23\xCA\x0A\xDF\xBC"
           "\x75\x4F\x0C\x4E\xD4\x3D\xA9\xCC\x37\x5B\x9D\x49\x6F\x6D\xB3\x71"
           "\x0C\x18\x18\x5C\xE6\x77\x54\xCA\xD7\x1C\x67\xAF\xA7\xAA\x57\x24"
           "\xA0\x94\xC0\x5F\x19\xC5\x65\x9A\xB4\x22\x22\xBB\x8B\x66\xCE\xFF"
           "\x31\xDA\xF4\xDF\x22\xA6\x13\xC0\xF6\xD9\x4F\x57\x41\x7F\xF6\x5C"
           "\x19\xC7\xAA\xF8\x38\x8E\x8C\x9E\x51\x7A\xC3\x97\x6D\x97\x06\x62"
           "\x80\x50\x23\x32\xCF\x50\x2B\x27"
           , 248);
    nInDataLen = 248;
    memset(bOutDataExp, 0x42, 248);
    bOutDataExp[0] = 0x30;
    bOutDataExp[247] = 0x39;
    nOutDataLenExp = 248;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 1152);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 248);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1984，无填充，解密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 248);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 248);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 248);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_12(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 0;
    memcpy(bSK,
           "\xB6\xF8\xDC\x3E\x12\x98\x52\xB8\xB1\x84\xC0\x51\x97\xD1\xBE\x87"
           "\x70\x24\xD7\xE1\x4A\x71\xC3\x20\xA9\xEE\x78\x93\xF8\x99\x5C\x1A"
           "\xE5\x32\x78\x65\x85\x07\xEB\x5E\x26\x79\x2F\x1E\xE1\x6E\x6E\xB9"
           "\xF7\x6A\x23\x46\x09\x92\xD0\x54\xD2\xCA\x6C\xB6\xCE\xB0\x0B\x1C"
           "\x83\xD3\xEB\x1B\x6F\x47\x05\x82\xBF\x68\x23\x24\x90\xDD\xA0\x4C"
           "\xAD\x00\xC2\xD6\xBE\x7D\x8C\x5C\xBF\x1B\xF6\xE1\x73\x51\x9E\x6D"
           "\x62\x46\xBF\x62\xD5\xA6\xD6\x93\x17\x5D\xEE\xEF\x03\x82\x5E\x89"
           "\xA5\x42\xF3\x09\xB1\x20\x11\x48\x39\x90\x8A\xBD\xAA\xE3\xA8\x12"
           "\x4E\xD2\x36\x25\x16\x60\x73\x35\x44\x99\x56\xFE\xED\xF1\xC7\x48"
           "\x57\x57\x56\x27\x7C\x94\xC5\x2D\x6B\x77\xFB\xDC\x82\xD8\xD0\xE0"
           "\x2D\x0E\x4D\x64\x5B\x98\x07\x49\x8A\x29\x70\xD9\xDE\xA9\x44\xC5"
           "\xDE\x71\xCE\xF5\xE0\x63\x40\x28\xF4\xD6\x6D\x86\x14\xCF\x70\x24"
           "\x5B\x05\xAE\xC7\xE9\x69\x7B\x42\xAB\xF6\x53\xA3\x97\x1C\x93\x61"
           "\xCE\x7E\x8F\x38\xF1\x85\xC6\xB8\x2C\x6F\x11\x3E\xA6\xF1\x18\xF8"
           "\x85\xAD\xF2\xE3\x32\x82\x51\x0D\xEB\x12\x68\xC0\x1B\xCD\xF2\x3A"
           "\xB5\x55\xCD\x1A\x92\x9D\x31\xDF\xA6\xB2\x7A\xEE\x99\xA1\x39\x62"
           "\xC9\xE5\xFD\x47\xD0\x37\xCE\x6C\x08\x33\x31\x58\x38\x7B\x3F\x77"
           "\xFF\x4B\x01\xFC\x24\x58\x33\x24\xEB\xA6\xE2\xEE\x33\x1B\x67\x52"
           "\x81\x19\x16\x3A\xFA\x23\x82\x1B\x61\xEE\x5B\xDD\x08\x83\xA4\x5D"
           "\xCC\x57\x5A\xBF\xA5\x5C\x6E\xD7\xB0\xA2\xB6\x73\x52\x92\x9E\x5C"
           "\x46\x8D\x3E\xFB\x15\x1C\xB2\x7E\xD0\x90\x09\x61\x4F\x98\xFF\xEE"
           "\x8C\x40\x99\x83\x62\x1C\x2A\x29\xA9\x35\x58\x08\xF7\x97\xE6\xC7"
           "\x74\x50\xC9\x7D\xBF\xA2\x61\x51\x57\xD2\xDB\xDD\xE7\x19\xEF\x75"
           "\x26\xC0\x48\x56\xD9\x38\xFC\xF6\xF1\xEC\x6E\x96\x72\xCE\x2F\x19"
           "\xCA\x17\x76\x25\xFA\xDB\x0A\xBF\x4E\xD3\x6F\x65\xE2\xA3\x53\x9F"
           "\x0F\x91\xCF\xA8\x32\x9D\x83\xF1\x62\x54\xA3\x3E\x89\xF9\xD3\x20"
           "\xE8\x10\xE5\xE8\x6A\x73\x40\x90\x9A\x9D\x21\xD0\x9E\xEE\xFA\x44"
           "\x29\x42\x36\x61\xF0\x89\x9E\xE2\xFA\xBE\x06\x74\x7A\xAC\x2A\xF6"
           "\xA6\xFE\xE0\x7E\x17\x7C\xDA\xA7\x4B\xA3\x33\xD0\x66\x40\x56\x07"
           "\xB5\x21\x1A\x1E\x17\x3B\x43\x62\x9C\x0D\x16\xFA\xF3\x09\x93\x99"
           "\x56\x6C\xFD\x6A\xB7\x64\x04\x77\x33\x61\x13\x13\xD0\x93\x30\xD7"
           "\x78\xAE\xD3\x91\x30\xC2\x2C\x81\x39\x88\x9F\xE3\x9B\x4F\xF0\xC8"
           "\xFF\xA0\xA7\xED\x5F\xC3\xD7\xFE\x9C\xA7\x85\x7D\x1E\x7E\xA6\x7C"
           "\xD7\x6C\xEF\x3A\xAD\xE2\xFE\x2E\xAD\x45\x17\x9E\xC8\xA9\x71\xAB"
           "\xBF\xB6\xE3\x16\xEC\x4B\xF5\xA7\x9D\x20\x72\x87\xB4\x7E\x80\x89"
           "\xD6\xEF\x8C\xEA\x5D\xD5\xD2\x26\x9B\x3E\x58\x2C\xEB\xE6\x07\x1A"
           "\x05\x01\xD6\xBB\xFB\xA4\x2C\x31\x7A\xC0\x03\xB2\x14\x3D\x95\x41"
           "\xB5\xE3\x35\xA8\x86\xCF\x8C\x68\xFE\x01\x75\x0F\x3B\x77\x56\xA2"
           "\xCF\x29\x24\xFE\x99\x37\x02\x75\x65\x0E\xD6\xD2\x82\x9A\x93\x74"
           "\xAD\xBE\x1E\x56\x13\xC4\x29\x53\x35\x57\x4B\x46\x22\x4B\xB8\x50"
           "\x53\x71\x44\x27\xA8\xBC\x5B\x31\x0A\x32\xD4\x0F\xFF\xB2\x32\x5F"
           "\x39\xCD\xB1\x90\x77\x70\x23\xF9\xF4\x85\xDA\xE9\x16\x9D\xD5\xA0"
           "\x2A\x71\xF9\xF4\x40\x7D\xD1\x24\x5D\xBF\x93\xB3\x7F\x0D\x95\x67"
           "\x19\x51\x18\xA0\x99\x7A\x84\x44\x71\x9A\x08\x0D\x98\x25\x2E\xA6"
           "\x55\x6B\xEC\xA9\xA0\x72\xA4\xEF\x41\xC4\x20\x67\xA8\x86\xC9\x82"
           "\x86\xE8\x58\x5B\xA6\x8B\xCB\x30\xED\xF7\x7B\x0E\x6A\x6F\x6C\x39"
           "\x7A\x48\xA8\xE1\x9C\xEE\xC5\xDF\x08\x4B\xC9\x0A\x5D\xA0\x34\x42"
           "\xB5\x79\x5C\x29\xAF\xA9\xF8\x84\x31\xBE\x94\x21\x29\x17\x82\x99"
           "\x81\xB4\x9E\x2B\xC9\x78\xC5\xA6\x25\xD7\x28\xEE\x3A\xD2\x3B\xD8"
           "\x05\xCE\xEA\x07\x92\xD4\x8B\x4D\x64\xB4\x7F\x57\x9D\x2A\xFB\x80"
           "\xFF\x16\x09\xE2\x9A\xAC\x7E\x32\x2D\x2B\xE7\xA2\x9F\x9F\x63\xAF"
           "\x59\x62\xC6\x8D\x51\xD9\x2F\x6B\xF2\xB8\xEA\x9B\xAE\x30\x7A\xBB"
           "\x76\xC7\xDE\xB7\xF8\xF0\x33\x2E\x69\x65\xC0\x89\x2B\x82\x72\xAE"
           "\x8B\x65\x53\xEF\x96\xA4\xCC\xE6\xAB\x80\x9D\x23\x51\xCB\x77\x5B"
           "\xAB\x75\x5A\x70\x7B\x9C\xBE\xD6\x44\xCD\x0A\x3A\x1C\xF8\xD7\xC8"
           "\x9E\x68\x2B\xA2\xB6\x30\xC4\xE7\x3A\xF2\xDA\xE4\x15\xDE\x80\xD5"
           "\x03\xF6\x06\x3E\x19\x0B\x09\xF5\xE1\xED\xE9\x82\x79\x02\xD7\x21"
           "\x5C\x71\xFE\x15\xCB\xB5\x85\xB1\x12\x75\xF2\x94\xFC\xB7\x24\x14"
           "\xFF\xDE\xA6\x49\x7D\x61\xF8\xAE\x83\x40\x97\xC6\x13\x8F\xD6\xE2"
           "\xDA\xE8\x9D\x66\x71\x4A\x22\x1F\xF9\x55\x79\xAA\xE0\xE6\xD7\x29"
           "\x3D\x44\x2E\xC0\xB9\x4D\x64\x65\x2A\x0E\x4A\xB8\x62\xC1\x84\x2E"
           "\x3F\x6F\xEB\x79\xDF\xCF\xAA\x83\xB9\x7C\x73\x7E\x48\x88\x44\x03"
           "\xEA\x4F\x09\xCD\x72\x37\xA7\x49\x37\x6E\x52\x57\xFC\x64\x17\xE5"
           "\x9E\x36\x4D\xD7\x33\x82\xA5\x42\x3F\x37\x96\xE9\x00\x70\x91\x7E"
           "\x1F\xFF\xCD\xD3\x39\xD8\x27\x8F\x67\x81\x51\xF8\x03\xB5\x3A\xB9"
           "\x57\x64\x16\xBF\x7F\x0C\xD6\x74\xE7\x37\xB2\xFD\xF4\x20\x1B\x4C"
           "\xFD\xFC\x5C\xEF\x78\x30\x05\x38\xD7\x51\xE8\xD3\x16\x0A\x7D\x8C"
           "\xBA\x84\x9D\x1F\xF5\x6F\xE7\x15\x41\x1D\x3E\x40\x4D\x98\x64\x46"
           "\x43\x35\xA6\xBB\x0B\x0D\xF3\x39\x1D\xF9\x2B\x8C\x8E\xBD\x43\x9B"
           "\x39\x39\x10\x04\x06\x0B\x31\x7C\xF0\x1E\xE1\x70\xB1\x55\xD1\x59"
           "\xBE\x38\x24\xC8\x3E\x53\x30\xF7\x0F\xCE\x37\xCD\x5C\xF7\x90\x33"
           "\x85\x7F\x4D\x02\xAB\xEA\x50\x12\x18\xF3\x6E\x56\xA8\xEE\x38\x08"
           "\x8F\x94\x95\xAE\xE3\x74\x54\xCF\x0B\x88\x16\x7D\x2E\xBA\xAB\xCE"
           "\xCD\x7B\xA5\x62\x51\x84\x6A\x30\x0E\xF6\x44\x6C\x62\xDB\x9B\x21"
           "\xCA\x09\x0C\xBD\xE5\x09\x1C\xFA\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78"
           , 1200);
    nSKLen = 1200;
    memcpy(bInData,
           "\xB2\xC8\xAC\xF5\xBD\x59\xF7\x13\x0D\xEA\xBB\xE9\x2A\xEA\x28\xF2"
           "\x1A\x72\xC7\x20\x92\xB7\xB8\xB7\xA4\xF5\x26\x8F\x2B\x9F\x6B\x37"
           "\x88\x4C\x7E\xE5\xAF\x87\x63\x41\x34\xB5\x4D\x15\xA6\x66\xAB\x62"
           "\xD3\xB3\x0E\x7A\x4D\x5E\x82\x76\x5E\x83\x22\x68\x13\x07\x0C\xB1"
           "\x8B\x03\x40\x44\xAA\x53\x25\x17\x26\xE1\xCB\x24\x31\xD7\xEC\x83"
           "\x85\x89\x9A\x8E\x13\xAB\xED\xF5\x5C\xF0\x6B\xD4\x79\x70\x13\xAD"
           "\xF2\x01\x0B\xD5\xA3\xD9\x57\x06\x0B\x76\x46\xF3\x4C\xBB\x2D\x2A"
           "\xEF\x6F\x1F\xBD\xA8\xDE\xD1\xEF\xF2\x1F\x61\xD5\xBD\x6E\xE0\x40"
           "\xB3\x2A\x7F\xED\x1D\xF9\x19\x1D\xC8\x16\xB4\x82\xB1\xC8\x4B\xD0"
           "\x91\x53\x8D\x99\xDB\x74\xDC\xB4\x04\x78\x0D\x19\xF5\x1A\xCD\x13"
           "\x2E\x63\x00\x81\x9F\x79\x4D\xD6\x3C\x7A\x36\x4F\x4A\xA9\x08\xDB"
           "\xE9\x6E\x23\xB6\xC1\xA9\x41\x39\xB1\x36\x45\x42\xBC\x38\x5C\xB6"
           "\x11\x22\x3A\x38\x45\x63\x8F\x2D\x9F\x36\x03\x2A\xCC\xB0\x1E\x55"
           "\xBC\x74\x4B\xA0\xEE\x05\x68\x25\x1A\x29\x77\x12\x84\x1A\x32\x71"
           "\xB2\xA8\x91\x82\xEB\x0F\x73\xB5\xA7\x53\x0A\x3F\x3E\x9A\xFA\xFA"
           "\xC4\xB6\x13\x58\x95\x75\x5F\x51\x9F\xA9\x89\x23\xA5\x19\x0F\xB0"
           , 256);
    nInDataLen = 256;
    memset(bOutDataExp, 0x42, 256);
    bOutDataExp[0] = 0x30;
    bOutDataExp[255] = 0x39;
    nOutDataLenExp = 256;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 1200);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 256);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-2048，无填充，解密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 256);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 256);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 256);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_13(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 1;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    memset(bInData, 0x42, 53);
    bInData[0] = 0x30;
    bInData[52] = 0x39;
    nInDataLen = 53;
    memcpy(bOutDataExp,
           "\xAC\xFE\x6C\xA5\x13\x16\x5C\xDB\x11\xD7\x54\x0E\x5F\x83\x98\xCD"
           "\xEC\x7B\x75\x16\x3B\x01\xD0\x24\x8C\x04\x04\x1B\x15\xB4\x87\xA8"
           "\xE9\xCE\x8C\x13\x65\xC1\x64\x8F\x81\xAC\x1F\x96\xFA\x97\xEC\xCE"
           "\x6C\x66\x99\xB9\x63\xB0\x37\xB3\xFE\x25\x2E\xED\x49\xC6\x1B\x00"
           , 64);
    nOutDataLenExp = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 320);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 53);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-512，PKCS#1填充，加密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 64);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 64);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 64);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_14(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 1;
    memcpy(bSK,
           "\x3B\xD4\x50\x5C\x7E\x86\x10\xCE\x25\x5C\xB9\x39\xC2\xD4\x61\x5C"
           "\x7F\xC2\xC4\x74\xE5\x22\x06\xCD\x50\x53\xAF\x84\x02\xF7\xE6\x54"
           "\x85\x44\x18\x4D\xE9\x05\x89\xF5\x5D\x0E\xC0\x55\x6A\xD2\x53\xA5"
           "\x36\x71\x2D\xD5\xFD\xEA\x8A\x45\x4C\xC6\x00\x3B\xE7\x01\x70\x1C"
           "\xEC\xA6\xD1\xF4\x7D\xF0\xD5\xF5\xB6\x5A\x00\x43\xBC\xF0\x6A\x79"
           "\xFF\xD3\x30\xB8\x5F\xFA\xEA\xE0\xD1\x9E\x6C\x02\xAE\x9A\x13\xF0"
           "\x09\xED\xB1\x9C\x0A\xBE\xA9\xB7\x93\x66\xBB\x08\xC6\x0A\xA2\xFD"
           "\xFE\x19\xBF\x9E\x9E\x7C\x1C\xCF\xBB\xF6\x3F\x4D\x1A\x35\xF9\x26"
           "\x2A\xF4\x84\x29\x43\x79\xE7\x3D\x9B\x58\xF9\x30\xE1\x27\x3B\xC0"
           "\xD7\xE7\xEF\xF8\x52\x50\x2C\x85\x65\x1B\x1C\x3D\x2D\xA9\x73\x8F"
           "\xCA\x54\xF3\x60\xE4\x84\x67\xAC\xEB\xAA\x24\x30\xC9\x98\x9D\x4B"
           "\x2E\xF3\xD7\xE1\x93\xCA\xC0\x63\x3F\xD1\xE4\xAF\x08\x37\x63\xB5"
           "\x8A\xDB\x3E\x66\x44\x4E\x01\x7F\x75\x92\xB4\x5D\x79\x6C\x94\x9B"
           "\x4C\x55\x2F\x9A\x26\xD9\x54\x65\x67\x41\x4A\xAC\x1F\x7C\x4A\xFE"
           "\x1E\xDD\xDD\xE1\x51\x3A\xB2\xE2\x92\xFA\x3F\x8D\xFF\xEE\x78\x0A"
           "\xBB\xFB\xD6\x94\xE3\x39\x48\xF8\xF1\xC0\x3A\x36\xF4\x65\xF6\xB9"
           "\x2A\x2C\xEE\x71\x11\xAA\x7B\x55\xBF\x9D\x13\x0F\x74\x47\x05\x87"
           "\x27\xF0\x9F\x65\x6E\xED\xAF\x2B\x78\x69\xFE\x3A\x40\xA3\xDB\x58"
           "\xCC\x5C\x83\xC5\x0E\x9B\xF3\xB5\x8B\x6D\xA8\xBE\x0C\x5E\x38\x2A"
           "\x12\x8C\x3E\x40\xA1\x03\x43\x20\x6B\x4B\x3D\x65\x8C\x96\x13\x5F"
           "\x58\x56\x87\x88\x20\x0A\x12\xD8\x42\x95\x55\x5D\xDD\x74\x23\xF3"
           "\x05\x77\x04\x02\xBC\x97\x6E\xED\xEB\x33\x10\x4B\x8C\x58\x0C\xDF"
           "\x9A\x54\xCD\xB9\x69\xAA\x0B\x15\x13\x8B\x95\x87\x55\xFC\x05\x0A"
           "\x81\x5E\x00\x9D\x50\x9D\x7D\x73\x94\x6B\x78\x30\x40\xC7\xF4\x89"
           "\x76\x9F\x1D\x3B\x69\xAE\x65\x5C\xF5\xAB\xF8\xC0\x33\x0F\xA3\x02"
           "\xA4\x41\x96\x86\x47\x75\x2F\x3B\xC4\x3D\xE8\x5A\x88\xAB\xB9\x74"
           "\xB9\x8F\xA7\xDC\xBE\x35\xE0\xA1\x31\xA1\xEE\xAC\xD3\x01\x97\x67"
           "\x65\x1D\x81\x74\x38\x11\xEF\xC5\x0F\xDD\x6B\x70\x98\xF8\xDC\x91"
           "\xFA\x20\xDD\x34\x9F\xB4\xB2\x09\x6B\x90\xD7\x81\xBA\xD4\x34\xEA"
           "\x24\x83\x49\x86\x3C\xDF\x51\x98\xDB\xA2\x68\x53\xC3\x41\x47\x3B"
           "\x70\x13\x1B\xC7\xB1\x4B\x64\xD3\xD1\x46\xF6\x97\x04\x65\x8C\x24"
           "\x13\xD0\xE5\x85\x7D\xBF\x31\x3A\xB5\x49\x14\xF1\x3F\xFA\xB5\xC1"
           "\x47\x61\x69\x76\x6E\xD2\x9D\x84\xA0\x88\xD6\x65\x35\x6E\xD4\xEB"
           "\x57\x1D\x9F\xF5\xB5\x10\x5D\x12\x05\xA1\xF2\x5A\x37\x4D\x9A\x65"
           "\xBA\xE8\x69\x9B\x02\x93\xAD\x7A\x84\xB0\x6E\xF2\xB6\xB3\x86\x11"
           "\x8F\xF8\xB2\x23\x4E\xD4\x33\x74\x9C\xB4\x91\xD8\x57\x01\x18\x14"
           "\x8A\x63\x13\xFB\x17\x1B\x91\x0E\x35\x71\xD2\x0A\x73\xCD\x99\xA9"
           "\x5C\x10\xD3\xDE\x93\xF4\x5A\x63\xCB\x08\x1E\x8F\x38\x0E\x1A\xB1"
           "\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78"
           , 616);
    nSKLen = 616;
    memset(bInData, 0x42, 64);
    bInData[0] = 0x30;
    bInData[63] = 0x39;
    nInDataLen = 64;
    memcpy(bOutDataExp,
           "\x45\x13\xD8\xF1\xEA\x82\xEA\x34\x9F\x82\x04\x9E\x15\x76\x89\x50"
           "\x5E\x47\x6B\xC7\x53\x8F\xB1\x1F\x88\xAA\x17\xCE\x71\x9C\x6D\x48"
           "\xF0\x60\x36\x56\x21\x80\xFA\x6E\x68\xCE\xF2\xF7\x32\x87\xFB\xB9"
           "\x13\xAF\xFD\x87\x37\x44\x38\xAB\x34\x15\xBF\x70\xB0\xD2\x4F\x73"
           "\xE7\x31\xD1\x1D\x3A\x58\x68\xFE\x84\x48\xAE\xE5\xAB\xDA\xF7\x2E"
           "\xC0\xBB\x12\xAD\x06\x6E\x9D\x27\xA6\x68\x28\x6F\xDB\xE3\x2D\xA8"
           "\x1C\x7E\x62\xD8\x9C\x1B\x7E\xE6\x24\xC7\x5B\xB5\x2F\xCC\x40\xE3"
           "\xCF\x22\x3E\xEC\xE6\x87\x31\x52\xCC\x60\x74\xEE\x30\x2C\x36\x2F"
           , 128);
    nOutDataLenExp = 128;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 616);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 64);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1024，PKCS#1填充，加密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 128);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 128);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 128);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_15(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 1;
    memcpy(bSK,
           "\xDF\x00\x50\x67\x45\x67\xCB\xA9\xF3\x62\x34\x84\x08\x05\xEE\x96"
           "\x70\x77\x07\xC3\x71\x70\xAD\xC0\xE9\x02\xE7\x50\x58\xCB\x00\xCF"
           "\x55\xAA\xB9\xE0\x3D\x47\x8D\xC8\x38\x3A\x78\x92\xB2\x54\x98\xEF"
           "\x5A\x46\x80\x77\x58\x05\x1E\x94\xA8\x62\xE6\xFA\x5C\x54\x15\x48"
           "\x2D\xDB\x8C\x41\x31\x90\x9F\xE9\x4D\x87\x7A\x21\xB9\xA3\x13\xE5"
           "\xE0\xED\x09\x27\x17\xB6\xB1\xAA\x23\xBE\x5F\x80\x9F\x25\xF2\xE1"
           "\x7A\xB2\xCB\x36\xF2\xE5\x2A\x6F\x63\xD1\x4C\xD6\x53\x07\xBF\x83"
           "\x4F\x59\xE1\x20\x63\x9C\x33\x38\x88\xD3\x79\x7D\xF1\x47\x6E\x16"
           "\x3F\x38\xF3\xCF\x0D\x25\xF4\xD5\x28\x76\x55\x5C\x22\x54\x1B\xAD"
           "\xCC\xB6\x21\x81\xFC\x32\xE0\xCF\x8C\x30\x3A\x96\x31\x48\x02\x7E"
           "\x0E\x2A\x4B\x99\x46\x5C\xCA\x23\x82\x41\xA6\x9B\x8A\x71\xF4\x4E"
           "\x7A\xCF\xBE\x9D\xEC\x18\x90\x04\xF2\x6F\x9F\xD9\x76\xFD\x43\x17"
           "\x81\xF0\xD7\xB8\x1B\xE6\x7C\xBB\x5F\xB9\x9D\x8E\x96\x4D\xC5\xE3"
           "\x7A\x98\xBA\x11\x2B\x52\x62\xA3\x48\x6F\x9C\x8F\x3F\x4A\x88\xF4"
           "\xEA\x82\x59\xBD\x2D\x55\x06\x8F\x51\x8D\x37\xA0\xB0\xF4\xA7\x23"
           "\x76\x86\xFF\x68\xEA\x6C\x64\xFE\xC0\xCD\x6C\x48\x20\xCB\xD2\x77"
           "\x31\x73\xD8\x50\x5A\x13\x84\x98\x8D\x0A\xF1\xB9\x8A\xD8\x87\x54"
           "\xDC\xB4\xBA\x6A\x0E\x7D\x04\x4D\x7C\x6C\xF6\xE3\x50\x65\xEF\xC2"
           "\x9C\x70\x39\x70\x99\x60\x53\x70\x88\x1D\xA2\x56\x1A\x78\xB8\x15"
           "\x17\x81\x3F\xEC\x07\x0A\xE0\x33\x7A\x82\x0B\xE2\x21\x53\x1B\x27"
           "\x7C\x06\x69\x00\x82\xB3\xAB\x74\xE9\x43\xDD\xCC\x69\x2C\xF8\x51"
           "\xAF\xEB\xEE\x15\x6E\xE0\x35\xA8\x6A\x0D\x35\x8A\x01\x98\x68\x8A"
           "\xC5\x71\xAA\x8C\xDB\x31\xC7\x04\x5D\xEF\x33\x50\x1A\x66\xC9\xBF"
           "\x85\xE8\x30\xBF\x8E\x36\x86\xA3\xB0\xBF\x18\x8E\xA0\x93\xB3\x5C"
           "\xD2\xD3\x6E\x57\x86\x14\x30\x5D\xC5\x29\x0B\x5A\xEF\xEA\xA3\x9C"
           "\xC0\xDD\x9B\xDF\x67\xB9\xAF\x01\xC4\x0C\x83\xE1\x36\x95\x4E\xB6"
           "\xF2\x61\x4F\xB8\x09\x8E\x66\x90\x23\xE7\x6D\xD1\x71\xF4\xF4\xE7"
           "\xF4\x3B\x54\x8D\x91\x05\x89\xB5\xFE\x78\xBA\x30\x87\xF5\xB5\xE6"
           "\xE8\x55\x5B\xCA\x64\xAF\x89\x59\xA0\x50\x8A\x7D\x19\x40\xDF\x49"
           "\x31\xEA\xEF\x76\x70\x2E\x1F\xC7\x05\x7E\xA0\x2A\x42\x17\xA2\x0A"
           "\x32\xAC\x36\x7F\x31\xFF\x11\xED\x06\x13\x03\xC6\xDF\xEF\xC4\x27"
           "\x8C\x29\xE3\x36\xE6\xDE\xBC\xE8\x7B\xB5\x7B\x9A\xCB\x93\xF1\x21"
           "\x26\x38\x94\xDA\xF5\x1B\xD7\x2F\xA9\x3C\xEC\xE3\xDC\xD6\xD8\xFC"
           "\x03\x4D\xE1\x49\xA2\x22\x6E\xFD\x57\x80\xAB\xF4\xFA\xD5\xC2\x53"
           "\xCE\x6D\xB2\x61\xE3\xA8\x22\xD8\xD2\x9C\xFE\x85\xE2\x80\xA0\x9D"
           "\x1E\xAF\x00\x3F\xF2\x36\xE1\xE5\xBC\x32\x73\x7E\xD0\x6E\x18\x66"
           "\x48\x64\x91\x0E\xB6\x70\x82\xAA\x40\xFA\x2D\xB5\x27\x0A\x71\x17"
           "\x15\x96\xD4\x2B\xEF\xB4\x82\xA2\x4C\x7C\x08\x2B\x9E\xD6\x99\x56"
           "\x20\x08\xCD\x7D\x6B\x5E\x38\x53\x67\x13\x38\xED\x16\x44\x71\x12"
           "\x97\x4B\x84\xE7\xCE\x12\x53\x70\x46\x6A\x71\x51\xAD\x8B\x71\x2D"
           "\xE5\x4C\xF7\xFF\xCE\x39\xB3\xA0\xB1\x46\x26\x4F\x1A\x63\x0C\xB9"
           "\xEE\x8F\xC7\x8E\x61\x24\xD0\xFB\xD4\x33\x00\xFD\x85\x23\x8B\x12"
           "\x09\x49\x7D\xA8\xE2\x9D\x2E\xFD"
           , 680);
    nSKLen = 680;
    memset(bInData, 0x42, 72);
    bInData[0] = 0x30;
    bInData[71] = 0x39;
    nInDataLen = 72;
    memcpy(bOutDataExp,
           "\x0C\xBC\xF6\x9A\xE4\xAA\xAA\xC5\xBC\x07\xD3\x59\xA2\x07\xF9\xFD"
           "\x3B\xC4\xD6\xB5\x42\x08\x96\x97\x86\xE2\xC8\xD1\xD9\x20\x9A\x1A"
           "\xA1\x27\xDE\xEB\x59\x5B\x3A\x04\xE1\xA6\x0D\xC9\x19\x7A\xF8\x58"
           "\x1F\x1B\x17\x2D\xF2\x13\x5B\xBD\x2C\x58\x5C\xAB\x17\x6E\xBA\xFD"
           "\xD6\x83\x63\x08\xA4\xD9\x91\xBF\x84\x74\xB3\xAE\x27\x58\xD9\xE4"
           "\x0D\xC4\xF1\x1A\x2F\xDE\x3A\x68\x2A\x6B\xAA\xD5\x96\xDE\x14\xCB"
           "\xBF\x11\x4A\xE7\x15\x91\xBA\x9F\xF3\x1D\xB4\x78\x24\xEA\x5E\x9A"
           "\x0A\xCF\xF9\xDF\x7C\x7F\xDC\x27\x6E\x89\x14\xB5\xF3\x89\xE0\xAF"
           "\xD7\x31\x6F\xB1\x02\x2C\x18\xEF\xA6\x77\x1D\x07\x97\xF9\x1A\x06"
           , 144);
    nOutDataLenExp = 144;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 680);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 72);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1152，PKCS#1填充，加密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 144);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 144);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 144);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_16(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 1;
    memcpy(bSK,
           "\x21\xE5\x82\xE3\xD4\x2B\x83\xA7\x68\x16\x92\xEF\x49\x12\x6D\x45"
           "\xC5\x11\xC5\x1E\x9E\x67\x6F\xF9\x04\x47\x04\x31\x37\x69\xFD\x3D"
           "\x6C\x60\x8F\x08\xC7\xF3\xF1\x69\xDF\xCC\x66\x75\xEA\xB0\x61\x33"
           "\xAF\x7A\x12\x41\x94\x5A\x51\x39\xB5\xBE\xE7\x4C\x9D\x98\x77\x80"
           "\x6C\xB9\x2B\x98\x4E\x55\xEC\x57\x0E\x8A\x1F\xA8\x52\xDE\x44\xC5"
           "\x08\x2F\x21\xD9\x0E\xDD\xB5\x5E\xF3\xA1\x8C\xF1\xC3\xCB\x0A\x18"
           "\xD3\x80\x83\x10\xEB\x2E\x99\x59\x45\x7D\x2B\x92\xF5\x22\x7B\x49"
           "\x67\x02\x84\x5F\x56\x56\xBC\x95\x04\xA4\xB7\xB7\x53\xAE\x19\xF1"
           "\xF8\x7C\x3D\xEA\xDA\xDF\x52\x99\xF5\xB4\x15\xAB\x03\x8B\xBD\x6B"
           "\xC0\x8C\x86\xFC\x56\xCC\x3C\x0C\x38\x31\xBD\xB7\x28\x29\xAC\x0E"
           "\x24\xF2\x12\x6E\x6A\xFC\x01\x1C\x18\xC6\x3A\xCD\xD8\x0A\x64\x27"
           "\x93\x9D\x76\xAA\x27\x42\x7E\xEF\xFB\x83\x2A\xB5\xF3\xD0\x15\xC8"
           "\xEF\xF4\x3E\x5B\x5F\x3B\x4F\x96\x2C\x76\x6A\xD6\x69\xD7\x57\xC1"
           "\xF6\x40\xDF\x49\x7B\x4A\x9B\xE2\x7A\xE3\x09\x8B\xC9\x47\xA9\x14"
           "\x5F\x1D\xC1\x4A\x7F\x9D\xCF\xEF\x7D\x1A\x91\x6F\xC7\xA0\x41\x7F"
           "\x7B\xC3\x15\x00\xEC\x53\x34\x22\x95\xEE\xE7\x08\x39\x63\xF5\x54"
           "\xB6\xAD\x39\x45\xB5\x21\x5C\x34\x5E\x67\x7B\xD8\x97\x50\x91\x75"
           "\x6F\x68\x0A\x95\x8F\x24\xBE\x83\xDB\x44\x91\xE0\xD2\x99\x24\x99"
           "\xBD\x11\x2E\x15\xA9\xCC\xCD\x14\xD9\xBB\x5E\x56\x0F\x69\x9A\x18"
           "\x5A\x42\x25\xB1\x3F\x6B\x03\x18\x51\x9C\x36\x8F\xDB\x1E\xB9\x11"
           "\x3A\xEF\x24\xDB\x9B\x2E\xA2\x1B\x11\x73\x86\x5A\x4C\x12\x4F\xD8"
           "\xCB\x07\xEE\x99\xAC\x04\x10\x2B\x1C\xD7\xB8\xEB\xE7\x56\x2C\x8A"
           "\x12\x36\xDD\xA0\x11\x9D\xC8\x26\x37\x66\x0B\x21\x89\xC3\x7D\xA1"
           "\x40\x85\x91\xFF\x5E\x80\x70\xFB\x68\x28\x03\x8A\x6F\x09\xBC\xD6"
           "\xAC\xAF\xF4\x60\x67\x8D\xA8\x3E\x17\x5B\x5A\xE9\x3E\x17\xA9\x34"
           "\xA9\xD7\x29\xBE\xBE\xE3\xCD\x09\x74\x23\xC7\x21\xEE\xA2\x63\xA2"
           "\x33\x64\x92\x53\x31\x74\xF2\x96\x0C\xD0\x11\x30\xB6\x9F\xE0\xBA"
           "\x5B\x4C\xFA\xA0\xBB\x83\x1C\x74\xD8\x70\xE0\x4B\x2A\xAA\xBD\x88"
           "\x4A\x1E\xB5\x22\x63\xD7\x2E\xBD\xA4\x8E\x6C\xA3\x10\x29\xE8\x29"
           "\xA8\x43\x89\x66\xB7\x7E\x3D\xBE\x8C\xE3\xFC\x5A\xBF\x06\x0B\xCC"
           "\x34\x91\x9D\xE3\x85\x1D\xB7\x39\x03\xC3\x0C\x05\x17\xA4\x8D\xE0"
           "\xB3\x9E\x01\xF7\x80\xF4\xBB\xF0\x22\x23\xDA\xBD\xC4\x14\xBB\x78"
           "\x58\xC5\x7F\xC6\x09\x41\x54\xBB\x11\x96\xE6\xA3\x1A\xC9\x55\xBD"
           "\x0F\xF0\x3F\xBE\x61\x83\xCE\x26\x82\xA2\x8E\xD5\x0D\x2D\xB7\x66"
           "\xBC\x2E\xF0\xEB\xC3\x2F\x6A\x2A\xF5\xB9\x8B\xF0\x42\x4F\x65\x8B"
           "\xD1\x6E\x76\x88\x8C\x29\x34\xCF\x26\x27\x84\x8E\x6B\xA2\xEB\x16"
           "\x77\x2D\x21\x7E\xEC\x18\x4D\x04\xDA\xEF\x95\x1C\x29\x75\x18\x1C"
           "\x83\xCA\xB6\x72\xC3\x77\x46\x29\xBB\xFC\xDE\x1D\x78\x72\x76\x47"
           "\x20\x40\x90\xDC\xBC\xA3\x72\x33\x64\x7E\x18\xD9\xA4\xD2\x46\x9C"
           "\x77\x8B\xF9\x6D\x97\xB0\xD6\xA1\x20\x2C\x0D\xB6\xE3\x2C\x09\x8F"
           "\x07\xB6\x5F\xD3\xDB\x3B\xFD\x77\x69\x7D\x56\xE4\x35\x18\x3A\x9B"
           "\xF6\x22\x3A\x01\x35\x71\xBE\xA4\x48\x97\x8B\x45\x90\x46\x07\x0E"
           "\x17\x68\x9E\x00\x11\x6F\x4A\x25\x55\xA0\x9C\x74\xD9\x15\xFF\xF5"
           "\xE0\x59\xD6\x86\xA0\x91\xD8\x7F\x9A\xFF\xE4\xBD\xAB\xE3\xF0\x94"
           "\x49\x66\x36\x7F\xD3\xD3\x8E\x13\xB7\xFC\x89\xB7\xA9\x3C\x7B\x0E"
           "\x11\xAC\x66\xCE\x34\x34\xAE\x67\x70\xE0\x3A\xB6\x0E\x78\xFD\x94"
           "\xF1\xB5\x74\xD3\x47\x2A\x74\x40\x51\x39\xD1\x49\x73\x94\xB4\xF9"
           "\x4C\xB6\x4B\x11\x19\x2F\x7E\x34\x3E\x6B\x4F\x34\x5B\x83\x52\x47"
           "\x99\x0C\xD6\xDF\x7B\xA3\x95\xE2\xCC\x39\x2F\xC4\x92\x43\x38\x2F"
           "\xCB\xE6\x8C\x2D\xAD\xD0\x5E\xE9\xD5\x3D\x5E\x70\x2E\xA8\x66\xB0"
           "\xA6\xB8\x7C\xA4\x3A\x9E\x28\x3B\x0E\x46\x20\x84\xF8\x5E\x53\x9E"
           "\xCF\xDE\xF3\x0F\x1F\xE3\x8D\x51"
           , 824);
    nSKLen = 824;
    memset(bInData, 0x42, 88);
    bInData[0] = 0x30;
    bInData[87] = 0x39;
    nInDataLen = 88;
    memcpy(bOutDataExp,
           "\x94\xAB\x1D\x36\x2F\xCF\x6B\xAB\x6A\x42\xD7\xF7\xFC\xA1\xFD\x79"
           "\x17\xFF\x37\x54\x1C\x40\xCB\x69\x1F\xA0\xF1\x8A\xF9\x0B\x64\x0D"
           "\x8D\xD6\xA9\x6D\xD4\x71\x25\x90\x6A\xB0\xE4\xFA\xED\x39\x94\x27"
           "\x18\x02\x54\x5D\x97\xEB\x02\x71\x39\x90\xB4\x33\x4F\xDF\x89\xF8"
           "\x89\xCA\x78\x21\xE7\xA1\xEB\x8E\x5E\xD7\x71\x16\xDC\xCD\x43\xDD"
           "\x9C\xD0\xE1\x86\xB0\x1F\x7B\xE5\xFF\xF5\xA5\x32\xD9\x7E\x50\x44"
           "\xF8\x45\xEA\xD0\x53\xE0\x6B\xBA\x45\x52\x36\x9D\x57\xB8\xD7\x28"
           "\x24\xFC\xFE\x2F\xF3\xBF\x78\x80\x1F\x0B\x63\x67\x69\xC2\xDA\x52"
           "\x0C\x76\x8A\xBA\xE0\xE5\x9E\x61\x78\xA0\x4D\xD6\xD5\x92\x9B\x05"
           "\xE0\x7E\x26\xE1\xE5\xC1\x42\x70\x0A\x66\x13\x8B\x91\x65\x35\xC6"
           "\xAB\xB2\xE1\x40\xB7\xAC\x75\x5F\xF1\x86\x86\x75\x55\xAB\x5E\x8E"
           , 176);
    nOutDataLenExp = 176;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 824);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 88);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1408，PKCS#1填充，加密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 176);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 176);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 176);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_17(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 1;
    memcpy(bSK,
           "\x6C\x18\x21\x1D\x3D\xDC\x38\xA8\xBA\x10\x33\x70\x83\x41\xB5\x37"
           "\xFE\x97\x6F\xB1\xF4\x21\x1A\xAD\x35\x77\xBD\x28\xB2\x57\x20\x10"
           "\x16\x13\x93\x89\x47\xC3\x73\xFC\xB9\x76\x48\x3A\x77\xCD\xA7\x0C"
           "\x17\xE9\xF1\x4C\xD0\xA7\xE1\xAA\x0D\x9A\x8C\x38\xD1\xE6\x83\xA6"
           "\x93\xD4\x55\x28\x6B\xB9\x0F\x81\x02\x7A\x78\x54\x00\x84\x94\xFB"
           "\x82\xCC\x8A\x78\xFC\x93\x45\x6E\xD3\x13\xD3\x1F\x18\x69\x73\x2A"
           "\x70\x86\x1F\xFB\x25\xE6\x2A\x64\xCC\x6F\x1F\x18\x26\x0D\x1C\x40"
           "\xAA\x5E\x52\x50\x22\x5A\xE4\x3C\xBC\x29\xFA\xCA\x30\xE3\x53\x40"
           "\x34\x35\xF1\xD0\xE2\x69\x1D\x34\x8E\x83\x96\xAC\xAA\xCF\x6C\x98"
           "\x3F\x4F\x8C\xEF\x8C\xB3\x3A\x04\xF5\x7C\xB1\x76\xA3\x32\x1B\xC1"
           "\x83\xAD\x70\xA5\xF9\x08\xB8\xD9\x2E\xED\x15\x65\xB0\x33\x30\x04"
           "\x1F\x69\x87\x1D\xFF\xBF\x0F\x59\xE3\x62\xE1\xE8\x2C\x03\x4B\x72"
           "\xB6\xAA\x8F\x73\xBA\xFE\xEE\xCC\xAF\x50\x87\x3D\xA0\x5F\x66\xA0"
           "\x88\x3A\x7F\xDF\xA1\x8E\x06\x08\x18\x2C\x1A\x16\xCE\x0C\x6E\x13"
           "\x4F\x2E\x26\x3B\xB8\xAF\x70\x5E\x70\x48\xED\xCE\x8D\x6C\x9B\x26"
           "\xD7\xFE\x95\x5F\xC6\x91\xB6\x81\x3F\x7C\x9A\xF1\x6D\x1B\xAB\x6E"
           "\x84\x10\x94\x5A\x07\x38\x56\x75\xF0\xEB\x3C\x5E\xA3\x0E\x85\x17"
           "\xFB\x5B\xD0\xFA\x84\x3D\x58\x4C\xFD\xF0\xE5\x37\x77\x29\xE2\x5A"
           "\x7C\x74\x87\x04\x9C\xF0\x7A\x2C\xE4\xD2\x0A\x1C\xD8\x8B\x37\x8C"
           "\x7F\x1C\x10\x6E\x73\xB2\x69\x4C\xBE\x1A\x84\x3C\xC8\xA7\xA3\x68"
           "\x48\x7E\x2F\xFD\x9B\x5F\x12\xAD\x15\x49\x3F\xC4\x10\x86\xAF\x56"
           "\x4D\xCB\xC6\xE8\xAD\x35\x72\x21\x24\xD9\xC3\xA3\x82\xF1\xB2\xAF"
           "\xD9\x88\xBF\xFB\xCB\x81\xF9\xF6\x3B\xC6\x1C\x34\xF0\x5A\x33\xE5"
           "\x41\x9B\xC2\xF9\xE2\x23\x0E\x2D\x11\xC5\xBF\x41\x91\x7B\xE9\x36"
           "\x07\xD8\x60\x00\x09\xDD\xD5\x86\xD7\x65\x50\x98\xBC\x5C\x0E\x60"
           "\xA0\xE5\x53\xEC\xA6\x9D\x11\x99\xEA\x25\x44\xF4\x50\x76\x0D\x4D"
           "\xE7\x72\x87\xCF\x6F\x7C\xF2\x27\xED\x73\xD7\xEF\x53\x6D\x0B\x99"
           "\x6B\x38\x44\xBC\xC0\x12\xF5\xD6\x92\x3F\x64\x81\x54\xC1\xEF\x04"
           "\x5C\x1F\x23\x7E\xF5\x38\xA7\x80\xFC\x17\xEF\x00\x3C\x8D\x09\xAB"
           "\xAA\xD0\x40\x14\xD7\xCB\xAC\xA1\x29\xE0\x12\xD5\xD4\xFF\x1B\xDD"
           "\xCA\x78\x2B\x1D\xEC\x9F\xA5\xAC\x67\x74\x31\x8C\xF6\x8F\x9A\x59"
           "\x7D\x84\xF1\x7E\x5D\xA4\xC9\x53\xEF\x58\x2D\x1F\x0F\x3A\x6D\x66"
           "\xFF\x06\x61\x1A\xDC\xDB\x19\x0C\xE6\x43\xC4\x4A\x2B\x3D\x8E\x79"
           "\xD4\x93\xA8\x9A\x1A\xF7\x91\x45\x77\x78\xAB\xE1\x77\x33\x26\xFF"
           "\x92\x0B\x96\xD5\xF3\xAF\x05\x0B\xC4\x53\x1B\x89\xEC\xDC\xD0\x12"
           "\x4A\x65\xF3\xAD\x43\x8C\x23\x35\x13\x79\x4E\xD8\x0D\x21\xC9\x61"
           "\x49\xCA\x48\x53\x48\xC6\xA1\x7E\xF0\x28\xA5\x97\x11\xB8\x18\x33"
           "\xAD\xEC\xEF\x6B\x5C\x71\x4A\xBE\x9F\x31\xB8\xA3\x98\xC5\x0C\x0B"
           "\x46\x51\xA2\xAE\x02\x6F\x98\x35\xF7\x4D\x21\x5E\xC3\xED\x61\xB0"
           "\x6B\x59\x79\x5A\xB9\xA8\x1C\xB0\xBA\x82\x67\xB9\x97\xBB\xD4\x4D"
           "\xF1\xA1\x56\x5C\x7D\xCB\x77\xD0\x28\xE0\xFF\x1C\xAA\x22\x07\x68"
           "\x9B\xF3\x80\xDE\x96\x1D\x03\xDD\x97\x8A\x69\xDA\x5C\x54\xD4\x80"
           "\x93\xB2\x0D\xCD\x43\xBA\xFC\xDF\x11\xCF\xFE\xCE\x3B\x74\x8E\x67"
           "\x17\x74\x8E\x29\xF9\x64\x97\x52\x8C\x7B\xC9\x71\xB3\x5E\x59\x86"
           "\x63\x38\xF6\x9E\x79\x43\x56\xD6\x6F\xE6\x26\x45\x62\x64\x26\xE0"
           "\xA7\xDC\x70\xCA\x5B\xCD\xE7\xC6\xE1\x1F\xFC\x97\x57\xA1\x2B\xC5"
           "\x12\xB6\x9E\x85\x37\x9E\x58\x48\x2F\x9A\x91\xB7\xB6\x7C\x28\x47"
           "\x1A\x73\x45\x41\xD4\x6E\xBE\xB5\xB7\x60\x1A\xF2\x8B\x04\x78\x38"
           "\x4B\xB6\x45\x8C\xA9\x3E\xE5\x7A\xBF\x1F\xC4\x86\x30\xB4\x0C\xB1"
           "\xC6\x9D\x80\x88\xD2\x49\xD9\x89\xD9\x50\xA8\xDE\xEC\xA5\x04\x7F"
           "\xFF\xEA\xC0\x2F\xCB\x37\x7A\xB6\x97\x59\xAD\x53\x29\x34\xB3\x79"
           "\x16\x3B\x3E\xF5\x7F\x14\xB3\x77\xF9\x2E\xE8\x3F\x04\xAE\xDE\x89"
           "\x73\x04\x32\xA7\x4C\xC0\x4D\x43\x0D\xC1\xE5\x21\x48\x32\xAA\xE1"
           "\x5E\x81\xB6\x23\x6A\x80\xCA\x17\x23\xFC\x5F\x47\xE1\x57\x14\x59"
           "\x46\x67\x0F\xBF\x6A\x57\x53\x10\x8E\xAB\xAA\x9C\x8A\xDD\xE0\x9D"
           "\xA2\xAC\x94\x87\x6A\x71\xD0\xAF\xE4\x8A\xCF\xEB\x23\x27\x00\xC2"
           "\x8B\x11\xA9\x2C\x02\xB5\x05\x03\x30\x7A\x0C\xEF\x7F\x5B\x1C\xE7"
           "\x64\xFF\x1E\x68\x78\x28\x1C\x6D\xA0\x16\x75\x36\x7F\x9F\xF9\xCD"
           "\x15\x3B\x8E\x26\xC3\xF1\x7A\xBC\x17\x42\x92\x7D\xA8\x4E\x22\x5F"
           "\xB9\x55\xF5\xB7\x2C\x10\x5E\x79\xBB\x81\x54\x32\xDC\x8D\xE7\x4B"
           "\xE3\xCB\xDB\x1D\x34\xA4\xBA\x5F\x1A\xFE\x43\x48\x46\xEF\x88\x67"
           "\xD5\xB6\xDD\x06\x99\x5C\xB3\x38\x45\xED\xD0\x21\x77\x22\xF4\xF3"
           "\x68\xD6\x90\x53\xB5\x1E\x36\x3C\x35\x08\xCF\xBE\x53\x8F\x59\xDB"
           "\x4D\xAA\xA2\xB4\xF9\x93\xAC\x4C\x0C\xE4\x5D\xDF\x79\x57\x3C\x8F"
           "\x42\x44\xEC\x0C\x09\xA9\xC6\xE8\xF9\xF0\x80\x2E\x76\x25\x2E\xC1"
           "\x72\x0E\x55\xD6\xB9\x78\x9A\xAE\x56\xFE\x8B\x35\x38\xAF\xE3\x80"
           "\x78\x57\x55\x15\xC9\xEC\xCC\xCB\x42\xC3\xC5\xDF\x8A\xAE\x67\xB0"
           "\xCD\x63\x8E\xFC\x28\x77\x7F\xD1\x31\xFD\x9D\xD2\x79\xC8\x0A\xE0"
           "\x1A\x86\x0D\xEB\x3B\xB4\x64\x49\xAA\x6B\x7B\x73\x27\xEC\x7D\x66"
           "\x6A\x4C\x37\xB3\xCD\x4E\x97\x97\x3C\xEF\x7E\x13\x45\x36\xAA\xFE"
           "\x2E\x16\x48\x90\x5F\x53\x63\x62\xC7\xAB\xC9\xC7\xB5\x9E\xFD\xA5"
           "\x8B\x0C\xCA\xD0\x1E\xBD\x51\x67\x98\x94\x63\x08\x13\xCC\x05\xB9"
           , 1152);
    nSKLen = 1152;
    memset(bInData, 0x42, 124);
    bInData[0] = 0x30;
    bInData[123] = 0x39;
    nInDataLen = 124;
    memcpy(bOutDataExp,
           "\x82\x05\x88\x30\xA8\x60\x00\xF5\x23\x6F\xDC\xB7\x44\x7B\x94\x4B"
           "\x9C\xF6\x82\xC4\xDF\xE1\xE4\x94\x4B\xD5\xBA\xC4\x58\xE4\x91\x41"
           "\x37\xA1\x46\x17\x67\x4D\xE8\xFB\x1B\x8A\x63\x3C\x50\x91\x30\x7B"
           "\x20\x8C\xC4\x88\x61\xDC\xCC\x4E\x2F\x2C\x78\x31\xF2\x75\x6B\x82"
           "\xA5\xCF\x4E\xFF\x1E\x2D\x3C\x24\xD5\xDA\x71\xF1\x7E\x7A\x41\xFF"
           "\xA2\xB6\x79\x2E\x13\x77\xED\x45\x89\x99\xBD\xAF\x08\xA2\x9C\x10"
           "\x9E\xA2\x7D\x1D\x17\xE8\xCB\x4B\x23\xE9\x33\xC6\xBF\x1A\x35\xA2"
           "\xE3\x73\x72\xDB\x39\xF7\xB8\x31\x5E\x5A\x7A\x04\x03\x13\x85\x65"
           "\x49\xBF\x06\xFB\x5A\x9F\xC2\x19\x05\xF5\xD7\x1E\x69\x30\xBB\x67"
           "\x47\x7E\xF1\x2E\x6B\xCB\x99\xD8\x45\xCE\xD6\xD3\xCA\x87\x94\x73"
           "\x44\xF5\xDF\x1F\xD3\xC1\xFA\x05\x7A\xDB\xE4\x5C\x6E\x94\x6B\x97"
           "\x12\xC6\xDB\x4F\x98\x4C\x17\xEB\x20\xDC\xE5\x6C\x02\xA7\x2D\xB1"
           "\xE2\x3D\xAC\x50\x57\x3E\x66\x0B\xB6\x80\x89\x4F\xC5\x83\xFA\x6F"
           "\x48\xF6\x7F\x3B\xD5\xE1\xAD\x8D\x47\xA5\xA2\x62\x33\x77\x43\xC3"
           "\x0E\xD4\x14\x2E\x46\x62\xA8\x43\x39\x5E\x7E\x26\x42\xB9\xF7\x22"
           "\x1A\x20\x01\x30\x2C\x6A\x24\x48"
           , 248);
    nOutDataLenExp = 248;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 1152);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 124);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1984，PKCS#1填充，加密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 248);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 248);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 248);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_18(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 1;
    memcpy(bSK,
           "\xB6\xF8\xDC\x3E\x12\x98\x52\xB8\xB1\x84\xC0\x51\x97\xD1\xBE\x87"
           "\x70\x24\xD7\xE1\x4A\x71\xC3\x20\xA9\xEE\x78\x93\xF8\x99\x5C\x1A"
           "\xE5\x32\x78\x65\x85\x07\xEB\x5E\x26\x79\x2F\x1E\xE1\x6E\x6E\xB9"
           "\xF7\x6A\x23\x46\x09\x92\xD0\x54\xD2\xCA\x6C\xB6\xCE\xB0\x0B\x1C"
           "\x83\xD3\xEB\x1B\x6F\x47\x05\x82\xBF\x68\x23\x24\x90\xDD\xA0\x4C"
           "\xAD\x00\xC2\xD6\xBE\x7D\x8C\x5C\xBF\x1B\xF6\xE1\x73\x51\x9E\x6D"
           "\x62\x46\xBF\x62\xD5\xA6\xD6\x93\x17\x5D\xEE\xEF\x03\x82\x5E\x89"
           "\xA5\x42\xF3\x09\xB1\x20\x11\x48\x39\x90\x8A\xBD\xAA\xE3\xA8\x12"
           "\x4E\xD2\x36\x25\x16\x60\x73\x35\x44\x99\x56\xFE\xED\xF1\xC7\x48"
           "\x57\x57\x56\x27\x7C\x94\xC5\x2D\x6B\x77\xFB\xDC\x82\xD8\xD0\xE0"
           "\x2D\x0E\x4D\x64\x5B\x98\x07\x49\x8A\x29\x70\xD9\xDE\xA9\x44\xC5"
           "\xDE\x71\xCE\xF5\xE0\x63\x40\x28\xF4\xD6\x6D\x86\x14\xCF\x70\x24"
           "\x5B\x05\xAE\xC7\xE9\x69\x7B\x42\xAB\xF6\x53\xA3\x97\x1C\x93\x61"
           "\xCE\x7E\x8F\x38\xF1\x85\xC6\xB8\x2C\x6F\x11\x3E\xA6\xF1\x18\xF8"
           "\x85\xAD\xF2\xE3\x32\x82\x51\x0D\xEB\x12\x68\xC0\x1B\xCD\xF2\x3A"
           "\xB5\x55\xCD\x1A\x92\x9D\x31\xDF\xA6\xB2\x7A\xEE\x99\xA1\x39\x62"
           "\xC9\xE5\xFD\x47\xD0\x37\xCE\x6C\x08\x33\x31\x58\x38\x7B\x3F\x77"
           "\xFF\x4B\x01\xFC\x24\x58\x33\x24\xEB\xA6\xE2\xEE\x33\x1B\x67\x52"
           "\x81\x19\x16\x3A\xFA\x23\x82\x1B\x61\xEE\x5B\xDD\x08\x83\xA4\x5D"
           "\xCC\x57\x5A\xBF\xA5\x5C\x6E\xD7\xB0\xA2\xB6\x73\x52\x92\x9E\x5C"
           "\x46\x8D\x3E\xFB\x15\x1C\xB2\x7E\xD0\x90\x09\x61\x4F\x98\xFF\xEE"
           "\x8C\x40\x99\x83\x62\x1C\x2A\x29\xA9\x35\x58\x08\xF7\x97\xE6\xC7"
           "\x74\x50\xC9\x7D\xBF\xA2\x61\x51\x57\xD2\xDB\xDD\xE7\x19\xEF\x75"
           "\x26\xC0\x48\x56\xD9\x38\xFC\xF6\xF1\xEC\x6E\x96\x72\xCE\x2F\x19"
           "\xCA\x17\x76\x25\xFA\xDB\x0A\xBF\x4E\xD3\x6F\x65\xE2\xA3\x53\x9F"
           "\x0F\x91\xCF\xA8\x32\x9D\x83\xF1\x62\x54\xA3\x3E\x89\xF9\xD3\x20"
           "\xE8\x10\xE5\xE8\x6A\x73\x40\x90\x9A\x9D\x21\xD0\x9E\xEE\xFA\x44"
           "\x29\x42\x36\x61\xF0\x89\x9E\xE2\xFA\xBE\x06\x74\x7A\xAC\x2A\xF6"
           "\xA6\xFE\xE0\x7E\x17\x7C\xDA\xA7\x4B\xA3\x33\xD0\x66\x40\x56\x07"
           "\xB5\x21\x1A\x1E\x17\x3B\x43\x62\x9C\x0D\x16\xFA\xF3\x09\x93\x99"
           "\x56\x6C\xFD\x6A\xB7\x64\x04\x77\x33\x61\x13\x13\xD0\x93\x30\xD7"
           "\x78\xAE\xD3\x91\x30\xC2\x2C\x81\x39\x88\x9F\xE3\x9B\x4F\xF0\xC8"
           "\xFF\xA0\xA7\xED\x5F\xC3\xD7\xFE\x9C\xA7\x85\x7D\x1E\x7E\xA6\x7C"
           "\xD7\x6C\xEF\x3A\xAD\xE2\xFE\x2E\xAD\x45\x17\x9E\xC8\xA9\x71\xAB"
           "\xBF\xB6\xE3\x16\xEC\x4B\xF5\xA7\x9D\x20\x72\x87\xB4\x7E\x80\x89"
           "\xD6\xEF\x8C\xEA\x5D\xD5\xD2\x26\x9B\x3E\x58\x2C\xEB\xE6\x07\x1A"
           "\x05\x01\xD6\xBB\xFB\xA4\x2C\x31\x7A\xC0\x03\xB2\x14\x3D\x95\x41"
           "\xB5\xE3\x35\xA8\x86\xCF\x8C\x68\xFE\x01\x75\x0F\x3B\x77\x56\xA2"
           "\xCF\x29\x24\xFE\x99\x37\x02\x75\x65\x0E\xD6\xD2\x82\x9A\x93\x74"
           "\xAD\xBE\x1E\x56\x13\xC4\x29\x53\x35\x57\x4B\x46\x22\x4B\xB8\x50"
           "\x53\x71\x44\x27\xA8\xBC\x5B\x31\x0A\x32\xD4\x0F\xFF\xB2\x32\x5F"
           "\x39\xCD\xB1\x90\x77\x70\x23\xF9\xF4\x85\xDA\xE9\x16\x9D\xD5\xA0"
           "\x2A\x71\xF9\xF4\x40\x7D\xD1\x24\x5D\xBF\x93\xB3\x7F\x0D\x95\x67"
           "\x19\x51\x18\xA0\x99\x7A\x84\x44\x71\x9A\x08\x0D\x98\x25\x2E\xA6"
           "\x55\x6B\xEC\xA9\xA0\x72\xA4\xEF\x41\xC4\x20\x67\xA8\x86\xC9\x82"
           "\x86\xE8\x58\x5B\xA6\x8B\xCB\x30\xED\xF7\x7B\x0E\x6A\x6F\x6C\x39"
           "\x7A\x48\xA8\xE1\x9C\xEE\xC5\xDF\x08\x4B\xC9\x0A\x5D\xA0\x34\x42"
           "\xB5\x79\x5C\x29\xAF\xA9\xF8\x84\x31\xBE\x94\x21\x29\x17\x82\x99"
           "\x81\xB4\x9E\x2B\xC9\x78\xC5\xA6\x25\xD7\x28\xEE\x3A\xD2\x3B\xD8"
           "\x05\xCE\xEA\x07\x92\xD4\x8B\x4D\x64\xB4\x7F\x57\x9D\x2A\xFB\x80"
           "\xFF\x16\x09\xE2\x9A\xAC\x7E\x32\x2D\x2B\xE7\xA2\x9F\x9F\x63\xAF"
           "\x59\x62\xC6\x8D\x51\xD9\x2F\x6B\xF2\xB8\xEA\x9B\xAE\x30\x7A\xBB"
           "\x76\xC7\xDE\xB7\xF8\xF0\x33\x2E\x69\x65\xC0\x89\x2B\x82\x72\xAE"
           "\x8B\x65\x53\xEF\x96\xA4\xCC\xE6\xAB\x80\x9D\x23\x51\xCB\x77\x5B"
           "\xAB\x75\x5A\x70\x7B\x9C\xBE\xD6\x44\xCD\x0A\x3A\x1C\xF8\xD7\xC8"
           "\x9E\x68\x2B\xA2\xB6\x30\xC4\xE7\x3A\xF2\xDA\xE4\x15\xDE\x80\xD5"
           "\x03\xF6\x06\x3E\x19\x0B\x09\xF5\xE1\xED\xE9\x82\x79\x02\xD7\x21"
           "\x5C\x71\xFE\x15\xCB\xB5\x85\xB1\x12\x75\xF2\x94\xFC\xB7\x24\x14"
           "\xFF\xDE\xA6\x49\x7D\x61\xF8\xAE\x83\x40\x97\xC6\x13\x8F\xD6\xE2"
           "\xDA\xE8\x9D\x66\x71\x4A\x22\x1F\xF9\x55\x79\xAA\xE0\xE6\xD7\x29"
           "\x3D\x44\x2E\xC0\xB9\x4D\x64\x65\x2A\x0E\x4A\xB8\x62\xC1\x84\x2E"
           "\x3F\x6F\xEB\x79\xDF\xCF\xAA\x83\xB9\x7C\x73\x7E\x48\x88\x44\x03"
           "\xEA\x4F\x09\xCD\x72\x37\xA7\x49\x37\x6E\x52\x57\xFC\x64\x17\xE5"
           "\x9E\x36\x4D\xD7\x33\x82\xA5\x42\x3F\x37\x96\xE9\x00\x70\x91\x7E"
           "\x1F\xFF\xCD\xD3\x39\xD8\x27\x8F\x67\x81\x51\xF8\x03\xB5\x3A\xB9"
           "\x57\x64\x16\xBF\x7F\x0C\xD6\x74\xE7\x37\xB2\xFD\xF4\x20\x1B\x4C"
           "\xFD\xFC\x5C\xEF\x78\x30\x05\x38\xD7\x51\xE8\xD3\x16\x0A\x7D\x8C"
           "\xBA\x84\x9D\x1F\xF5\x6F\xE7\x15\x41\x1D\x3E\x40\x4D\x98\x64\x46"
           "\x43\x35\xA6\xBB\x0B\x0D\xF3\x39\x1D\xF9\x2B\x8C\x8E\xBD\x43\x9B"
           "\x39\x39\x10\x04\x06\x0B\x31\x7C\xF0\x1E\xE1\x70\xB1\x55\xD1\x59"
           "\xBE\x38\x24\xC8\x3E\x53\x30\xF7\x0F\xCE\x37\xCD\x5C\xF7\x90\x33"
           "\x85\x7F\x4D\x02\xAB\xEA\x50\x12\x18\xF3\x6E\x56\xA8\xEE\x38\x08"
           "\x8F\x94\x95\xAE\xE3\x74\x54\xCF\x0B\x88\x16\x7D\x2E\xBA\xAB\xCE"
           "\xCD\x7B\xA5\x62\x51\x84\x6A\x30\x0E\xF6\x44\x6C\x62\xDB\x9B\x21"
           "\xCA\x09\x0C\xBD\xE5\x09\x1C\xFA\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78"
           , 1200);
    nSKLen = 1200;
    memset(bInData, 0x42, 1);
    nInDataLen = 1;
    memcpy(bOutDataExp,
           "\xAC\x87\x17\x34\x90\x4B\x52\x08\x55\xBA\x3B\x60\xF6\x49\xFE\x62"
           "\xEA\x8C\xE9\x0A\xCD\x14\xF5\x3E\xF4\x6A\x3D\x00\x78\xDF\xE2\x83"
           "\x20\x22\xD0\x60\x3B\x31\xC9\x06\x37\xFB\x17\xBF\x75\xFA\x0F\x6F"
           "\x75\x94\x66\x02\x71\x83\x40\x9E\xA1\xF9\x35\x96\x18\xA0\x35\xFD"
           "\xCC\x83\x63\xE3\x8B\x06\xFF\x04\x18\x56\x16\x69\xDF\x9A\xD1\xAD"
           "\x4E\x2D\xCD\xF7\xB2\x0D\x80\x36\x46\xC4\xB7\x6B\xC7\xCF\x61\x9D"
           "\x1A\xAE\x95\x45\x35\x54\xB9\x71\x4D\xB3\xA1\xBF\x89\x8C\x07\x9C"
           "\x61\x94\x93\x8B\xC7\xCC\xDC\x8F\x9E\x0C\xF7\x7E\x9C\x09\x9C\x92"
           "\x81\x88\x82\x09\x5A\x64\xA5\x4F\x3B\xBE\x38\xCD\xEE\x67\xB0\x2C"
           "\x02\xBA\xEF\x49\x66\x8E\xE4\x31\x25\xCB\xB3\x6D\xA6\xD3\x77\xE5"
           "\xF4\xBA\x86\x0D\xD9\xA7\x81\x62\x1E\xB3\x97\x94\x5C\x17\x95\x3B"
           "\xEA\x89\x4E\x76\x00\x79\xBB\x8C\x7F\xA9\x2D\x5C\xEB\x59\xA3\x46"
           "\xFE\xFF\x27\x3A\xF2\x44\x80\x4C\x96\x18\x0B\xF5\x42\xF2\x8A\x97"
           "\x65\x2C\xC1\xC3\xF1\x4E\x7E\x94\x17\x34\x0C\x00\xB7\x8C\x72\xE5"
           "\xD1\x3E\xD4\x14\xA5\x03\x1B\x1E\x43\x25\xC8\x2A\x41\x7F\x2C\x90"
           "\xC3\x20\x1E\x1F\x5F\xDA\x16\x11\x95\xF4\x96\xF0\x1E\x1F\xF8\x2E"
           , 256);
    nOutDataLenExp = 256;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 1200);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 1);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-2048，PKCS#1填充，加密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 256);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 256);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 256);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_19(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 1;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    memcpy(bInData,
           "\xA0\xC4\xFD\xA5\x70\x44\xD4\xEF\x2E\x16\x32\xC1\xCF\xD9\x9F\x07"
           "\x06\xA8\x3F\x80\x9B\xC0\x73\xF2\x72\x2E\x0D\xE3\xC4\xEA\x4E\x74"
           "\x37\xBD\x25\x7C\x4F\xE1\x0D\x69\xB7\x46\xB5\x41\x95\x53\x7E\xC6"
           "\x3C\x5D\x01\x38\x50\x06\x7B\xF8\x0C\x2D\x29\x0C\x52\x77\x11\x7F"
           , 64);
    nInDataLen = 64;
    memset(bOutDataExp, 0x42, 53);
    bOutDataExp[0] = 0x30;
    bOutDataExp[52] = 0x39;
    nOutDataLenExp = 53;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 320);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 64);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-512，PKCS#1填充，解密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 53);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 53);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 53);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_20(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 1;
    memcpy(bSK,
           "\x3B\xD4\x50\x5C\x7E\x86\x10\xCE\x25\x5C\xB9\x39\xC2\xD4\x61\x5C"
           "\x7F\xC2\xC4\x74\xE5\x22\x06\xCD\x50\x53\xAF\x84\x02\xF7\xE6\x54"
           "\x85\x44\x18\x4D\xE9\x05\x89\xF5\x5D\x0E\xC0\x55\x6A\xD2\x53\xA5"
           "\x36\x71\x2D\xD5\xFD\xEA\x8A\x45\x4C\xC6\x00\x3B\xE7\x01\x70\x1C"
           "\xEC\xA6\xD1\xF4\x7D\xF0\xD5\xF5\xB6\x5A\x00\x43\xBC\xF0\x6A\x79"
           "\xFF\xD3\x30\xB8\x5F\xFA\xEA\xE0\xD1\x9E\x6C\x02\xAE\x9A\x13\xF0"
           "\x09\xED\xB1\x9C\x0A\xBE\xA9\xB7\x93\x66\xBB\x08\xC6\x0A\xA2\xFD"
           "\xFE\x19\xBF\x9E\x9E\x7C\x1C\xCF\xBB\xF6\x3F\x4D\x1A\x35\xF9\x26"
           "\x2A\xF4\x84\x29\x43\x79\xE7\x3D\x9B\x58\xF9\x30\xE1\x27\x3B\xC0"
           "\xD7\xE7\xEF\xF8\x52\x50\x2C\x85\x65\x1B\x1C\x3D\x2D\xA9\x73\x8F"
           "\xCA\x54\xF3\x60\xE4\x84\x67\xAC\xEB\xAA\x24\x30\xC9\x98\x9D\x4B"
           "\x2E\xF3\xD7\xE1\x93\xCA\xC0\x63\x3F\xD1\xE4\xAF\x08\x37\x63\xB5"
           "\x8A\xDB\x3E\x66\x44\x4E\x01\x7F\x75\x92\xB4\x5D\x79\x6C\x94\x9B"
           "\x4C\x55\x2F\x9A\x26\xD9\x54\x65\x67\x41\x4A\xAC\x1F\x7C\x4A\xFE"
           "\x1E\xDD\xDD\xE1\x51\x3A\xB2\xE2\x92\xFA\x3F\x8D\xFF\xEE\x78\x0A"
           "\xBB\xFB\xD6\x94\xE3\x39\x48\xF8\xF1\xC0\x3A\x36\xF4\x65\xF6\xB9"
           "\x2A\x2C\xEE\x71\x11\xAA\x7B\x55\xBF\x9D\x13\x0F\x74\x47\x05\x87"
           "\x27\xF0\x9F\x65\x6E\xED\xAF\x2B\x78\x69\xFE\x3A\x40\xA3\xDB\x58"
           "\xCC\x5C\x83\xC5\x0E\x9B\xF3\xB5\x8B\x6D\xA8\xBE\x0C\x5E\x38\x2A"
           "\x12\x8C\x3E\x40\xA1\x03\x43\x20\x6B\x4B\x3D\x65\x8C\x96\x13\x5F"
           "\x58\x56\x87\x88\x20\x0A\x12\xD8\x42\x95\x55\x5D\xDD\x74\x23\xF3"
           "\x05\x77\x04\x02\xBC\x97\x6E\xED\xEB\x33\x10\x4B\x8C\x58\x0C\xDF"
           "\x9A\x54\xCD\xB9\x69\xAA\x0B\x15\x13\x8B\x95\x87\x55\xFC\x05\x0A"
           "\x81\x5E\x00\x9D\x50\x9D\x7D\x73\x94\x6B\x78\x30\x40\xC7\xF4\x89"
           "\x76\x9F\x1D\x3B\x69\xAE\x65\x5C\xF5\xAB\xF8\xC0\x33\x0F\xA3\x02"
           "\xA4\x41\x96\x86\x47\x75\x2F\x3B\xC4\x3D\xE8\x5A\x88\xAB\xB9\x74"
           "\xB9\x8F\xA7\xDC\xBE\x35\xE0\xA1\x31\xA1\xEE\xAC\xD3\x01\x97\x67"
           "\x65\x1D\x81\x74\x38\x11\xEF\xC5\x0F\xDD\x6B\x70\x98\xF8\xDC\x91"
           "\xFA\x20\xDD\x34\x9F\xB4\xB2\x09\x6B\x90\xD7\x81\xBA\xD4\x34\xEA"
           "\x24\x83\x49\x86\x3C\xDF\x51\x98\xDB\xA2\x68\x53\xC3\x41\x47\x3B"
           "\x70\x13\x1B\xC7\xB1\x4B\x64\xD3\xD1\x46\xF6\x97\x04\x65\x8C\x24"
           "\x13\xD0\xE5\x85\x7D\xBF\x31\x3A\xB5\x49\x14\xF1\x3F\xFA\xB5\xC1"
           "\x47\x61\x69\x76\x6E\xD2\x9D\x84\xA0\x88\xD6\x65\x35\x6E\xD4\xEB"
           "\x57\x1D\x9F\xF5\xB5\x10\x5D\x12\x05\xA1\xF2\x5A\x37\x4D\x9A\x65"
           "\xBA\xE8\x69\x9B\x02\x93\xAD\x7A\x84\xB0\x6E\xF2\xB6\xB3\x86\x11"
           "\x8F\xF8\xB2\x23\x4E\xD4\x33\x74\x9C\xB4\x91\xD8\x57\x01\x18\x14"
           "\x8A\x63\x13\xFB\x17\x1B\x91\x0E\x35\x71\xD2\x0A\x73\xCD\x99\xA9"
           "\x5C\x10\xD3\xDE\x93\xF4\x5A\x63\xCB\x08\x1E\x8F\x38\x0E\x1A\xB1"
           "\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78"
           , 616);
    nSKLen = 616;
    memcpy(bInData,
           "\x9E\x37\xE5\xA8\x5A\x79\x94\xAB\x81\x89\xF0\x51\x93\x39\xCB\xD9"
           "\xFB\x91\x1F\xA1\x1C\xA3\xCE\x59\x20\x81\x61\x83\x4E\xCA\xDD\xA3"
           "\x52\xD8\x0F\x0B\x39\x0B\xF9\x3A\x89\x57\x37\xA9\xE1\x86\x85\xCF"
           "\x09\x3F\x7C\x41\x38\x1C\xFB\x58\x1E\x49\x4A\x68\x7D\x6F\x45\x61"
           "\xEF\x0F\xF9\xC4\x52\xD2\x0F\x6F\xFE\x58\xBE\xCF\x69\x4E\x8C\x1D"
           "\xAB\x73\x04\xA3\x1F\xA9\x07\xCD\x6B\xD1\xB3\x50\x74\x32\x19\x3D"
           "\xC9\x50\xD3\x12\xF9\xF4\xE2\xC3\xE3\xAE\x61\xE2\x29\x19\x04\x5C"
           "\x73\xC5\xC7\x3E\xAA\x78\x1A\xB5\x58\x59\xF9\xA9\x6F\xBC\xFC\xAE"
           , 128);
    nInDataLen = 128;
    memset(bOutDataExp, 0x42, 64);
    bOutDataExp[0] = 0x30;
    bOutDataExp[63] = 0x39;
    nOutDataLenExp = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 616);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 128);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1024，PKCS#1填充，解密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 64);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 64);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 64);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_21(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 1;
    memcpy(bSK,
           "\xDF\x00\x50\x67\x45\x67\xCB\xA9\xF3\x62\x34\x84\x08\x05\xEE\x96"
           "\x70\x77\x07\xC3\x71\x70\xAD\xC0\xE9\x02\xE7\x50\x58\xCB\x00\xCF"
           "\x55\xAA\xB9\xE0\x3D\x47\x8D\xC8\x38\x3A\x78\x92\xB2\x54\x98\xEF"
           "\x5A\x46\x80\x77\x58\x05\x1E\x94\xA8\x62\xE6\xFA\x5C\x54\x15\x48"
           "\x2D\xDB\x8C\x41\x31\x90\x9F\xE9\x4D\x87\x7A\x21\xB9\xA3\x13\xE5"
           "\xE0\xED\x09\x27\x17\xB6\xB1\xAA\x23\xBE\x5F\x80\x9F\x25\xF2\xE1"
           "\x7A\xB2\xCB\x36\xF2\xE5\x2A\x6F\x63\xD1\x4C\xD6\x53\x07\xBF\x83"
           "\x4F\x59\xE1\x20\x63\x9C\x33\x38\x88\xD3\x79\x7D\xF1\x47\x6E\x16"
           "\x3F\x38\xF3\xCF\x0D\x25\xF4\xD5\x28\x76\x55\x5C\x22\x54\x1B\xAD"
           "\xCC\xB6\x21\x81\xFC\x32\xE0\xCF\x8C\x30\x3A\x96\x31\x48\x02\x7E"
           "\x0E\x2A\x4B\x99\x46\x5C\xCA\x23\x82\x41\xA6\x9B\x8A\x71\xF4\x4E"
           "\x7A\xCF\xBE\x9D\xEC\x18\x90\x04\xF2\x6F\x9F\xD9\x76\xFD\x43\x17"
           "\x81\xF0\xD7\xB8\x1B\xE6\x7C\xBB\x5F\xB9\x9D\x8E\x96\x4D\xC5\xE3"
           "\x7A\x98\xBA\x11\x2B\x52\x62\xA3\x48\x6F\x9C\x8F\x3F\x4A\x88\xF4"
           "\xEA\x82\x59\xBD\x2D\x55\x06\x8F\x51\x8D\x37\xA0\xB0\xF4\xA7\x23"
           "\x76\x86\xFF\x68\xEA\x6C\x64\xFE\xC0\xCD\x6C\x48\x20\xCB\xD2\x77"
           "\x31\x73\xD8\x50\x5A\x13\x84\x98\x8D\x0A\xF1\xB9\x8A\xD8\x87\x54"
           "\xDC\xB4\xBA\x6A\x0E\x7D\x04\x4D\x7C\x6C\xF6\xE3\x50\x65\xEF\xC2"
           "\x9C\x70\x39\x70\x99\x60\x53\x70\x88\x1D\xA2\x56\x1A\x78\xB8\x15"
           "\x17\x81\x3F\xEC\x07\x0A\xE0\x33\x7A\x82\x0B\xE2\x21\x53\x1B\x27"
           "\x7C\x06\x69\x00\x82\xB3\xAB\x74\xE9\x43\xDD\xCC\x69\x2C\xF8\x51"
           "\xAF\xEB\xEE\x15\x6E\xE0\x35\xA8\x6A\x0D\x35\x8A\x01\x98\x68\x8A"
           "\xC5\x71\xAA\x8C\xDB\x31\xC7\x04\x5D\xEF\x33\x50\x1A\x66\xC9\xBF"
           "\x85\xE8\x30\xBF\x8E\x36\x86\xA3\xB0\xBF\x18\x8E\xA0\x93\xB3\x5C"
           "\xD2\xD3\x6E\x57\x86\x14\x30\x5D\xC5\x29\x0B\x5A\xEF\xEA\xA3\x9C"
           "\xC0\xDD\x9B\xDF\x67\xB9\xAF\x01\xC4\x0C\x83\xE1\x36\x95\x4E\xB6"
           "\xF2\x61\x4F\xB8\x09\x8E\x66\x90\x23\xE7\x6D\xD1\x71\xF4\xF4\xE7"
           "\xF4\x3B\x54\x8D\x91\x05\x89\xB5\xFE\x78\xBA\x30\x87\xF5\xB5\xE6"
           "\xE8\x55\x5B\xCA\x64\xAF\x89\x59\xA0\x50\x8A\x7D\x19\x40\xDF\x49"
           "\x31\xEA\xEF\x76\x70\x2E\x1F\xC7\x05\x7E\xA0\x2A\x42\x17\xA2\x0A"
           "\x32\xAC\x36\x7F\x31\xFF\x11\xED\x06\x13\x03\xC6\xDF\xEF\xC4\x27"
           "\x8C\x29\xE3\x36\xE6\xDE\xBC\xE8\x7B\xB5\x7B\x9A\xCB\x93\xF1\x21"
           "\x26\x38\x94\xDA\xF5\x1B\xD7\x2F\xA9\x3C\xEC\xE3\xDC\xD6\xD8\xFC"
           "\x03\x4D\xE1\x49\xA2\x22\x6E\xFD\x57\x80\xAB\xF4\xFA\xD5\xC2\x53"
           "\xCE\x6D\xB2\x61\xE3\xA8\x22\xD8\xD2\x9C\xFE\x85\xE2\x80\xA0\x9D"
           "\x1E\xAF\x00\x3F\xF2\x36\xE1\xE5\xBC\x32\x73\x7E\xD0\x6E\x18\x66"
           "\x48\x64\x91\x0E\xB6\x70\x82\xAA\x40\xFA\x2D\xB5\x27\x0A\x71\x17"
           "\x15\x96\xD4\x2B\xEF\xB4\x82\xA2\x4C\x7C\x08\x2B\x9E\xD6\x99\x56"
           "\x20\x08\xCD\x7D\x6B\x5E\x38\x53\x67\x13\x38\xED\x16\x44\x71\x12"
           "\x97\x4B\x84\xE7\xCE\x12\x53\x70\x46\x6A\x71\x51\xAD\x8B\x71\x2D"
           "\xE5\x4C\xF7\xFF\xCE\x39\xB3\xA0\xB1\x46\x26\x4F\x1A\x63\x0C\xB9"
           "\xEE\x8F\xC7\x8E\x61\x24\xD0\xFB\xD4\x33\x00\xFD\x85\x23\x8B\x12"
           "\x09\x49\x7D\xA8\xE2\x9D\x2E\xFD"
           , 680);
    nSKLen = 680;
    memcpy(bInData,
           "\x9D\xE1\xCB\x5B\x6E\xEB\x7F\xB7\x6D\x12\x31\x1F\x2F\xE9\x24\xB9"
           "\xDA\xA7\x2A\x86\xE3\x9D\xE4\xE8\xAD\x3A\x50\xA9\xF7\x01\xD1\xE5"
           "\xB3\xEE\xEF\x12\xD6\x15\xCD\xA9\x31\xD0\xBF\x0F\x7F\xC4\x7D\xED"
           "\x47\x0F\xC7\x90\x23\xF8\xA7\x9C\xCE\xE2\xDF\xD1\xC0\x54\x3D\xFB"
           "\xD4\x6A\x30\x27\x87\x01\x28\x9B\xDF\xD5\x46\xE9\xDA\xCF\xC1\xD2"
           "\xAF\x91\x64\x50\x03\x51\xDA\x34\xAD\xB4\xE7\x9C\xF2\xA4\xDB\x54"
           "\xEB\x3B\xA1\x49\x6C\x9C\xA4\x44\x4C\x8F\x5A\xF1\x6C\x64\xD4\xB7"
           "\x77\x18\xE0\x1A\x5A\xD8\x3E\xB5\x71\x6D\x0B\x1C\xFE\xFF\x0D\xB2"
           "\x28\x60\x24\x82\xEB\xA5\x31\xEA\xCE\xF6\xAD\x45\xF3\x1D\x28\x8E"
           , 144);
    nInDataLen = 144;
    memset(bOutDataExp, 0x42, 72);
    bOutDataExp[0] = 0x30;
    bOutDataExp[71] = 0x39;
    nOutDataLenExp = 72;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 680);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 144);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1152，PKCS#1填充，解密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 72);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 72);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 72);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_22(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 1;
    memcpy(bSK,
           "\x21\xE5\x82\xE3\xD4\x2B\x83\xA7\x68\x16\x92\xEF\x49\x12\x6D\x45"
           "\xC5\x11\xC5\x1E\x9E\x67\x6F\xF9\x04\x47\x04\x31\x37\x69\xFD\x3D"
           "\x6C\x60\x8F\x08\xC7\xF3\xF1\x69\xDF\xCC\x66\x75\xEA\xB0\x61\x33"
           "\xAF\x7A\x12\x41\x94\x5A\x51\x39\xB5\xBE\xE7\x4C\x9D\x98\x77\x80"
           "\x6C\xB9\x2B\x98\x4E\x55\xEC\x57\x0E\x8A\x1F\xA8\x52\xDE\x44\xC5"
           "\x08\x2F\x21\xD9\x0E\xDD\xB5\x5E\xF3\xA1\x8C\xF1\xC3\xCB\x0A\x18"
           "\xD3\x80\x83\x10\xEB\x2E\x99\x59\x45\x7D\x2B\x92\xF5\x22\x7B\x49"
           "\x67\x02\x84\x5F\x56\x56\xBC\x95\x04\xA4\xB7\xB7\x53\xAE\x19\xF1"
           "\xF8\x7C\x3D\xEA\xDA\xDF\x52\x99\xF5\xB4\x15\xAB\x03\x8B\xBD\x6B"
           "\xC0\x8C\x86\xFC\x56\xCC\x3C\x0C\x38\x31\xBD\xB7\x28\x29\xAC\x0E"
           "\x24\xF2\x12\x6E\x6A\xFC\x01\x1C\x18\xC6\x3A\xCD\xD8\x0A\x64\x27"
           "\x93\x9D\x76\xAA\x27\x42\x7E\xEF\xFB\x83\x2A\xB5\xF3\xD0\x15\xC8"
           "\xEF\xF4\x3E\x5B\x5F\x3B\x4F\x96\x2C\x76\x6A\xD6\x69\xD7\x57\xC1"
           "\xF6\x40\xDF\x49\x7B\x4A\x9B\xE2\x7A\xE3\x09\x8B\xC9\x47\xA9\x14"
           "\x5F\x1D\xC1\x4A\x7F\x9D\xCF\xEF\x7D\x1A\x91\x6F\xC7\xA0\x41\x7F"
           "\x7B\xC3\x15\x00\xEC\x53\x34\x22\x95\xEE\xE7\x08\x39\x63\xF5\x54"
           "\xB6\xAD\x39\x45\xB5\x21\x5C\x34\x5E\x67\x7B\xD8\x97\x50\x91\x75"
           "\x6F\x68\x0A\x95\x8F\x24\xBE\x83\xDB\x44\x91\xE0\xD2\x99\x24\x99"
           "\xBD\x11\x2E\x15\xA9\xCC\xCD\x14\xD9\xBB\x5E\x56\x0F\x69\x9A\x18"
           "\x5A\x42\x25\xB1\x3F\x6B\x03\x18\x51\x9C\x36\x8F\xDB\x1E\xB9\x11"
           "\x3A\xEF\x24\xDB\x9B\x2E\xA2\x1B\x11\x73\x86\x5A\x4C\x12\x4F\xD8"
           "\xCB\x07\xEE\x99\xAC\x04\x10\x2B\x1C\xD7\xB8\xEB\xE7\x56\x2C\x8A"
           "\x12\x36\xDD\xA0\x11\x9D\xC8\x26\x37\x66\x0B\x21\x89\xC3\x7D\xA1"
           "\x40\x85\x91\xFF\x5E\x80\x70\xFB\x68\x28\x03\x8A\x6F\x09\xBC\xD6"
           "\xAC\xAF\xF4\x60\x67\x8D\xA8\x3E\x17\x5B\x5A\xE9\x3E\x17\xA9\x34"
           "\xA9\xD7\x29\xBE\xBE\xE3\xCD\x09\x74\x23\xC7\x21\xEE\xA2\x63\xA2"
           "\x33\x64\x92\x53\x31\x74\xF2\x96\x0C\xD0\x11\x30\xB6\x9F\xE0\xBA"
           "\x5B\x4C\xFA\xA0\xBB\x83\x1C\x74\xD8\x70\xE0\x4B\x2A\xAA\xBD\x88"
           "\x4A\x1E\xB5\x22\x63\xD7\x2E\xBD\xA4\x8E\x6C\xA3\x10\x29\xE8\x29"
           "\xA8\x43\x89\x66\xB7\x7E\x3D\xBE\x8C\xE3\xFC\x5A\xBF\x06\x0B\xCC"
           "\x34\x91\x9D\xE3\x85\x1D\xB7\x39\x03\xC3\x0C\x05\x17\xA4\x8D\xE0"
           "\xB3\x9E\x01\xF7\x80\xF4\xBB\xF0\x22\x23\xDA\xBD\xC4\x14\xBB\x78"
           "\x58\xC5\x7F\xC6\x09\x41\x54\xBB\x11\x96\xE6\xA3\x1A\xC9\x55\xBD"
           "\x0F\xF0\x3F\xBE\x61\x83\xCE\x26\x82\xA2\x8E\xD5\x0D\x2D\xB7\x66"
           "\xBC\x2E\xF0\xEB\xC3\x2F\x6A\x2A\xF5\xB9\x8B\xF0\x42\x4F\x65\x8B"
           "\xD1\x6E\x76\x88\x8C\x29\x34\xCF\x26\x27\x84\x8E\x6B\xA2\xEB\x16"
           "\x77\x2D\x21\x7E\xEC\x18\x4D\x04\xDA\xEF\x95\x1C\x29\x75\x18\x1C"
           "\x83\xCA\xB6\x72\xC3\x77\x46\x29\xBB\xFC\xDE\x1D\x78\x72\x76\x47"
           "\x20\x40\x90\xDC\xBC\xA3\x72\x33\x64\x7E\x18\xD9\xA4\xD2\x46\x9C"
           "\x77\x8B\xF9\x6D\x97\xB0\xD6\xA1\x20\x2C\x0D\xB6\xE3\x2C\x09\x8F"
           "\x07\xB6\x5F\xD3\xDB\x3B\xFD\x77\x69\x7D\x56\xE4\x35\x18\x3A\x9B"
           "\xF6\x22\x3A\x01\x35\x71\xBE\xA4\x48\x97\x8B\x45\x90\x46\x07\x0E"
           "\x17\x68\x9E\x00\x11\x6F\x4A\x25\x55\xA0\x9C\x74\xD9\x15\xFF\xF5"
           "\xE0\x59\xD6\x86\xA0\x91\xD8\x7F\x9A\xFF\xE4\xBD\xAB\xE3\xF0\x94"
           "\x49\x66\x36\x7F\xD3\xD3\x8E\x13\xB7\xFC\x89\xB7\xA9\x3C\x7B\x0E"
           "\x11\xAC\x66\xCE\x34\x34\xAE\x67\x70\xE0\x3A\xB6\x0E\x78\xFD\x94"
           "\xF1\xB5\x74\xD3\x47\x2A\x74\x40\x51\x39\xD1\x49\x73\x94\xB4\xF9"
           "\x4C\xB6\x4B\x11\x19\x2F\x7E\x34\x3E\x6B\x4F\x34\x5B\x83\x52\x47"
           "\x99\x0C\xD6\xDF\x7B\xA3\x95\xE2\xCC\x39\x2F\xC4\x92\x43\x38\x2F"
           "\xCB\xE6\x8C\x2D\xAD\xD0\x5E\xE9\xD5\x3D\x5E\x70\x2E\xA8\x66\xB0"
           "\xA6\xB8\x7C\xA4\x3A\x9E\x28\x3B\x0E\x46\x20\x84\xF8\x5E\x53\x9E"
           "\xCF\xDE\xF3\x0F\x1F\xE3\x8D\x51"
           , 824);
    nSKLen = 824;
    memcpy(bInData,
           "\x4E\x2F\xC0\x3C\xB4\x9A\xF4\x5F\x46\xDF\x11\xC8\x09\x11\xD4\x62"
           "\xC1\x45\xC4\x88\x8A\xBD\x54\xA4\xEA\xD0\xE5\x9E\xA0\x07\x28\xE4"
           "\x04\x8A\x3B\x31\x94\xE0\x5B\xA0\x5E\x8E\x52\xEE\x04\xE7\x36\x86"
           "\x5F\x4A\x21\x11\xA0\xD9\xF6\x38\x86\x8A\xFC\x4F\x1A\xAD\xEC\xF2"
           "\x64\xD8\xC5\x49\xDF\xE8\xC7\xE1\x54\xEA\xDE\x9A\xCA\xEB\xA1\xC0"
           "\x8C\x4A\x46\xE4\x1A\x3B\x2E\xE7\x3D\xF8\x5F\xA5\x13\x4A\xAB\xD3"
           "\x9B\x60\x91\x96\xD6\xDD\xB2\x2A\x7D\x36\xBC\x5F\x73\x36\x6D\xF7"
           "\xFC\xC1\x02\x42\x4B\xE6\x9C\x58\xB8\x08\x2C\xBE\x95\x19\xBF\xE0"
           "\xC2\xE7\xA8\xE6\xE0\x8B\x6D\xA8\x29\xA2\x0D\x97\x82\xCD\x7C\xE2"
           "\xF0\x69\xF6\xF5\xE9\xB4\x18\x38\xD6\x83\xC6\xD4\xBF\x82\x8F\x70"
           "\x03\xF5\x7B\x23\xE7\xC9\x2D\x10\xB1\x0B\x0A\x5E\x5C\xB4\x8F\x9D"
           , 176);
    nInDataLen = 176;
    memset(bOutDataExp, 0x42, 88);
    bOutDataExp[0] = 0x30;
    bOutDataExp[87] = 0x39;
    nOutDataLenExp = 88;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 824);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 176);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1408，PKCS#1填充，解密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 88);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 88);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 88);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_23(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 1;
    memcpy(bSK,
           "\x6C\x18\x21\x1D\x3D\xDC\x38\xA8\xBA\x10\x33\x70\x83\x41\xB5\x37"
           "\xFE\x97\x6F\xB1\xF4\x21\x1A\xAD\x35\x77\xBD\x28\xB2\x57\x20\x10"
           "\x16\x13\x93\x89\x47\xC3\x73\xFC\xB9\x76\x48\x3A\x77\xCD\xA7\x0C"
           "\x17\xE9\xF1\x4C\xD0\xA7\xE1\xAA\x0D\x9A\x8C\x38\xD1\xE6\x83\xA6"
           "\x93\xD4\x55\x28\x6B\xB9\x0F\x81\x02\x7A\x78\x54\x00\x84\x94\xFB"
           "\x82\xCC\x8A\x78\xFC\x93\x45\x6E\xD3\x13\xD3\x1F\x18\x69\x73\x2A"
           "\x70\x86\x1F\xFB\x25\xE6\x2A\x64\xCC\x6F\x1F\x18\x26\x0D\x1C\x40"
           "\xAA\x5E\x52\x50\x22\x5A\xE4\x3C\xBC\x29\xFA\xCA\x30\xE3\x53\x40"
           "\x34\x35\xF1\xD0\xE2\x69\x1D\x34\x8E\x83\x96\xAC\xAA\xCF\x6C\x98"
           "\x3F\x4F\x8C\xEF\x8C\xB3\x3A\x04\xF5\x7C\xB1\x76\xA3\x32\x1B\xC1"
           "\x83\xAD\x70\xA5\xF9\x08\xB8\xD9\x2E\xED\x15\x65\xB0\x33\x30\x04"
           "\x1F\x69\x87\x1D\xFF\xBF\x0F\x59\xE3\x62\xE1\xE8\x2C\x03\x4B\x72"
           "\xB6\xAA\x8F\x73\xBA\xFE\xEE\xCC\xAF\x50\x87\x3D\xA0\x5F\x66\xA0"
           "\x88\x3A\x7F\xDF\xA1\x8E\x06\x08\x18\x2C\x1A\x16\xCE\x0C\x6E\x13"
           "\x4F\x2E\x26\x3B\xB8\xAF\x70\x5E\x70\x48\xED\xCE\x8D\x6C\x9B\x26"
           "\xD7\xFE\x95\x5F\xC6\x91\xB6\x81\x3F\x7C\x9A\xF1\x6D\x1B\xAB\x6E"
           "\x84\x10\x94\x5A\x07\x38\x56\x75\xF0\xEB\x3C\x5E\xA3\x0E\x85\x17"
           "\xFB\x5B\xD0\xFA\x84\x3D\x58\x4C\xFD\xF0\xE5\x37\x77\x29\xE2\x5A"
           "\x7C\x74\x87\x04\x9C\xF0\x7A\x2C\xE4\xD2\x0A\x1C\xD8\x8B\x37\x8C"
           "\x7F\x1C\x10\x6E\x73\xB2\x69\x4C\xBE\x1A\x84\x3C\xC8\xA7\xA3\x68"
           "\x48\x7E\x2F\xFD\x9B\x5F\x12\xAD\x15\x49\x3F\xC4\x10\x86\xAF\x56"
           "\x4D\xCB\xC6\xE8\xAD\x35\x72\x21\x24\xD9\xC3\xA3\x82\xF1\xB2\xAF"
           "\xD9\x88\xBF\xFB\xCB\x81\xF9\xF6\x3B\xC6\x1C\x34\xF0\x5A\x33\xE5"
           "\x41\x9B\xC2\xF9\xE2\x23\x0E\x2D\x11\xC5\xBF\x41\x91\x7B\xE9\x36"
           "\x07\xD8\x60\x00\x09\xDD\xD5\x86\xD7\x65\x50\x98\xBC\x5C\x0E\x60"
           "\xA0\xE5\x53\xEC\xA6\x9D\x11\x99\xEA\x25\x44\xF4\x50\x76\x0D\x4D"
           "\xE7\x72\x87\xCF\x6F\x7C\xF2\x27\xED\x73\xD7\xEF\x53\x6D\x0B\x99"
           "\x6B\x38\x44\xBC\xC0\x12\xF5\xD6\x92\x3F\x64\x81\x54\xC1\xEF\x04"
           "\x5C\x1F\x23\x7E\xF5\x38\xA7\x80\xFC\x17\xEF\x00\x3C\x8D\x09\xAB"
           "\xAA\xD0\x40\x14\xD7\xCB\xAC\xA1\x29\xE0\x12\xD5\xD4\xFF\x1B\xDD"
           "\xCA\x78\x2B\x1D\xEC\x9F\xA5\xAC\x67\x74\x31\x8C\xF6\x8F\x9A\x59"
           "\x7D\x84\xF1\x7E\x5D\xA4\xC9\x53\xEF\x58\x2D\x1F\x0F\x3A\x6D\x66"
           "\xFF\x06\x61\x1A\xDC\xDB\x19\x0C\xE6\x43\xC4\x4A\x2B\x3D\x8E\x79"
           "\xD4\x93\xA8\x9A\x1A\xF7\x91\x45\x77\x78\xAB\xE1\x77\x33\x26\xFF"
           "\x92\x0B\x96\xD5\xF3\xAF\x05\x0B\xC4\x53\x1B\x89\xEC\xDC\xD0\x12"
           "\x4A\x65\xF3\xAD\x43\x8C\x23\x35\x13\x79\x4E\xD8\x0D\x21\xC9\x61"
           "\x49\xCA\x48\x53\x48\xC6\xA1\x7E\xF0\x28\xA5\x97\x11\xB8\x18\x33"
           "\xAD\xEC\xEF\x6B\x5C\x71\x4A\xBE\x9F\x31\xB8\xA3\x98\xC5\x0C\x0B"
           "\x46\x51\xA2\xAE\x02\x6F\x98\x35\xF7\x4D\x21\x5E\xC3\xED\x61\xB0"
           "\x6B\x59\x79\x5A\xB9\xA8\x1C\xB0\xBA\x82\x67\xB9\x97\xBB\xD4\x4D"
           "\xF1\xA1\x56\x5C\x7D\xCB\x77\xD0\x28\xE0\xFF\x1C\xAA\x22\x07\x68"
           "\x9B\xF3\x80\xDE\x96\x1D\x03\xDD\x97\x8A\x69\xDA\x5C\x54\xD4\x80"
           "\x93\xB2\x0D\xCD\x43\xBA\xFC\xDF\x11\xCF\xFE\xCE\x3B\x74\x8E\x67"
           "\x17\x74\x8E\x29\xF9\x64\x97\x52\x8C\x7B\xC9\x71\xB3\x5E\x59\x86"
           "\x63\x38\xF6\x9E\x79\x43\x56\xD6\x6F\xE6\x26\x45\x62\x64\x26\xE0"
           "\xA7\xDC\x70\xCA\x5B\xCD\xE7\xC6\xE1\x1F\xFC\x97\x57\xA1\x2B\xC5"
           "\x12\xB6\x9E\x85\x37\x9E\x58\x48\x2F\x9A\x91\xB7\xB6\x7C\x28\x47"
           "\x1A\x73\x45\x41\xD4\x6E\xBE\xB5\xB7\x60\x1A\xF2\x8B\x04\x78\x38"
           "\x4B\xB6\x45\x8C\xA9\x3E\xE5\x7A\xBF\x1F\xC4\x86\x30\xB4\x0C\xB1"
           "\xC6\x9D\x80\x88\xD2\x49\xD9\x89\xD9\x50\xA8\xDE\xEC\xA5\x04\x7F"
           "\xFF\xEA\xC0\x2F\xCB\x37\x7A\xB6\x97\x59\xAD\x53\x29\x34\xB3\x79"
           "\x16\x3B\x3E\xF5\x7F\x14\xB3\x77\xF9\x2E\xE8\x3F\x04\xAE\xDE\x89"
           "\x73\x04\x32\xA7\x4C\xC0\x4D\x43\x0D\xC1\xE5\x21\x48\x32\xAA\xE1"
           "\x5E\x81\xB6\x23\x6A\x80\xCA\x17\x23\xFC\x5F\x47\xE1\x57\x14\x59"
           "\x46\x67\x0F\xBF\x6A\x57\x53\x10\x8E\xAB\xAA\x9C\x8A\xDD\xE0\x9D"
           "\xA2\xAC\x94\x87\x6A\x71\xD0\xAF\xE4\x8A\xCF\xEB\x23\x27\x00\xC2"
           "\x8B\x11\xA9\x2C\x02\xB5\x05\x03\x30\x7A\x0C\xEF\x7F\x5B\x1C\xE7"
           "\x64\xFF\x1E\x68\x78\x28\x1C\x6D\xA0\x16\x75\x36\x7F\x9F\xF9\xCD"
           "\x15\x3B\x8E\x26\xC3\xF1\x7A\xBC\x17\x42\x92\x7D\xA8\x4E\x22\x5F"
           "\xB9\x55\xF5\xB7\x2C\x10\x5E\x79\xBB\x81\x54\x32\xDC\x8D\xE7\x4B"
           "\xE3\xCB\xDB\x1D\x34\xA4\xBA\x5F\x1A\xFE\x43\x48\x46\xEF\x88\x67"
           "\xD5\xB6\xDD\x06\x99\x5C\xB3\x38\x45\xED\xD0\x21\x77\x22\xF4\xF3"
           "\x68\xD6\x90\x53\xB5\x1E\x36\x3C\x35\x08\xCF\xBE\x53\x8F\x59\xDB"
           "\x4D\xAA\xA2\xB4\xF9\x93\xAC\x4C\x0C\xE4\x5D\xDF\x79\x57\x3C\x8F"
           "\x42\x44\xEC\x0C\x09\xA9\xC6\xE8\xF9\xF0\x80\x2E\x76\x25\x2E\xC1"
           "\x72\x0E\x55\xD6\xB9\x78\x9A\xAE\x56\xFE\x8B\x35\x38\xAF\xE3\x80"
           "\x78\x57\x55\x15\xC9\xEC\xCC\xCB\x42\xC3\xC5\xDF\x8A\xAE\x67\xB0"
           "\xCD\x63\x8E\xFC\x28\x77\x7F\xD1\x31\xFD\x9D\xD2\x79\xC8\x0A\xE0"
           "\x1A\x86\x0D\xEB\x3B\xB4\x64\x49\xAA\x6B\x7B\x73\x27\xEC\x7D\x66"
           "\x6A\x4C\x37\xB3\xCD\x4E\x97\x97\x3C\xEF\x7E\x13\x45\x36\xAA\xFE"
           "\x2E\x16\x48\x90\x5F\x53\x63\x62\xC7\xAB\xC9\xC7\xB5\x9E\xFD\xA5"
           "\x8B\x0C\xCA\xD0\x1E\xBD\x51\x67\x98\x94\x63\x08\x13\xCC\x05\xB9"
           , 1152);
    nSKLen = 1152;
    memcpy(bInData,
           "\x46\x41\xB5\x66\x79\xB8\x14\x2E\x39\xB8\x8F\xC2\x4C\x08\x4A\xCE"
           "\x1D\x7E\xAB\xF8\x04\x34\xE0\x4E\x91\x6A\x5A\x41\x08\xA7\x9A\xD8"
           "\x04\xEC\xD9\x6E\xAE\xC9\xEA\x85\xAF\x21\xFD\x1B\x1E\x0D\x95\x3C"
           "\xBA\x6E\x2B\xEA\x8E\x2A\x2B\xEE\x19\xA3\x3C\xF1\x55\xD5\x4D\x1E"
           "\x30\xC1\x01\xE8\xD9\x22\x29\xCE\xB1\xBB\xEB\xE7\x43\xB0\xC9\xF1"
           "\x63\xE2\x28\x01\x3B\x55\x8B\x44\xFC\xF3\x5F\x3D\x7C\x46\x63\xF9"
           "\x22\x28\x9C\x83\x01\xE9\x2C\x07\xA0\xF5\x73\x0D\x10\x34\x43\x98"
           "\x87\xAB\x2A\x3F\x67\x3D\xCD\x18\x3E\x3A\xE4\x95\x65\x42\xBB\xD3"
           "\x31\x9F\xDE\x86\x07\x6E\x88\xA6\x00\x48\xB7\xB6\xC6\xC8\x7B\xF5"
           "\x5E\x80\x78\x83\x74\x7A\xF2\x6E\x92\xC5\x28\x87\x1C\x7F\x35\x62"
           "\x66\xCB\x57\x26\x79\x1B\xD4\x58\x2F\x72\x97\x7D\x6B\x18\x6B\x82"
           "\xB0\x74\xFE\xB6\x4F\x18\x10\x57\x8D\x1E\x29\x8C\x4C\xF7\xDD\x26"
           "\xF4\x99\xBC\x44\xAE\xCA\x59\x33\x67\x74\x8D\xAF\x90\xC5\x4A\xB3"
           "\xB1\xE0\x43\xDC\x82\x1D\xFA\x8D\xC6\x6B\xBF\xAE\x3C\x3F\x02\x55"
           "\xF9\x27\xB3\xCA\xFD\xF8\xDB\x3B\xDC\x7B\x33\xE3\xC5\x2A\x95\x84"
           "\x96\x51\x69\x67\x85\x24\x09\xD3"
           , 248);
    nInDataLen = 248;
    memset(bOutDataExp, 0x42, 124);
    bOutDataExp[0] = 0x30;
    bOutDataExp[123] = 0x39;
    nOutDataLenExp = 124;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 1152);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 248);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1984，PKCS#1填充，解密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 124);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 124);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 124);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_24(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 1;
    memcpy(bSK,
           "\xB6\xF8\xDC\x3E\x12\x98\x52\xB8\xB1\x84\xC0\x51\x97\xD1\xBE\x87"
           "\x70\x24\xD7\xE1\x4A\x71\xC3\x20\xA9\xEE\x78\x93\xF8\x99\x5C\x1A"
           "\xE5\x32\x78\x65\x85\x07\xEB\x5E\x26\x79\x2F\x1E\xE1\x6E\x6E\xB9"
           "\xF7\x6A\x23\x46\x09\x92\xD0\x54\xD2\xCA\x6C\xB6\xCE\xB0\x0B\x1C"
           "\x83\xD3\xEB\x1B\x6F\x47\x05\x82\xBF\x68\x23\x24\x90\xDD\xA0\x4C"
           "\xAD\x00\xC2\xD6\xBE\x7D\x8C\x5C\xBF\x1B\xF6\xE1\x73\x51\x9E\x6D"
           "\x62\x46\xBF\x62\xD5\xA6\xD6\x93\x17\x5D\xEE\xEF\x03\x82\x5E\x89"
           "\xA5\x42\xF3\x09\xB1\x20\x11\x48\x39\x90\x8A\xBD\xAA\xE3\xA8\x12"
           "\x4E\xD2\x36\x25\x16\x60\x73\x35\x44\x99\x56\xFE\xED\xF1\xC7\x48"
           "\x57\x57\x56\x27\x7C\x94\xC5\x2D\x6B\x77\xFB\xDC\x82\xD8\xD0\xE0"
           "\x2D\x0E\x4D\x64\x5B\x98\x07\x49\x8A\x29\x70\xD9\xDE\xA9\x44\xC5"
           "\xDE\x71\xCE\xF5\xE0\x63\x40\x28\xF4\xD6\x6D\x86\x14\xCF\x70\x24"
           "\x5B\x05\xAE\xC7\xE9\x69\x7B\x42\xAB\xF6\x53\xA3\x97\x1C\x93\x61"
           "\xCE\x7E\x8F\x38\xF1\x85\xC6\xB8\x2C\x6F\x11\x3E\xA6\xF1\x18\xF8"
           "\x85\xAD\xF2\xE3\x32\x82\x51\x0D\xEB\x12\x68\xC0\x1B\xCD\xF2\x3A"
           "\xB5\x55\xCD\x1A\x92\x9D\x31\xDF\xA6\xB2\x7A\xEE\x99\xA1\x39\x62"
           "\xC9\xE5\xFD\x47\xD0\x37\xCE\x6C\x08\x33\x31\x58\x38\x7B\x3F\x77"
           "\xFF\x4B\x01\xFC\x24\x58\x33\x24\xEB\xA6\xE2\xEE\x33\x1B\x67\x52"
           "\x81\x19\x16\x3A\xFA\x23\x82\x1B\x61\xEE\x5B\xDD\x08\x83\xA4\x5D"
           "\xCC\x57\x5A\xBF\xA5\x5C\x6E\xD7\xB0\xA2\xB6\x73\x52\x92\x9E\x5C"
           "\x46\x8D\x3E\xFB\x15\x1C\xB2\x7E\xD0\x90\x09\x61\x4F\x98\xFF\xEE"
           "\x8C\x40\x99\x83\x62\x1C\x2A\x29\xA9\x35\x58\x08\xF7\x97\xE6\xC7"
           "\x74\x50\xC9\x7D\xBF\xA2\x61\x51\x57\xD2\xDB\xDD\xE7\x19\xEF\x75"
           "\x26\xC0\x48\x56\xD9\x38\xFC\xF6\xF1\xEC\x6E\x96\x72\xCE\x2F\x19"
           "\xCA\x17\x76\x25\xFA\xDB\x0A\xBF\x4E\xD3\x6F\x65\xE2\xA3\x53\x9F"
           "\x0F\x91\xCF\xA8\x32\x9D\x83\xF1\x62\x54\xA3\x3E\x89\xF9\xD3\x20"
           "\xE8\x10\xE5\xE8\x6A\x73\x40\x90\x9A\x9D\x21\xD0\x9E\xEE\xFA\x44"
           "\x29\x42\x36\x61\xF0\x89\x9E\xE2\xFA\xBE\x06\x74\x7A\xAC\x2A\xF6"
           "\xA6\xFE\xE0\x7E\x17\x7C\xDA\xA7\x4B\xA3\x33\xD0\x66\x40\x56\x07"
           "\xB5\x21\x1A\x1E\x17\x3B\x43\x62\x9C\x0D\x16\xFA\xF3\x09\x93\x99"
           "\x56\x6C\xFD\x6A\xB7\x64\x04\x77\x33\x61\x13\x13\xD0\x93\x30\xD7"
           "\x78\xAE\xD3\x91\x30\xC2\x2C\x81\x39\x88\x9F\xE3\x9B\x4F\xF0\xC8"
           "\xFF\xA0\xA7\xED\x5F\xC3\xD7\xFE\x9C\xA7\x85\x7D\x1E\x7E\xA6\x7C"
           "\xD7\x6C\xEF\x3A\xAD\xE2\xFE\x2E\xAD\x45\x17\x9E\xC8\xA9\x71\xAB"
           "\xBF\xB6\xE3\x16\xEC\x4B\xF5\xA7\x9D\x20\x72\x87\xB4\x7E\x80\x89"
           "\xD6\xEF\x8C\xEA\x5D\xD5\xD2\x26\x9B\x3E\x58\x2C\xEB\xE6\x07\x1A"
           "\x05\x01\xD6\xBB\xFB\xA4\x2C\x31\x7A\xC0\x03\xB2\x14\x3D\x95\x41"
           "\xB5\xE3\x35\xA8\x86\xCF\x8C\x68\xFE\x01\x75\x0F\x3B\x77\x56\xA2"
           "\xCF\x29\x24\xFE\x99\x37\x02\x75\x65\x0E\xD6\xD2\x82\x9A\x93\x74"
           "\xAD\xBE\x1E\x56\x13\xC4\x29\x53\x35\x57\x4B\x46\x22\x4B\xB8\x50"
           "\x53\x71\x44\x27\xA8\xBC\x5B\x31\x0A\x32\xD4\x0F\xFF\xB2\x32\x5F"
           "\x39\xCD\xB1\x90\x77\x70\x23\xF9\xF4\x85\xDA\xE9\x16\x9D\xD5\xA0"
           "\x2A\x71\xF9\xF4\x40\x7D\xD1\x24\x5D\xBF\x93\xB3\x7F\x0D\x95\x67"
           "\x19\x51\x18\xA0\x99\x7A\x84\x44\x71\x9A\x08\x0D\x98\x25\x2E\xA6"
           "\x55\x6B\xEC\xA9\xA0\x72\xA4\xEF\x41\xC4\x20\x67\xA8\x86\xC9\x82"
           "\x86\xE8\x58\x5B\xA6\x8B\xCB\x30\xED\xF7\x7B\x0E\x6A\x6F\x6C\x39"
           "\x7A\x48\xA8\xE1\x9C\xEE\xC5\xDF\x08\x4B\xC9\x0A\x5D\xA0\x34\x42"
           "\xB5\x79\x5C\x29\xAF\xA9\xF8\x84\x31\xBE\x94\x21\x29\x17\x82\x99"
           "\x81\xB4\x9E\x2B\xC9\x78\xC5\xA6\x25\xD7\x28\xEE\x3A\xD2\x3B\xD8"
           "\x05\xCE\xEA\x07\x92\xD4\x8B\x4D\x64\xB4\x7F\x57\x9D\x2A\xFB\x80"
           "\xFF\x16\x09\xE2\x9A\xAC\x7E\x32\x2D\x2B\xE7\xA2\x9F\x9F\x63\xAF"
           "\x59\x62\xC6\x8D\x51\xD9\x2F\x6B\xF2\xB8\xEA\x9B\xAE\x30\x7A\xBB"
           "\x76\xC7\xDE\xB7\xF8\xF0\x33\x2E\x69\x65\xC0\x89\x2B\x82\x72\xAE"
           "\x8B\x65\x53\xEF\x96\xA4\xCC\xE6\xAB\x80\x9D\x23\x51\xCB\x77\x5B"
           "\xAB\x75\x5A\x70\x7B\x9C\xBE\xD6\x44\xCD\x0A\x3A\x1C\xF8\xD7\xC8"
           "\x9E\x68\x2B\xA2\xB6\x30\xC4\xE7\x3A\xF2\xDA\xE4\x15\xDE\x80\xD5"
           "\x03\xF6\x06\x3E\x19\x0B\x09\xF5\xE1\xED\xE9\x82\x79\x02\xD7\x21"
           "\x5C\x71\xFE\x15\xCB\xB5\x85\xB1\x12\x75\xF2\x94\xFC\xB7\x24\x14"
           "\xFF\xDE\xA6\x49\x7D\x61\xF8\xAE\x83\x40\x97\xC6\x13\x8F\xD6\xE2"
           "\xDA\xE8\x9D\x66\x71\x4A\x22\x1F\xF9\x55\x79\xAA\xE0\xE6\xD7\x29"
           "\x3D\x44\x2E\xC0\xB9\x4D\x64\x65\x2A\x0E\x4A\xB8\x62\xC1\x84\x2E"
           "\x3F\x6F\xEB\x79\xDF\xCF\xAA\x83\xB9\x7C\x73\x7E\x48\x88\x44\x03"
           "\xEA\x4F\x09\xCD\x72\x37\xA7\x49\x37\x6E\x52\x57\xFC\x64\x17\xE5"
           "\x9E\x36\x4D\xD7\x33\x82\xA5\x42\x3F\x37\x96\xE9\x00\x70\x91\x7E"
           "\x1F\xFF\xCD\xD3\x39\xD8\x27\x8F\x67\x81\x51\xF8\x03\xB5\x3A\xB9"
           "\x57\x64\x16\xBF\x7F\x0C\xD6\x74\xE7\x37\xB2\xFD\xF4\x20\x1B\x4C"
           "\xFD\xFC\x5C\xEF\x78\x30\x05\x38\xD7\x51\xE8\xD3\x16\x0A\x7D\x8C"
           "\xBA\x84\x9D\x1F\xF5\x6F\xE7\x15\x41\x1D\x3E\x40\x4D\x98\x64\x46"
           "\x43\x35\xA6\xBB\x0B\x0D\xF3\x39\x1D\xF9\x2B\x8C\x8E\xBD\x43\x9B"
           "\x39\x39\x10\x04\x06\x0B\x31\x7C\xF0\x1E\xE1\x70\xB1\x55\xD1\x59"
           "\xBE\x38\x24\xC8\x3E\x53\x30\xF7\x0F\xCE\x37\xCD\x5C\xF7\x90\x33"
           "\x85\x7F\x4D\x02\xAB\xEA\x50\x12\x18\xF3\x6E\x56\xA8\xEE\x38\x08"
           "\x8F\x94\x95\xAE\xE3\x74\x54\xCF\x0B\x88\x16\x7D\x2E\xBA\xAB\xCE"
           "\xCD\x7B\xA5\x62\x51\x84\x6A\x30\x0E\xF6\x44\x6C\x62\xDB\x9B\x21"
           "\xCA\x09\x0C\xBD\xE5\x09\x1C\xFA\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78"
           , 1200);
    nSKLen = 1200;
    memcpy(bInData,
           "\x8A\x1F\x27\xD1\xD3\x71\xF2\x9B\x8A\xAA\x1D\xF0\xBD\xBE\x59\x07"
           "\x55\x4B\xAC\x7D\x89\xE1\x29\xF4\x72\x48\x42\xF8\x25\xEF\x07\xF5"
           "\x21\x84\x09\x27\x70\xFE\x6C\xA5\xA6\xED\x82\x51\xC0\xC1\x84\xF5"
           "\x8B\xD7\x7B\xEA\x3D\xDB\x66\x2C\xA9\x79\x85\x18\x97\x8F\x5A\x69"
           "\xCF\xD1\x06\xDE\xD4\xF8\x9B\x2D\x7B\x4E\xE3\x62\x61\xEB\xB0\xEC"
           "\x53\x46\x62\x27\xCE\xDC\x22\x87\x76\xCE\xD1\x5E\xF9\x76\x4A\xE0"
           "\xA4\x2F\xD2\x12\xB7\xAB\xD2\xF4\xFE\x56\xC1\x7A\xD6\x5A\x7F\xBC"
           "\x03\x3B\xB6\xC2\xE2\x00\xD9\x21\x91\xA5\x2D\xAB\x59\x33\xA0\x24"
           "\x63\x50\xF6\x75\x66\xAD\xE8\xA4\xC8\x54\x8F\x61\x58\xF5\x8E\xB2"
           "\x21\x24\x91\x8F\xF9\x0A\xFF\x4C\x50\x68\xFC\x59\x72\x3F\xD9\x6D"
           "\x1E\x47\xAD\x04\x83\x6C\x84\x1E\x09\x64\x34\x17\xCB\x6F\x62\xC0"
           "\x18\x58\x4A\xA4\x82\x03\x1F\x25\xEB\x0A\x2D\xC9\x3F\x41\x15\xA3"
           "\x3C\x80\x12\x64\xE8\x4E\x73\x74\x06\x29\xAE\xC0\xC5\xC9\x64\xD7"
           "\x78\x32\x22\x9E\xC9\xF9\xA1\x96\xD4\x58\xFC\x29\xA0\xA1\xE0\xAA"
           "\x27\xD7\xEE\x6C\xEA\x6F\xF5\x04\x78\xBC\xBC\x58\x4C\x5A\xAB\x04"
           "\x53\x16\xC7\x97\xA5\x51\x21\x12\xBE\x01\x88\x18\x61\x03\x39\x10"
           , 256);
    nInDataLen = 256;
    memset(bOutDataExp, 0x42, 1);
    nOutDataLenExp = 1;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 1200);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 256);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-2048，PKCS#1填充，解密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 1);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 1);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 1);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_25(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 2;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    memcpy(bInData,
           "\x24\x77\xD9\xBF\x74\x57\x57\x25\xC5\xD1\xEE\x64\x8D\xA8\x30\xAE"
           "\x28\xD6\x54\x18\x9C\xE8\x2A\x8C\x2E\xA3\xEB\x89\xB7\x01\x9F\xC5"
           "\xE7\x8B\xF4\x82\xD5\xCA\xCA\x77\xEE\xEC\xAC\x53\xC3\x80\x3F\x60"
           "\xA7\x0B\x3E\x79\x44\xA9\xDA\xED\x05\xD0\x61\x06\x31\x44\xAD\x17"
           , 64);
    nInDataLen = 64;
    memset(bOutDataExp, 0x42, 22);
    bOutDataExp[0] = 0x30;
    bOutDataExp[21] = 0x39;
    nOutDataLenExp = 22;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 320);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 64);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-512，OAEP填充，解密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 22);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 22);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 22);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_26(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 2;
    memcpy(bSK,
           "\x3B\xD4\x50\x5C\x7E\x86\x10\xCE\x25\x5C\xB9\x39\xC2\xD4\x61\x5C"
           "\x7F\xC2\xC4\x74\xE5\x22\x06\xCD\x50\x53\xAF\x84\x02\xF7\xE6\x54"
           "\x85\x44\x18\x4D\xE9\x05\x89\xF5\x5D\x0E\xC0\x55\x6A\xD2\x53\xA5"
           "\x36\x71\x2D\xD5\xFD\xEA\x8A\x45\x4C\xC6\x00\x3B\xE7\x01\x70\x1C"
           "\xEC\xA6\xD1\xF4\x7D\xF0\xD5\xF5\xB6\x5A\x00\x43\xBC\xF0\x6A\x79"
           "\xFF\xD3\x30\xB8\x5F\xFA\xEA\xE0\xD1\x9E\x6C\x02\xAE\x9A\x13\xF0"
           "\x09\xED\xB1\x9C\x0A\xBE\xA9\xB7\x93\x66\xBB\x08\xC6\x0A\xA2\xFD"
           "\xFE\x19\xBF\x9E\x9E\x7C\x1C\xCF\xBB\xF6\x3F\x4D\x1A\x35\xF9\x26"
           "\x2A\xF4\x84\x29\x43\x79\xE7\x3D\x9B\x58\xF9\x30\xE1\x27\x3B\xC0"
           "\xD7\xE7\xEF\xF8\x52\x50\x2C\x85\x65\x1B\x1C\x3D\x2D\xA9\x73\x8F"
           "\xCA\x54\xF3\x60\xE4\x84\x67\xAC\xEB\xAA\x24\x30\xC9\x98\x9D\x4B"
           "\x2E\xF3\xD7\xE1\x93\xCA\xC0\x63\x3F\xD1\xE4\xAF\x08\x37\x63\xB5"
           "\x8A\xDB\x3E\x66\x44\x4E\x01\x7F\x75\x92\xB4\x5D\x79\x6C\x94\x9B"
           "\x4C\x55\x2F\x9A\x26\xD9\x54\x65\x67\x41\x4A\xAC\x1F\x7C\x4A\xFE"
           "\x1E\xDD\xDD\xE1\x51\x3A\xB2\xE2\x92\xFA\x3F\x8D\xFF\xEE\x78\x0A"
           "\xBB\xFB\xD6\x94\xE3\x39\x48\xF8\xF1\xC0\x3A\x36\xF4\x65\xF6\xB9"
           "\x2A\x2C\xEE\x71\x11\xAA\x7B\x55\xBF\x9D\x13\x0F\x74\x47\x05\x87"
           "\x27\xF0\x9F\x65\x6E\xED\xAF\x2B\x78\x69\xFE\x3A\x40\xA3\xDB\x58"
           "\xCC\x5C\x83\xC5\x0E\x9B\xF3\xB5\x8B\x6D\xA8\xBE\x0C\x5E\x38\x2A"
           "\x12\x8C\x3E\x40\xA1\x03\x43\x20\x6B\x4B\x3D\x65\x8C\x96\x13\x5F"
           "\x58\x56\x87\x88\x20\x0A\x12\xD8\x42\x95\x55\x5D\xDD\x74\x23\xF3"
           "\x05\x77\x04\x02\xBC\x97\x6E\xED\xEB\x33\x10\x4B\x8C\x58\x0C\xDF"
           "\x9A\x54\xCD\xB9\x69\xAA\x0B\x15\x13\x8B\x95\x87\x55\xFC\x05\x0A"
           "\x81\x5E\x00\x9D\x50\x9D\x7D\x73\x94\x6B\x78\x30\x40\xC7\xF4\x89"
           "\x76\x9F\x1D\x3B\x69\xAE\x65\x5C\xF5\xAB\xF8\xC0\x33\x0F\xA3\x02"
           "\xA4\x41\x96\x86\x47\x75\x2F\x3B\xC4\x3D\xE8\x5A\x88\xAB\xB9\x74"
           "\xB9\x8F\xA7\xDC\xBE\x35\xE0\xA1\x31\xA1\xEE\xAC\xD3\x01\x97\x67"
           "\x65\x1D\x81\x74\x38\x11\xEF\xC5\x0F\xDD\x6B\x70\x98\xF8\xDC\x91"
           "\xFA\x20\xDD\x34\x9F\xB4\xB2\x09\x6B\x90\xD7\x81\xBA\xD4\x34\xEA"
           "\x24\x83\x49\x86\x3C\xDF\x51\x98\xDB\xA2\x68\x53\xC3\x41\x47\x3B"
           "\x70\x13\x1B\xC7\xB1\x4B\x64\xD3\xD1\x46\xF6\x97\x04\x65\x8C\x24"
           "\x13\xD0\xE5\x85\x7D\xBF\x31\x3A\xB5\x49\x14\xF1\x3F\xFA\xB5\xC1"
           "\x47\x61\x69\x76\x6E\xD2\x9D\x84\xA0\x88\xD6\x65\x35\x6E\xD4\xEB"
           "\x57\x1D\x9F\xF5\xB5\x10\x5D\x12\x05\xA1\xF2\x5A\x37\x4D\x9A\x65"
           "\xBA\xE8\x69\x9B\x02\x93\xAD\x7A\x84\xB0\x6E\xF2\xB6\xB3\x86\x11"
           "\x8F\xF8\xB2\x23\x4E\xD4\x33\x74\x9C\xB4\x91\xD8\x57\x01\x18\x14"
           "\x8A\x63\x13\xFB\x17\x1B\x91\x0E\x35\x71\xD2\x0A\x73\xCD\x99\xA9"
           "\x5C\x10\xD3\xDE\x93\xF4\x5A\x63\xCB\x08\x1E\x8F\x38\x0E\x1A\xB1"
           "\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78"
           , 616);
    nSKLen = 616;
    memcpy(bInData,
           "\x39\xF7\xA4\xF4\xFC\xE6\x36\xDF\xAA\x56\x90\x30\xE9\x57\x6E\x7F"
           "\x18\x04\xBE\x16\x72\x58\xE7\x98\x07\x39\x59\xBF\xF2\xA6\xE3\x42"
           "\x85\xB7\xEF\xD9\x3E\xF7\x11\x87\xB5\xC1\x8A\x72\xAE\xF2\x63\x5C"
           "\xE6\x55\x60\xD9\xB6\xCB\x5A\xAF\x2A\x5D\x49\xF5\x6F\xFD\x0C\x4A"
           "\x98\xAA\x83\xAB\x60\xB3\xB0\x1B\x35\xE2\xAB\x2C\xBD\x00\x6A\x1A"
           "\xF4\xCE\xAA\xFC\x01\xE8\xEC\x89\x01\x71\x98\x11\xBC\xC4\x62\x2D"
           "\x6F\xF2\x9D\xEC\x29\xDE\xBC\xED\x6E\xD0\xC8\x9A\x31\xC5\xF4\xF2"
           "\xF8\x7A\x90\x87\x6A\x19\x6F\x8D\x0F\x44\x5D\xF6\xD0\x3A\x35\x15"
           , 128);
    nInDataLen = 128;
    memset(bOutDataExp, 0x42, 64);
    bOutDataExp[0] = 0x30;
    bOutDataExp[63] = 0x39;
    nOutDataLenExp = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 616);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 128);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1024，OAEP填充，解密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 64);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 64);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 64);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_27(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 2;
    memcpy(bSK,
           "\xDF\x00\x50\x67\x45\x67\xCB\xA9\xF3\x62\x34\x84\x08\x05\xEE\x96"
           "\x70\x77\x07\xC3\x71\x70\xAD\xC0\xE9\x02\xE7\x50\x58\xCB\x00\xCF"
           "\x55\xAA\xB9\xE0\x3D\x47\x8D\xC8\x38\x3A\x78\x92\xB2\x54\x98\xEF"
           "\x5A\x46\x80\x77\x58\x05\x1E\x94\xA8\x62\xE6\xFA\x5C\x54\x15\x48"
           "\x2D\xDB\x8C\x41\x31\x90\x9F\xE9\x4D\x87\x7A\x21\xB9\xA3\x13\xE5"
           "\xE0\xED\x09\x27\x17\xB6\xB1\xAA\x23\xBE\x5F\x80\x9F\x25\xF2\xE1"
           "\x7A\xB2\xCB\x36\xF2\xE5\x2A\x6F\x63\xD1\x4C\xD6\x53\x07\xBF\x83"
           "\x4F\x59\xE1\x20\x63\x9C\x33\x38\x88\xD3\x79\x7D\xF1\x47\x6E\x16"
           "\x3F\x38\xF3\xCF\x0D\x25\xF4\xD5\x28\x76\x55\x5C\x22\x54\x1B\xAD"
           "\xCC\xB6\x21\x81\xFC\x32\xE0\xCF\x8C\x30\x3A\x96\x31\x48\x02\x7E"
           "\x0E\x2A\x4B\x99\x46\x5C\xCA\x23\x82\x41\xA6\x9B\x8A\x71\xF4\x4E"
           "\x7A\xCF\xBE\x9D\xEC\x18\x90\x04\xF2\x6F\x9F\xD9\x76\xFD\x43\x17"
           "\x81\xF0\xD7\xB8\x1B\xE6\x7C\xBB\x5F\xB9\x9D\x8E\x96\x4D\xC5\xE3"
           "\x7A\x98\xBA\x11\x2B\x52\x62\xA3\x48\x6F\x9C\x8F\x3F\x4A\x88\xF4"
           "\xEA\x82\x59\xBD\x2D\x55\x06\x8F\x51\x8D\x37\xA0\xB0\xF4\xA7\x23"
           "\x76\x86\xFF\x68\xEA\x6C\x64\xFE\xC0\xCD\x6C\x48\x20\xCB\xD2\x77"
           "\x31\x73\xD8\x50\x5A\x13\x84\x98\x8D\x0A\xF1\xB9\x8A\xD8\x87\x54"
           "\xDC\xB4\xBA\x6A\x0E\x7D\x04\x4D\x7C\x6C\xF6\xE3\x50\x65\xEF\xC2"
           "\x9C\x70\x39\x70\x99\x60\x53\x70\x88\x1D\xA2\x56\x1A\x78\xB8\x15"
           "\x17\x81\x3F\xEC\x07\x0A\xE0\x33\x7A\x82\x0B\xE2\x21\x53\x1B\x27"
           "\x7C\x06\x69\x00\x82\xB3\xAB\x74\xE9\x43\xDD\xCC\x69\x2C\xF8\x51"
           "\xAF\xEB\xEE\x15\x6E\xE0\x35\xA8\x6A\x0D\x35\x8A\x01\x98\x68\x8A"
           "\xC5\x71\xAA\x8C\xDB\x31\xC7\x04\x5D\xEF\x33\x50\x1A\x66\xC9\xBF"
           "\x85\xE8\x30\xBF\x8E\x36\x86\xA3\xB0\xBF\x18\x8E\xA0\x93\xB3\x5C"
           "\xD2\xD3\x6E\x57\x86\x14\x30\x5D\xC5\x29\x0B\x5A\xEF\xEA\xA3\x9C"
           "\xC0\xDD\x9B\xDF\x67\xB9\xAF\x01\xC4\x0C\x83\xE1\x36\x95\x4E\xB6"
           "\xF2\x61\x4F\xB8\x09\x8E\x66\x90\x23\xE7\x6D\xD1\x71\xF4\xF4\xE7"
           "\xF4\x3B\x54\x8D\x91\x05\x89\xB5\xFE\x78\xBA\x30\x87\xF5\xB5\xE6"
           "\xE8\x55\x5B\xCA\x64\xAF\x89\x59\xA0\x50\x8A\x7D\x19\x40\xDF\x49"
           "\x31\xEA\xEF\x76\x70\x2E\x1F\xC7\x05\x7E\xA0\x2A\x42\x17\xA2\x0A"
           "\x32\xAC\x36\x7F\x31\xFF\x11\xED\x06\x13\x03\xC6\xDF\xEF\xC4\x27"
           "\x8C\x29\xE3\x36\xE6\xDE\xBC\xE8\x7B\xB5\x7B\x9A\xCB\x93\xF1\x21"
           "\x26\x38\x94\xDA\xF5\x1B\xD7\x2F\xA9\x3C\xEC\xE3\xDC\xD6\xD8\xFC"
           "\x03\x4D\xE1\x49\xA2\x22\x6E\xFD\x57\x80\xAB\xF4\xFA\xD5\xC2\x53"
           "\xCE\x6D\xB2\x61\xE3\xA8\x22\xD8\xD2\x9C\xFE\x85\xE2\x80\xA0\x9D"
           "\x1E\xAF\x00\x3F\xF2\x36\xE1\xE5\xBC\x32\x73\x7E\xD0\x6E\x18\x66"
           "\x48\x64\x91\x0E\xB6\x70\x82\xAA\x40\xFA\x2D\xB5\x27\x0A\x71\x17"
           "\x15\x96\xD4\x2B\xEF\xB4\x82\xA2\x4C\x7C\x08\x2B\x9E\xD6\x99\x56"
           "\x20\x08\xCD\x7D\x6B\x5E\x38\x53\x67\x13\x38\xED\x16\x44\x71\x12"
           "\x97\x4B\x84\xE7\xCE\x12\x53\x70\x46\x6A\x71\x51\xAD\x8B\x71\x2D"
           "\xE5\x4C\xF7\xFF\xCE\x39\xB3\xA0\xB1\x46\x26\x4F\x1A\x63\x0C\xB9"
           "\xEE\x8F\xC7\x8E\x61\x24\xD0\xFB\xD4\x33\x00\xFD\x85\x23\x8B\x12"
           "\x09\x49\x7D\xA8\xE2\x9D\x2E\xFD"
           , 680);
    nSKLen = 680;
    memcpy(bInData,
           "\xA7\xA3\x3E\x9A\x74\x51\x01\x1F\xFB\x4C\x6B\xC3\x63\x99\x60\x00"
           "\x8F\x27\xCB\x67\x3A\x09\xBF\x82\x42\xDB\x46\xB7\xE6\x2C\xFE\x2D"
           "\xBE\x67\x6F\x0C\x6C\x26\xFD\xE3\xD6\xAB\xC5\x1E\x50\xFC\x6E\xB2"
           "\x90\x1F\xCB\xD1\x0F\xF6\x20\x3C\xE6\x0A\x1C\x6C\xC5\x05\xA2\x43"
           "\x33\xBD\x8C\xF2\x3E\x49\x79\x5F\x4A\x09\x4B\x1B\x9B\x09\xA0\x31"
           "\xDE\xA7\x4F\xD3\x25\x5A\x2D\xF6\x09\xAA\x00\xEE\xAC\x04\x4E\xE0"
           "\xBD\x78\x28\x50\xBB\xC4\x69\xAB\x4C\x84\x1A\x4A\x2A\xD1\xCF\xFF"
           "\xE7\x23\x8F\xF3\x7A\xA2\x1A\xFB\x83\x75\xD7\x76\x60\xE4\xF5\x89"
           "\xAE\x38\xC3\x16\xA4\xE3\xCC\x38\x13\x51\xEE\x96\x03\x54\x7B\xA7"
           , 144);
    nInDataLen = 144;
    memset(bOutDataExp, 0x42, 72);
    bOutDataExp[0] = 0x30;
    bOutDataExp[71] = 0x39;
    nOutDataLenExp = 72;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 680);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 144);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1152，OAEP填充，解密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 72);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 72);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 72);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_28(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 2;
    memcpy(bSK,
           "\x21\xE5\x82\xE3\xD4\x2B\x83\xA7\x68\x16\x92\xEF\x49\x12\x6D\x45"
           "\xC5\x11\xC5\x1E\x9E\x67\x6F\xF9\x04\x47\x04\x31\x37\x69\xFD\x3D"
           "\x6C\x60\x8F\x08\xC7\xF3\xF1\x69\xDF\xCC\x66\x75\xEA\xB0\x61\x33"
           "\xAF\x7A\x12\x41\x94\x5A\x51\x39\xB5\xBE\xE7\x4C\x9D\x98\x77\x80"
           "\x6C\xB9\x2B\x98\x4E\x55\xEC\x57\x0E\x8A\x1F\xA8\x52\xDE\x44\xC5"
           "\x08\x2F\x21\xD9\x0E\xDD\xB5\x5E\xF3\xA1\x8C\xF1\xC3\xCB\x0A\x18"
           "\xD3\x80\x83\x10\xEB\x2E\x99\x59\x45\x7D\x2B\x92\xF5\x22\x7B\x49"
           "\x67\x02\x84\x5F\x56\x56\xBC\x95\x04\xA4\xB7\xB7\x53\xAE\x19\xF1"
           "\xF8\x7C\x3D\xEA\xDA\xDF\x52\x99\xF5\xB4\x15\xAB\x03\x8B\xBD\x6B"
           "\xC0\x8C\x86\xFC\x56\xCC\x3C\x0C\x38\x31\xBD\xB7\x28\x29\xAC\x0E"
           "\x24\xF2\x12\x6E\x6A\xFC\x01\x1C\x18\xC6\x3A\xCD\xD8\x0A\x64\x27"
           "\x93\x9D\x76\xAA\x27\x42\x7E\xEF\xFB\x83\x2A\xB5\xF3\xD0\x15\xC8"
           "\xEF\xF4\x3E\x5B\x5F\x3B\x4F\x96\x2C\x76\x6A\xD6\x69\xD7\x57\xC1"
           "\xF6\x40\xDF\x49\x7B\x4A\x9B\xE2\x7A\xE3\x09\x8B\xC9\x47\xA9\x14"
           "\x5F\x1D\xC1\x4A\x7F\x9D\xCF\xEF\x7D\x1A\x91\x6F\xC7\xA0\x41\x7F"
           "\x7B\xC3\x15\x00\xEC\x53\x34\x22\x95\xEE\xE7\x08\x39\x63\xF5\x54"
           "\xB6\xAD\x39\x45\xB5\x21\x5C\x34\x5E\x67\x7B\xD8\x97\x50\x91\x75"
           "\x6F\x68\x0A\x95\x8F\x24\xBE\x83\xDB\x44\x91\xE0\xD2\x99\x24\x99"
           "\xBD\x11\x2E\x15\xA9\xCC\xCD\x14\xD9\xBB\x5E\x56\x0F\x69\x9A\x18"
           "\x5A\x42\x25\xB1\x3F\x6B\x03\x18\x51\x9C\x36\x8F\xDB\x1E\xB9\x11"
           "\x3A\xEF\x24\xDB\x9B\x2E\xA2\x1B\x11\x73\x86\x5A\x4C\x12\x4F\xD8"
           "\xCB\x07\xEE\x99\xAC\x04\x10\x2B\x1C\xD7\xB8\xEB\xE7\x56\x2C\x8A"
           "\x12\x36\xDD\xA0\x11\x9D\xC8\x26\x37\x66\x0B\x21\x89\xC3\x7D\xA1"
           "\x40\x85\x91\xFF\x5E\x80\x70\xFB\x68\x28\x03\x8A\x6F\x09\xBC\xD6"
           "\xAC\xAF\xF4\x60\x67\x8D\xA8\x3E\x17\x5B\x5A\xE9\x3E\x17\xA9\x34"
           "\xA9\xD7\x29\xBE\xBE\xE3\xCD\x09\x74\x23\xC7\x21\xEE\xA2\x63\xA2"
           "\x33\x64\x92\x53\x31\x74\xF2\x96\x0C\xD0\x11\x30\xB6\x9F\xE0\xBA"
           "\x5B\x4C\xFA\xA0\xBB\x83\x1C\x74\xD8\x70\xE0\x4B\x2A\xAA\xBD\x88"
           "\x4A\x1E\xB5\x22\x63\xD7\x2E\xBD\xA4\x8E\x6C\xA3\x10\x29\xE8\x29"
           "\xA8\x43\x89\x66\xB7\x7E\x3D\xBE\x8C\xE3\xFC\x5A\xBF\x06\x0B\xCC"
           "\x34\x91\x9D\xE3\x85\x1D\xB7\x39\x03\xC3\x0C\x05\x17\xA4\x8D\xE0"
           "\xB3\x9E\x01\xF7\x80\xF4\xBB\xF0\x22\x23\xDA\xBD\xC4\x14\xBB\x78"
           "\x58\xC5\x7F\xC6\x09\x41\x54\xBB\x11\x96\xE6\xA3\x1A\xC9\x55\xBD"
           "\x0F\xF0\x3F\xBE\x61\x83\xCE\x26\x82\xA2\x8E\xD5\x0D\x2D\xB7\x66"
           "\xBC\x2E\xF0\xEB\xC3\x2F\x6A\x2A\xF5\xB9\x8B\xF0\x42\x4F\x65\x8B"
           "\xD1\x6E\x76\x88\x8C\x29\x34\xCF\x26\x27\x84\x8E\x6B\xA2\xEB\x16"
           "\x77\x2D\x21\x7E\xEC\x18\x4D\x04\xDA\xEF\x95\x1C\x29\x75\x18\x1C"
           "\x83\xCA\xB6\x72\xC3\x77\x46\x29\xBB\xFC\xDE\x1D\x78\x72\x76\x47"
           "\x20\x40\x90\xDC\xBC\xA3\x72\x33\x64\x7E\x18\xD9\xA4\xD2\x46\x9C"
           "\x77\x8B\xF9\x6D\x97\xB0\xD6\xA1\x20\x2C\x0D\xB6\xE3\x2C\x09\x8F"
           "\x07\xB6\x5F\xD3\xDB\x3B\xFD\x77\x69\x7D\x56\xE4\x35\x18\x3A\x9B"
           "\xF6\x22\x3A\x01\x35\x71\xBE\xA4\x48\x97\x8B\x45\x90\x46\x07\x0E"
           "\x17\x68\x9E\x00\x11\x6F\x4A\x25\x55\xA0\x9C\x74\xD9\x15\xFF\xF5"
           "\xE0\x59\xD6\x86\xA0\x91\xD8\x7F\x9A\xFF\xE4\xBD\xAB\xE3\xF0\x94"
           "\x49\x66\x36\x7F\xD3\xD3\x8E\x13\xB7\xFC\x89\xB7\xA9\x3C\x7B\x0E"
           "\x11\xAC\x66\xCE\x34\x34\xAE\x67\x70\xE0\x3A\xB6\x0E\x78\xFD\x94"
           "\xF1\xB5\x74\xD3\x47\x2A\x74\x40\x51\x39\xD1\x49\x73\x94\xB4\xF9"
           "\x4C\xB6\x4B\x11\x19\x2F\x7E\x34\x3E\x6B\x4F\x34\x5B\x83\x52\x47"
           "\x99\x0C\xD6\xDF\x7B\xA3\x95\xE2\xCC\x39\x2F\xC4\x92\x43\x38\x2F"
           "\xCB\xE6\x8C\x2D\xAD\xD0\x5E\xE9\xD5\x3D\x5E\x70\x2E\xA8\x66\xB0"
           "\xA6\xB8\x7C\xA4\x3A\x9E\x28\x3B\x0E\x46\x20\x84\xF8\x5E\x53\x9E"
           "\xCF\xDE\xF3\x0F\x1F\xE3\x8D\x51"
           , 824);
    nSKLen = 824;
    memcpy(bInData,
           "\x51\xE7\x8D\xE8\xAC\x05\x5E\xDA\x04\x06\x93\x67\xAC\xBF\xC6\xD9"
           "\x36\x6C\xA0\x1F\xBA\xE4\xF9\x0A\xE9\x50\xED\xC5\x34\x2C\x34\x1F"
           "\x9B\xA5\x7E\xCE\x7E\x94\x41\x85\xC5\xA4\x36\xFA\x40\x1C\xF7\x0F"
           "\x61\x33\xA4\x2B\xBD\xE0\x44\x84\x9D\xD6\xB1\xE7\x02\x46\x50\x32"
           "\xE0\x96\x08\x33\x0A\x83\x23\x74\xE6\x4E\x42\x31\xA4\xAC\x8E\xD0"
           "\x4A\xF5\xC7\xC9\x3F\x63\x7E\xFD\x2F\xFD\x4C\x62\x8C\xAE\xC4\xC1"
           "\xCB\x05\x7E\xD6\x96\x84\xB9\xF6\xAA\xE9\xC0\x3A\xBD\x1C\xF2\x4D"
           "\xE3\xE2\x67\xEC\xAB\x9B\xF2\xCE\xD1\xFE\xA3\x52\x88\x7F\x59\x98"
           "\x98\xC5\x73\xDE\xCD\xCF\xE4\xE3\x6B\xDF\x68\x15\xBF\x5E\xCC\xD2"
           "\x92\x90\x4E\x41\x22\xA0\xA2\xD9\xC0\x84\x96\x43\xDF\x62\x00\x21"
           "\xEE\xE9\x41\x9E\x80\xA7\xCF\xE5\xA6\x1B\xBC\xE1\x15\x97\x6E\x52"
           , 176);
    nInDataLen = 176;
    memset(bOutDataExp, 0x42, 88);
    bOutDataExp[0] = 0x30;
    bOutDataExp[87] = 0x39;
    nOutDataLenExp = 88;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 824);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 176);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1408，OAEP填充，解密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 88);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 88);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 88);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_29(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 2;
    memcpy(bSK,
           "\x6C\x18\x21\x1D\x3D\xDC\x38\xA8\xBA\x10\x33\x70\x83\x41\xB5\x37"
           "\xFE\x97\x6F\xB1\xF4\x21\x1A\xAD\x35\x77\xBD\x28\xB2\x57\x20\x10"
           "\x16\x13\x93\x89\x47\xC3\x73\xFC\xB9\x76\x48\x3A\x77\xCD\xA7\x0C"
           "\x17\xE9\xF1\x4C\xD0\xA7\xE1\xAA\x0D\x9A\x8C\x38\xD1\xE6\x83\xA6"
           "\x93\xD4\x55\x28\x6B\xB9\x0F\x81\x02\x7A\x78\x54\x00\x84\x94\xFB"
           "\x82\xCC\x8A\x78\xFC\x93\x45\x6E\xD3\x13\xD3\x1F\x18\x69\x73\x2A"
           "\x70\x86\x1F\xFB\x25\xE6\x2A\x64\xCC\x6F\x1F\x18\x26\x0D\x1C\x40"
           "\xAA\x5E\x52\x50\x22\x5A\xE4\x3C\xBC\x29\xFA\xCA\x30\xE3\x53\x40"
           "\x34\x35\xF1\xD0\xE2\x69\x1D\x34\x8E\x83\x96\xAC\xAA\xCF\x6C\x98"
           "\x3F\x4F\x8C\xEF\x8C\xB3\x3A\x04\xF5\x7C\xB1\x76\xA3\x32\x1B\xC1"
           "\x83\xAD\x70\xA5\xF9\x08\xB8\xD9\x2E\xED\x15\x65\xB0\x33\x30\x04"
           "\x1F\x69\x87\x1D\xFF\xBF\x0F\x59\xE3\x62\xE1\xE8\x2C\x03\x4B\x72"
           "\xB6\xAA\x8F\x73\xBA\xFE\xEE\xCC\xAF\x50\x87\x3D\xA0\x5F\x66\xA0"
           "\x88\x3A\x7F\xDF\xA1\x8E\x06\x08\x18\x2C\x1A\x16\xCE\x0C\x6E\x13"
           "\x4F\x2E\x26\x3B\xB8\xAF\x70\x5E\x70\x48\xED\xCE\x8D\x6C\x9B\x26"
           "\xD7\xFE\x95\x5F\xC6\x91\xB6\x81\x3F\x7C\x9A\xF1\x6D\x1B\xAB\x6E"
           "\x84\x10\x94\x5A\x07\x38\x56\x75\xF0\xEB\x3C\x5E\xA3\x0E\x85\x17"
           "\xFB\x5B\xD0\xFA\x84\x3D\x58\x4C\xFD\xF0\xE5\x37\x77\x29\xE2\x5A"
           "\x7C\x74\x87\x04\x9C\xF0\x7A\x2C\xE4\xD2\x0A\x1C\xD8\x8B\x37\x8C"
           "\x7F\x1C\x10\x6E\x73\xB2\x69\x4C\xBE\x1A\x84\x3C\xC8\xA7\xA3\x68"
           "\x48\x7E\x2F\xFD\x9B\x5F\x12\xAD\x15\x49\x3F\xC4\x10\x86\xAF\x56"
           "\x4D\xCB\xC6\xE8\xAD\x35\x72\x21\x24\xD9\xC3\xA3\x82\xF1\xB2\xAF"
           "\xD9\x88\xBF\xFB\xCB\x81\xF9\xF6\x3B\xC6\x1C\x34\xF0\x5A\x33\xE5"
           "\x41\x9B\xC2\xF9\xE2\x23\x0E\x2D\x11\xC5\xBF\x41\x91\x7B\xE9\x36"
           "\x07\xD8\x60\x00\x09\xDD\xD5\x86\xD7\x65\x50\x98\xBC\x5C\x0E\x60"
           "\xA0\xE5\x53\xEC\xA6\x9D\x11\x99\xEA\x25\x44\xF4\x50\x76\x0D\x4D"
           "\xE7\x72\x87\xCF\x6F\x7C\xF2\x27\xED\x73\xD7\xEF\x53\x6D\x0B\x99"
           "\x6B\x38\x44\xBC\xC0\x12\xF5\xD6\x92\x3F\x64\x81\x54\xC1\xEF\x04"
           "\x5C\x1F\x23\x7E\xF5\x38\xA7\x80\xFC\x17\xEF\x00\x3C\x8D\x09\xAB"
           "\xAA\xD0\x40\x14\xD7\xCB\xAC\xA1\x29\xE0\x12\xD5\xD4\xFF\x1B\xDD"
           "\xCA\x78\x2B\x1D\xEC\x9F\xA5\xAC\x67\x74\x31\x8C\xF6\x8F\x9A\x59"
           "\x7D\x84\xF1\x7E\x5D\xA4\xC9\x53\xEF\x58\x2D\x1F\x0F\x3A\x6D\x66"
           "\xFF\x06\x61\x1A\xDC\xDB\x19\x0C\xE6\x43\xC4\x4A\x2B\x3D\x8E\x79"
           "\xD4\x93\xA8\x9A\x1A\xF7\x91\x45\x77\x78\xAB\xE1\x77\x33\x26\xFF"
           "\x92\x0B\x96\xD5\xF3\xAF\x05\x0B\xC4\x53\x1B\x89\xEC\xDC\xD0\x12"
           "\x4A\x65\xF3\xAD\x43\x8C\x23\x35\x13\x79\x4E\xD8\x0D\x21\xC9\x61"
           "\x49\xCA\x48\x53\x48\xC6\xA1\x7E\xF0\x28\xA5\x97\x11\xB8\x18\x33"
           "\xAD\xEC\xEF\x6B\x5C\x71\x4A\xBE\x9F\x31\xB8\xA3\x98\xC5\x0C\x0B"
           "\x46\x51\xA2\xAE\x02\x6F\x98\x35\xF7\x4D\x21\x5E\xC3\xED\x61\xB0"
           "\x6B\x59\x79\x5A\xB9\xA8\x1C\xB0\xBA\x82\x67\xB9\x97\xBB\xD4\x4D"
           "\xF1\xA1\x56\x5C\x7D\xCB\x77\xD0\x28\xE0\xFF\x1C\xAA\x22\x07\x68"
           "\x9B\xF3\x80\xDE\x96\x1D\x03\xDD\x97\x8A\x69\xDA\x5C\x54\xD4\x80"
           "\x93\xB2\x0D\xCD\x43\xBA\xFC\xDF\x11\xCF\xFE\xCE\x3B\x74\x8E\x67"
           "\x17\x74\x8E\x29\xF9\x64\x97\x52\x8C\x7B\xC9\x71\xB3\x5E\x59\x86"
           "\x63\x38\xF6\x9E\x79\x43\x56\xD6\x6F\xE6\x26\x45\x62\x64\x26\xE0"
           "\xA7\xDC\x70\xCA\x5B\xCD\xE7\xC6\xE1\x1F\xFC\x97\x57\xA1\x2B\xC5"
           "\x12\xB6\x9E\x85\x37\x9E\x58\x48\x2F\x9A\x91\xB7\xB6\x7C\x28\x47"
           "\x1A\x73\x45\x41\xD4\x6E\xBE\xB5\xB7\x60\x1A\xF2\x8B\x04\x78\x38"
           "\x4B\xB6\x45\x8C\xA9\x3E\xE5\x7A\xBF\x1F\xC4\x86\x30\xB4\x0C\xB1"
           "\xC6\x9D\x80\x88\xD2\x49\xD9\x89\xD9\x50\xA8\xDE\xEC\xA5\x04\x7F"
           "\xFF\xEA\xC0\x2F\xCB\x37\x7A\xB6\x97\x59\xAD\x53\x29\x34\xB3\x79"
           "\x16\x3B\x3E\xF5\x7F\x14\xB3\x77\xF9\x2E\xE8\x3F\x04\xAE\xDE\x89"
           "\x73\x04\x32\xA7\x4C\xC0\x4D\x43\x0D\xC1\xE5\x21\x48\x32\xAA\xE1"
           "\x5E\x81\xB6\x23\x6A\x80\xCA\x17\x23\xFC\x5F\x47\xE1\x57\x14\x59"
           "\x46\x67\x0F\xBF\x6A\x57\x53\x10\x8E\xAB\xAA\x9C\x8A\xDD\xE0\x9D"
           "\xA2\xAC\x94\x87\x6A\x71\xD0\xAF\xE4\x8A\xCF\xEB\x23\x27\x00\xC2"
           "\x8B\x11\xA9\x2C\x02\xB5\x05\x03\x30\x7A\x0C\xEF\x7F\x5B\x1C\xE7"
           "\x64\xFF\x1E\x68\x78\x28\x1C\x6D\xA0\x16\x75\x36\x7F\x9F\xF9\xCD"
           "\x15\x3B\x8E\x26\xC3\xF1\x7A\xBC\x17\x42\x92\x7D\xA8\x4E\x22\x5F"
           "\xB9\x55\xF5\xB7\x2C\x10\x5E\x79\xBB\x81\x54\x32\xDC\x8D\xE7\x4B"
           "\xE3\xCB\xDB\x1D\x34\xA4\xBA\x5F\x1A\xFE\x43\x48\x46\xEF\x88\x67"
           "\xD5\xB6\xDD\x06\x99\x5C\xB3\x38\x45\xED\xD0\x21\x77\x22\xF4\xF3"
           "\x68\xD6\x90\x53\xB5\x1E\x36\x3C\x35\x08\xCF\xBE\x53\x8F\x59\xDB"
           "\x4D\xAA\xA2\xB4\xF9\x93\xAC\x4C\x0C\xE4\x5D\xDF\x79\x57\x3C\x8F"
           "\x42\x44\xEC\x0C\x09\xA9\xC6\xE8\xF9\xF0\x80\x2E\x76\x25\x2E\xC1"
           "\x72\x0E\x55\xD6\xB9\x78\x9A\xAE\x56\xFE\x8B\x35\x38\xAF\xE3\x80"
           "\x78\x57\x55\x15\xC9\xEC\xCC\xCB\x42\xC3\xC5\xDF\x8A\xAE\x67\xB0"
           "\xCD\x63\x8E\xFC\x28\x77\x7F\xD1\x31\xFD\x9D\xD2\x79\xC8\x0A\xE0"
           "\x1A\x86\x0D\xEB\x3B\xB4\x64\x49\xAA\x6B\x7B\x73\x27\xEC\x7D\x66"
           "\x6A\x4C\x37\xB3\xCD\x4E\x97\x97\x3C\xEF\x7E\x13\x45\x36\xAA\xFE"
           "\x2E\x16\x48\x90\x5F\x53\x63\x62\xC7\xAB\xC9\xC7\xB5\x9E\xFD\xA5"
           "\x8B\x0C\xCA\xD0\x1E\xBD\x51\x67\x98\x94\x63\x08\x13\xCC\x05\xB9"
           , 1152);
    nSKLen = 1152;
    memcpy(bInData,
           "\xAC\x05\xC4\xB0\x09\x39\x04\xF4\xA8\xD8\x4B\x58\xA9\x3A\x12\x95"
           "\x9E\x0F\x6A\x24\xC0\xD6\x04\x6F\xDD\x39\x57\x96\x17\x1E\x4F\x7D"
           "\x60\xEA\x20\x4F\xD3\x57\xBE\x8F\x67\x15\xDC\xAB\x4F\xE1\x6B\x53"
           "\x1C\xE8\x80\xFA\x3B\x34\x56\x47\x01\x10\x3B\x40\x69\x4E\x68\x70"
           "\x31\x07\x0C\x04\x7A\x2C\x48\xF8\xE1\xFA\x98\x43\x52\x53\xF2\xDA"
           "\x0B\x2E\x92\x17\xB5\xE8\xD7\xFF\xFF\xC9\x61\x7F\x4C\x6A\xF8\x6B"
           "\x7A\xAE\x20\x02\x81\x1A\x50\x86\xB1\x4E\x81\xAB\xE1\x00\xE3\x74"
           "\xED\x5C\xCD\x48\xC2\xE4\xFC\x01\xAF\x4B\x84\xDB\xC7\xE3\x5F\xEA"
           "\xEB\xA1\x91\xC5\x03\x52\xEC\x09\x4A\xE6\x36\x53\x07\x03\xED\xAD"
           "\x59\xAD\xDF\x51\x82\x88\x4E\xBB\xA0\x2A\x1F\x3A\xA1\x55\x20\xEF"
           "\xFA\x89\x7D\x08\x2F\xA4\x0D\x48\xCF\x0F\x83\x5C\x45\xEF\x5A\x97"
           "\x23\x8E\x0C\xC8\xAE\x2C\x14\x87\x51\xF6\x31\x66\x77\x80\x78\x73"
           "\x39\x86\xBD\x5B\xFF\x32\xF4\xB9\x13\x26\x73\x4B\xA1\xFD\x37\xD5"
           "\x6F\x44\x00\x6E\x30\xC3\x38\xA8\x0A\x3A\xF6\x7F\x57\x81\xD4\x3F"
           "\xC2\xD8\x0F\x77\x5E\xE9\x05\xD2\xD7\x37\xEA\xA3\x80\x25\xF7\x5F"
           "\xEC\x64\xC2\x5F\x4C\xD7\x36\x33"
           , 248);
    nInDataLen = 248;
    memset(bOutDataExp, 0x42, 124);
    bOutDataExp[0] = 0x30;
    bOutDataExp[123] = 0x39;
    nOutDataLenExp = 124;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 1152);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 248);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1984，OAEP填充，解密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 124);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 124);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 124);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_30(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 2;
    memcpy(bSK,
           "\xB6\xF8\xDC\x3E\x12\x98\x52\xB8\xB1\x84\xC0\x51\x97\xD1\xBE\x87"
           "\x70\x24\xD7\xE1\x4A\x71\xC3\x20\xA9\xEE\x78\x93\xF8\x99\x5C\x1A"
           "\xE5\x32\x78\x65\x85\x07\xEB\x5E\x26\x79\x2F\x1E\xE1\x6E\x6E\xB9"
           "\xF7\x6A\x23\x46\x09\x92\xD0\x54\xD2\xCA\x6C\xB6\xCE\xB0\x0B\x1C"
           "\x83\xD3\xEB\x1B\x6F\x47\x05\x82\xBF\x68\x23\x24\x90\xDD\xA0\x4C"
           "\xAD\x00\xC2\xD6\xBE\x7D\x8C\x5C\xBF\x1B\xF6\xE1\x73\x51\x9E\x6D"
           "\x62\x46\xBF\x62\xD5\xA6\xD6\x93\x17\x5D\xEE\xEF\x03\x82\x5E\x89"
           "\xA5\x42\xF3\x09\xB1\x20\x11\x48\x39\x90\x8A\xBD\xAA\xE3\xA8\x12"
           "\x4E\xD2\x36\x25\x16\x60\x73\x35\x44\x99\x56\xFE\xED\xF1\xC7\x48"
           "\x57\x57\x56\x27\x7C\x94\xC5\x2D\x6B\x77\xFB\xDC\x82\xD8\xD0\xE0"
           "\x2D\x0E\x4D\x64\x5B\x98\x07\x49\x8A\x29\x70\xD9\xDE\xA9\x44\xC5"
           "\xDE\x71\xCE\xF5\xE0\x63\x40\x28\xF4\xD6\x6D\x86\x14\xCF\x70\x24"
           "\x5B\x05\xAE\xC7\xE9\x69\x7B\x42\xAB\xF6\x53\xA3\x97\x1C\x93\x61"
           "\xCE\x7E\x8F\x38\xF1\x85\xC6\xB8\x2C\x6F\x11\x3E\xA6\xF1\x18\xF8"
           "\x85\xAD\xF2\xE3\x32\x82\x51\x0D\xEB\x12\x68\xC0\x1B\xCD\xF2\x3A"
           "\xB5\x55\xCD\x1A\x92\x9D\x31\xDF\xA6\xB2\x7A\xEE\x99\xA1\x39\x62"
           "\xC9\xE5\xFD\x47\xD0\x37\xCE\x6C\x08\x33\x31\x58\x38\x7B\x3F\x77"
           "\xFF\x4B\x01\xFC\x24\x58\x33\x24\xEB\xA6\xE2\xEE\x33\x1B\x67\x52"
           "\x81\x19\x16\x3A\xFA\x23\x82\x1B\x61\xEE\x5B\xDD\x08\x83\xA4\x5D"
           "\xCC\x57\x5A\xBF\xA5\x5C\x6E\xD7\xB0\xA2\xB6\x73\x52\x92\x9E\x5C"
           "\x46\x8D\x3E\xFB\x15\x1C\xB2\x7E\xD0\x90\x09\x61\x4F\x98\xFF\xEE"
           "\x8C\x40\x99\x83\x62\x1C\x2A\x29\xA9\x35\x58\x08\xF7\x97\xE6\xC7"
           "\x74\x50\xC9\x7D\xBF\xA2\x61\x51\x57\xD2\xDB\xDD\xE7\x19\xEF\x75"
           "\x26\xC0\x48\x56\xD9\x38\xFC\xF6\xF1\xEC\x6E\x96\x72\xCE\x2F\x19"
           "\xCA\x17\x76\x25\xFA\xDB\x0A\xBF\x4E\xD3\x6F\x65\xE2\xA3\x53\x9F"
           "\x0F\x91\xCF\xA8\x32\x9D\x83\xF1\x62\x54\xA3\x3E\x89\xF9\xD3\x20"
           "\xE8\x10\xE5\xE8\x6A\x73\x40\x90\x9A\x9D\x21\xD0\x9E\xEE\xFA\x44"
           "\x29\x42\x36\x61\xF0\x89\x9E\xE2\xFA\xBE\x06\x74\x7A\xAC\x2A\xF6"
           "\xA6\xFE\xE0\x7E\x17\x7C\xDA\xA7\x4B\xA3\x33\xD0\x66\x40\x56\x07"
           "\xB5\x21\x1A\x1E\x17\x3B\x43\x62\x9C\x0D\x16\xFA\xF3\x09\x93\x99"
           "\x56\x6C\xFD\x6A\xB7\x64\x04\x77\x33\x61\x13\x13\xD0\x93\x30\xD7"
           "\x78\xAE\xD3\x91\x30\xC2\x2C\x81\x39\x88\x9F\xE3\x9B\x4F\xF0\xC8"
           "\xFF\xA0\xA7\xED\x5F\xC3\xD7\xFE\x9C\xA7\x85\x7D\x1E\x7E\xA6\x7C"
           "\xD7\x6C\xEF\x3A\xAD\xE2\xFE\x2E\xAD\x45\x17\x9E\xC8\xA9\x71\xAB"
           "\xBF\xB6\xE3\x16\xEC\x4B\xF5\xA7\x9D\x20\x72\x87\xB4\x7E\x80\x89"
           "\xD6\xEF\x8C\xEA\x5D\xD5\xD2\x26\x9B\x3E\x58\x2C\xEB\xE6\x07\x1A"
           "\x05\x01\xD6\xBB\xFB\xA4\x2C\x31\x7A\xC0\x03\xB2\x14\x3D\x95\x41"
           "\xB5\xE3\x35\xA8\x86\xCF\x8C\x68\xFE\x01\x75\x0F\x3B\x77\x56\xA2"
           "\xCF\x29\x24\xFE\x99\x37\x02\x75\x65\x0E\xD6\xD2\x82\x9A\x93\x74"
           "\xAD\xBE\x1E\x56\x13\xC4\x29\x53\x35\x57\x4B\x46\x22\x4B\xB8\x50"
           "\x53\x71\x44\x27\xA8\xBC\x5B\x31\x0A\x32\xD4\x0F\xFF\xB2\x32\x5F"
           "\x39\xCD\xB1\x90\x77\x70\x23\xF9\xF4\x85\xDA\xE9\x16\x9D\xD5\xA0"
           "\x2A\x71\xF9\xF4\x40\x7D\xD1\x24\x5D\xBF\x93\xB3\x7F\x0D\x95\x67"
           "\x19\x51\x18\xA0\x99\x7A\x84\x44\x71\x9A\x08\x0D\x98\x25\x2E\xA6"
           "\x55\x6B\xEC\xA9\xA0\x72\xA4\xEF\x41\xC4\x20\x67\xA8\x86\xC9\x82"
           "\x86\xE8\x58\x5B\xA6\x8B\xCB\x30\xED\xF7\x7B\x0E\x6A\x6F\x6C\x39"
           "\x7A\x48\xA8\xE1\x9C\xEE\xC5\xDF\x08\x4B\xC9\x0A\x5D\xA0\x34\x42"
           "\xB5\x79\x5C\x29\xAF\xA9\xF8\x84\x31\xBE\x94\x21\x29\x17\x82\x99"
           "\x81\xB4\x9E\x2B\xC9\x78\xC5\xA6\x25\xD7\x28\xEE\x3A\xD2\x3B\xD8"
           "\x05\xCE\xEA\x07\x92\xD4\x8B\x4D\x64\xB4\x7F\x57\x9D\x2A\xFB\x80"
           "\xFF\x16\x09\xE2\x9A\xAC\x7E\x32\x2D\x2B\xE7\xA2\x9F\x9F\x63\xAF"
           "\x59\x62\xC6\x8D\x51\xD9\x2F\x6B\xF2\xB8\xEA\x9B\xAE\x30\x7A\xBB"
           "\x76\xC7\xDE\xB7\xF8\xF0\x33\x2E\x69\x65\xC0\x89\x2B\x82\x72\xAE"
           "\x8B\x65\x53\xEF\x96\xA4\xCC\xE6\xAB\x80\x9D\x23\x51\xCB\x77\x5B"
           "\xAB\x75\x5A\x70\x7B\x9C\xBE\xD6\x44\xCD\x0A\x3A\x1C\xF8\xD7\xC8"
           "\x9E\x68\x2B\xA2\xB6\x30\xC4\xE7\x3A\xF2\xDA\xE4\x15\xDE\x80\xD5"
           "\x03\xF6\x06\x3E\x19\x0B\x09\xF5\xE1\xED\xE9\x82\x79\x02\xD7\x21"
           "\x5C\x71\xFE\x15\xCB\xB5\x85\xB1\x12\x75\xF2\x94\xFC\xB7\x24\x14"
           "\xFF\xDE\xA6\x49\x7D\x61\xF8\xAE\x83\x40\x97\xC6\x13\x8F\xD6\xE2"
           "\xDA\xE8\x9D\x66\x71\x4A\x22\x1F\xF9\x55\x79\xAA\xE0\xE6\xD7\x29"
           "\x3D\x44\x2E\xC0\xB9\x4D\x64\x65\x2A\x0E\x4A\xB8\x62\xC1\x84\x2E"
           "\x3F\x6F\xEB\x79\xDF\xCF\xAA\x83\xB9\x7C\x73\x7E\x48\x88\x44\x03"
           "\xEA\x4F\x09\xCD\x72\x37\xA7\x49\x37\x6E\x52\x57\xFC\x64\x17\xE5"
           "\x9E\x36\x4D\xD7\x33\x82\xA5\x42\x3F\x37\x96\xE9\x00\x70\x91\x7E"
           "\x1F\xFF\xCD\xD3\x39\xD8\x27\x8F\x67\x81\x51\xF8\x03\xB5\x3A\xB9"
           "\x57\x64\x16\xBF\x7F\x0C\xD6\x74\xE7\x37\xB2\xFD\xF4\x20\x1B\x4C"
           "\xFD\xFC\x5C\xEF\x78\x30\x05\x38\xD7\x51\xE8\xD3\x16\x0A\x7D\x8C"
           "\xBA\x84\x9D\x1F\xF5\x6F\xE7\x15\x41\x1D\x3E\x40\x4D\x98\x64\x46"
           "\x43\x35\xA6\xBB\x0B\x0D\xF3\x39\x1D\xF9\x2B\x8C\x8E\xBD\x43\x9B"
           "\x39\x39\x10\x04\x06\x0B\x31\x7C\xF0\x1E\xE1\x70\xB1\x55\xD1\x59"
           "\xBE\x38\x24\xC8\x3E\x53\x30\xF7\x0F\xCE\x37\xCD\x5C\xF7\x90\x33"
           "\x85\x7F\x4D\x02\xAB\xEA\x50\x12\x18\xF3\x6E\x56\xA8\xEE\x38\x08"
           "\x8F\x94\x95\xAE\xE3\x74\x54\xCF\x0B\x88\x16\x7D\x2E\xBA\xAB\xCE"
           "\xCD\x7B\xA5\x62\x51\x84\x6A\x30\x0E\xF6\x44\x6C\x62\xDB\x9B\x21"
           "\xCA\x09\x0C\xBD\xE5\x09\x1C\xFA\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78"
           , 1200);
    nSKLen = 1200;
    memcpy(bInData,
           "\x40\x7F\x44\x0E\xCC\xC6\x69\x74\x0D\x12\x43\x29\xF1\xDE\x4D\xCC"
           "\x9C\x69\xBF\xC4\x3D\x38\x4F\xD8\x27\xFF\x24\x0C\x7B\x69\x08\x86"
           "\x50\xFA\x35\x62\xE5\xAF\x14\x62\xAE\x1C\x82\xCE\xAA\x78\x95\x22"
           "\xB0\x34\x88\xBE\x0A\xD6\x1D\x0D\x2C\x9B\x20\x02\x45\x33\xB0\xC5"
           "\xB5\x2E\xD0\x16\x4E\x90\x46\xE9\xB6\x0A\xEF\x0E\x2E\x0F\x99\x14"
           "\x6B\xA1\x7C\xC3\xE8\xFD\xD2\xF2\xE2\x78\x21\xA3\xEB\xAA\xAA\x9C"
           "\x30\x64\x1F\x5D\x56\x8A\x23\x6B\x2A\x0A\x85\x43\x92\x18\x8F\x68"
           "\xF1\x64\xEC\xD9\x9B\x10\xBC\x84\xBB\x0C\x21\xCA\xE0\xC0\x51\x9C"
           "\x3A\xD3\x13\x2C\x50\xED\x0F\xD1\x04\x48\x9D\x66\x4E\x06\x2C\x5D"
           "\x11\x02\xDF\x20\xDF\xE0\x06\xDB\xB4\xE8\x11\x66\x93\xE7\x70\xFE"
           "\x1F\x22\x1F\x7F\xA8\x87\x81\x93\x95\xD4\x83\x82\xC3\xA2\x71\x5C"
           "\x9A\xC3\x7C\x5B\x0D\xE9\x39\x93\x7A\x5D\xF4\xC9\x48\x02\xD2\x41"
           "\xC4\xCA\xC6\x69\xD9\x06\x06\x0B\x9C\xFB\x8A\xFF\xFA\xCA\x1E\x04"
           "\x6F\x34\x25\xAE\x41\xE2\x2E\xE5\x45\x24\xE7\x85\xF4\xE8\xAD\xAE"
           "\xDF\xEE\xCE\x52\x39\xF2\xF3\x96\x74\x76\x93\xCF\x92\xC0\x3F\x00"
           "\x5E\x50\x23\x19\xAE\xA5\xB2\x0D\x47\x3E\x66\x48\x95\x9C\xF5\xDB"
           , 256);
    nInDataLen = 256;
    memset(bOutDataExp, 0x42, 1);
    nOutDataLenExp = 1;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 1200);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 256);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-2048，OAEP填充，解密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 1);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 1);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 1);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_31(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nSock = -1;
    nFlag = 1;
    nPadMode = 0;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    memset(bInData, 0x42, 64);
    bInData[0] = 0x30;
    bInData[63] = 0x39;
    nInDataLen = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 320);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 64);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_32(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nSock = 8;
    nFlag = 1;
    nPadMode = 0;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    memset(bInData, 0x42, 64);
    bInData[0] = 0x30;
    bInData[63] = 0x39;
    nInDataLen = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 320);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 64);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[8]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_33(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = -1;
    nPadMode = 0;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    memset(bInData, 0x42, 64);
    bInData[0] = 0x30;
    bInData[63] = 0x39;
    nInDataLen = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 320);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 64);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效加解密标志[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_34(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 2;
    nPadMode = 0;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    memset(bInData, 0x42, 64);
    bInData[0] = 0x30;
    bInData[63] = 0x39;
    nInDataLen = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 320);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 64);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效加解密标志[2]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_35(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = -1;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    memset(bInData, 0x42, 64);
    bInData[0] = 0x30;
    bInData[63] = 0x39;
    nInDataLen = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 320);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 64);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效填充模式[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_36(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 3;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    memset(bInData, 0x42, 64);
    bInData[0] = 0x30;
    bInData[63] = 0x39;
    nInDataLen = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 320);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 64);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效填充模式[3]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_37(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 0;
    nSKLen = 0;
    memset(bInData, 0x42, 64);
    bInData[0] = 0x30;
    bInData[63] = 0x39;
    nInDataLen = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 0);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 64);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效私钥长度=0测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_38(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 0;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    nInDataLen = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 320);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 0);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无填充，无效数据长度=0，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_39(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 0;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    memset(bInData, 0x42, 63);
    bInData[0] = 0x30;
    bInData[62] = 0x39;
    nInDataLen = 63;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 320);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 63);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无填充，无效数据长度=63，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_40(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 0;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    memset(bInData, 0x42, 65);
    bInData[0] = 0x30;
    bInData[64] = 0x39;
    nInDataLen = 65;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 320);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 65);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无填充，无效数据长度=65，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_41(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 0;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    memset(bInData, 0x42, 72);
    bInData[0] = 0x30;
    bInData[71] = 0x39;
    nInDataLen = 72;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 320);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 72);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无填充，无效数据长度=72，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_42(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 1;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    nInDataLen = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 320);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 0);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "PKCS#1填充，无效数据长度=0，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_43(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 1;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    memset(bInData, 0x42, 54);
    bInData[0] = 0x30;
    bInData[53] = 0x39;
    nInDataLen = 54;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 320);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 54);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "PKCS#1填充，无效数据长度=54，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_44(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 1;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    memset(bInData, 0x42, 64);
    bInData[0] = 0x30;
    bInData[63] = 0x39;
    nInDataLen = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 320);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 64);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "PKCS#1填充，无效数据长度=64，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_45(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 0;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    nInDataLen = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 320);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 0);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "解密，无填充，无效数据长度=0，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_46(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 0;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    memset(bInData, 0x42, 63);
    bInData[0] = 0x30;
    bInData[62] = 0x39;
    nInDataLen = 63;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 320);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 63);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "解密，无填充，无效数据长度=63，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_47(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 1;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    nInDataLen = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 320);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 0);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "解密，PKCS#1填充，无效数据长度=0，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_48(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 1;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    memset(bInData, 0x42, 63);
    bInData[0] = 0x30;
    bInData[62] = 0x39;
    nInDataLen = 63;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 320);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 63);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "解密，PKCS#1填充，无效数据长度=63，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_49(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 2;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    nInDataLen = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 320);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 0);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "解密，OAEP填充，无效数据长度=0，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateCalc_Test_50(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 2;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    memset(bInData, 0x42, 63);
    bInData[0] = 0x30;
    bInData[62] = 0x39;
    nInDataLen = 63;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 320);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 63);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "解密，OAEP填充，无效数据长度=63，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 0;
    nPadMode = 1;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    memset(bData, 0x42, 1);
    nDataLen = 1;
    memcpy(bSignExp,
           "\x6A\xCC\xF7\x0F\x1B\xD2\x9B\xF3\x06\xEE\xE5\x23\x4D\x02\x5C\x47"
           "\x60\x8E\x88\xFA\x20\x57\x36\x31\x51\xA3\x83\x71\x23\x16\x0C\xEF"
           "\xA5\x53\xB0\xE9\xD7\xD4\xAB\xBA\xD7\xE0\xB4\xD5\x1A\x04\x45\xD4"
           "\x1A\xE1\xF2\x28\xE8\x78\xD3\xA6\xD7\x5E\x54\x46\x35\x81\xEB\x91"
           , 64);
    nSignLenExp = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 320);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 1);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-512，MD5，PKCS#1填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bSign    =", bSign, 64);
    DspHex("[OUT]bSignExp =", bSignExp, 64);
    ASSERT_OUT_HEX(bSign, bSignExp, 64);
    ASSERT_OUT(nSignLen, nSignLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 1;
    nPadMode = 1;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    memset(bData, 0x42, 64);
    bData[0] = 0x30;
    bData[63] = 0x39;
    nDataLen = 64;
    memcpy(bSignExp,
           "\x9B\xD4\xE1\x2E\x47\x40\x76\x3F\xAD\x3E\x39\xBC\xCF\xE9\xC3\xC0"
           "\xFF\x2F\x2D\x59\x96\x49\x68\x27\x82\x59\x3A\x51\x9B\xCF\x43\x8B"
           "\x96\xEF\xF0\x47\x80\xBB\x2A\x66\x58\x17\x72\x28\x62\xB3\xFB\xF9"
           "\x9B\x8C\x3C\x62\x24\xB0\xA9\xA6\xF8\x1C\x5E\xE0\xC0\x03\x8D\x88"
           , 64);
    nSignLenExp = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 320);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 64);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-512，SHA-1，PKCS#1填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bSign    =", bSign, 64);
    DspHex("[OUT]bSignExp =", bSignExp, 64);
    ASSERT_OUT_HEX(bSign, bSignExp, 64);
    ASSERT_OUT(nSignLen, nSignLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 2;
    nPadMode = 1;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    memset(bData, 0x42, 64);
    bData[0] = 0x30;
    bData[63] = 0x39;
    nDataLen = 64;
    memcpy(bSignExp,
           "\x0C\x6D\xDB\xB2\xC0\xC6\x66\x85\x2F\xD7\x3C\xD1\x76\xF5\x4E\xFB"
           "\x22\xF4\xB7\xEA\x3C\xAF\xD0\xFB\xAF\x7C\x27\xA4\xC6\x2E\x1A\x77"
           "\x68\x4A\x37\x43\x84\xCB\xD4\xE6\x80\x71\x00\x4D\x13\xEC\xCF\xB4"
           "\x29\x05\xEA\x03\x7C\xB2\x5C\xC3\xF2\x72\x63\xBC\xD9\x55\xDB\x37"
           , 64);
    nSignLenExp = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 320);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 64);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-512，SHA-224，PKCS#1填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bSign    =", bSign, 64);
    DspHex("[OUT]bSignExp =", bSignExp, 64);
    ASSERT_OUT_HEX(bSign, bSignExp, 64);
    ASSERT_OUT(nSignLen, nSignLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 3;
    nPadMode = 1;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    memset(bData, 0x42, 64);
    bData[0] = 0x30;
    bData[63] = 0x39;
    nDataLen = 64;
    memcpy(bSignExp,
           "\x56\x97\xCD\xB6\x93\xE6\x99\x84\x86\x42\xEF\x3A\xA9\x4F\x40\x1D"
           "\xB0\xA9\x7F\xD4\x8F\x1A\x5A\xF8\x79\x8A\x17\x2E\x93\xC7\x5E\x96"
           "\x68\x3D\x6C\x67\xD6\x5A\x53\x9D\x15\xF6\xF9\x2D\x26\x82\xCC\x3D"
           "\x9D\x9B\x88\xFA\xE4\x8F\xE5\x8C\xB6\xD8\xCF\xBE\x66\x8E\x68\x2C"
           , 64);
    nSignLenExp = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 320);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 64);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-512，SHA-256，PKCS#1填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bSign    =", bSign, 64);
    DspHex("[OUT]bSignExp =", bSignExp, 64);
    ASSERT_OUT_HEX(bSign, bSignExp, 64);
    ASSERT_OUT(nSignLen, nSignLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 4;
    nPadMode = 1;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    memset(bData, 0x42, 64);
    bData[0] = 0x30;
    bData[63] = 0x39;
    nDataLen = 64;
    memcpy(bSignExp,
           "\x4C\x0E\x30\x56\xF4\x2D\xF8\x2D\x97\xCF\xE4\x9D\xB1\x05\xE6\x10"
           "\x2C\xD5\x4F\x78\xE0\xF6\x56\x9F\x4B\x57\x86\x46\x80\xF8\x9E\xBF"
           "\x68\x4C\x8A\xDF\xA4\x87\xE6\x8D\x79\xCF\x38\xB8\x0A\xD0\xEB\xB2"
           "\x8D\xB1\x64\xAE\xCC\x51\x9F\xFD\x0B\x1D\x95\xCA\x45\x7B\xE2\xA7"
           , 64);
    nSignLenExp = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 320);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 64);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-512，SHA-384，PKCS#1填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bSign    =", bSign, 64);
    DspHex("[OUT]bSignExp =", bSignExp, 64);
    ASSERT_OUT_HEX(bSign, bSignExp, 64);
    ASSERT_OUT(nSignLen, nSignLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 5;
    nPadMode = 1;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    memset(bData, 0x42, 2048);
    bData[0] = 0x30;
    bData[2047] = 0x39;
    nDataLen = 2048;
    memset(bSign, 0, 512);
    nSignLen = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 320);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 2048);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "RSA-512，SHA-512，PKCS#1填充，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_07(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 0;
    nPadMode = 1;
    memcpy(bSK,
           "\x3B\xD4\x50\x5C\x7E\x86\x10\xCE\x25\x5C\xB9\x39\xC2\xD4\x61\x5C"
           "\x7F\xC2\xC4\x74\xE5\x22\x06\xCD\x50\x53\xAF\x84\x02\xF7\xE6\x54"
           "\x85\x44\x18\x4D\xE9\x05\x89\xF5\x5D\x0E\xC0\x55\x6A\xD2\x53\xA5"
           "\x36\x71\x2D\xD5\xFD\xEA\x8A\x45\x4C\xC6\x00\x3B\xE7\x01\x70\x1C"
           "\xEC\xA6\xD1\xF4\x7D\xF0\xD5\xF5\xB6\x5A\x00\x43\xBC\xF0\x6A\x79"
           "\xFF\xD3\x30\xB8\x5F\xFA\xEA\xE0\xD1\x9E\x6C\x02\xAE\x9A\x13\xF0"
           "\x09\xED\xB1\x9C\x0A\xBE\xA9\xB7\x93\x66\xBB\x08\xC6\x0A\xA2\xFD"
           "\xFE\x19\xBF\x9E\x9E\x7C\x1C\xCF\xBB\xF6\x3F\x4D\x1A\x35\xF9\x26"
           "\x2A\xF4\x84\x29\x43\x79\xE7\x3D\x9B\x58\xF9\x30\xE1\x27\x3B\xC0"
           "\xD7\xE7\xEF\xF8\x52\x50\x2C\x85\x65\x1B\x1C\x3D\x2D\xA9\x73\x8F"
           "\xCA\x54\xF3\x60\xE4\x84\x67\xAC\xEB\xAA\x24\x30\xC9\x98\x9D\x4B"
           "\x2E\xF3\xD7\xE1\x93\xCA\xC0\x63\x3F\xD1\xE4\xAF\x08\x37\x63\xB5"
           "\x8A\xDB\x3E\x66\x44\x4E\x01\x7F\x75\x92\xB4\x5D\x79\x6C\x94\x9B"
           "\x4C\x55\x2F\x9A\x26\xD9\x54\x65\x67\x41\x4A\xAC\x1F\x7C\x4A\xFE"
           "\x1E\xDD\xDD\xE1\x51\x3A\xB2\xE2\x92\xFA\x3F\x8D\xFF\xEE\x78\x0A"
           "\xBB\xFB\xD6\x94\xE3\x39\x48\xF8\xF1\xC0\x3A\x36\xF4\x65\xF6\xB9"
           "\x2A\x2C\xEE\x71\x11\xAA\x7B\x55\xBF\x9D\x13\x0F\x74\x47\x05\x87"
           "\x27\xF0\x9F\x65\x6E\xED\xAF\x2B\x78\x69\xFE\x3A\x40\xA3\xDB\x58"
           "\xCC\x5C\x83\xC5\x0E\x9B\xF3\xB5\x8B\x6D\xA8\xBE\x0C\x5E\x38\x2A"
           "\x12\x8C\x3E\x40\xA1\x03\x43\x20\x6B\x4B\x3D\x65\x8C\x96\x13\x5F"
           "\x58\x56\x87\x88\x20\x0A\x12\xD8\x42\x95\x55\x5D\xDD\x74\x23\xF3"
           "\x05\x77\x04\x02\xBC\x97\x6E\xED\xEB\x33\x10\x4B\x8C\x58\x0C\xDF"
           "\x9A\x54\xCD\xB9\x69\xAA\x0B\x15\x13\x8B\x95\x87\x55\xFC\x05\x0A"
           "\x81\x5E\x00\x9D\x50\x9D\x7D\x73\x94\x6B\x78\x30\x40\xC7\xF4\x89"
           "\x76\x9F\x1D\x3B\x69\xAE\x65\x5C\xF5\xAB\xF8\xC0\x33\x0F\xA3\x02"
           "\xA4\x41\x96\x86\x47\x75\x2F\x3B\xC4\x3D\xE8\x5A\x88\xAB\xB9\x74"
           "\xB9\x8F\xA7\xDC\xBE\x35\xE0\xA1\x31\xA1\xEE\xAC\xD3\x01\x97\x67"
           "\x65\x1D\x81\x74\x38\x11\xEF\xC5\x0F\xDD\x6B\x70\x98\xF8\xDC\x91"
           "\xFA\x20\xDD\x34\x9F\xB4\xB2\x09\x6B\x90\xD7\x81\xBA\xD4\x34\xEA"
           "\x24\x83\x49\x86\x3C\xDF\x51\x98\xDB\xA2\x68\x53\xC3\x41\x47\x3B"
           "\x70\x13\x1B\xC7\xB1\x4B\x64\xD3\xD1\x46\xF6\x97\x04\x65\x8C\x24"
           "\x13\xD0\xE5\x85\x7D\xBF\x31\x3A\xB5\x49\x14\xF1\x3F\xFA\xB5\xC1"
           "\x47\x61\x69\x76\x6E\xD2\x9D\x84\xA0\x88\xD6\x65\x35\x6E\xD4\xEB"
           "\x57\x1D\x9F\xF5\xB5\x10\x5D\x12\x05\xA1\xF2\x5A\x37\x4D\x9A\x65"
           "\xBA\xE8\x69\x9B\x02\x93\xAD\x7A\x84\xB0\x6E\xF2\xB6\xB3\x86\x11"
           "\x8F\xF8\xB2\x23\x4E\xD4\x33\x74\x9C\xB4\x91\xD8\x57\x01\x18\x14"
           "\x8A\x63\x13\xFB\x17\x1B\x91\x0E\x35\x71\xD2\x0A\x73\xCD\x99\xA9"
           "\x5C\x10\xD3\xDE\x93\xF4\x5A\x63\xCB\x08\x1E\x8F\x38\x0E\x1A\xB1"
           "\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78"
           , 616);
    nSKLen = 616;
    memset(bData, 0x42, 1);
    nDataLen = 1;
    memcpy(bSignExp,
           "\x13\x90\x6D\x9D\x0C\x56\x96\x26\x88\xD3\xAB\x51\x91\x8B\x03\x7B"
           "\x26\xB2\x3D\x15\x99\x04\x41\xC0\xBB\x25\x4E\x99\x5C\xBA\xF0\xD3"
           "\xF5\x67\xEB\x26\xBB\x40\x79\xCC\x53\xE4\xD6\xAB\xC9\x5D\x6A\x77"
           "\xB8\x65\xC9\xFF\xB0\xE0\x7A\xBB\x83\xB7\x9F\x0C\x2B\xB1\x28\x45"
           "\x30\xAC\x49\xE3\x4C\x8A\xF9\x82\x73\xD1\xC0\x87\x18\x38\xEC\x43"
           "\x27\x3F\xC1\x3C\x70\x23\xC1\x4C\xB6\x5B\x9F\x9E\xDE\x2A\x0A\x1B"
           "\x58\x27\x9D\xA3\x9B\x61\x56\xB3\x87\x1D\xF9\x1A\x11\xCD\x06\x40"
           "\xB6\x2D\x64\x9D\x4F\x2A\x23\x1B\x14\x09\x9D\x65\xF3\x87\xCB\x50"
           , 128);
    nSignLenExp = 128;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 616);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 1);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1024，MD5，PKCS#1填充，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bSign    =", bSign, 128);
    DspHex("[OUT]bSignExp =", bSignExp, 128);
    ASSERT_OUT_HEX(bSign, bSignExp, 128);
    ASSERT_OUT(nSignLen, nSignLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_08(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 1;
    nPadMode = 1;
    memcpy(bSK,
           "\x3B\xD4\x50\x5C\x7E\x86\x10\xCE\x25\x5C\xB9\x39\xC2\xD4\x61\x5C"
           "\x7F\xC2\xC4\x74\xE5\x22\x06\xCD\x50\x53\xAF\x84\x02\xF7\xE6\x54"
           "\x85\x44\x18\x4D\xE9\x05\x89\xF5\x5D\x0E\xC0\x55\x6A\xD2\x53\xA5"
           "\x36\x71\x2D\xD5\xFD\xEA\x8A\x45\x4C\xC6\x00\x3B\xE7\x01\x70\x1C"
           "\xEC\xA6\xD1\xF4\x7D\xF0\xD5\xF5\xB6\x5A\x00\x43\xBC\xF0\x6A\x79"
           "\xFF\xD3\x30\xB8\x5F\xFA\xEA\xE0\xD1\x9E\x6C\x02\xAE\x9A\x13\xF0"
           "\x09\xED\xB1\x9C\x0A\xBE\xA9\xB7\x93\x66\xBB\x08\xC6\x0A\xA2\xFD"
           "\xFE\x19\xBF\x9E\x9E\x7C\x1C\xCF\xBB\xF6\x3F\x4D\x1A\x35\xF9\x26"
           "\x2A\xF4\x84\x29\x43\x79\xE7\x3D\x9B\x58\xF9\x30\xE1\x27\x3B\xC0"
           "\xD7\xE7\xEF\xF8\x52\x50\x2C\x85\x65\x1B\x1C\x3D\x2D\xA9\x73\x8F"
           "\xCA\x54\xF3\x60\xE4\x84\x67\xAC\xEB\xAA\x24\x30\xC9\x98\x9D\x4B"
           "\x2E\xF3\xD7\xE1\x93\xCA\xC0\x63\x3F\xD1\xE4\xAF\x08\x37\x63\xB5"
           "\x8A\xDB\x3E\x66\x44\x4E\x01\x7F\x75\x92\xB4\x5D\x79\x6C\x94\x9B"
           "\x4C\x55\x2F\x9A\x26\xD9\x54\x65\x67\x41\x4A\xAC\x1F\x7C\x4A\xFE"
           "\x1E\xDD\xDD\xE1\x51\x3A\xB2\xE2\x92\xFA\x3F\x8D\xFF\xEE\x78\x0A"
           "\xBB\xFB\xD6\x94\xE3\x39\x48\xF8\xF1\xC0\x3A\x36\xF4\x65\xF6\xB9"
           "\x2A\x2C\xEE\x71\x11\xAA\x7B\x55\xBF\x9D\x13\x0F\x74\x47\x05\x87"
           "\x27\xF0\x9F\x65\x6E\xED\xAF\x2B\x78\x69\xFE\x3A\x40\xA3\xDB\x58"
           "\xCC\x5C\x83\xC5\x0E\x9B\xF3\xB5\x8B\x6D\xA8\xBE\x0C\x5E\x38\x2A"
           "\x12\x8C\x3E\x40\xA1\x03\x43\x20\x6B\x4B\x3D\x65\x8C\x96\x13\x5F"
           "\x58\x56\x87\x88\x20\x0A\x12\xD8\x42\x95\x55\x5D\xDD\x74\x23\xF3"
           "\x05\x77\x04\x02\xBC\x97\x6E\xED\xEB\x33\x10\x4B\x8C\x58\x0C\xDF"
           "\x9A\x54\xCD\xB9\x69\xAA\x0B\x15\x13\x8B\x95\x87\x55\xFC\x05\x0A"
           "\x81\x5E\x00\x9D\x50\x9D\x7D\x73\x94\x6B\x78\x30\x40\xC7\xF4\x89"
           "\x76\x9F\x1D\x3B\x69\xAE\x65\x5C\xF5\xAB\xF8\xC0\x33\x0F\xA3\x02"
           "\xA4\x41\x96\x86\x47\x75\x2F\x3B\xC4\x3D\xE8\x5A\x88\xAB\xB9\x74"
           "\xB9\x8F\xA7\xDC\xBE\x35\xE0\xA1\x31\xA1\xEE\xAC\xD3\x01\x97\x67"
           "\x65\x1D\x81\x74\x38\x11\xEF\xC5\x0F\xDD\x6B\x70\x98\xF8\xDC\x91"
           "\xFA\x20\xDD\x34\x9F\xB4\xB2\x09\x6B\x90\xD7\x81\xBA\xD4\x34\xEA"
           "\x24\x83\x49\x86\x3C\xDF\x51\x98\xDB\xA2\x68\x53\xC3\x41\x47\x3B"
           "\x70\x13\x1B\xC7\xB1\x4B\x64\xD3\xD1\x46\xF6\x97\x04\x65\x8C\x24"
           "\x13\xD0\xE5\x85\x7D\xBF\x31\x3A\xB5\x49\x14\xF1\x3F\xFA\xB5\xC1"
           "\x47\x61\x69\x76\x6E\xD2\x9D\x84\xA0\x88\xD6\x65\x35\x6E\xD4\xEB"
           "\x57\x1D\x9F\xF5\xB5\x10\x5D\x12\x05\xA1\xF2\x5A\x37\x4D\x9A\x65"
           "\xBA\xE8\x69\x9B\x02\x93\xAD\x7A\x84\xB0\x6E\xF2\xB6\xB3\x86\x11"
           "\x8F\xF8\xB2\x23\x4E\xD4\x33\x74\x9C\xB4\x91\xD8\x57\x01\x18\x14"
           "\x8A\x63\x13\xFB\x17\x1B\x91\x0E\x35\x71\xD2\x0A\x73\xCD\x99\xA9"
           "\x5C\x10\xD3\xDE\x93\xF4\x5A\x63\xCB\x08\x1E\x8F\x38\x0E\x1A\xB1"
           "\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78"
           , 616);
    nSKLen = 616;
    memset(bData, 0x42, 128);
    bData[0] = 0x30;
    bData[127] = 0x39;
    nDataLen = 128;
    memcpy(bSignExp,
           "\x4F\x6C\xBD\x21\x5B\xB0\xCE\x16\xB7\x59\x43\x14\x2B\x05\x5F\xB6"
           "\x01\x99\xE1\x83\x8F\x46\xA3\x4E\x38\x4A\xFA\xC9\xB5\xC5\x03\xB0"
           "\x8D\xC6\xEE\x18\x68\x9A\xCF\x54\x69\x11\x0C\xA6\x98\xA3\xDF\xBD"
           "\x1C\x28\x7A\xD7\xB0\xF5\xE2\x68\x97\xCB\xF3\xFA\x99\x28\x20\xD7"
           "\x2F\x04\x83\x16\xC6\xC6\x7C\xBE\x71\xF6\x99\x4D\xF7\x82\x7E\x1A"
           "\xB7\xDD\xA2\xAD\x9B\xB3\xC2\xDB\x9B\x1B\x42\x47\xC1\xB8\x6E\x6C"
           "\xE0\x1C\x77\x62\xCE\xB3\xBA\xDD\xB6\x9F\x55\xB6\x81\xB0\xAA\xEE"
           "\x69\x77\x8D\xB5\x8E\x0A\x75\x3B\x2F\x8B\x21\x6A\xEF\xCC\x46\xCD"
           , 128);
    nSignLenExp = 128;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 616);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 128);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1024，SHA-1，PKCS#1填充，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bSign    =", bSign, 128);
    DspHex("[OUT]bSignExp =", bSignExp, 128);
    ASSERT_OUT_HEX(bSign, bSignExp, 128);
    ASSERT_OUT(nSignLen, nSignLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_09(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 2;
    nPadMode = 1;
    memcpy(bSK,
           "\x3B\xD4\x50\x5C\x7E\x86\x10\xCE\x25\x5C\xB9\x39\xC2\xD4\x61\x5C"
           "\x7F\xC2\xC4\x74\xE5\x22\x06\xCD\x50\x53\xAF\x84\x02\xF7\xE6\x54"
           "\x85\x44\x18\x4D\xE9\x05\x89\xF5\x5D\x0E\xC0\x55\x6A\xD2\x53\xA5"
           "\x36\x71\x2D\xD5\xFD\xEA\x8A\x45\x4C\xC6\x00\x3B\xE7\x01\x70\x1C"
           "\xEC\xA6\xD1\xF4\x7D\xF0\xD5\xF5\xB6\x5A\x00\x43\xBC\xF0\x6A\x79"
           "\xFF\xD3\x30\xB8\x5F\xFA\xEA\xE0\xD1\x9E\x6C\x02\xAE\x9A\x13\xF0"
           "\x09\xED\xB1\x9C\x0A\xBE\xA9\xB7\x93\x66\xBB\x08\xC6\x0A\xA2\xFD"
           "\xFE\x19\xBF\x9E\x9E\x7C\x1C\xCF\xBB\xF6\x3F\x4D\x1A\x35\xF9\x26"
           "\x2A\xF4\x84\x29\x43\x79\xE7\x3D\x9B\x58\xF9\x30\xE1\x27\x3B\xC0"
           "\xD7\xE7\xEF\xF8\x52\x50\x2C\x85\x65\x1B\x1C\x3D\x2D\xA9\x73\x8F"
           "\xCA\x54\xF3\x60\xE4\x84\x67\xAC\xEB\xAA\x24\x30\xC9\x98\x9D\x4B"
           "\x2E\xF3\xD7\xE1\x93\xCA\xC0\x63\x3F\xD1\xE4\xAF\x08\x37\x63\xB5"
           "\x8A\xDB\x3E\x66\x44\x4E\x01\x7F\x75\x92\xB4\x5D\x79\x6C\x94\x9B"
           "\x4C\x55\x2F\x9A\x26\xD9\x54\x65\x67\x41\x4A\xAC\x1F\x7C\x4A\xFE"
           "\x1E\xDD\xDD\xE1\x51\x3A\xB2\xE2\x92\xFA\x3F\x8D\xFF\xEE\x78\x0A"
           "\xBB\xFB\xD6\x94\xE3\x39\x48\xF8\xF1\xC0\x3A\x36\xF4\x65\xF6\xB9"
           "\x2A\x2C\xEE\x71\x11\xAA\x7B\x55\xBF\x9D\x13\x0F\x74\x47\x05\x87"
           "\x27\xF0\x9F\x65\x6E\xED\xAF\x2B\x78\x69\xFE\x3A\x40\xA3\xDB\x58"
           "\xCC\x5C\x83\xC5\x0E\x9B\xF3\xB5\x8B\x6D\xA8\xBE\x0C\x5E\x38\x2A"
           "\x12\x8C\x3E\x40\xA1\x03\x43\x20\x6B\x4B\x3D\x65\x8C\x96\x13\x5F"
           "\x58\x56\x87\x88\x20\x0A\x12\xD8\x42\x95\x55\x5D\xDD\x74\x23\xF3"
           "\x05\x77\x04\x02\xBC\x97\x6E\xED\xEB\x33\x10\x4B\x8C\x58\x0C\xDF"
           "\x9A\x54\xCD\xB9\x69\xAA\x0B\x15\x13\x8B\x95\x87\x55\xFC\x05\x0A"
           "\x81\x5E\x00\x9D\x50\x9D\x7D\x73\x94\x6B\x78\x30\x40\xC7\xF4\x89"
           "\x76\x9F\x1D\x3B\x69\xAE\x65\x5C\xF5\xAB\xF8\xC0\x33\x0F\xA3\x02"
           "\xA4\x41\x96\x86\x47\x75\x2F\x3B\xC4\x3D\xE8\x5A\x88\xAB\xB9\x74"
           "\xB9\x8F\xA7\xDC\xBE\x35\xE0\xA1\x31\xA1\xEE\xAC\xD3\x01\x97\x67"
           "\x65\x1D\x81\x74\x38\x11\xEF\xC5\x0F\xDD\x6B\x70\x98\xF8\xDC\x91"
           "\xFA\x20\xDD\x34\x9F\xB4\xB2\x09\x6B\x90\xD7\x81\xBA\xD4\x34\xEA"
           "\x24\x83\x49\x86\x3C\xDF\x51\x98\xDB\xA2\x68\x53\xC3\x41\x47\x3B"
           "\x70\x13\x1B\xC7\xB1\x4B\x64\xD3\xD1\x46\xF6\x97\x04\x65\x8C\x24"
           "\x13\xD0\xE5\x85\x7D\xBF\x31\x3A\xB5\x49\x14\xF1\x3F\xFA\xB5\xC1"
           "\x47\x61\x69\x76\x6E\xD2\x9D\x84\xA0\x88\xD6\x65\x35\x6E\xD4\xEB"
           "\x57\x1D\x9F\xF5\xB5\x10\x5D\x12\x05\xA1\xF2\x5A\x37\x4D\x9A\x65"
           "\xBA\xE8\x69\x9B\x02\x93\xAD\x7A\x84\xB0\x6E\xF2\xB6\xB3\x86\x11"
           "\x8F\xF8\xB2\x23\x4E\xD4\x33\x74\x9C\xB4\x91\xD8\x57\x01\x18\x14"
           "\x8A\x63\x13\xFB\x17\x1B\x91\x0E\x35\x71\xD2\x0A\x73\xCD\x99\xA9"
           "\x5C\x10\xD3\xDE\x93\xF4\x5A\x63\xCB\x08\x1E\x8F\x38\x0E\x1A\xB1"
           "\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78"
           , 616);
    nSKLen = 616;
    memset(bData, 0x42, 128);
    bData[0] = 0x30;
    bData[127] = 0x39;
    nDataLen = 128;
    memcpy(bSignExp,
           "\x35\x04\x68\x23\x0E\x26\x91\x1B\xD3\xB6\x0F\xAE\x92\x9D\xA9\x37"
           "\xD8\x6C\x72\x28\x6F\xB0\xAF\x43\x45\x0E\x5E\xF3\xC7\xB0\x70\x13"
           "\xF2\x41\xCF\xE9\x42\x0A\x21\xB6\x5C\xAD\x9F\x6E\xB5\x4E\xAB\x5B"
           "\x57\x6B\x3A\x84\x49\x67\x6B\x7E\xC8\x9A\x7F\xA4\x6E\x5D\x56\xFC"
           "\x44\x51\xA6\x7D\xDE\x74\xD1\x8B\x6A\x87\xB5\x92\x5B\xB8\x7E\x2B"
           "\xE0\xD4\x99\x37\xA8\xFC\x33\xBB\xD1\x11\x7D\xDC\x3B\x34\xA4\x87"
           "\x06\xBB\x6E\x2F\xA6\x5A\x31\xA8\x09\x36\x59\xB6\xCE\xFF\x5E\x96"
           "\x23\xC9\xA0\x11\x89\xBD\x38\x5A\xB1\xE4\x94\x61\xA9\x9F\x0A\x14"
           , 128);
    nSignLenExp = 128;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 616);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 128);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1024，SHA-224，PKCS#1填充，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bSign    =", bSign, 128);
    DspHex("[OUT]bSignExp =", bSignExp, 128);
    ASSERT_OUT_HEX(bSign, bSignExp, 128);
    ASSERT_OUT(nSignLen, nSignLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_10(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 3;
    nPadMode = 1;
    memcpy(bSK,
           "\x3B\xD4\x50\x5C\x7E\x86\x10\xCE\x25\x5C\xB9\x39\xC2\xD4\x61\x5C"
           "\x7F\xC2\xC4\x74\xE5\x22\x06\xCD\x50\x53\xAF\x84\x02\xF7\xE6\x54"
           "\x85\x44\x18\x4D\xE9\x05\x89\xF5\x5D\x0E\xC0\x55\x6A\xD2\x53\xA5"
           "\x36\x71\x2D\xD5\xFD\xEA\x8A\x45\x4C\xC6\x00\x3B\xE7\x01\x70\x1C"
           "\xEC\xA6\xD1\xF4\x7D\xF0\xD5\xF5\xB6\x5A\x00\x43\xBC\xF0\x6A\x79"
           "\xFF\xD3\x30\xB8\x5F\xFA\xEA\xE0\xD1\x9E\x6C\x02\xAE\x9A\x13\xF0"
           "\x09\xED\xB1\x9C\x0A\xBE\xA9\xB7\x93\x66\xBB\x08\xC6\x0A\xA2\xFD"
           "\xFE\x19\xBF\x9E\x9E\x7C\x1C\xCF\xBB\xF6\x3F\x4D\x1A\x35\xF9\x26"
           "\x2A\xF4\x84\x29\x43\x79\xE7\x3D\x9B\x58\xF9\x30\xE1\x27\x3B\xC0"
           "\xD7\xE7\xEF\xF8\x52\x50\x2C\x85\x65\x1B\x1C\x3D\x2D\xA9\x73\x8F"
           "\xCA\x54\xF3\x60\xE4\x84\x67\xAC\xEB\xAA\x24\x30\xC9\x98\x9D\x4B"
           "\x2E\xF3\xD7\xE1\x93\xCA\xC0\x63\x3F\xD1\xE4\xAF\x08\x37\x63\xB5"
           "\x8A\xDB\x3E\x66\x44\x4E\x01\x7F\x75\x92\xB4\x5D\x79\x6C\x94\x9B"
           "\x4C\x55\x2F\x9A\x26\xD9\x54\x65\x67\x41\x4A\xAC\x1F\x7C\x4A\xFE"
           "\x1E\xDD\xDD\xE1\x51\x3A\xB2\xE2\x92\xFA\x3F\x8D\xFF\xEE\x78\x0A"
           "\xBB\xFB\xD6\x94\xE3\x39\x48\xF8\xF1\xC0\x3A\x36\xF4\x65\xF6\xB9"
           "\x2A\x2C\xEE\x71\x11\xAA\x7B\x55\xBF\x9D\x13\x0F\x74\x47\x05\x87"
           "\x27\xF0\x9F\x65\x6E\xED\xAF\x2B\x78\x69\xFE\x3A\x40\xA3\xDB\x58"
           "\xCC\x5C\x83\xC5\x0E\x9B\xF3\xB5\x8B\x6D\xA8\xBE\x0C\x5E\x38\x2A"
           "\x12\x8C\x3E\x40\xA1\x03\x43\x20\x6B\x4B\x3D\x65\x8C\x96\x13\x5F"
           "\x58\x56\x87\x88\x20\x0A\x12\xD8\x42\x95\x55\x5D\xDD\x74\x23\xF3"
           "\x05\x77\x04\x02\xBC\x97\x6E\xED\xEB\x33\x10\x4B\x8C\x58\x0C\xDF"
           "\x9A\x54\xCD\xB9\x69\xAA\x0B\x15\x13\x8B\x95\x87\x55\xFC\x05\x0A"
           "\x81\x5E\x00\x9D\x50\x9D\x7D\x73\x94\x6B\x78\x30\x40\xC7\xF4\x89"
           "\x76\x9F\x1D\x3B\x69\xAE\x65\x5C\xF5\xAB\xF8\xC0\x33\x0F\xA3\x02"
           "\xA4\x41\x96\x86\x47\x75\x2F\x3B\xC4\x3D\xE8\x5A\x88\xAB\xB9\x74"
           "\xB9\x8F\xA7\xDC\xBE\x35\xE0\xA1\x31\xA1\xEE\xAC\xD3\x01\x97\x67"
           "\x65\x1D\x81\x74\x38\x11\xEF\xC5\x0F\xDD\x6B\x70\x98\xF8\xDC\x91"
           "\xFA\x20\xDD\x34\x9F\xB4\xB2\x09\x6B\x90\xD7\x81\xBA\xD4\x34\xEA"
           "\x24\x83\x49\x86\x3C\xDF\x51\x98\xDB\xA2\x68\x53\xC3\x41\x47\x3B"
           "\x70\x13\x1B\xC7\xB1\x4B\x64\xD3\xD1\x46\xF6\x97\x04\x65\x8C\x24"
           "\x13\xD0\xE5\x85\x7D\xBF\x31\x3A\xB5\x49\x14\xF1\x3F\xFA\xB5\xC1"
           "\x47\x61\x69\x76\x6E\xD2\x9D\x84\xA0\x88\xD6\x65\x35\x6E\xD4\xEB"
           "\x57\x1D\x9F\xF5\xB5\x10\x5D\x12\x05\xA1\xF2\x5A\x37\x4D\x9A\x65"
           "\xBA\xE8\x69\x9B\x02\x93\xAD\x7A\x84\xB0\x6E\xF2\xB6\xB3\x86\x11"
           "\x8F\xF8\xB2\x23\x4E\xD4\x33\x74\x9C\xB4\x91\xD8\x57\x01\x18\x14"
           "\x8A\x63\x13\xFB\x17\x1B\x91\x0E\x35\x71\xD2\x0A\x73\xCD\x99\xA9"
           "\x5C\x10\xD3\xDE\x93\xF4\x5A\x63\xCB\x08\x1E\x8F\x38\x0E\x1A\xB1"
           "\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78"
           , 616);
    nSKLen = 616;
    memset(bData, 0x42, 128);
    bData[0] = 0x30;
    bData[127] = 0x39;
    nDataLen = 128;
    memcpy(bSignExp,
           "\x91\x3D\x05\xA6\xD5\x9A\xFA\xB7\x4F\x4D\x58\x0C\xE7\x2C\xF6\x79"
           "\x6C\xAE\x45\x8E\x38\x52\x3A\xB7\xE0\xCA\x1D\xF3\x69\x10\x56\x00"
           "\x0B\xC3\x12\x1B\x35\x94\x76\xE9\xDB\x24\xEB\xEB\x4C\x2C\x6C\x05"
           "\xFD\xA3\x4D\x4E\x3F\xCC\x4C\xC7\xA0\xB0\x91\x63\x4F\x3D\x7D\xB7"
           "\xD8\xAF\xBA\x38\x3D\x5F\xB7\xDC\x73\xD5\xC6\xD3\xEC\xF5\xB7\xE0"
           "\xCE\x73\x7B\xFF\xB1\x67\x4D\xAC\x34\x64\x6C\xD0\xE6\x61\x4E\x53"
           "\xC4\xC2\x54\x45\xD0\x53\x49\x65\xC1\xED\x5A\x76\x73\xE5\x0B\xA3"
           "\xD6\xAC\x9A\x56\xE0\x85\xD7\x01\xC7\x07\x8A\xE6\xC1\xD8\xAF\x7A"
           , 128);
    nSignLenExp = 128;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 616);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 128);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1024，SHA-256，PKCS#1填充，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bSign    =", bSign, 128);
    DspHex("[OUT]bSignExp =", bSignExp, 128);
    ASSERT_OUT_HEX(bSign, bSignExp, 128);
    ASSERT_OUT(nSignLen, nSignLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_11(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 4;
    nPadMode = 1;
    memcpy(bSK,
           "\x3B\xD4\x50\x5C\x7E\x86\x10\xCE\x25\x5C\xB9\x39\xC2\xD4\x61\x5C"
           "\x7F\xC2\xC4\x74\xE5\x22\x06\xCD\x50\x53\xAF\x84\x02\xF7\xE6\x54"
           "\x85\x44\x18\x4D\xE9\x05\x89\xF5\x5D\x0E\xC0\x55\x6A\xD2\x53\xA5"
           "\x36\x71\x2D\xD5\xFD\xEA\x8A\x45\x4C\xC6\x00\x3B\xE7\x01\x70\x1C"
           "\xEC\xA6\xD1\xF4\x7D\xF0\xD5\xF5\xB6\x5A\x00\x43\xBC\xF0\x6A\x79"
           "\xFF\xD3\x30\xB8\x5F\xFA\xEA\xE0\xD1\x9E\x6C\x02\xAE\x9A\x13\xF0"
           "\x09\xED\xB1\x9C\x0A\xBE\xA9\xB7\x93\x66\xBB\x08\xC6\x0A\xA2\xFD"
           "\xFE\x19\xBF\x9E\x9E\x7C\x1C\xCF\xBB\xF6\x3F\x4D\x1A\x35\xF9\x26"
           "\x2A\xF4\x84\x29\x43\x79\xE7\x3D\x9B\x58\xF9\x30\xE1\x27\x3B\xC0"
           "\xD7\xE7\xEF\xF8\x52\x50\x2C\x85\x65\x1B\x1C\x3D\x2D\xA9\x73\x8F"
           "\xCA\x54\xF3\x60\xE4\x84\x67\xAC\xEB\xAA\x24\x30\xC9\x98\x9D\x4B"
           "\x2E\xF3\xD7\xE1\x93\xCA\xC0\x63\x3F\xD1\xE4\xAF\x08\x37\x63\xB5"
           "\x8A\xDB\x3E\x66\x44\x4E\x01\x7F\x75\x92\xB4\x5D\x79\x6C\x94\x9B"
           "\x4C\x55\x2F\x9A\x26\xD9\x54\x65\x67\x41\x4A\xAC\x1F\x7C\x4A\xFE"
           "\x1E\xDD\xDD\xE1\x51\x3A\xB2\xE2\x92\xFA\x3F\x8D\xFF\xEE\x78\x0A"
           "\xBB\xFB\xD6\x94\xE3\x39\x48\xF8\xF1\xC0\x3A\x36\xF4\x65\xF6\xB9"
           "\x2A\x2C\xEE\x71\x11\xAA\x7B\x55\xBF\x9D\x13\x0F\x74\x47\x05\x87"
           "\x27\xF0\x9F\x65\x6E\xED\xAF\x2B\x78\x69\xFE\x3A\x40\xA3\xDB\x58"
           "\xCC\x5C\x83\xC5\x0E\x9B\xF3\xB5\x8B\x6D\xA8\xBE\x0C\x5E\x38\x2A"
           "\x12\x8C\x3E\x40\xA1\x03\x43\x20\x6B\x4B\x3D\x65\x8C\x96\x13\x5F"
           "\x58\x56\x87\x88\x20\x0A\x12\xD8\x42\x95\x55\x5D\xDD\x74\x23\xF3"
           "\x05\x77\x04\x02\xBC\x97\x6E\xED\xEB\x33\x10\x4B\x8C\x58\x0C\xDF"
           "\x9A\x54\xCD\xB9\x69\xAA\x0B\x15\x13\x8B\x95\x87\x55\xFC\x05\x0A"
           "\x81\x5E\x00\x9D\x50\x9D\x7D\x73\x94\x6B\x78\x30\x40\xC7\xF4\x89"
           "\x76\x9F\x1D\x3B\x69\xAE\x65\x5C\xF5\xAB\xF8\xC0\x33\x0F\xA3\x02"
           "\xA4\x41\x96\x86\x47\x75\x2F\x3B\xC4\x3D\xE8\x5A\x88\xAB\xB9\x74"
           "\xB9\x8F\xA7\xDC\xBE\x35\xE0\xA1\x31\xA1\xEE\xAC\xD3\x01\x97\x67"
           "\x65\x1D\x81\x74\x38\x11\xEF\xC5\x0F\xDD\x6B\x70\x98\xF8\xDC\x91"
           "\xFA\x20\xDD\x34\x9F\xB4\xB2\x09\x6B\x90\xD7\x81\xBA\xD4\x34\xEA"
           "\x24\x83\x49\x86\x3C\xDF\x51\x98\xDB\xA2\x68\x53\xC3\x41\x47\x3B"
           "\x70\x13\x1B\xC7\xB1\x4B\x64\xD3\xD1\x46\xF6\x97\x04\x65\x8C\x24"
           "\x13\xD0\xE5\x85\x7D\xBF\x31\x3A\xB5\x49\x14\xF1\x3F\xFA\xB5\xC1"
           "\x47\x61\x69\x76\x6E\xD2\x9D\x84\xA0\x88\xD6\x65\x35\x6E\xD4\xEB"
           "\x57\x1D\x9F\xF5\xB5\x10\x5D\x12\x05\xA1\xF2\x5A\x37\x4D\x9A\x65"
           "\xBA\xE8\x69\x9B\x02\x93\xAD\x7A\x84\xB0\x6E\xF2\xB6\xB3\x86\x11"
           "\x8F\xF8\xB2\x23\x4E\xD4\x33\x74\x9C\xB4\x91\xD8\x57\x01\x18\x14"
           "\x8A\x63\x13\xFB\x17\x1B\x91\x0E\x35\x71\xD2\x0A\x73\xCD\x99\xA9"
           "\x5C\x10\xD3\xDE\x93\xF4\x5A\x63\xCB\x08\x1E\x8F\x38\x0E\x1A\xB1"
           "\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78"
           , 616);
    nSKLen = 616;
    memset(bData, 0x42, 128);
    bData[0] = 0x30;
    bData[127] = 0x39;
    nDataLen = 128;
    memcpy(bSignExp,
           "\x38\xBB\x1B\x0C\xBC\x24\x8E\x8E\x2D\x25\x22\x64\xF9\xEA\x75\x97"
           "\xCE\xFF\x5E\xCF\x8A\x94\x50\xA7\xCE\xA3\xC8\xAC\xF2\x8B\xD1\x50"
           "\x65\x68\x45\xC6\x6D\x3F\x48\x4B\x57\xB2\x81\xF4\x43\xE1\x29\x0A"
           "\xF4\x70\xBB\xB1\x82\x9F\xA5\x2E\x63\x6B\x2B\x8D\x90\x82\x1F\x94"
           "\xFC\x7B\x34\x07\xF5\xF8\x72\x68\x56\x3D\x66\x91\x26\x52\xEF\x60"
           "\x63\xAE\x22\x3E\x8F\x39\x27\xBB\x88\x20\x3F\x9E\x4B\x3E\x3C\x93"
           "\xF9\x83\x38\x3C\x4A\xB6\xC3\xDC\x43\xE7\x61\xBB\xD2\xC6\xB0\x0D"
           "\x74\x0A\xC2\xCA\x36\xCE\xB0\xC2\xD7\xAD\x06\x00\xBD\x88\x05\x7C"
           , 128);
    nSignLenExp = 128;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 616);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 128);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1024，SHA-384，PKCS#1填充，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bSign    =", bSign, 128);
    DspHex("[OUT]bSignExp =", bSignExp, 128);
    ASSERT_OUT_HEX(bSign, bSignExp, 128);
    ASSERT_OUT(nSignLen, nSignLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_12(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 5;
    nPadMode = 1;
    memcpy(bSK,
           "\x3B\xD4\x50\x5C\x7E\x86\x10\xCE\x25\x5C\xB9\x39\xC2\xD4\x61\x5C"
           "\x7F\xC2\xC4\x74\xE5\x22\x06\xCD\x50\x53\xAF\x84\x02\xF7\xE6\x54"
           "\x85\x44\x18\x4D\xE9\x05\x89\xF5\x5D\x0E\xC0\x55\x6A\xD2\x53\xA5"
           "\x36\x71\x2D\xD5\xFD\xEA\x8A\x45\x4C\xC6\x00\x3B\xE7\x01\x70\x1C"
           "\xEC\xA6\xD1\xF4\x7D\xF0\xD5\xF5\xB6\x5A\x00\x43\xBC\xF0\x6A\x79"
           "\xFF\xD3\x30\xB8\x5F\xFA\xEA\xE0\xD1\x9E\x6C\x02\xAE\x9A\x13\xF0"
           "\x09\xED\xB1\x9C\x0A\xBE\xA9\xB7\x93\x66\xBB\x08\xC6\x0A\xA2\xFD"
           "\xFE\x19\xBF\x9E\x9E\x7C\x1C\xCF\xBB\xF6\x3F\x4D\x1A\x35\xF9\x26"
           "\x2A\xF4\x84\x29\x43\x79\xE7\x3D\x9B\x58\xF9\x30\xE1\x27\x3B\xC0"
           "\xD7\xE7\xEF\xF8\x52\x50\x2C\x85\x65\x1B\x1C\x3D\x2D\xA9\x73\x8F"
           "\xCA\x54\xF3\x60\xE4\x84\x67\xAC\xEB\xAA\x24\x30\xC9\x98\x9D\x4B"
           "\x2E\xF3\xD7\xE1\x93\xCA\xC0\x63\x3F\xD1\xE4\xAF\x08\x37\x63\xB5"
           "\x8A\xDB\x3E\x66\x44\x4E\x01\x7F\x75\x92\xB4\x5D\x79\x6C\x94\x9B"
           "\x4C\x55\x2F\x9A\x26\xD9\x54\x65\x67\x41\x4A\xAC\x1F\x7C\x4A\xFE"
           "\x1E\xDD\xDD\xE1\x51\x3A\xB2\xE2\x92\xFA\x3F\x8D\xFF\xEE\x78\x0A"
           "\xBB\xFB\xD6\x94\xE3\x39\x48\xF8\xF1\xC0\x3A\x36\xF4\x65\xF6\xB9"
           "\x2A\x2C\xEE\x71\x11\xAA\x7B\x55\xBF\x9D\x13\x0F\x74\x47\x05\x87"
           "\x27\xF0\x9F\x65\x6E\xED\xAF\x2B\x78\x69\xFE\x3A\x40\xA3\xDB\x58"
           "\xCC\x5C\x83\xC5\x0E\x9B\xF3\xB5\x8B\x6D\xA8\xBE\x0C\x5E\x38\x2A"
           "\x12\x8C\x3E\x40\xA1\x03\x43\x20\x6B\x4B\x3D\x65\x8C\x96\x13\x5F"
           "\x58\x56\x87\x88\x20\x0A\x12\xD8\x42\x95\x55\x5D\xDD\x74\x23\xF3"
           "\x05\x77\x04\x02\xBC\x97\x6E\xED\xEB\x33\x10\x4B\x8C\x58\x0C\xDF"
           "\x9A\x54\xCD\xB9\x69\xAA\x0B\x15\x13\x8B\x95\x87\x55\xFC\x05\x0A"
           "\x81\x5E\x00\x9D\x50\x9D\x7D\x73\x94\x6B\x78\x30\x40\xC7\xF4\x89"
           "\x76\x9F\x1D\x3B\x69\xAE\x65\x5C\xF5\xAB\xF8\xC0\x33\x0F\xA3\x02"
           "\xA4\x41\x96\x86\x47\x75\x2F\x3B\xC4\x3D\xE8\x5A\x88\xAB\xB9\x74"
           "\xB9\x8F\xA7\xDC\xBE\x35\xE0\xA1\x31\xA1\xEE\xAC\xD3\x01\x97\x67"
           "\x65\x1D\x81\x74\x38\x11\xEF\xC5\x0F\xDD\x6B\x70\x98\xF8\xDC\x91"
           "\xFA\x20\xDD\x34\x9F\xB4\xB2\x09\x6B\x90\xD7\x81\xBA\xD4\x34\xEA"
           "\x24\x83\x49\x86\x3C\xDF\x51\x98\xDB\xA2\x68\x53\xC3\x41\x47\x3B"
           "\x70\x13\x1B\xC7\xB1\x4B\x64\xD3\xD1\x46\xF6\x97\x04\x65\x8C\x24"
           "\x13\xD0\xE5\x85\x7D\xBF\x31\x3A\xB5\x49\x14\xF1\x3F\xFA\xB5\xC1"
           "\x47\x61\x69\x76\x6E\xD2\x9D\x84\xA0\x88\xD6\x65\x35\x6E\xD4\xEB"
           "\x57\x1D\x9F\xF5\xB5\x10\x5D\x12\x05\xA1\xF2\x5A\x37\x4D\x9A\x65"
           "\xBA\xE8\x69\x9B\x02\x93\xAD\x7A\x84\xB0\x6E\xF2\xB6\xB3\x86\x11"
           "\x8F\xF8\xB2\x23\x4E\xD4\x33\x74\x9C\xB4\x91\xD8\x57\x01\x18\x14"
           "\x8A\x63\x13\xFB\x17\x1B\x91\x0E\x35\x71\xD2\x0A\x73\xCD\x99\xA9"
           "\x5C\x10\xD3\xDE\x93\xF4\x5A\x63\xCB\x08\x1E\x8F\x38\x0E\x1A\xB1"
           "\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78"
           , 616);
    nSKLen = 616;
    memset(bData, 0x42, 2048);
    bData[0] = 0x30;
    bData[2047] = 0x39;
    nDataLen = 2048;
    memcpy(bSignExp,
           "\x00\xF6\xC3\xAB\x74\x47\x25\xE6\xFB\x4D\xF9\x0F\xC7\x43\x12\x37"
           "\x85\xA2\x5A\xB4\xFC\xBF\x40\x82\x75\x76\xF5\xAB\x9E\x75\x09\x91"
           "\xC8\xE8\x89\xB8\x91\xE8\x41\x7A\xC5\x37\xF8\x68\xC0\x35\x04\x87"
           "\x94\x8A\x97\xC4\x35\x34\x02\x1F\x60\xDF\x20\xB4\x91\x86\x30\xB5"
           "\xBD\x7C\x63\xF5\xEA\x72\x84\x9A\x68\x5D\x34\x8E\xE5\xB9\xFB\x6F"
           "\x9A\xEE\x7A\x30\x5F\x3C\xBA\x48\x77\x88\x2D\x3B\xCC\x00\x79\xC3"
           "\x68\xAD\xFD\x9A\xCB\x06\x2D\xC9\xD5\xD8\x5A\xBF\x73\x7D\x15\xDC"
           "\xFA\x88\x15\x58\x8F\xC0\xC7\x11\xFE\x70\xBB\x70\x61\x00\x03\xC1"
           , 128);
    nSignLenExp = 128;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 616);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 2048);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1024，SHA-512，PKCS#1填充，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bSign    =", bSign, 128);
    DspHex("[OUT]bSignExp =", bSignExp, 128);
    ASSERT_OUT_HEX(bSign, bSignExp, 128);
    ASSERT_OUT(nSignLen, nSignLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_13(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 0;
    nPadMode = 1;
    memcpy(bSK,
           "\xDF\x00\x50\x67\x45\x67\xCB\xA9\xF3\x62\x34\x84\x08\x05\xEE\x96"
           "\x70\x77\x07\xC3\x71\x70\xAD\xC0\xE9\x02\xE7\x50\x58\xCB\x00\xCF"
           "\x55\xAA\xB9\xE0\x3D\x47\x8D\xC8\x38\x3A\x78\x92\xB2\x54\x98\xEF"
           "\x5A\x46\x80\x77\x58\x05\x1E\x94\xA8\x62\xE6\xFA\x5C\x54\x15\x48"
           "\x2D\xDB\x8C\x41\x31\x90\x9F\xE9\x4D\x87\x7A\x21\xB9\xA3\x13\xE5"
           "\xE0\xED\x09\x27\x17\xB6\xB1\xAA\x23\xBE\x5F\x80\x9F\x25\xF2\xE1"
           "\x7A\xB2\xCB\x36\xF2\xE5\x2A\x6F\x63\xD1\x4C\xD6\x53\x07\xBF\x83"
           "\x4F\x59\xE1\x20\x63\x9C\x33\x38\x88\xD3\x79\x7D\xF1\x47\x6E\x16"
           "\x3F\x38\xF3\xCF\x0D\x25\xF4\xD5\x28\x76\x55\x5C\x22\x54\x1B\xAD"
           "\xCC\xB6\x21\x81\xFC\x32\xE0\xCF\x8C\x30\x3A\x96\x31\x48\x02\x7E"
           "\x0E\x2A\x4B\x99\x46\x5C\xCA\x23\x82\x41\xA6\x9B\x8A\x71\xF4\x4E"
           "\x7A\xCF\xBE\x9D\xEC\x18\x90\x04\xF2\x6F\x9F\xD9\x76\xFD\x43\x17"
           "\x81\xF0\xD7\xB8\x1B\xE6\x7C\xBB\x5F\xB9\x9D\x8E\x96\x4D\xC5\xE3"
           "\x7A\x98\xBA\x11\x2B\x52\x62\xA3\x48\x6F\x9C\x8F\x3F\x4A\x88\xF4"
           "\xEA\x82\x59\xBD\x2D\x55\x06\x8F\x51\x8D\x37\xA0\xB0\xF4\xA7\x23"
           "\x76\x86\xFF\x68\xEA\x6C\x64\xFE\xC0\xCD\x6C\x48\x20\xCB\xD2\x77"
           "\x31\x73\xD8\x50\x5A\x13\x84\x98\x8D\x0A\xF1\xB9\x8A\xD8\x87\x54"
           "\xDC\xB4\xBA\x6A\x0E\x7D\x04\x4D\x7C\x6C\xF6\xE3\x50\x65\xEF\xC2"
           "\x9C\x70\x39\x70\x99\x60\x53\x70\x88\x1D\xA2\x56\x1A\x78\xB8\x15"
           "\x17\x81\x3F\xEC\x07\x0A\xE0\x33\x7A\x82\x0B\xE2\x21\x53\x1B\x27"
           "\x7C\x06\x69\x00\x82\xB3\xAB\x74\xE9\x43\xDD\xCC\x69\x2C\xF8\x51"
           "\xAF\xEB\xEE\x15\x6E\xE0\x35\xA8\x6A\x0D\x35\x8A\x01\x98\x68\x8A"
           "\xC5\x71\xAA\x8C\xDB\x31\xC7\x04\x5D\xEF\x33\x50\x1A\x66\xC9\xBF"
           "\x85\xE8\x30\xBF\x8E\x36\x86\xA3\xB0\xBF\x18\x8E\xA0\x93\xB3\x5C"
           "\xD2\xD3\x6E\x57\x86\x14\x30\x5D\xC5\x29\x0B\x5A\xEF\xEA\xA3\x9C"
           "\xC0\xDD\x9B\xDF\x67\xB9\xAF\x01\xC4\x0C\x83\xE1\x36\x95\x4E\xB6"
           "\xF2\x61\x4F\xB8\x09\x8E\x66\x90\x23\xE7\x6D\xD1\x71\xF4\xF4\xE7"
           "\xF4\x3B\x54\x8D\x91\x05\x89\xB5\xFE\x78\xBA\x30\x87\xF5\xB5\xE6"
           "\xE8\x55\x5B\xCA\x64\xAF\x89\x59\xA0\x50\x8A\x7D\x19\x40\xDF\x49"
           "\x31\xEA\xEF\x76\x70\x2E\x1F\xC7\x05\x7E\xA0\x2A\x42\x17\xA2\x0A"
           "\x32\xAC\x36\x7F\x31\xFF\x11\xED\x06\x13\x03\xC6\xDF\xEF\xC4\x27"
           "\x8C\x29\xE3\x36\xE6\xDE\xBC\xE8\x7B\xB5\x7B\x9A\xCB\x93\xF1\x21"
           "\x26\x38\x94\xDA\xF5\x1B\xD7\x2F\xA9\x3C\xEC\xE3\xDC\xD6\xD8\xFC"
           "\x03\x4D\xE1\x49\xA2\x22\x6E\xFD\x57\x80\xAB\xF4\xFA\xD5\xC2\x53"
           "\xCE\x6D\xB2\x61\xE3\xA8\x22\xD8\xD2\x9C\xFE\x85\xE2\x80\xA0\x9D"
           "\x1E\xAF\x00\x3F\xF2\x36\xE1\xE5\xBC\x32\x73\x7E\xD0\x6E\x18\x66"
           "\x48\x64\x91\x0E\xB6\x70\x82\xAA\x40\xFA\x2D\xB5\x27\x0A\x71\x17"
           "\x15\x96\xD4\x2B\xEF\xB4\x82\xA2\x4C\x7C\x08\x2B\x9E\xD6\x99\x56"
           "\x20\x08\xCD\x7D\x6B\x5E\x38\x53\x67\x13\x38\xED\x16\x44\x71\x12"
           "\x97\x4B\x84\xE7\xCE\x12\x53\x70\x46\x6A\x71\x51\xAD\x8B\x71\x2D"
           "\xE5\x4C\xF7\xFF\xCE\x39\xB3\xA0\xB1\x46\x26\x4F\x1A\x63\x0C\xB9"
           "\xEE\x8F\xC7\x8E\x61\x24\xD0\xFB\xD4\x33\x00\xFD\x85\x23\x8B\x12"
           "\x09\x49\x7D\xA8\xE2\x9D\x2E\xFD"
           , 680);
    nSKLen = 680;
    memset(bData, 0x42, 1);
    nDataLen = 1;
    memcpy(bSignExp,
           "\x56\x33\x96\x77\x5D\xB7\xE1\xCA\x20\xFF\x60\x73\x3B\xF6\x19\xAD"
           "\xC2\x0A\xA7\x91\x0F\x9C\x67\x56\xCE\x63\xB6\x33\x85\x31\x32\x44"
           "\x0B\xA1\xA0\xA0\xC5\x0D\x91\x8B\xAA\x85\x01\xF5\xAF\xA2\xB0\xAA"
           "\x75\xD9\xC9\xF0\x4D\xEF\xF4\x1F\xE4\xCC\x26\x0C\xA0\x08\x83\x33"
           "\x7F\x16\xF5\x24\x76\x6B\x36\xE3\xAD\xA0\xCA\x11\x11\xE8\xD3\x65"
           "\x4B\x9F\x19\x5C\x53\xA2\x4B\x44\xAA\xC8\x67\x7D\x92\xB1\xD3\x10"
           "\xF9\x78\xD3\xE1\x57\x45\xC1\xC0\x8C\x1D\x60\xA0\xB3\x38\x8E\xE3"
           "\x8F\xBA\x5C\x36\xD0\xD1\x3F\x69\x5B\xA1\x42\x2C\xFC\x35\x8B\x92"
           "\x04\x8F\x7A\x45\x3C\x54\xC1\xA1\xFD\x25\x10\x85\xE6\x5B\x94\xC8"
           , 144);
    nSignLenExp = 144;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 680);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 1);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1152，MD5，PKCS#1填充，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bSign    =", bSign, 144);
    DspHex("[OUT]bSignExp =", bSignExp, 144);
    ASSERT_OUT_HEX(bSign, bSignExp, 144);
    ASSERT_OUT(nSignLen, nSignLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_14(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 1;
    nPadMode = 1;
    memcpy(bSK,
           "\xDF\x00\x50\x67\x45\x67\xCB\xA9\xF3\x62\x34\x84\x08\x05\xEE\x96"
           "\x70\x77\x07\xC3\x71\x70\xAD\xC0\xE9\x02\xE7\x50\x58\xCB\x00\xCF"
           "\x55\xAA\xB9\xE0\x3D\x47\x8D\xC8\x38\x3A\x78\x92\xB2\x54\x98\xEF"
           "\x5A\x46\x80\x77\x58\x05\x1E\x94\xA8\x62\xE6\xFA\x5C\x54\x15\x48"
           "\x2D\xDB\x8C\x41\x31\x90\x9F\xE9\x4D\x87\x7A\x21\xB9\xA3\x13\xE5"
           "\xE0\xED\x09\x27\x17\xB6\xB1\xAA\x23\xBE\x5F\x80\x9F\x25\xF2\xE1"
           "\x7A\xB2\xCB\x36\xF2\xE5\x2A\x6F\x63\xD1\x4C\xD6\x53\x07\xBF\x83"
           "\x4F\x59\xE1\x20\x63\x9C\x33\x38\x88\xD3\x79\x7D\xF1\x47\x6E\x16"
           "\x3F\x38\xF3\xCF\x0D\x25\xF4\xD5\x28\x76\x55\x5C\x22\x54\x1B\xAD"
           "\xCC\xB6\x21\x81\xFC\x32\xE0\xCF\x8C\x30\x3A\x96\x31\x48\x02\x7E"
           "\x0E\x2A\x4B\x99\x46\x5C\xCA\x23\x82\x41\xA6\x9B\x8A\x71\xF4\x4E"
           "\x7A\xCF\xBE\x9D\xEC\x18\x90\x04\xF2\x6F\x9F\xD9\x76\xFD\x43\x17"
           "\x81\xF0\xD7\xB8\x1B\xE6\x7C\xBB\x5F\xB9\x9D\x8E\x96\x4D\xC5\xE3"
           "\x7A\x98\xBA\x11\x2B\x52\x62\xA3\x48\x6F\x9C\x8F\x3F\x4A\x88\xF4"
           "\xEA\x82\x59\xBD\x2D\x55\x06\x8F\x51\x8D\x37\xA0\xB0\xF4\xA7\x23"
           "\x76\x86\xFF\x68\xEA\x6C\x64\xFE\xC0\xCD\x6C\x48\x20\xCB\xD2\x77"
           "\x31\x73\xD8\x50\x5A\x13\x84\x98\x8D\x0A\xF1\xB9\x8A\xD8\x87\x54"
           "\xDC\xB4\xBA\x6A\x0E\x7D\x04\x4D\x7C\x6C\xF6\xE3\x50\x65\xEF\xC2"
           "\x9C\x70\x39\x70\x99\x60\x53\x70\x88\x1D\xA2\x56\x1A\x78\xB8\x15"
           "\x17\x81\x3F\xEC\x07\x0A\xE0\x33\x7A\x82\x0B\xE2\x21\x53\x1B\x27"
           "\x7C\x06\x69\x00\x82\xB3\xAB\x74\xE9\x43\xDD\xCC\x69\x2C\xF8\x51"
           "\xAF\xEB\xEE\x15\x6E\xE0\x35\xA8\x6A\x0D\x35\x8A\x01\x98\x68\x8A"
           "\xC5\x71\xAA\x8C\xDB\x31\xC7\x04\x5D\xEF\x33\x50\x1A\x66\xC9\xBF"
           "\x85\xE8\x30\xBF\x8E\x36\x86\xA3\xB0\xBF\x18\x8E\xA0\x93\xB3\x5C"
           "\xD2\xD3\x6E\x57\x86\x14\x30\x5D\xC5\x29\x0B\x5A\xEF\xEA\xA3\x9C"
           "\xC0\xDD\x9B\xDF\x67\xB9\xAF\x01\xC4\x0C\x83\xE1\x36\x95\x4E\xB6"
           "\xF2\x61\x4F\xB8\x09\x8E\x66\x90\x23\xE7\x6D\xD1\x71\xF4\xF4\xE7"
           "\xF4\x3B\x54\x8D\x91\x05\x89\xB5\xFE\x78\xBA\x30\x87\xF5\xB5\xE6"
           "\xE8\x55\x5B\xCA\x64\xAF\x89\x59\xA0\x50\x8A\x7D\x19\x40\xDF\x49"
           "\x31\xEA\xEF\x76\x70\x2E\x1F\xC7\x05\x7E\xA0\x2A\x42\x17\xA2\x0A"
           "\x32\xAC\x36\x7F\x31\xFF\x11\xED\x06\x13\x03\xC6\xDF\xEF\xC4\x27"
           "\x8C\x29\xE3\x36\xE6\xDE\xBC\xE8\x7B\xB5\x7B\x9A\xCB\x93\xF1\x21"
           "\x26\x38\x94\xDA\xF5\x1B\xD7\x2F\xA9\x3C\xEC\xE3\xDC\xD6\xD8\xFC"
           "\x03\x4D\xE1\x49\xA2\x22\x6E\xFD\x57\x80\xAB\xF4\xFA\xD5\xC2\x53"
           "\xCE\x6D\xB2\x61\xE3\xA8\x22\xD8\xD2\x9C\xFE\x85\xE2\x80\xA0\x9D"
           "\x1E\xAF\x00\x3F\xF2\x36\xE1\xE5\xBC\x32\x73\x7E\xD0\x6E\x18\x66"
           "\x48\x64\x91\x0E\xB6\x70\x82\xAA\x40\xFA\x2D\xB5\x27\x0A\x71\x17"
           "\x15\x96\xD4\x2B\xEF\xB4\x82\xA2\x4C\x7C\x08\x2B\x9E\xD6\x99\x56"
           "\x20\x08\xCD\x7D\x6B\x5E\x38\x53\x67\x13\x38\xED\x16\x44\x71\x12"
           "\x97\x4B\x84\xE7\xCE\x12\x53\x70\x46\x6A\x71\x51\xAD\x8B\x71\x2D"
           "\xE5\x4C\xF7\xFF\xCE\x39\xB3\xA0\xB1\x46\x26\x4F\x1A\x63\x0C\xB9"
           "\xEE\x8F\xC7\x8E\x61\x24\xD0\xFB\xD4\x33\x00\xFD\x85\x23\x8B\x12"
           "\x09\x49\x7D\xA8\xE2\x9D\x2E\xFD"
           , 680);
    nSKLen = 680;
    memset(bData, 0x42, 144);
    bData[0] = 0x30;
    bData[143] = 0x39;
    nDataLen = 144;
    memcpy(bSignExp,
           "\x1A\x48\x83\x0E\xAC\x20\xB0\xAA\x6D\x8A\xEE\x3D\xE5\xF5\xD2\xB6"
           "\x09\xE1\x14\x43\x1D\x18\xDB\xED\x86\xA8\x7C\xAE\x29\x76\x86\x92"
           "\x39\x36\x37\x94\xBF\x45\x02\x70\xB8\x27\x4C\xDE\xA0\xDA\xB8\xD9"
           "\x42\x20\xB6\xEE\x59\x34\x52\x5F\x98\x5F\xD6\xE7\x18\x5B\x22\x85"
           "\xAB\x6E\xD6\x81\x9C\xCF\x75\xF5\x64\x9E\x5A\x1F\xD2\xEB\x48\x1E"
           "\x8B\x20\x7E\x4F\xB0\x06\x29\x71\x34\xBF\xBF\xD5\xA5\x4B\x3E\x2C"
           "\x44\xC2\xA6\xDE\x40\x3B\x51\xD2\x00\xF3\xEF\x77\x08\x9A\xB6\x91"
           "\xE8\x5D\xC4\xA6\xDF\xE5\x27\x05\x0F\x6A\xAB\x92\x51\xAD\xCE\x9A"
           "\xF1\x36\xFE\xFF\x96\xC8\x96\xB2\xFB\xEC\xEA\xE5\x5E\x64\x85\x9B"
           , 144);
    nSignLenExp = 144;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 680);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 144);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1152，SHA-1，PKCS#1填充，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bSign    =", bSign, 144);
    DspHex("[OUT]bSignExp =", bSignExp, 144);
    ASSERT_OUT_HEX(bSign, bSignExp, 144);
    ASSERT_OUT(nSignLen, nSignLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_15(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 2;
    nPadMode = 1;
    memcpy(bSK,
           "\xDF\x00\x50\x67\x45\x67\xCB\xA9\xF3\x62\x34\x84\x08\x05\xEE\x96"
           "\x70\x77\x07\xC3\x71\x70\xAD\xC0\xE9\x02\xE7\x50\x58\xCB\x00\xCF"
           "\x55\xAA\xB9\xE0\x3D\x47\x8D\xC8\x38\x3A\x78\x92\xB2\x54\x98\xEF"
           "\x5A\x46\x80\x77\x58\x05\x1E\x94\xA8\x62\xE6\xFA\x5C\x54\x15\x48"
           "\x2D\xDB\x8C\x41\x31\x90\x9F\xE9\x4D\x87\x7A\x21\xB9\xA3\x13\xE5"
           "\xE0\xED\x09\x27\x17\xB6\xB1\xAA\x23\xBE\x5F\x80\x9F\x25\xF2\xE1"
           "\x7A\xB2\xCB\x36\xF2\xE5\x2A\x6F\x63\xD1\x4C\xD6\x53\x07\xBF\x83"
           "\x4F\x59\xE1\x20\x63\x9C\x33\x38\x88\xD3\x79\x7D\xF1\x47\x6E\x16"
           "\x3F\x38\xF3\xCF\x0D\x25\xF4\xD5\x28\x76\x55\x5C\x22\x54\x1B\xAD"
           "\xCC\xB6\x21\x81\xFC\x32\xE0\xCF\x8C\x30\x3A\x96\x31\x48\x02\x7E"
           "\x0E\x2A\x4B\x99\x46\x5C\xCA\x23\x82\x41\xA6\x9B\x8A\x71\xF4\x4E"
           "\x7A\xCF\xBE\x9D\xEC\x18\x90\x04\xF2\x6F\x9F\xD9\x76\xFD\x43\x17"
           "\x81\xF0\xD7\xB8\x1B\xE6\x7C\xBB\x5F\xB9\x9D\x8E\x96\x4D\xC5\xE3"
           "\x7A\x98\xBA\x11\x2B\x52\x62\xA3\x48\x6F\x9C\x8F\x3F\x4A\x88\xF4"
           "\xEA\x82\x59\xBD\x2D\x55\x06\x8F\x51\x8D\x37\xA0\xB0\xF4\xA7\x23"
           "\x76\x86\xFF\x68\xEA\x6C\x64\xFE\xC0\xCD\x6C\x48\x20\xCB\xD2\x77"
           "\x31\x73\xD8\x50\x5A\x13\x84\x98\x8D\x0A\xF1\xB9\x8A\xD8\x87\x54"
           "\xDC\xB4\xBA\x6A\x0E\x7D\x04\x4D\x7C\x6C\xF6\xE3\x50\x65\xEF\xC2"
           "\x9C\x70\x39\x70\x99\x60\x53\x70\x88\x1D\xA2\x56\x1A\x78\xB8\x15"
           "\x17\x81\x3F\xEC\x07\x0A\xE0\x33\x7A\x82\x0B\xE2\x21\x53\x1B\x27"
           "\x7C\x06\x69\x00\x82\xB3\xAB\x74\xE9\x43\xDD\xCC\x69\x2C\xF8\x51"
           "\xAF\xEB\xEE\x15\x6E\xE0\x35\xA8\x6A\x0D\x35\x8A\x01\x98\x68\x8A"
           "\xC5\x71\xAA\x8C\xDB\x31\xC7\x04\x5D\xEF\x33\x50\x1A\x66\xC9\xBF"
           "\x85\xE8\x30\xBF\x8E\x36\x86\xA3\xB0\xBF\x18\x8E\xA0\x93\xB3\x5C"
           "\xD2\xD3\x6E\x57\x86\x14\x30\x5D\xC5\x29\x0B\x5A\xEF\xEA\xA3\x9C"
           "\xC0\xDD\x9B\xDF\x67\xB9\xAF\x01\xC4\x0C\x83\xE1\x36\x95\x4E\xB6"
           "\xF2\x61\x4F\xB8\x09\x8E\x66\x90\x23\xE7\x6D\xD1\x71\xF4\xF4\xE7"
           "\xF4\x3B\x54\x8D\x91\x05\x89\xB5\xFE\x78\xBA\x30\x87\xF5\xB5\xE6"
           "\xE8\x55\x5B\xCA\x64\xAF\x89\x59\xA0\x50\x8A\x7D\x19\x40\xDF\x49"
           "\x31\xEA\xEF\x76\x70\x2E\x1F\xC7\x05\x7E\xA0\x2A\x42\x17\xA2\x0A"
           "\x32\xAC\x36\x7F\x31\xFF\x11\xED\x06\x13\x03\xC6\xDF\xEF\xC4\x27"
           "\x8C\x29\xE3\x36\xE6\xDE\xBC\xE8\x7B\xB5\x7B\x9A\xCB\x93\xF1\x21"
           "\x26\x38\x94\xDA\xF5\x1B\xD7\x2F\xA9\x3C\xEC\xE3\xDC\xD6\xD8\xFC"
           "\x03\x4D\xE1\x49\xA2\x22\x6E\xFD\x57\x80\xAB\xF4\xFA\xD5\xC2\x53"
           "\xCE\x6D\xB2\x61\xE3\xA8\x22\xD8\xD2\x9C\xFE\x85\xE2\x80\xA0\x9D"
           "\x1E\xAF\x00\x3F\xF2\x36\xE1\xE5\xBC\x32\x73\x7E\xD0\x6E\x18\x66"
           "\x48\x64\x91\x0E\xB6\x70\x82\xAA\x40\xFA\x2D\xB5\x27\x0A\x71\x17"
           "\x15\x96\xD4\x2B\xEF\xB4\x82\xA2\x4C\x7C\x08\x2B\x9E\xD6\x99\x56"
           "\x20\x08\xCD\x7D\x6B\x5E\x38\x53\x67\x13\x38\xED\x16\x44\x71\x12"
           "\x97\x4B\x84\xE7\xCE\x12\x53\x70\x46\x6A\x71\x51\xAD\x8B\x71\x2D"
           "\xE5\x4C\xF7\xFF\xCE\x39\xB3\xA0\xB1\x46\x26\x4F\x1A\x63\x0C\xB9"
           "\xEE\x8F\xC7\x8E\x61\x24\xD0\xFB\xD4\x33\x00\xFD\x85\x23\x8B\x12"
           "\x09\x49\x7D\xA8\xE2\x9D\x2E\xFD"
           , 680);
    nSKLen = 680;
    memset(bData, 0x42, 144);
    bData[0] = 0x30;
    bData[143] = 0x39;
    nDataLen = 144;
    memcpy(bSignExp,
           "\x19\x06\x61\x75\x56\x03\xE3\xC2\x1F\xEC\xF9\x89\x9E\xB9\xD4\xCA"
           "\x9F\x19\x10\x62\xFB\xE5\x38\x17\xA6\xB6\x4F\x3E\x2E\x88\xED\x12"
           "\x6C\xCC\x9E\xB2\xB4\xD1\x6F\x4C\xA0\x3F\x41\xCF\xCC\x9D\xFC\x15"
           "\xCF\x54\x6B\xC6\x8C\x72\x77\xF8\xE1\x3D\x51\xC6\xC8\x38\xBE\xC8"
           "\x4D\x70\x78\x06\xEE\xC1\xF5\x12\xEB\xE7\x54\xBA\x11\x1E\xC5\x73"
           "\xD7\x8F\x0A\x27\xAE\x80\x63\xDC\xE9\xE2\x00\x7D\x9C\x06\xB6\xE4"
           "\xDE\x1C\x7A\xEC\xE1\x11\xCF\x93\x91\x56\x77\x38\x4E\x23\xB2\x72"
           "\x25\x13\xDF\x41\xF4\x03\xD5\xA9\x01\xEB\x02\x5E\x9C\xA5\xD0\x63"
           "\x01\x1D\xFB\x33\xC1\xFB\x1A\x59\xBE\xFB\xF1\x81\x47\xD8\x1F\x18"
           , 144);
    nSignLenExp = 144;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 680);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 144);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1152，SHA-224，PKCS#1填充，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bSign    =", bSign, 144);
    DspHex("[OUT]bSignExp =", bSignExp, 144);
    ASSERT_OUT_HEX(bSign, bSignExp, 144);
    ASSERT_OUT(nSignLen, nSignLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_16(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 3;
    nPadMode = 1;
    memcpy(bSK,
           "\xDF\x00\x50\x67\x45\x67\xCB\xA9\xF3\x62\x34\x84\x08\x05\xEE\x96"
           "\x70\x77\x07\xC3\x71\x70\xAD\xC0\xE9\x02\xE7\x50\x58\xCB\x00\xCF"
           "\x55\xAA\xB9\xE0\x3D\x47\x8D\xC8\x38\x3A\x78\x92\xB2\x54\x98\xEF"
           "\x5A\x46\x80\x77\x58\x05\x1E\x94\xA8\x62\xE6\xFA\x5C\x54\x15\x48"
           "\x2D\xDB\x8C\x41\x31\x90\x9F\xE9\x4D\x87\x7A\x21\xB9\xA3\x13\xE5"
           "\xE0\xED\x09\x27\x17\xB6\xB1\xAA\x23\xBE\x5F\x80\x9F\x25\xF2\xE1"
           "\x7A\xB2\xCB\x36\xF2\xE5\x2A\x6F\x63\xD1\x4C\xD6\x53\x07\xBF\x83"
           "\x4F\x59\xE1\x20\x63\x9C\x33\x38\x88\xD3\x79\x7D\xF1\x47\x6E\x16"
           "\x3F\x38\xF3\xCF\x0D\x25\xF4\xD5\x28\x76\x55\x5C\x22\x54\x1B\xAD"
           "\xCC\xB6\x21\x81\xFC\x32\xE0\xCF\x8C\x30\x3A\x96\x31\x48\x02\x7E"
           "\x0E\x2A\x4B\x99\x46\x5C\xCA\x23\x82\x41\xA6\x9B\x8A\x71\xF4\x4E"
           "\x7A\xCF\xBE\x9D\xEC\x18\x90\x04\xF2\x6F\x9F\xD9\x76\xFD\x43\x17"
           "\x81\xF0\xD7\xB8\x1B\xE6\x7C\xBB\x5F\xB9\x9D\x8E\x96\x4D\xC5\xE3"
           "\x7A\x98\xBA\x11\x2B\x52\x62\xA3\x48\x6F\x9C\x8F\x3F\x4A\x88\xF4"
           "\xEA\x82\x59\xBD\x2D\x55\x06\x8F\x51\x8D\x37\xA0\xB0\xF4\xA7\x23"
           "\x76\x86\xFF\x68\xEA\x6C\x64\xFE\xC0\xCD\x6C\x48\x20\xCB\xD2\x77"
           "\x31\x73\xD8\x50\x5A\x13\x84\x98\x8D\x0A\xF1\xB9\x8A\xD8\x87\x54"
           "\xDC\xB4\xBA\x6A\x0E\x7D\x04\x4D\x7C\x6C\xF6\xE3\x50\x65\xEF\xC2"
           "\x9C\x70\x39\x70\x99\x60\x53\x70\x88\x1D\xA2\x56\x1A\x78\xB8\x15"
           "\x17\x81\x3F\xEC\x07\x0A\xE0\x33\x7A\x82\x0B\xE2\x21\x53\x1B\x27"
           "\x7C\x06\x69\x00\x82\xB3\xAB\x74\xE9\x43\xDD\xCC\x69\x2C\xF8\x51"
           "\xAF\xEB\xEE\x15\x6E\xE0\x35\xA8\x6A\x0D\x35\x8A\x01\x98\x68\x8A"
           "\xC5\x71\xAA\x8C\xDB\x31\xC7\x04\x5D\xEF\x33\x50\x1A\x66\xC9\xBF"
           "\x85\xE8\x30\xBF\x8E\x36\x86\xA3\xB0\xBF\x18\x8E\xA0\x93\xB3\x5C"
           "\xD2\xD3\x6E\x57\x86\x14\x30\x5D\xC5\x29\x0B\x5A\xEF\xEA\xA3\x9C"
           "\xC0\xDD\x9B\xDF\x67\xB9\xAF\x01\xC4\x0C\x83\xE1\x36\x95\x4E\xB6"
           "\xF2\x61\x4F\xB8\x09\x8E\x66\x90\x23\xE7\x6D\xD1\x71\xF4\xF4\xE7"
           "\xF4\x3B\x54\x8D\x91\x05\x89\xB5\xFE\x78\xBA\x30\x87\xF5\xB5\xE6"
           "\xE8\x55\x5B\xCA\x64\xAF\x89\x59\xA0\x50\x8A\x7D\x19\x40\xDF\x49"
           "\x31\xEA\xEF\x76\x70\x2E\x1F\xC7\x05\x7E\xA0\x2A\x42\x17\xA2\x0A"
           "\x32\xAC\x36\x7F\x31\xFF\x11\xED\x06\x13\x03\xC6\xDF\xEF\xC4\x27"
           "\x8C\x29\xE3\x36\xE6\xDE\xBC\xE8\x7B\xB5\x7B\x9A\xCB\x93\xF1\x21"
           "\x26\x38\x94\xDA\xF5\x1B\xD7\x2F\xA9\x3C\xEC\xE3\xDC\xD6\xD8\xFC"
           "\x03\x4D\xE1\x49\xA2\x22\x6E\xFD\x57\x80\xAB\xF4\xFA\xD5\xC2\x53"
           "\xCE\x6D\xB2\x61\xE3\xA8\x22\xD8\xD2\x9C\xFE\x85\xE2\x80\xA0\x9D"
           "\x1E\xAF\x00\x3F\xF2\x36\xE1\xE5\xBC\x32\x73\x7E\xD0\x6E\x18\x66"
           "\x48\x64\x91\x0E\xB6\x70\x82\xAA\x40\xFA\x2D\xB5\x27\x0A\x71\x17"
           "\x15\x96\xD4\x2B\xEF\xB4\x82\xA2\x4C\x7C\x08\x2B\x9E\xD6\x99\x56"
           "\x20\x08\xCD\x7D\x6B\x5E\x38\x53\x67\x13\x38\xED\x16\x44\x71\x12"
           "\x97\x4B\x84\xE7\xCE\x12\x53\x70\x46\x6A\x71\x51\xAD\x8B\x71\x2D"
           "\xE5\x4C\xF7\xFF\xCE\x39\xB3\xA0\xB1\x46\x26\x4F\x1A\x63\x0C\xB9"
           "\xEE\x8F\xC7\x8E\x61\x24\xD0\xFB\xD4\x33\x00\xFD\x85\x23\x8B\x12"
           "\x09\x49\x7D\xA8\xE2\x9D\x2E\xFD"
           , 680);
    nSKLen = 680;
    memset(bData, 0x42, 144);
    bData[0] = 0x30;
    bData[143] = 0x39;
    nDataLen = 144;
    memcpy(bSignExp,
           "\x88\xF8\x24\x38\x51\x2B\xF7\x2F\xCD\x76\xE3\x1E\x7D\x42\xB4\x96"
           "\x51\x9C\x2B\xD9\x0D\xE8\x09\xDA\x6F\x60\x6E\xBF\x5A\x73\x81\xE2"
           "\x47\xAE\x2E\x7E\x8B\x77\x25\xC9\x65\x16\xC4\xF2\xA0\xB1\x23\xA3"
           "\xAB\x92\xA6\xA0\x6B\xFC\xB2\x9F\x44\x1E\x61\x37\xB7\xF2\x81\x69"
           "\xE5\xB0\xA0\xE1\xE1\x4D\xED\x1C\xF4\x87\x72\xB2\x0E\x39\xE7\xC0"
           "\x73\xA6\x32\x0B\xFF\x4F\x6B\xB7\xE1\x80\x4F\x0A\x04\xF0\x33\x87"
           "\x86\x45\xD5\xFB\xF0\xB6\x99\x75\xCF\x9B\x44\x07\x02\x75\xA3\x15"
           "\x7E\x17\x71\x70\x6A\xCD\xFE\xAA\x50\x6B\x79\x91\x2E\x50\x70\xCF"
           "\x13\x10\xD0\x12\x96\x7F\xAD\x03\xFD\x1E\x0C\xD7\x1D\x55\x8B\x85"
           , 144);
    nSignLenExp = 144;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 680);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 144);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1152，SHA-256，PKCS#1填充，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bSign    =", bSign, 144);
    DspHex("[OUT]bSignExp =", bSignExp, 144);
    ASSERT_OUT_HEX(bSign, bSignExp, 144);
    ASSERT_OUT(nSignLen, nSignLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_17(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 4;
    nPadMode = 1;
    memcpy(bSK,
           "\xDF\x00\x50\x67\x45\x67\xCB\xA9\xF3\x62\x34\x84\x08\x05\xEE\x96"
           "\x70\x77\x07\xC3\x71\x70\xAD\xC0\xE9\x02\xE7\x50\x58\xCB\x00\xCF"
           "\x55\xAA\xB9\xE0\x3D\x47\x8D\xC8\x38\x3A\x78\x92\xB2\x54\x98\xEF"
           "\x5A\x46\x80\x77\x58\x05\x1E\x94\xA8\x62\xE6\xFA\x5C\x54\x15\x48"
           "\x2D\xDB\x8C\x41\x31\x90\x9F\xE9\x4D\x87\x7A\x21\xB9\xA3\x13\xE5"
           "\xE0\xED\x09\x27\x17\xB6\xB1\xAA\x23\xBE\x5F\x80\x9F\x25\xF2\xE1"
           "\x7A\xB2\xCB\x36\xF2\xE5\x2A\x6F\x63\xD1\x4C\xD6\x53\x07\xBF\x83"
           "\x4F\x59\xE1\x20\x63\x9C\x33\x38\x88\xD3\x79\x7D\xF1\x47\x6E\x16"
           "\x3F\x38\xF3\xCF\x0D\x25\xF4\xD5\x28\x76\x55\x5C\x22\x54\x1B\xAD"
           "\xCC\xB6\x21\x81\xFC\x32\xE0\xCF\x8C\x30\x3A\x96\x31\x48\x02\x7E"
           "\x0E\x2A\x4B\x99\x46\x5C\xCA\x23\x82\x41\xA6\x9B\x8A\x71\xF4\x4E"
           "\x7A\xCF\xBE\x9D\xEC\x18\x90\x04\xF2\x6F\x9F\xD9\x76\xFD\x43\x17"
           "\x81\xF0\xD7\xB8\x1B\xE6\x7C\xBB\x5F\xB9\x9D\x8E\x96\x4D\xC5\xE3"
           "\x7A\x98\xBA\x11\x2B\x52\x62\xA3\x48\x6F\x9C\x8F\x3F\x4A\x88\xF4"
           "\xEA\x82\x59\xBD\x2D\x55\x06\x8F\x51\x8D\x37\xA0\xB0\xF4\xA7\x23"
           "\x76\x86\xFF\x68\xEA\x6C\x64\xFE\xC0\xCD\x6C\x48\x20\xCB\xD2\x77"
           "\x31\x73\xD8\x50\x5A\x13\x84\x98\x8D\x0A\xF1\xB9\x8A\xD8\x87\x54"
           "\xDC\xB4\xBA\x6A\x0E\x7D\x04\x4D\x7C\x6C\xF6\xE3\x50\x65\xEF\xC2"
           "\x9C\x70\x39\x70\x99\x60\x53\x70\x88\x1D\xA2\x56\x1A\x78\xB8\x15"
           "\x17\x81\x3F\xEC\x07\x0A\xE0\x33\x7A\x82\x0B\xE2\x21\x53\x1B\x27"
           "\x7C\x06\x69\x00\x82\xB3\xAB\x74\xE9\x43\xDD\xCC\x69\x2C\xF8\x51"
           "\xAF\xEB\xEE\x15\x6E\xE0\x35\xA8\x6A\x0D\x35\x8A\x01\x98\x68\x8A"
           "\xC5\x71\xAA\x8C\xDB\x31\xC7\x04\x5D\xEF\x33\x50\x1A\x66\xC9\xBF"
           "\x85\xE8\x30\xBF\x8E\x36\x86\xA3\xB0\xBF\x18\x8E\xA0\x93\xB3\x5C"
           "\xD2\xD3\x6E\x57\x86\x14\x30\x5D\xC5\x29\x0B\x5A\xEF\xEA\xA3\x9C"
           "\xC0\xDD\x9B\xDF\x67\xB9\xAF\x01\xC4\x0C\x83\xE1\x36\x95\x4E\xB6"
           "\xF2\x61\x4F\xB8\x09\x8E\x66\x90\x23\xE7\x6D\xD1\x71\xF4\xF4\xE7"
           "\xF4\x3B\x54\x8D\x91\x05\x89\xB5\xFE\x78\xBA\x30\x87\xF5\xB5\xE6"
           "\xE8\x55\x5B\xCA\x64\xAF\x89\x59\xA0\x50\x8A\x7D\x19\x40\xDF\x49"
           "\x31\xEA\xEF\x76\x70\x2E\x1F\xC7\x05\x7E\xA0\x2A\x42\x17\xA2\x0A"
           "\x32\xAC\x36\x7F\x31\xFF\x11\xED\x06\x13\x03\xC6\xDF\xEF\xC4\x27"
           "\x8C\x29\xE3\x36\xE6\xDE\xBC\xE8\x7B\xB5\x7B\x9A\xCB\x93\xF1\x21"
           "\x26\x38\x94\xDA\xF5\x1B\xD7\x2F\xA9\x3C\xEC\xE3\xDC\xD6\xD8\xFC"
           "\x03\x4D\xE1\x49\xA2\x22\x6E\xFD\x57\x80\xAB\xF4\xFA\xD5\xC2\x53"
           "\xCE\x6D\xB2\x61\xE3\xA8\x22\xD8\xD2\x9C\xFE\x85\xE2\x80\xA0\x9D"
           "\x1E\xAF\x00\x3F\xF2\x36\xE1\xE5\xBC\x32\x73\x7E\xD0\x6E\x18\x66"
           "\x48\x64\x91\x0E\xB6\x70\x82\xAA\x40\xFA\x2D\xB5\x27\x0A\x71\x17"
           "\x15\x96\xD4\x2B\xEF\xB4\x82\xA2\x4C\x7C\x08\x2B\x9E\xD6\x99\x56"
           "\x20\x08\xCD\x7D\x6B\x5E\x38\x53\x67\x13\x38\xED\x16\x44\x71\x12"
           "\x97\x4B\x84\xE7\xCE\x12\x53\x70\x46\x6A\x71\x51\xAD\x8B\x71\x2D"
           "\xE5\x4C\xF7\xFF\xCE\x39\xB3\xA0\xB1\x46\x26\x4F\x1A\x63\x0C\xB9"
           "\xEE\x8F\xC7\x8E\x61\x24\xD0\xFB\xD4\x33\x00\xFD\x85\x23\x8B\x12"
           "\x09\x49\x7D\xA8\xE2\x9D\x2E\xFD"
           , 680);
    nSKLen = 680;
    memset(bData, 0x42, 144);
    bData[0] = 0x30;
    bData[143] = 0x39;
    nDataLen = 144;
    memcpy(bSignExp,
           "\x58\x74\x13\x6A\xAC\x21\x01\x19\x49\xD8\x0B\x47\xF6\x46\xB4\x49"
           "\x6F\x4E\x3B\xF8\x1F\xA2\x76\xDC\xBD\x8E\x06\xCC\x07\x76\x17\x25"
           "\x05\x60\x32\x9E\xFA\x1F\x14\xA8\x9D\x45\xEC\x59\x40\x0F\xA1\xBA"
           "\x39\x4D\xE0\x14\xAC\x22\x84\x52\x56\x23\xED\xA2\xCA\x76\x3D\xA5"
           "\x75\xCC\x54\x2E\xEA\x91\x77\x16\x5A\x6A\x7A\xD7\xE8\xAA\x17\xE0"
           "\xDA\xD4\xCB\x18\xAF\x39\x43\x58\x5D\x15\xCC\x56\x58\x44\xB0\x51"
           "\x8A\x13\x02\x91\xEA\xA3\xBC\x8D\xB7\xB2\xD2\x4E\x26\xEA\xFF\xB9"
           "\xAC\xB7\x39\x2F\x2D\xCB\x8A\xD2\xBD\x29\xC1\xE9\x88\xC1\xD2\xC7"
           "\x4A\xDA\xB8\x54\x28\x9D\xA6\xC3\x1E\xDA\x87\x1F\xAC\x71\xE9\x7B"
           , 144);
    nSignLenExp = 144;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 680);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 144);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1152，SHA-384，PKCS#1填充，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bSign    =", bSign, 144);
    DspHex("[OUT]bSignExp =", bSignExp, 144);
    ASSERT_OUT_HEX(bSign, bSignExp, 144);
    ASSERT_OUT(nSignLen, nSignLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_18(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 5;
    nPadMode = 1;
    memcpy(bSK,
           "\xDF\x00\x50\x67\x45\x67\xCB\xA9\xF3\x62\x34\x84\x08\x05\xEE\x96"
           "\x70\x77\x07\xC3\x71\x70\xAD\xC0\xE9\x02\xE7\x50\x58\xCB\x00\xCF"
           "\x55\xAA\xB9\xE0\x3D\x47\x8D\xC8\x38\x3A\x78\x92\xB2\x54\x98\xEF"
           "\x5A\x46\x80\x77\x58\x05\x1E\x94\xA8\x62\xE6\xFA\x5C\x54\x15\x48"
           "\x2D\xDB\x8C\x41\x31\x90\x9F\xE9\x4D\x87\x7A\x21\xB9\xA3\x13\xE5"
           "\xE0\xED\x09\x27\x17\xB6\xB1\xAA\x23\xBE\x5F\x80\x9F\x25\xF2\xE1"
           "\x7A\xB2\xCB\x36\xF2\xE5\x2A\x6F\x63\xD1\x4C\xD6\x53\x07\xBF\x83"
           "\x4F\x59\xE1\x20\x63\x9C\x33\x38\x88\xD3\x79\x7D\xF1\x47\x6E\x16"
           "\x3F\x38\xF3\xCF\x0D\x25\xF4\xD5\x28\x76\x55\x5C\x22\x54\x1B\xAD"
           "\xCC\xB6\x21\x81\xFC\x32\xE0\xCF\x8C\x30\x3A\x96\x31\x48\x02\x7E"
           "\x0E\x2A\x4B\x99\x46\x5C\xCA\x23\x82\x41\xA6\x9B\x8A\x71\xF4\x4E"
           "\x7A\xCF\xBE\x9D\xEC\x18\x90\x04\xF2\x6F\x9F\xD9\x76\xFD\x43\x17"
           "\x81\xF0\xD7\xB8\x1B\xE6\x7C\xBB\x5F\xB9\x9D\x8E\x96\x4D\xC5\xE3"
           "\x7A\x98\xBA\x11\x2B\x52\x62\xA3\x48\x6F\x9C\x8F\x3F\x4A\x88\xF4"
           "\xEA\x82\x59\xBD\x2D\x55\x06\x8F\x51\x8D\x37\xA0\xB0\xF4\xA7\x23"
           "\x76\x86\xFF\x68\xEA\x6C\x64\xFE\xC0\xCD\x6C\x48\x20\xCB\xD2\x77"
           "\x31\x73\xD8\x50\x5A\x13\x84\x98\x8D\x0A\xF1\xB9\x8A\xD8\x87\x54"
           "\xDC\xB4\xBA\x6A\x0E\x7D\x04\x4D\x7C\x6C\xF6\xE3\x50\x65\xEF\xC2"
           "\x9C\x70\x39\x70\x99\x60\x53\x70\x88\x1D\xA2\x56\x1A\x78\xB8\x15"
           "\x17\x81\x3F\xEC\x07\x0A\xE0\x33\x7A\x82\x0B\xE2\x21\x53\x1B\x27"
           "\x7C\x06\x69\x00\x82\xB3\xAB\x74\xE9\x43\xDD\xCC\x69\x2C\xF8\x51"
           "\xAF\xEB\xEE\x15\x6E\xE0\x35\xA8\x6A\x0D\x35\x8A\x01\x98\x68\x8A"
           "\xC5\x71\xAA\x8C\xDB\x31\xC7\x04\x5D\xEF\x33\x50\x1A\x66\xC9\xBF"
           "\x85\xE8\x30\xBF\x8E\x36\x86\xA3\xB0\xBF\x18\x8E\xA0\x93\xB3\x5C"
           "\xD2\xD3\x6E\x57\x86\x14\x30\x5D\xC5\x29\x0B\x5A\xEF\xEA\xA3\x9C"
           "\xC0\xDD\x9B\xDF\x67\xB9\xAF\x01\xC4\x0C\x83\xE1\x36\x95\x4E\xB6"
           "\xF2\x61\x4F\xB8\x09\x8E\x66\x90\x23\xE7\x6D\xD1\x71\xF4\xF4\xE7"
           "\xF4\x3B\x54\x8D\x91\x05\x89\xB5\xFE\x78\xBA\x30\x87\xF5\xB5\xE6"
           "\xE8\x55\x5B\xCA\x64\xAF\x89\x59\xA0\x50\x8A\x7D\x19\x40\xDF\x49"
           "\x31\xEA\xEF\x76\x70\x2E\x1F\xC7\x05\x7E\xA0\x2A\x42\x17\xA2\x0A"
           "\x32\xAC\x36\x7F\x31\xFF\x11\xED\x06\x13\x03\xC6\xDF\xEF\xC4\x27"
           "\x8C\x29\xE3\x36\xE6\xDE\xBC\xE8\x7B\xB5\x7B\x9A\xCB\x93\xF1\x21"
           "\x26\x38\x94\xDA\xF5\x1B\xD7\x2F\xA9\x3C\xEC\xE3\xDC\xD6\xD8\xFC"
           "\x03\x4D\xE1\x49\xA2\x22\x6E\xFD\x57\x80\xAB\xF4\xFA\xD5\xC2\x53"
           "\xCE\x6D\xB2\x61\xE3\xA8\x22\xD8\xD2\x9C\xFE\x85\xE2\x80\xA0\x9D"
           "\x1E\xAF\x00\x3F\xF2\x36\xE1\xE5\xBC\x32\x73\x7E\xD0\x6E\x18\x66"
           "\x48\x64\x91\x0E\xB6\x70\x82\xAA\x40\xFA\x2D\xB5\x27\x0A\x71\x17"
           "\x15\x96\xD4\x2B\xEF\xB4\x82\xA2\x4C\x7C\x08\x2B\x9E\xD6\x99\x56"
           "\x20\x08\xCD\x7D\x6B\x5E\x38\x53\x67\x13\x38\xED\x16\x44\x71\x12"
           "\x97\x4B\x84\xE7\xCE\x12\x53\x70\x46\x6A\x71\x51\xAD\x8B\x71\x2D"
           "\xE5\x4C\xF7\xFF\xCE\x39\xB3\xA0\xB1\x46\x26\x4F\x1A\x63\x0C\xB9"
           "\xEE\x8F\xC7\x8E\x61\x24\xD0\xFB\xD4\x33\x00\xFD\x85\x23\x8B\x12"
           "\x09\x49\x7D\xA8\xE2\x9D\x2E\xFD"
           , 680);
    nSKLen = 680;
    memset(bData, 0x42, 2048);
    bData[0] = 0x30;
    bData[2047] = 0x39;
    nDataLen = 2048;
    memcpy(bSignExp,
           "\x50\xF6\x7F\x08\x75\x23\x88\x97\x4E\x07\x45\xC8\xA3\xDA\x95\x9A"
           "\xD7\xAA\xAA\x96\x1C\x98\x24\x8E\x2E\xCA\x29\xC3\xFD\xB7\x41\xDE"
           "\x29\x7E\xB7\xC6\x60\xF7\x53\x24\xCF\xAA\x20\x05\x93\xC1\x85\x28"
           "\xD1\x0A\x9A\x94\x03\x18\x94\xA7\x72\xFE\xD0\x8A\x1D\x35\x05\x3A"
           "\x0D\x82\x71\xE4\xFC\x40\x7F\x78\xB0\x8B\x8A\x62\xB4\x92\xD3\xE6"
           "\xC2\x9C\xF4\xA0\x79\xF7\xA7\x76\xA8\x84\xF5\x4F\x9F\x57\x3F\x72"
           "\x5B\x7F\xDB\x15\xEB\xEB\x6D\xF3\x54\x90\x85\x74\x4A\x09\x8C\x5B"
           "\x5C\x1C\xBB\x01\xE0\x8F\x45\xF1\x24\xDE\x79\x39\xE0\x9A\x16\x51"
           "\x00\x8E\x94\x12\x58\xF4\x45\x9E\x45\x7B\x71\x2D\x13\x8D\x54\x3D"
           , 144);
    nSignLenExp = 144;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 680);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 2048);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1152，SHA-512，PKCS#1填充，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bSign    =", bSign, 144);
    DspHex("[OUT]bSignExp =", bSignExp, 144);
    ASSERT_OUT_HEX(bSign, bSignExp, 144);
    ASSERT_OUT(nSignLen, nSignLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_19(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 0;
    nPadMode = 1;
    memcpy(bSK,
           "\x21\xE5\x82\xE3\xD4\x2B\x83\xA7\x68\x16\x92\xEF\x49\x12\x6D\x45"
           "\xC5\x11\xC5\x1E\x9E\x67\x6F\xF9\x04\x47\x04\x31\x37\x69\xFD\x3D"
           "\x6C\x60\x8F\x08\xC7\xF3\xF1\x69\xDF\xCC\x66\x75\xEA\xB0\x61\x33"
           "\xAF\x7A\x12\x41\x94\x5A\x51\x39\xB5\xBE\xE7\x4C\x9D\x98\x77\x80"
           "\x6C\xB9\x2B\x98\x4E\x55\xEC\x57\x0E\x8A\x1F\xA8\x52\xDE\x44\xC5"
           "\x08\x2F\x21\xD9\x0E\xDD\xB5\x5E\xF3\xA1\x8C\xF1\xC3\xCB\x0A\x18"
           "\xD3\x80\x83\x10\xEB\x2E\x99\x59\x45\x7D\x2B\x92\xF5\x22\x7B\x49"
           "\x67\x02\x84\x5F\x56\x56\xBC\x95\x04\xA4\xB7\xB7\x53\xAE\x19\xF1"
           "\xF8\x7C\x3D\xEA\xDA\xDF\x52\x99\xF5\xB4\x15\xAB\x03\x8B\xBD\x6B"
           "\xC0\x8C\x86\xFC\x56\xCC\x3C\x0C\x38\x31\xBD\xB7\x28\x29\xAC\x0E"
           "\x24\xF2\x12\x6E\x6A\xFC\x01\x1C\x18\xC6\x3A\xCD\xD8\x0A\x64\x27"
           "\x93\x9D\x76\xAA\x27\x42\x7E\xEF\xFB\x83\x2A\xB5\xF3\xD0\x15\xC8"
           "\xEF\xF4\x3E\x5B\x5F\x3B\x4F\x96\x2C\x76\x6A\xD6\x69\xD7\x57\xC1"
           "\xF6\x40\xDF\x49\x7B\x4A\x9B\xE2\x7A\xE3\x09\x8B\xC9\x47\xA9\x14"
           "\x5F\x1D\xC1\x4A\x7F\x9D\xCF\xEF\x7D\x1A\x91\x6F\xC7\xA0\x41\x7F"
           "\x7B\xC3\x15\x00\xEC\x53\x34\x22\x95\xEE\xE7\x08\x39\x63\xF5\x54"
           "\xB6\xAD\x39\x45\xB5\x21\x5C\x34\x5E\x67\x7B\xD8\x97\x50\x91\x75"
           "\x6F\x68\x0A\x95\x8F\x24\xBE\x83\xDB\x44\x91\xE0\xD2\x99\x24\x99"
           "\xBD\x11\x2E\x15\xA9\xCC\xCD\x14\xD9\xBB\x5E\x56\x0F\x69\x9A\x18"
           "\x5A\x42\x25\xB1\x3F\x6B\x03\x18\x51\x9C\x36\x8F\xDB\x1E\xB9\x11"
           "\x3A\xEF\x24\xDB\x9B\x2E\xA2\x1B\x11\x73\x86\x5A\x4C\x12\x4F\xD8"
           "\xCB\x07\xEE\x99\xAC\x04\x10\x2B\x1C\xD7\xB8\xEB\xE7\x56\x2C\x8A"
           "\x12\x36\xDD\xA0\x11\x9D\xC8\x26\x37\x66\x0B\x21\x89\xC3\x7D\xA1"
           "\x40\x85\x91\xFF\x5E\x80\x70\xFB\x68\x28\x03\x8A\x6F\x09\xBC\xD6"
           "\xAC\xAF\xF4\x60\x67\x8D\xA8\x3E\x17\x5B\x5A\xE9\x3E\x17\xA9\x34"
           "\xA9\xD7\x29\xBE\xBE\xE3\xCD\x09\x74\x23\xC7\x21\xEE\xA2\x63\xA2"
           "\x33\x64\x92\x53\x31\x74\xF2\x96\x0C\xD0\x11\x30\xB6\x9F\xE0\xBA"
           "\x5B\x4C\xFA\xA0\xBB\x83\x1C\x74\xD8\x70\xE0\x4B\x2A\xAA\xBD\x88"
           "\x4A\x1E\xB5\x22\x63\xD7\x2E\xBD\xA4\x8E\x6C\xA3\x10\x29\xE8\x29"
           "\xA8\x43\x89\x66\xB7\x7E\x3D\xBE\x8C\xE3\xFC\x5A\xBF\x06\x0B\xCC"
           "\x34\x91\x9D\xE3\x85\x1D\xB7\x39\x03\xC3\x0C\x05\x17\xA4\x8D\xE0"
           "\xB3\x9E\x01\xF7\x80\xF4\xBB\xF0\x22\x23\xDA\xBD\xC4\x14\xBB\x78"
           "\x58\xC5\x7F\xC6\x09\x41\x54\xBB\x11\x96\xE6\xA3\x1A\xC9\x55\xBD"
           "\x0F\xF0\x3F\xBE\x61\x83\xCE\x26\x82\xA2\x8E\xD5\x0D\x2D\xB7\x66"
           "\xBC\x2E\xF0\xEB\xC3\x2F\x6A\x2A\xF5\xB9\x8B\xF0\x42\x4F\x65\x8B"
           "\xD1\x6E\x76\x88\x8C\x29\x34\xCF\x26\x27\x84\x8E\x6B\xA2\xEB\x16"
           "\x77\x2D\x21\x7E\xEC\x18\x4D\x04\xDA\xEF\x95\x1C\x29\x75\x18\x1C"
           "\x83\xCA\xB6\x72\xC3\x77\x46\x29\xBB\xFC\xDE\x1D\x78\x72\x76\x47"
           "\x20\x40\x90\xDC\xBC\xA3\x72\x33\x64\x7E\x18\xD9\xA4\xD2\x46\x9C"
           "\x77\x8B\xF9\x6D\x97\xB0\xD6\xA1\x20\x2C\x0D\xB6\xE3\x2C\x09\x8F"
           "\x07\xB6\x5F\xD3\xDB\x3B\xFD\x77\x69\x7D\x56\xE4\x35\x18\x3A\x9B"
           "\xF6\x22\x3A\x01\x35\x71\xBE\xA4\x48\x97\x8B\x45\x90\x46\x07\x0E"
           "\x17\x68\x9E\x00\x11\x6F\x4A\x25\x55\xA0\x9C\x74\xD9\x15\xFF\xF5"
           "\xE0\x59\xD6\x86\xA0\x91\xD8\x7F\x9A\xFF\xE4\xBD\xAB\xE3\xF0\x94"
           "\x49\x66\x36\x7F\xD3\xD3\x8E\x13\xB7\xFC\x89\xB7\xA9\x3C\x7B\x0E"
           "\x11\xAC\x66\xCE\x34\x34\xAE\x67\x70\xE0\x3A\xB6\x0E\x78\xFD\x94"
           "\xF1\xB5\x74\xD3\x47\x2A\x74\x40\x51\x39\xD1\x49\x73\x94\xB4\xF9"
           "\x4C\xB6\x4B\x11\x19\x2F\x7E\x34\x3E\x6B\x4F\x34\x5B\x83\x52\x47"
           "\x99\x0C\xD6\xDF\x7B\xA3\x95\xE2\xCC\x39\x2F\xC4\x92\x43\x38\x2F"
           "\xCB\xE6\x8C\x2D\xAD\xD0\x5E\xE9\xD5\x3D\x5E\x70\x2E\xA8\x66\xB0"
           "\xA6\xB8\x7C\xA4\x3A\x9E\x28\x3B\x0E\x46\x20\x84\xF8\x5E\x53\x9E"
           "\xCF\xDE\xF3\x0F\x1F\xE3\x8D\x51"
           , 824);
    nSKLen = 824;
    memset(bData, 0x42, 1);
    nDataLen = 1;
    memcpy(bSignExp,
           "\x9A\x13\x07\x6E\xAF\x92\x98\xA5\x81\xA8\x7C\x4A\x74\xBC\x6A\x64"
           "\x98\x64\xBD\x93\x48\x60\x9B\xCC\x3F\x65\x7F\xC2\x76\x63\xA1\x53"
           "\x79\x74\x55\x17\xFF\xD6\x59\x59\xF3\xAF\x28\x30\x1A\x03\x95\x94"
           "\x82\x50\xF1\xAE\xD8\x84\xA9\xF7\x45\xA5\x51\x9E\x0F\x4D\xC2\xF0"
           "\x12\x26\x4D\xA3\x7E\xB1\x1A\xA3\x5B\xED\xBA\xB7\xA7\xAF\x37\x07"
           "\xFA\xA8\xCE\xB2\xDB\x0F\x85\x1C\xA1\xEA\x2D\x76\xCE\x0D\xBC\x92"
           "\x39\xD4\x0C\x2C\x82\x92\x05\xF2\xC1\x36\xB4\x16\x86\x39\x36\xF6"
           "\x66\x69\x83\x62\x36\x68\x03\x27\x1A\xB5\xEC\x7F\xC3\x87\x0D\x45"
           "\xCB\x9F\xB6\x72\xED\xAF\xE0\x21\x2E\x97\x55\x64\x29\x40\xFC\x81"
           "\x7B\xDF\x4A\x12\x7B\x78\x11\x29\x04\xE4\x46\x7F\xC0\x94\x97\xE0"
           "\x2F\x4B\x8D\x3A\x9A\x52\x7A\x64\x90\x4A\x85\x8B\x99\xD1\xBD\x90"
           , 176);
    nSignLenExp = 176;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 824);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 1);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1408，MD5，PKCS#1填充，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bSign    =", bSign, 176);
    DspHex("[OUT]bSignExp =", bSignExp, 176);
    ASSERT_OUT_HEX(bSign, bSignExp, 176);
    ASSERT_OUT(nSignLen, nSignLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_20(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 1;
    nPadMode = 1;
    memcpy(bSK,
           "\x21\xE5\x82\xE3\xD4\x2B\x83\xA7\x68\x16\x92\xEF\x49\x12\x6D\x45"
           "\xC5\x11\xC5\x1E\x9E\x67\x6F\xF9\x04\x47\x04\x31\x37\x69\xFD\x3D"
           "\x6C\x60\x8F\x08\xC7\xF3\xF1\x69\xDF\xCC\x66\x75\xEA\xB0\x61\x33"
           "\xAF\x7A\x12\x41\x94\x5A\x51\x39\xB5\xBE\xE7\x4C\x9D\x98\x77\x80"
           "\x6C\xB9\x2B\x98\x4E\x55\xEC\x57\x0E\x8A\x1F\xA8\x52\xDE\x44\xC5"
           "\x08\x2F\x21\xD9\x0E\xDD\xB5\x5E\xF3\xA1\x8C\xF1\xC3\xCB\x0A\x18"
           "\xD3\x80\x83\x10\xEB\x2E\x99\x59\x45\x7D\x2B\x92\xF5\x22\x7B\x49"
           "\x67\x02\x84\x5F\x56\x56\xBC\x95\x04\xA4\xB7\xB7\x53\xAE\x19\xF1"
           "\xF8\x7C\x3D\xEA\xDA\xDF\x52\x99\xF5\xB4\x15\xAB\x03\x8B\xBD\x6B"
           "\xC0\x8C\x86\xFC\x56\xCC\x3C\x0C\x38\x31\xBD\xB7\x28\x29\xAC\x0E"
           "\x24\xF2\x12\x6E\x6A\xFC\x01\x1C\x18\xC6\x3A\xCD\xD8\x0A\x64\x27"
           "\x93\x9D\x76\xAA\x27\x42\x7E\xEF\xFB\x83\x2A\xB5\xF3\xD0\x15\xC8"
           "\xEF\xF4\x3E\x5B\x5F\x3B\x4F\x96\x2C\x76\x6A\xD6\x69\xD7\x57\xC1"
           "\xF6\x40\xDF\x49\x7B\x4A\x9B\xE2\x7A\xE3\x09\x8B\xC9\x47\xA9\x14"
           "\x5F\x1D\xC1\x4A\x7F\x9D\xCF\xEF\x7D\x1A\x91\x6F\xC7\xA0\x41\x7F"
           "\x7B\xC3\x15\x00\xEC\x53\x34\x22\x95\xEE\xE7\x08\x39\x63\xF5\x54"
           "\xB6\xAD\x39\x45\xB5\x21\x5C\x34\x5E\x67\x7B\xD8\x97\x50\x91\x75"
           "\x6F\x68\x0A\x95\x8F\x24\xBE\x83\xDB\x44\x91\xE0\xD2\x99\x24\x99"
           "\xBD\x11\x2E\x15\xA9\xCC\xCD\x14\xD9\xBB\x5E\x56\x0F\x69\x9A\x18"
           "\x5A\x42\x25\xB1\x3F\x6B\x03\x18\x51\x9C\x36\x8F\xDB\x1E\xB9\x11"
           "\x3A\xEF\x24\xDB\x9B\x2E\xA2\x1B\x11\x73\x86\x5A\x4C\x12\x4F\xD8"
           "\xCB\x07\xEE\x99\xAC\x04\x10\x2B\x1C\xD7\xB8\xEB\xE7\x56\x2C\x8A"
           "\x12\x36\xDD\xA0\x11\x9D\xC8\x26\x37\x66\x0B\x21\x89\xC3\x7D\xA1"
           "\x40\x85\x91\xFF\x5E\x80\x70\xFB\x68\x28\x03\x8A\x6F\x09\xBC\xD6"
           "\xAC\xAF\xF4\x60\x67\x8D\xA8\x3E\x17\x5B\x5A\xE9\x3E\x17\xA9\x34"
           "\xA9\xD7\x29\xBE\xBE\xE3\xCD\x09\x74\x23\xC7\x21\xEE\xA2\x63\xA2"
           "\x33\x64\x92\x53\x31\x74\xF2\x96\x0C\xD0\x11\x30\xB6\x9F\xE0\xBA"
           "\x5B\x4C\xFA\xA0\xBB\x83\x1C\x74\xD8\x70\xE0\x4B\x2A\xAA\xBD\x88"
           "\x4A\x1E\xB5\x22\x63\xD7\x2E\xBD\xA4\x8E\x6C\xA3\x10\x29\xE8\x29"
           "\xA8\x43\x89\x66\xB7\x7E\x3D\xBE\x8C\xE3\xFC\x5A\xBF\x06\x0B\xCC"
           "\x34\x91\x9D\xE3\x85\x1D\xB7\x39\x03\xC3\x0C\x05\x17\xA4\x8D\xE0"
           "\xB3\x9E\x01\xF7\x80\xF4\xBB\xF0\x22\x23\xDA\xBD\xC4\x14\xBB\x78"
           "\x58\xC5\x7F\xC6\x09\x41\x54\xBB\x11\x96\xE6\xA3\x1A\xC9\x55\xBD"
           "\x0F\xF0\x3F\xBE\x61\x83\xCE\x26\x82\xA2\x8E\xD5\x0D\x2D\xB7\x66"
           "\xBC\x2E\xF0\xEB\xC3\x2F\x6A\x2A\xF5\xB9\x8B\xF0\x42\x4F\x65\x8B"
           "\xD1\x6E\x76\x88\x8C\x29\x34\xCF\x26\x27\x84\x8E\x6B\xA2\xEB\x16"
           "\x77\x2D\x21\x7E\xEC\x18\x4D\x04\xDA\xEF\x95\x1C\x29\x75\x18\x1C"
           "\x83\xCA\xB6\x72\xC3\x77\x46\x29\xBB\xFC\xDE\x1D\x78\x72\x76\x47"
           "\x20\x40\x90\xDC\xBC\xA3\x72\x33\x64\x7E\x18\xD9\xA4\xD2\x46\x9C"
           "\x77\x8B\xF9\x6D\x97\xB0\xD6\xA1\x20\x2C\x0D\xB6\xE3\x2C\x09\x8F"
           "\x07\xB6\x5F\xD3\xDB\x3B\xFD\x77\x69\x7D\x56\xE4\x35\x18\x3A\x9B"
           "\xF6\x22\x3A\x01\x35\x71\xBE\xA4\x48\x97\x8B\x45\x90\x46\x07\x0E"
           "\x17\x68\x9E\x00\x11\x6F\x4A\x25\x55\xA0\x9C\x74\xD9\x15\xFF\xF5"
           "\xE0\x59\xD6\x86\xA0\x91\xD8\x7F\x9A\xFF\xE4\xBD\xAB\xE3\xF0\x94"
           "\x49\x66\x36\x7F\xD3\xD3\x8E\x13\xB7\xFC\x89\xB7\xA9\x3C\x7B\x0E"
           "\x11\xAC\x66\xCE\x34\x34\xAE\x67\x70\xE0\x3A\xB6\x0E\x78\xFD\x94"
           "\xF1\xB5\x74\xD3\x47\x2A\x74\x40\x51\x39\xD1\x49\x73\x94\xB4\xF9"
           "\x4C\xB6\x4B\x11\x19\x2F\x7E\x34\x3E\x6B\x4F\x34\x5B\x83\x52\x47"
           "\x99\x0C\xD6\xDF\x7B\xA3\x95\xE2\xCC\x39\x2F\xC4\x92\x43\x38\x2F"
           "\xCB\xE6\x8C\x2D\xAD\xD0\x5E\xE9\xD5\x3D\x5E\x70\x2E\xA8\x66\xB0"
           "\xA6\xB8\x7C\xA4\x3A\x9E\x28\x3B\x0E\x46\x20\x84\xF8\x5E\x53\x9E"
           "\xCF\xDE\xF3\x0F\x1F\xE3\x8D\x51"
           , 824);
    nSKLen = 824;
    memset(bData, 0x42, 176);
    bData[0] = 0x30;
    bData[175] = 0x39;
    nDataLen = 176;
    memcpy(bSignExp,
           "\x26\x57\xD2\x2E\xA8\x97\x76\xEF\xB7\x77\x15\x64\xA2\x11\xEE\xD5"
           "\xA5\x7C\x71\x8A\x5B\x9B\xD7\xA1\xFE\x14\x3B\x09\xFB\x8F\x32\x45"
           "\x81\x35\xBF\x44\xFB\x3B\xE4\xDD\xD3\x78\x98\xC1\xDE\xC1\xC4\xC0"
           "\x09\x16\xCC\xE6\x3A\xA8\x19\x1A\xDE\x27\xB2\xE3\xF3\x35\x48\x36"
           "\x85\xF2\xDB\xCF\xDC\x6B\x3C\xC1\xA5\x8B\xFC\x4B\xC0\x96\x62\xC5"
           "\x11\x67\xF1\x96\xE0\x53\xA0\xC0\x8E\xA9\x3E\xAA\x40\x31\x58\xB3"
           "\x73\x60\x85\x8E\x3A\x0D\x92\x92\x70\xCE\xE1\xB0\xC1\xEE\xA6\xCD"
           "\x6F\xBB\x1F\xD1\x0F\x65\x5C\x8B\x65\xBF\x29\xFC\x6F\x1F\x87\x58"
           "\x78\x9F\x8B\x37\x33\x37\x0A\x4E\x1B\x46\x89\x5C\x2D\x89\x79\xE3"
           "\xB2\x42\x08\xC2\xD7\xF9\x76\xD6\xCB\x5C\xB5\xD3\xF6\xCE\xF3\x04"
           "\xAF\xE6\x22\xD9\x69\x35\x7D\x94\xC7\x09\xBB\x02\x1B\x86\x95\x2C"
           , 176);
    nSignLenExp = 176;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 824);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 176);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1408，SHA-1，PKCS#1填充，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bSign    =", bSign, 176);
    DspHex("[OUT]bSignExp =", bSignExp, 176);
    ASSERT_OUT_HEX(bSign, bSignExp, 176);
    ASSERT_OUT(nSignLen, nSignLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_21(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 2;
    nPadMode = 1;
    memcpy(bSK,
           "\x21\xE5\x82\xE3\xD4\x2B\x83\xA7\x68\x16\x92\xEF\x49\x12\x6D\x45"
           "\xC5\x11\xC5\x1E\x9E\x67\x6F\xF9\x04\x47\x04\x31\x37\x69\xFD\x3D"
           "\x6C\x60\x8F\x08\xC7\xF3\xF1\x69\xDF\xCC\x66\x75\xEA\xB0\x61\x33"
           "\xAF\x7A\x12\x41\x94\x5A\x51\x39\xB5\xBE\xE7\x4C\x9D\x98\x77\x80"
           "\x6C\xB9\x2B\x98\x4E\x55\xEC\x57\x0E\x8A\x1F\xA8\x52\xDE\x44\xC5"
           "\x08\x2F\x21\xD9\x0E\xDD\xB5\x5E\xF3\xA1\x8C\xF1\xC3\xCB\x0A\x18"
           "\xD3\x80\x83\x10\xEB\x2E\x99\x59\x45\x7D\x2B\x92\xF5\x22\x7B\x49"
           "\x67\x02\x84\x5F\x56\x56\xBC\x95\x04\xA4\xB7\xB7\x53\xAE\x19\xF1"
           "\xF8\x7C\x3D\xEA\xDA\xDF\x52\x99\xF5\xB4\x15\xAB\x03\x8B\xBD\x6B"
           "\xC0\x8C\x86\xFC\x56\xCC\x3C\x0C\x38\x31\xBD\xB7\x28\x29\xAC\x0E"
           "\x24\xF2\x12\x6E\x6A\xFC\x01\x1C\x18\xC6\x3A\xCD\xD8\x0A\x64\x27"
           "\x93\x9D\x76\xAA\x27\x42\x7E\xEF\xFB\x83\x2A\xB5\xF3\xD0\x15\xC8"
           "\xEF\xF4\x3E\x5B\x5F\x3B\x4F\x96\x2C\x76\x6A\xD6\x69\xD7\x57\xC1"
           "\xF6\x40\xDF\x49\x7B\x4A\x9B\xE2\x7A\xE3\x09\x8B\xC9\x47\xA9\x14"
           "\x5F\x1D\xC1\x4A\x7F\x9D\xCF\xEF\x7D\x1A\x91\x6F\xC7\xA0\x41\x7F"
           "\x7B\xC3\x15\x00\xEC\x53\x34\x22\x95\xEE\xE7\x08\x39\x63\xF5\x54"
           "\xB6\xAD\x39\x45\xB5\x21\x5C\x34\x5E\x67\x7B\xD8\x97\x50\x91\x75"
           "\x6F\x68\x0A\x95\x8F\x24\xBE\x83\xDB\x44\x91\xE0\xD2\x99\x24\x99"
           "\xBD\x11\x2E\x15\xA9\xCC\xCD\x14\xD9\xBB\x5E\x56\x0F\x69\x9A\x18"
           "\x5A\x42\x25\xB1\x3F\x6B\x03\x18\x51\x9C\x36\x8F\xDB\x1E\xB9\x11"
           "\x3A\xEF\x24\xDB\x9B\x2E\xA2\x1B\x11\x73\x86\x5A\x4C\x12\x4F\xD8"
           "\xCB\x07\xEE\x99\xAC\x04\x10\x2B\x1C\xD7\xB8\xEB\xE7\x56\x2C\x8A"
           "\x12\x36\xDD\xA0\x11\x9D\xC8\x26\x37\x66\x0B\x21\x89\xC3\x7D\xA1"
           "\x40\x85\x91\xFF\x5E\x80\x70\xFB\x68\x28\x03\x8A\x6F\x09\xBC\xD6"
           "\xAC\xAF\xF4\x60\x67\x8D\xA8\x3E\x17\x5B\x5A\xE9\x3E\x17\xA9\x34"
           "\xA9\xD7\x29\xBE\xBE\xE3\xCD\x09\x74\x23\xC7\x21\xEE\xA2\x63\xA2"
           "\x33\x64\x92\x53\x31\x74\xF2\x96\x0C\xD0\x11\x30\xB6\x9F\xE0\xBA"
           "\x5B\x4C\xFA\xA0\xBB\x83\x1C\x74\xD8\x70\xE0\x4B\x2A\xAA\xBD\x88"
           "\x4A\x1E\xB5\x22\x63\xD7\x2E\xBD\xA4\x8E\x6C\xA3\x10\x29\xE8\x29"
           "\xA8\x43\x89\x66\xB7\x7E\x3D\xBE\x8C\xE3\xFC\x5A\xBF\x06\x0B\xCC"
           "\x34\x91\x9D\xE3\x85\x1D\xB7\x39\x03\xC3\x0C\x05\x17\xA4\x8D\xE0"
           "\xB3\x9E\x01\xF7\x80\xF4\xBB\xF0\x22\x23\xDA\xBD\xC4\x14\xBB\x78"
           "\x58\xC5\x7F\xC6\x09\x41\x54\xBB\x11\x96\xE6\xA3\x1A\xC9\x55\xBD"
           "\x0F\xF0\x3F\xBE\x61\x83\xCE\x26\x82\xA2\x8E\xD5\x0D\x2D\xB7\x66"
           "\xBC\x2E\xF0\xEB\xC3\x2F\x6A\x2A\xF5\xB9\x8B\xF0\x42\x4F\x65\x8B"
           "\xD1\x6E\x76\x88\x8C\x29\x34\xCF\x26\x27\x84\x8E\x6B\xA2\xEB\x16"
           "\x77\x2D\x21\x7E\xEC\x18\x4D\x04\xDA\xEF\x95\x1C\x29\x75\x18\x1C"
           "\x83\xCA\xB6\x72\xC3\x77\x46\x29\xBB\xFC\xDE\x1D\x78\x72\x76\x47"
           "\x20\x40\x90\xDC\xBC\xA3\x72\x33\x64\x7E\x18\xD9\xA4\xD2\x46\x9C"
           "\x77\x8B\xF9\x6D\x97\xB0\xD6\xA1\x20\x2C\x0D\xB6\xE3\x2C\x09\x8F"
           "\x07\xB6\x5F\xD3\xDB\x3B\xFD\x77\x69\x7D\x56\xE4\x35\x18\x3A\x9B"
           "\xF6\x22\x3A\x01\x35\x71\xBE\xA4\x48\x97\x8B\x45\x90\x46\x07\x0E"
           "\x17\x68\x9E\x00\x11\x6F\x4A\x25\x55\xA0\x9C\x74\xD9\x15\xFF\xF5"
           "\xE0\x59\xD6\x86\xA0\x91\xD8\x7F\x9A\xFF\xE4\xBD\xAB\xE3\xF0\x94"
           "\x49\x66\x36\x7F\xD3\xD3\x8E\x13\xB7\xFC\x89\xB7\xA9\x3C\x7B\x0E"
           "\x11\xAC\x66\xCE\x34\x34\xAE\x67\x70\xE0\x3A\xB6\x0E\x78\xFD\x94"
           "\xF1\xB5\x74\xD3\x47\x2A\x74\x40\x51\x39\xD1\x49\x73\x94\xB4\xF9"
           "\x4C\xB6\x4B\x11\x19\x2F\x7E\x34\x3E\x6B\x4F\x34\x5B\x83\x52\x47"
           "\x99\x0C\xD6\xDF\x7B\xA3\x95\xE2\xCC\x39\x2F\xC4\x92\x43\x38\x2F"
           "\xCB\xE6\x8C\x2D\xAD\xD0\x5E\xE9\xD5\x3D\x5E\x70\x2E\xA8\x66\xB0"
           "\xA6\xB8\x7C\xA4\x3A\x9E\x28\x3B\x0E\x46\x20\x84\xF8\x5E\x53\x9E"
           "\xCF\xDE\xF3\x0F\x1F\xE3\x8D\x51"
           , 824);
    nSKLen = 824;
    memset(bData, 0x42, 176);
    bData[0] = 0x30;
    bData[175] = 0x39;
    nDataLen = 176;
    memcpy(bSignExp,
           "\x39\x3B\x49\x0A\x1B\x4B\x62\x4A\x01\x6C\xFD\x7D\x13\xFE\xE4\x4B"
           "\x42\x59\x5C\xDF\x9F\x32\x38\x6B\x78\x0E\xFF\x7C\x32\x53\xDA\x69"
           "\xAB\xF6\xC3\xD8\xF1\xCB\x16\xA1\x83\x71\x00\xDF\x0D\x10\x86\xEE"
           "\xDA\xBC\x34\x5A\x9C\x23\x93\x06\x4E\xEC\xC8\xEF\xB9\x47\xEF\x86"
           "\xED\x31\xA6\x6B\x52\xF7\x27\x13\x7E\x2F\x47\x29\x07\x9F\x8C\xC2"
           "\x00\xF0\x01\xE9\xBF\xCC\x49\xDA\x72\x3F\xA1\x98\xA4\x3E\x87\xE2"
           "\xC2\xEB\xA1\xA8\xED\x15\xE4\xC4\x91\xE6\xF9\x32\xD6\x7D\xD8\xFE"
           "\x81\x42\x7C\xDF\xD9\x14\xDD\x37\xFA\xAF\x4F\xEB\xB1\x94\x58\xDB"
           "\xFF\x1F\x46\xD9\x92\xE3\x59\xF5\xE9\xBA\xE8\xFC\x00\x97\x44\xEB"
           "\xE1\x83\x00\xE9\x02\x08\x7D\x80\x9A\xBB\x14\xE8\xAE\x41\xAF\x80"
           "\x8E\x93\x12\x76\xC8\x06\x4B\x0F\x57\xB7\xF6\x8A\x2E\x47\x62\x74"
           , 176);
    nSignLenExp = 176;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 824);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 176);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1408，SHA-224，PKCS#1填充，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bSign    =", bSign, 176);
    DspHex("[OUT]bSignExp =", bSignExp, 176);
    ASSERT_OUT_HEX(bSign, bSignExp, 176);
    ASSERT_OUT(nSignLen, nSignLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_22(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 3;
    nPadMode = 1;
    memcpy(bSK,
           "\x21\xE5\x82\xE3\xD4\x2B\x83\xA7\x68\x16\x92\xEF\x49\x12\x6D\x45"
           "\xC5\x11\xC5\x1E\x9E\x67\x6F\xF9\x04\x47\x04\x31\x37\x69\xFD\x3D"
           "\x6C\x60\x8F\x08\xC7\xF3\xF1\x69\xDF\xCC\x66\x75\xEA\xB0\x61\x33"
           "\xAF\x7A\x12\x41\x94\x5A\x51\x39\xB5\xBE\xE7\x4C\x9D\x98\x77\x80"
           "\x6C\xB9\x2B\x98\x4E\x55\xEC\x57\x0E\x8A\x1F\xA8\x52\xDE\x44\xC5"
           "\x08\x2F\x21\xD9\x0E\xDD\xB5\x5E\xF3\xA1\x8C\xF1\xC3\xCB\x0A\x18"
           "\xD3\x80\x83\x10\xEB\x2E\x99\x59\x45\x7D\x2B\x92\xF5\x22\x7B\x49"
           "\x67\x02\x84\x5F\x56\x56\xBC\x95\x04\xA4\xB7\xB7\x53\xAE\x19\xF1"
           "\xF8\x7C\x3D\xEA\xDA\xDF\x52\x99\xF5\xB4\x15\xAB\x03\x8B\xBD\x6B"
           "\xC0\x8C\x86\xFC\x56\xCC\x3C\x0C\x38\x31\xBD\xB7\x28\x29\xAC\x0E"
           "\x24\xF2\x12\x6E\x6A\xFC\x01\x1C\x18\xC6\x3A\xCD\xD8\x0A\x64\x27"
           "\x93\x9D\x76\xAA\x27\x42\x7E\xEF\xFB\x83\x2A\xB5\xF3\xD0\x15\xC8"
           "\xEF\xF4\x3E\x5B\x5F\x3B\x4F\x96\x2C\x76\x6A\xD6\x69\xD7\x57\xC1"
           "\xF6\x40\xDF\x49\x7B\x4A\x9B\xE2\x7A\xE3\x09\x8B\xC9\x47\xA9\x14"
           "\x5F\x1D\xC1\x4A\x7F\x9D\xCF\xEF\x7D\x1A\x91\x6F\xC7\xA0\x41\x7F"
           "\x7B\xC3\x15\x00\xEC\x53\x34\x22\x95\xEE\xE7\x08\x39\x63\xF5\x54"
           "\xB6\xAD\x39\x45\xB5\x21\x5C\x34\x5E\x67\x7B\xD8\x97\x50\x91\x75"
           "\x6F\x68\x0A\x95\x8F\x24\xBE\x83\xDB\x44\x91\xE0\xD2\x99\x24\x99"
           "\xBD\x11\x2E\x15\xA9\xCC\xCD\x14\xD9\xBB\x5E\x56\x0F\x69\x9A\x18"
           "\x5A\x42\x25\xB1\x3F\x6B\x03\x18\x51\x9C\x36\x8F\xDB\x1E\xB9\x11"
           "\x3A\xEF\x24\xDB\x9B\x2E\xA2\x1B\x11\x73\x86\x5A\x4C\x12\x4F\xD8"
           "\xCB\x07\xEE\x99\xAC\x04\x10\x2B\x1C\xD7\xB8\xEB\xE7\x56\x2C\x8A"
           "\x12\x36\xDD\xA0\x11\x9D\xC8\x26\x37\x66\x0B\x21\x89\xC3\x7D\xA1"
           "\x40\x85\x91\xFF\x5E\x80\x70\xFB\x68\x28\x03\x8A\x6F\x09\xBC\xD6"
           "\xAC\xAF\xF4\x60\x67\x8D\xA8\x3E\x17\x5B\x5A\xE9\x3E\x17\xA9\x34"
           "\xA9\xD7\x29\xBE\xBE\xE3\xCD\x09\x74\x23\xC7\x21\xEE\xA2\x63\xA2"
           "\x33\x64\x92\x53\x31\x74\xF2\x96\x0C\xD0\x11\x30\xB6\x9F\xE0\xBA"
           "\x5B\x4C\xFA\xA0\xBB\x83\x1C\x74\xD8\x70\xE0\x4B\x2A\xAA\xBD\x88"
           "\x4A\x1E\xB5\x22\x63\xD7\x2E\xBD\xA4\x8E\x6C\xA3\x10\x29\xE8\x29"
           "\xA8\x43\x89\x66\xB7\x7E\x3D\xBE\x8C\xE3\xFC\x5A\xBF\x06\x0B\xCC"
           "\x34\x91\x9D\xE3\x85\x1D\xB7\x39\x03\xC3\x0C\x05\x17\xA4\x8D\xE0"
           "\xB3\x9E\x01\xF7\x80\xF4\xBB\xF0\x22\x23\xDA\xBD\xC4\x14\xBB\x78"
           "\x58\xC5\x7F\xC6\x09\x41\x54\xBB\x11\x96\xE6\xA3\x1A\xC9\x55\xBD"
           "\x0F\xF0\x3F\xBE\x61\x83\xCE\x26\x82\xA2\x8E\xD5\x0D\x2D\xB7\x66"
           "\xBC\x2E\xF0\xEB\xC3\x2F\x6A\x2A\xF5\xB9\x8B\xF0\x42\x4F\x65\x8B"
           "\xD1\x6E\x76\x88\x8C\x29\x34\xCF\x26\x27\x84\x8E\x6B\xA2\xEB\x16"
           "\x77\x2D\x21\x7E\xEC\x18\x4D\x04\xDA\xEF\x95\x1C\x29\x75\x18\x1C"
           "\x83\xCA\xB6\x72\xC3\x77\x46\x29\xBB\xFC\xDE\x1D\x78\x72\x76\x47"
           "\x20\x40\x90\xDC\xBC\xA3\x72\x33\x64\x7E\x18\xD9\xA4\xD2\x46\x9C"
           "\x77\x8B\xF9\x6D\x97\xB0\xD6\xA1\x20\x2C\x0D\xB6\xE3\x2C\x09\x8F"
           "\x07\xB6\x5F\xD3\xDB\x3B\xFD\x77\x69\x7D\x56\xE4\x35\x18\x3A\x9B"
           "\xF6\x22\x3A\x01\x35\x71\xBE\xA4\x48\x97\x8B\x45\x90\x46\x07\x0E"
           "\x17\x68\x9E\x00\x11\x6F\x4A\x25\x55\xA0\x9C\x74\xD9\x15\xFF\xF5"
           "\xE0\x59\xD6\x86\xA0\x91\xD8\x7F\x9A\xFF\xE4\xBD\xAB\xE3\xF0\x94"
           "\x49\x66\x36\x7F\xD3\xD3\x8E\x13\xB7\xFC\x89\xB7\xA9\x3C\x7B\x0E"
           "\x11\xAC\x66\xCE\x34\x34\xAE\x67\x70\xE0\x3A\xB6\x0E\x78\xFD\x94"
           "\xF1\xB5\x74\xD3\x47\x2A\x74\x40\x51\x39\xD1\x49\x73\x94\xB4\xF9"
           "\x4C\xB6\x4B\x11\x19\x2F\x7E\x34\x3E\x6B\x4F\x34\x5B\x83\x52\x47"
           "\x99\x0C\xD6\xDF\x7B\xA3\x95\xE2\xCC\x39\x2F\xC4\x92\x43\x38\x2F"
           "\xCB\xE6\x8C\x2D\xAD\xD0\x5E\xE9\xD5\x3D\x5E\x70\x2E\xA8\x66\xB0"
           "\xA6\xB8\x7C\xA4\x3A\x9E\x28\x3B\x0E\x46\x20\x84\xF8\x5E\x53\x9E"
           "\xCF\xDE\xF3\x0F\x1F\xE3\x8D\x51"
           , 824);
    nSKLen = 824;
    memset(bData, 0x42, 176);
    bData[0] = 0x30;
    bData[175] = 0x39;
    nDataLen = 176;
    memcpy(bSignExp,
           "\x06\x15\x84\xB2\x28\xFC\x25\x45\x73\x4A\xE6\x57\xA9\x6C\xD4\x30"
           "\x94\xEC\x30\x2D\x61\x46\x4E\x86\x38\x22\x9A\x21\x14\x54\x52\x93"
           "\x7B\xA5\x7E\x38\xEA\x9B\x28\x34\x81\x26\x44\xB3\x9D\x90\xD3\x98"
           "\x08\x70\x33\x5E\x95\xA4\xDE\xA2\x6C\x3C\x3C\xFB\xB2\x85\xEB\xFA"
           "\xC4\x99\xEE\x1E\xDC\x47\xBC\x0D\x9F\xDD\x3D\xD0\x12\xFF\xCC\x90"
           "\x31\x59\x80\x7A\x4F\xE1\x8E\xE2\x11\xB8\x32\xD6\xF0\x7B\xCF\x31"
           "\x1B\x66\xC3\x9A\x60\x31\xC4\xF9\xDC\x04\x84\xB9\x3C\x49\x1F\x97"
           "\xCE\x11\xCF\xC0\xC0\x30\x4B\x68\x63\x3B\x47\x27\xE0\x76\xBE\xBC"
           "\xD2\x9D\x94\x78\x5D\xB3\x15\x40\x5C\xE2\xBB\xF5\xED\x4C\x20\x84"
           "\x6C\x88\x77\xC3\xCA\xD0\x74\xF5\x60\xA5\x83\xAB\xEE\x62\x78\x83"
           "\x29\xE7\xD8\x55\xD3\x23\xD6\x46\x4D\x1B\x56\xDB\xFC\x38\xFF\xB4"
           , 176);
    nSignLenExp = 176;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 824);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 176);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1408，SHA-256，PKCS#1填充，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bSign    =", bSign, 176);
    DspHex("[OUT]bSignExp =", bSignExp, 176);
    ASSERT_OUT_HEX(bSign, bSignExp, 176);
    ASSERT_OUT(nSignLen, nSignLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_23(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 4;
    nPadMode = 1;
    memcpy(bSK,
           "\x21\xE5\x82\xE3\xD4\x2B\x83\xA7\x68\x16\x92\xEF\x49\x12\x6D\x45"
           "\xC5\x11\xC5\x1E\x9E\x67\x6F\xF9\x04\x47\x04\x31\x37\x69\xFD\x3D"
           "\x6C\x60\x8F\x08\xC7\xF3\xF1\x69\xDF\xCC\x66\x75\xEA\xB0\x61\x33"
           "\xAF\x7A\x12\x41\x94\x5A\x51\x39\xB5\xBE\xE7\x4C\x9D\x98\x77\x80"
           "\x6C\xB9\x2B\x98\x4E\x55\xEC\x57\x0E\x8A\x1F\xA8\x52\xDE\x44\xC5"
           "\x08\x2F\x21\xD9\x0E\xDD\xB5\x5E\xF3\xA1\x8C\xF1\xC3\xCB\x0A\x18"
           "\xD3\x80\x83\x10\xEB\x2E\x99\x59\x45\x7D\x2B\x92\xF5\x22\x7B\x49"
           "\x67\x02\x84\x5F\x56\x56\xBC\x95\x04\xA4\xB7\xB7\x53\xAE\x19\xF1"
           "\xF8\x7C\x3D\xEA\xDA\xDF\x52\x99\xF5\xB4\x15\xAB\x03\x8B\xBD\x6B"
           "\xC0\x8C\x86\xFC\x56\xCC\x3C\x0C\x38\x31\xBD\xB7\x28\x29\xAC\x0E"
           "\x24\xF2\x12\x6E\x6A\xFC\x01\x1C\x18\xC6\x3A\xCD\xD8\x0A\x64\x27"
           "\x93\x9D\x76\xAA\x27\x42\x7E\xEF\xFB\x83\x2A\xB5\xF3\xD0\x15\xC8"
           "\xEF\xF4\x3E\x5B\x5F\x3B\x4F\x96\x2C\x76\x6A\xD6\x69\xD7\x57\xC1"
           "\xF6\x40\xDF\x49\x7B\x4A\x9B\xE2\x7A\xE3\x09\x8B\xC9\x47\xA9\x14"
           "\x5F\x1D\xC1\x4A\x7F\x9D\xCF\xEF\x7D\x1A\x91\x6F\xC7\xA0\x41\x7F"
           "\x7B\xC3\x15\x00\xEC\x53\x34\x22\x95\xEE\xE7\x08\x39\x63\xF5\x54"
           "\xB6\xAD\x39\x45\xB5\x21\x5C\x34\x5E\x67\x7B\xD8\x97\x50\x91\x75"
           "\x6F\x68\x0A\x95\x8F\x24\xBE\x83\xDB\x44\x91\xE0\xD2\x99\x24\x99"
           "\xBD\x11\x2E\x15\xA9\xCC\xCD\x14\xD9\xBB\x5E\x56\x0F\x69\x9A\x18"
           "\x5A\x42\x25\xB1\x3F\x6B\x03\x18\x51\x9C\x36\x8F\xDB\x1E\xB9\x11"
           "\x3A\xEF\x24\xDB\x9B\x2E\xA2\x1B\x11\x73\x86\x5A\x4C\x12\x4F\xD8"
           "\xCB\x07\xEE\x99\xAC\x04\x10\x2B\x1C\xD7\xB8\xEB\xE7\x56\x2C\x8A"
           "\x12\x36\xDD\xA0\x11\x9D\xC8\x26\x37\x66\x0B\x21\x89\xC3\x7D\xA1"
           "\x40\x85\x91\xFF\x5E\x80\x70\xFB\x68\x28\x03\x8A\x6F\x09\xBC\xD6"
           "\xAC\xAF\xF4\x60\x67\x8D\xA8\x3E\x17\x5B\x5A\xE9\x3E\x17\xA9\x34"
           "\xA9\xD7\x29\xBE\xBE\xE3\xCD\x09\x74\x23\xC7\x21\xEE\xA2\x63\xA2"
           "\x33\x64\x92\x53\x31\x74\xF2\x96\x0C\xD0\x11\x30\xB6\x9F\xE0\xBA"
           "\x5B\x4C\xFA\xA0\xBB\x83\x1C\x74\xD8\x70\xE0\x4B\x2A\xAA\xBD\x88"
           "\x4A\x1E\xB5\x22\x63\xD7\x2E\xBD\xA4\x8E\x6C\xA3\x10\x29\xE8\x29"
           "\xA8\x43\x89\x66\xB7\x7E\x3D\xBE\x8C\xE3\xFC\x5A\xBF\x06\x0B\xCC"
           "\x34\x91\x9D\xE3\x85\x1D\xB7\x39\x03\xC3\x0C\x05\x17\xA4\x8D\xE0"
           "\xB3\x9E\x01\xF7\x80\xF4\xBB\xF0\x22\x23\xDA\xBD\xC4\x14\xBB\x78"
           "\x58\xC5\x7F\xC6\x09\x41\x54\xBB\x11\x96\xE6\xA3\x1A\xC9\x55\xBD"
           "\x0F\xF0\x3F\xBE\x61\x83\xCE\x26\x82\xA2\x8E\xD5\x0D\x2D\xB7\x66"
           "\xBC\x2E\xF0\xEB\xC3\x2F\x6A\x2A\xF5\xB9\x8B\xF0\x42\x4F\x65\x8B"
           "\xD1\x6E\x76\x88\x8C\x29\x34\xCF\x26\x27\x84\x8E\x6B\xA2\xEB\x16"
           "\x77\x2D\x21\x7E\xEC\x18\x4D\x04\xDA\xEF\x95\x1C\x29\x75\x18\x1C"
           "\x83\xCA\xB6\x72\xC3\x77\x46\x29\xBB\xFC\xDE\x1D\x78\x72\x76\x47"
           "\x20\x40\x90\xDC\xBC\xA3\x72\x33\x64\x7E\x18\xD9\xA4\xD2\x46\x9C"
           "\x77\x8B\xF9\x6D\x97\xB0\xD6\xA1\x20\x2C\x0D\xB6\xE3\x2C\x09\x8F"
           "\x07\xB6\x5F\xD3\xDB\x3B\xFD\x77\x69\x7D\x56\xE4\x35\x18\x3A\x9B"
           "\xF6\x22\x3A\x01\x35\x71\xBE\xA4\x48\x97\x8B\x45\x90\x46\x07\x0E"
           "\x17\x68\x9E\x00\x11\x6F\x4A\x25\x55\xA0\x9C\x74\xD9\x15\xFF\xF5"
           "\xE0\x59\xD6\x86\xA0\x91\xD8\x7F\x9A\xFF\xE4\xBD\xAB\xE3\xF0\x94"
           "\x49\x66\x36\x7F\xD3\xD3\x8E\x13\xB7\xFC\x89\xB7\xA9\x3C\x7B\x0E"
           "\x11\xAC\x66\xCE\x34\x34\xAE\x67\x70\xE0\x3A\xB6\x0E\x78\xFD\x94"
           "\xF1\xB5\x74\xD3\x47\x2A\x74\x40\x51\x39\xD1\x49\x73\x94\xB4\xF9"
           "\x4C\xB6\x4B\x11\x19\x2F\x7E\x34\x3E\x6B\x4F\x34\x5B\x83\x52\x47"
           "\x99\x0C\xD6\xDF\x7B\xA3\x95\xE2\xCC\x39\x2F\xC4\x92\x43\x38\x2F"
           "\xCB\xE6\x8C\x2D\xAD\xD0\x5E\xE9\xD5\x3D\x5E\x70\x2E\xA8\x66\xB0"
           "\xA6\xB8\x7C\xA4\x3A\x9E\x28\x3B\x0E\x46\x20\x84\xF8\x5E\x53\x9E"
           "\xCF\xDE\xF3\x0F\x1F\xE3\x8D\x51"
           , 824);
    nSKLen = 824;
    memset(bData, 0x42, 176);
    bData[0] = 0x30;
    bData[175] = 0x39;
    nDataLen = 176;
    memcpy(bSignExp,
           "\x51\x30\xCA\xB0\xA3\x27\x24\x42\x08\x78\x84\x2F\xA2\xA1\x62\x82"
           "\xB8\x33\x74\xA9\xAB\x92\xB5\xA5\xDA\x95\x2A\xD0\x58\x0C\xF2\x18"
           "\xEE\xB8\x18\x2A\x38\xFE\xD6\xF5\x93\xA0\x20\xD7\xB6\xC7\x62\x1B"
           "\x68\x6A\x75\x59\x79\x85\x92\x6B\xB2\xE0\x4D\xA4\x8F\x15\x41\x2C"
           "\x8F\x6C\x9D\x2C\xCA\x0F\x4B\xFC\xF3\x77\xC8\x62\x2F\x9A\x6C\xD5"
           "\x73\x5E\x42\x77\xFF\x7F\x6B\xF1\x32\x1A\x0A\x93\xE6\x18\xB0\xD7"
           "\x01\x3D\xDC\x02\x76\xEF\x98\xDC\xD4\x44\x54\x95\xA2\xD2\xDD\x73"
           "\xBC\x28\xCE\xEA\x7D\xC1\x68\xDA\x21\xD5\xC0\x27\x6C\x26\xEE\x27"
           "\xB9\xE3\x4B\x18\x83\xE7\xB5\xA8\x5E\x34\xD7\x1F\xF6\x0A\xCE\xB6"
           "\xDF\xEA\x5D\x32\xF1\x0D\x71\xB6\x96\x06\x06\x87\xBD\xFF\x15\x17"
           "\xE9\x73\x8B\x7D\x1F\x9F\x7B\x76\xC8\xA5\x74\x07\x5B\xBE\x2C\xDC"
           , 176);
    nSignLenExp = 176;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 824);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 176);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1408，SHA-384，PKCS#1填充，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bSign    =", bSign, 176);
    DspHex("[OUT]bSignExp =", bSignExp, 176);
    ASSERT_OUT_HEX(bSign, bSignExp, 176);
    ASSERT_OUT(nSignLen, nSignLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_24(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 5;
    nPadMode = 1;
    memcpy(bSK,
           "\x21\xE5\x82\xE3\xD4\x2B\x83\xA7\x68\x16\x92\xEF\x49\x12\x6D\x45"
           "\xC5\x11\xC5\x1E\x9E\x67\x6F\xF9\x04\x47\x04\x31\x37\x69\xFD\x3D"
           "\x6C\x60\x8F\x08\xC7\xF3\xF1\x69\xDF\xCC\x66\x75\xEA\xB0\x61\x33"
           "\xAF\x7A\x12\x41\x94\x5A\x51\x39\xB5\xBE\xE7\x4C\x9D\x98\x77\x80"
           "\x6C\xB9\x2B\x98\x4E\x55\xEC\x57\x0E\x8A\x1F\xA8\x52\xDE\x44\xC5"
           "\x08\x2F\x21\xD9\x0E\xDD\xB5\x5E\xF3\xA1\x8C\xF1\xC3\xCB\x0A\x18"
           "\xD3\x80\x83\x10\xEB\x2E\x99\x59\x45\x7D\x2B\x92\xF5\x22\x7B\x49"
           "\x67\x02\x84\x5F\x56\x56\xBC\x95\x04\xA4\xB7\xB7\x53\xAE\x19\xF1"
           "\xF8\x7C\x3D\xEA\xDA\xDF\x52\x99\xF5\xB4\x15\xAB\x03\x8B\xBD\x6B"
           "\xC0\x8C\x86\xFC\x56\xCC\x3C\x0C\x38\x31\xBD\xB7\x28\x29\xAC\x0E"
           "\x24\xF2\x12\x6E\x6A\xFC\x01\x1C\x18\xC6\x3A\xCD\xD8\x0A\x64\x27"
           "\x93\x9D\x76\xAA\x27\x42\x7E\xEF\xFB\x83\x2A\xB5\xF3\xD0\x15\xC8"
           "\xEF\xF4\x3E\x5B\x5F\x3B\x4F\x96\x2C\x76\x6A\xD6\x69\xD7\x57\xC1"
           "\xF6\x40\xDF\x49\x7B\x4A\x9B\xE2\x7A\xE3\x09\x8B\xC9\x47\xA9\x14"
           "\x5F\x1D\xC1\x4A\x7F\x9D\xCF\xEF\x7D\x1A\x91\x6F\xC7\xA0\x41\x7F"
           "\x7B\xC3\x15\x00\xEC\x53\x34\x22\x95\xEE\xE7\x08\x39\x63\xF5\x54"
           "\xB6\xAD\x39\x45\xB5\x21\x5C\x34\x5E\x67\x7B\xD8\x97\x50\x91\x75"
           "\x6F\x68\x0A\x95\x8F\x24\xBE\x83\xDB\x44\x91\xE0\xD2\x99\x24\x99"
           "\xBD\x11\x2E\x15\xA9\xCC\xCD\x14\xD9\xBB\x5E\x56\x0F\x69\x9A\x18"
           "\x5A\x42\x25\xB1\x3F\x6B\x03\x18\x51\x9C\x36\x8F\xDB\x1E\xB9\x11"
           "\x3A\xEF\x24\xDB\x9B\x2E\xA2\x1B\x11\x73\x86\x5A\x4C\x12\x4F\xD8"
           "\xCB\x07\xEE\x99\xAC\x04\x10\x2B\x1C\xD7\xB8\xEB\xE7\x56\x2C\x8A"
           "\x12\x36\xDD\xA0\x11\x9D\xC8\x26\x37\x66\x0B\x21\x89\xC3\x7D\xA1"
           "\x40\x85\x91\xFF\x5E\x80\x70\xFB\x68\x28\x03\x8A\x6F\x09\xBC\xD6"
           "\xAC\xAF\xF4\x60\x67\x8D\xA8\x3E\x17\x5B\x5A\xE9\x3E\x17\xA9\x34"
           "\xA9\xD7\x29\xBE\xBE\xE3\xCD\x09\x74\x23\xC7\x21\xEE\xA2\x63\xA2"
           "\x33\x64\x92\x53\x31\x74\xF2\x96\x0C\xD0\x11\x30\xB6\x9F\xE0\xBA"
           "\x5B\x4C\xFA\xA0\xBB\x83\x1C\x74\xD8\x70\xE0\x4B\x2A\xAA\xBD\x88"
           "\x4A\x1E\xB5\x22\x63\xD7\x2E\xBD\xA4\x8E\x6C\xA3\x10\x29\xE8\x29"
           "\xA8\x43\x89\x66\xB7\x7E\x3D\xBE\x8C\xE3\xFC\x5A\xBF\x06\x0B\xCC"
           "\x34\x91\x9D\xE3\x85\x1D\xB7\x39\x03\xC3\x0C\x05\x17\xA4\x8D\xE0"
           "\xB3\x9E\x01\xF7\x80\xF4\xBB\xF0\x22\x23\xDA\xBD\xC4\x14\xBB\x78"
           "\x58\xC5\x7F\xC6\x09\x41\x54\xBB\x11\x96\xE6\xA3\x1A\xC9\x55\xBD"
           "\x0F\xF0\x3F\xBE\x61\x83\xCE\x26\x82\xA2\x8E\xD5\x0D\x2D\xB7\x66"
           "\xBC\x2E\xF0\xEB\xC3\x2F\x6A\x2A\xF5\xB9\x8B\xF0\x42\x4F\x65\x8B"
           "\xD1\x6E\x76\x88\x8C\x29\x34\xCF\x26\x27\x84\x8E\x6B\xA2\xEB\x16"
           "\x77\x2D\x21\x7E\xEC\x18\x4D\x04\xDA\xEF\x95\x1C\x29\x75\x18\x1C"
           "\x83\xCA\xB6\x72\xC3\x77\x46\x29\xBB\xFC\xDE\x1D\x78\x72\x76\x47"
           "\x20\x40\x90\xDC\xBC\xA3\x72\x33\x64\x7E\x18\xD9\xA4\xD2\x46\x9C"
           "\x77\x8B\xF9\x6D\x97\xB0\xD6\xA1\x20\x2C\x0D\xB6\xE3\x2C\x09\x8F"
           "\x07\xB6\x5F\xD3\xDB\x3B\xFD\x77\x69\x7D\x56\xE4\x35\x18\x3A\x9B"
           "\xF6\x22\x3A\x01\x35\x71\xBE\xA4\x48\x97\x8B\x45\x90\x46\x07\x0E"
           "\x17\x68\x9E\x00\x11\x6F\x4A\x25\x55\xA0\x9C\x74\xD9\x15\xFF\xF5"
           "\xE0\x59\xD6\x86\xA0\x91\xD8\x7F\x9A\xFF\xE4\xBD\xAB\xE3\xF0\x94"
           "\x49\x66\x36\x7F\xD3\xD3\x8E\x13\xB7\xFC\x89\xB7\xA9\x3C\x7B\x0E"
           "\x11\xAC\x66\xCE\x34\x34\xAE\x67\x70\xE0\x3A\xB6\x0E\x78\xFD\x94"
           "\xF1\xB5\x74\xD3\x47\x2A\x74\x40\x51\x39\xD1\x49\x73\x94\xB4\xF9"
           "\x4C\xB6\x4B\x11\x19\x2F\x7E\x34\x3E\x6B\x4F\x34\x5B\x83\x52\x47"
           "\x99\x0C\xD6\xDF\x7B\xA3\x95\xE2\xCC\x39\x2F\xC4\x92\x43\x38\x2F"
           "\xCB\xE6\x8C\x2D\xAD\xD0\x5E\xE9\xD5\x3D\x5E\x70\x2E\xA8\x66\xB0"
           "\xA6\xB8\x7C\xA4\x3A\x9E\x28\x3B\x0E\x46\x20\x84\xF8\x5E\x53\x9E"
           "\xCF\xDE\xF3\x0F\x1F\xE3\x8D\x51"
           , 824);
    nSKLen = 824;
    memset(bData, 0x42, 2048);
    bData[0] = 0x30;
    bData[2047] = 0x39;
    nDataLen = 2048;
    memcpy(bSignExp,
           "\x54\x03\xBF\xCD\x44\xBB\x12\x57\x41\x78\x8B\xAA\xDC\xE1\x49\x15"
           "\x08\xFE\xBD\xF4\x98\xBE\x3E\x74\xA7\xD5\x0D\x21\x36\xEC\x42\xD4"
           "\x10\x68\x1D\x66\xDC\xD3\xF9\xF5\x5B\x73\x01\xA5\xA7\x22\xF2\xBF"
           "\x10\x60\x86\xE9\xC9\x20\xED\x03\x23\x99\x6B\x9D\x87\xD7\x7C\xE4"
           "\x21\x2C\x8B\xCC\xB4\xB1\xE7\x84\x71\x54\xDE\x62\xAD\x95\xD5\x56"
           "\xCB\x88\x8E\x5F\xB5\xEC\x10\x93\xBF\xF2\x5D\xD8\xE1\x2E\x38\x7C"
           "\xA8\x12\xE0\xF8\xEC\x5E\x34\x68\xBD\x2A\xA5\xF8\xD6\x76\x8A\x31"
           "\x59\x5B\xCB\x9E\x2B\x50\x10\xD3\x58\x06\x90\xD8\xE6\x55\x02\x12"
           "\x7C\xC3\x85\x9F\x2C\x60\xC3\xB9\x12\x6C\x62\xFF\x5D\x09\x79\x5B"
           "\x8B\xF4\x1C\xC3\x21\x31\x04\x3E\x69\xA6\x93\xF7\xD6\xFA\xE8\x94"
           "\x24\x8D\xE3\x62\x0B\xB4\xE2\x1C\x02\xE3\x1D\xEF\x01\x15\x2B\x34"
           , 176);
    nSignLenExp = 176;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 824);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 2048);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1408，SHA-512，PKCS#1填充，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bSign    =", bSign, 176);
    DspHex("[OUT]bSignExp =", bSignExp, 176);
    ASSERT_OUT_HEX(bSign, bSignExp, 176);
    ASSERT_OUT(nSignLen, nSignLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_25(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 0;
    nPadMode = 1;
    memcpy(bSK,
           "\x6C\x18\x21\x1D\x3D\xDC\x38\xA8\xBA\x10\x33\x70\x83\x41\xB5\x37"
           "\xFE\x97\x6F\xB1\xF4\x21\x1A\xAD\x35\x77\xBD\x28\xB2\x57\x20\x10"
           "\x16\x13\x93\x89\x47\xC3\x73\xFC\xB9\x76\x48\x3A\x77\xCD\xA7\x0C"
           "\x17\xE9\xF1\x4C\xD0\xA7\xE1\xAA\x0D\x9A\x8C\x38\xD1\xE6\x83\xA6"
           "\x93\xD4\x55\x28\x6B\xB9\x0F\x81\x02\x7A\x78\x54\x00\x84\x94\xFB"
           "\x82\xCC\x8A\x78\xFC\x93\x45\x6E\xD3\x13\xD3\x1F\x18\x69\x73\x2A"
           "\x70\x86\x1F\xFB\x25\xE6\x2A\x64\xCC\x6F\x1F\x18\x26\x0D\x1C\x40"
           "\xAA\x5E\x52\x50\x22\x5A\xE4\x3C\xBC\x29\xFA\xCA\x30\xE3\x53\x40"
           "\x34\x35\xF1\xD0\xE2\x69\x1D\x34\x8E\x83\x96\xAC\xAA\xCF\x6C\x98"
           "\x3F\x4F\x8C\xEF\x8C\xB3\x3A\x04\xF5\x7C\xB1\x76\xA3\x32\x1B\xC1"
           "\x83\xAD\x70\xA5\xF9\x08\xB8\xD9\x2E\xED\x15\x65\xB0\x33\x30\x04"
           "\x1F\x69\x87\x1D\xFF\xBF\x0F\x59\xE3\x62\xE1\xE8\x2C\x03\x4B\x72"
           "\xB6\xAA\x8F\x73\xBA\xFE\xEE\xCC\xAF\x50\x87\x3D\xA0\x5F\x66\xA0"
           "\x88\x3A\x7F\xDF\xA1\x8E\x06\x08\x18\x2C\x1A\x16\xCE\x0C\x6E\x13"
           "\x4F\x2E\x26\x3B\xB8\xAF\x70\x5E\x70\x48\xED\xCE\x8D\x6C\x9B\x26"
           "\xD7\xFE\x95\x5F\xC6\x91\xB6\x81\x3F\x7C\x9A\xF1\x6D\x1B\xAB\x6E"
           "\x84\x10\x94\x5A\x07\x38\x56\x75\xF0\xEB\x3C\x5E\xA3\x0E\x85\x17"
           "\xFB\x5B\xD0\xFA\x84\x3D\x58\x4C\xFD\xF0\xE5\x37\x77\x29\xE2\x5A"
           "\x7C\x74\x87\x04\x9C\xF0\x7A\x2C\xE4\xD2\x0A\x1C\xD8\x8B\x37\x8C"
           "\x7F\x1C\x10\x6E\x73\xB2\x69\x4C\xBE\x1A\x84\x3C\xC8\xA7\xA3\x68"
           "\x48\x7E\x2F\xFD\x9B\x5F\x12\xAD\x15\x49\x3F\xC4\x10\x86\xAF\x56"
           "\x4D\xCB\xC6\xE8\xAD\x35\x72\x21\x24\xD9\xC3\xA3\x82\xF1\xB2\xAF"
           "\xD9\x88\xBF\xFB\xCB\x81\xF9\xF6\x3B\xC6\x1C\x34\xF0\x5A\x33\xE5"
           "\x41\x9B\xC2\xF9\xE2\x23\x0E\x2D\x11\xC5\xBF\x41\x91\x7B\xE9\x36"
           "\x07\xD8\x60\x00\x09\xDD\xD5\x86\xD7\x65\x50\x98\xBC\x5C\x0E\x60"
           "\xA0\xE5\x53\xEC\xA6\x9D\x11\x99\xEA\x25\x44\xF4\x50\x76\x0D\x4D"
           "\xE7\x72\x87\xCF\x6F\x7C\xF2\x27\xED\x73\xD7\xEF\x53\x6D\x0B\x99"
           "\x6B\x38\x44\xBC\xC0\x12\xF5\xD6\x92\x3F\x64\x81\x54\xC1\xEF\x04"
           "\x5C\x1F\x23\x7E\xF5\x38\xA7\x80\xFC\x17\xEF\x00\x3C\x8D\x09\xAB"
           "\xAA\xD0\x40\x14\xD7\xCB\xAC\xA1\x29\xE0\x12\xD5\xD4\xFF\x1B\xDD"
           "\xCA\x78\x2B\x1D\xEC\x9F\xA5\xAC\x67\x74\x31\x8C\xF6\x8F\x9A\x59"
           "\x7D\x84\xF1\x7E\x5D\xA4\xC9\x53\xEF\x58\x2D\x1F\x0F\x3A\x6D\x66"
           "\xFF\x06\x61\x1A\xDC\xDB\x19\x0C\xE6\x43\xC4\x4A\x2B\x3D\x8E\x79"
           "\xD4\x93\xA8\x9A\x1A\xF7\x91\x45\x77\x78\xAB\xE1\x77\x33\x26\xFF"
           "\x92\x0B\x96\xD5\xF3\xAF\x05\x0B\xC4\x53\x1B\x89\xEC\xDC\xD0\x12"
           "\x4A\x65\xF3\xAD\x43\x8C\x23\x35\x13\x79\x4E\xD8\x0D\x21\xC9\x61"
           "\x49\xCA\x48\x53\x48\xC6\xA1\x7E\xF0\x28\xA5\x97\x11\xB8\x18\x33"
           "\xAD\xEC\xEF\x6B\x5C\x71\x4A\xBE\x9F\x31\xB8\xA3\x98\xC5\x0C\x0B"
           "\x46\x51\xA2\xAE\x02\x6F\x98\x35\xF7\x4D\x21\x5E\xC3\xED\x61\xB0"
           "\x6B\x59\x79\x5A\xB9\xA8\x1C\xB0\xBA\x82\x67\xB9\x97\xBB\xD4\x4D"
           "\xF1\xA1\x56\x5C\x7D\xCB\x77\xD0\x28\xE0\xFF\x1C\xAA\x22\x07\x68"
           "\x9B\xF3\x80\xDE\x96\x1D\x03\xDD\x97\x8A\x69\xDA\x5C\x54\xD4\x80"
           "\x93\xB2\x0D\xCD\x43\xBA\xFC\xDF\x11\xCF\xFE\xCE\x3B\x74\x8E\x67"
           "\x17\x74\x8E\x29\xF9\x64\x97\x52\x8C\x7B\xC9\x71\xB3\x5E\x59\x86"
           "\x63\x38\xF6\x9E\x79\x43\x56\xD6\x6F\xE6\x26\x45\x62\x64\x26\xE0"
           "\xA7\xDC\x70\xCA\x5B\xCD\xE7\xC6\xE1\x1F\xFC\x97\x57\xA1\x2B\xC5"
           "\x12\xB6\x9E\x85\x37\x9E\x58\x48\x2F\x9A\x91\xB7\xB6\x7C\x28\x47"
           "\x1A\x73\x45\x41\xD4\x6E\xBE\xB5\xB7\x60\x1A\xF2\x8B\x04\x78\x38"
           "\x4B\xB6\x45\x8C\xA9\x3E\xE5\x7A\xBF\x1F\xC4\x86\x30\xB4\x0C\xB1"
           "\xC6\x9D\x80\x88\xD2\x49\xD9\x89\xD9\x50\xA8\xDE\xEC\xA5\x04\x7F"
           "\xFF\xEA\xC0\x2F\xCB\x37\x7A\xB6\x97\x59\xAD\x53\x29\x34\xB3\x79"
           "\x16\x3B\x3E\xF5\x7F\x14\xB3\x77\xF9\x2E\xE8\x3F\x04\xAE\xDE\x89"
           "\x73\x04\x32\xA7\x4C\xC0\x4D\x43\x0D\xC1\xE5\x21\x48\x32\xAA\xE1"
           "\x5E\x81\xB6\x23\x6A\x80\xCA\x17\x23\xFC\x5F\x47\xE1\x57\x14\x59"
           "\x46\x67\x0F\xBF\x6A\x57\x53\x10\x8E\xAB\xAA\x9C\x8A\xDD\xE0\x9D"
           "\xA2\xAC\x94\x87\x6A\x71\xD0\xAF\xE4\x8A\xCF\xEB\x23\x27\x00\xC2"
           "\x8B\x11\xA9\x2C\x02\xB5\x05\x03\x30\x7A\x0C\xEF\x7F\x5B\x1C\xE7"
           "\x64\xFF\x1E\x68\x78\x28\x1C\x6D\xA0\x16\x75\x36\x7F\x9F\xF9\xCD"
           "\x15\x3B\x8E\x26\xC3\xF1\x7A\xBC\x17\x42\x92\x7D\xA8\x4E\x22\x5F"
           "\xB9\x55\xF5\xB7\x2C\x10\x5E\x79\xBB\x81\x54\x32\xDC\x8D\xE7\x4B"
           "\xE3\xCB\xDB\x1D\x34\xA4\xBA\x5F\x1A\xFE\x43\x48\x46\xEF\x88\x67"
           "\xD5\xB6\xDD\x06\x99\x5C\xB3\x38\x45\xED\xD0\x21\x77\x22\xF4\xF3"
           "\x68\xD6\x90\x53\xB5\x1E\x36\x3C\x35\x08\xCF\xBE\x53\x8F\x59\xDB"
           "\x4D\xAA\xA2\xB4\xF9\x93\xAC\x4C\x0C\xE4\x5D\xDF\x79\x57\x3C\x8F"
           "\x42\x44\xEC\x0C\x09\xA9\xC6\xE8\xF9\xF0\x80\x2E\x76\x25\x2E\xC1"
           "\x72\x0E\x55\xD6\xB9\x78\x9A\xAE\x56\xFE\x8B\x35\x38\xAF\xE3\x80"
           "\x78\x57\x55\x15\xC9\xEC\xCC\xCB\x42\xC3\xC5\xDF\x8A\xAE\x67\xB0"
           "\xCD\x63\x8E\xFC\x28\x77\x7F\xD1\x31\xFD\x9D\xD2\x79\xC8\x0A\xE0"
           "\x1A\x86\x0D\xEB\x3B\xB4\x64\x49\xAA\x6B\x7B\x73\x27\xEC\x7D\x66"
           "\x6A\x4C\x37\xB3\xCD\x4E\x97\x97\x3C\xEF\x7E\x13\x45\x36\xAA\xFE"
           "\x2E\x16\x48\x90\x5F\x53\x63\x62\xC7\xAB\xC9\xC7\xB5\x9E\xFD\xA5"
           "\x8B\x0C\xCA\xD0\x1E\xBD\x51\x67\x98\x94\x63\x08\x13\xCC\x05\xB9"
           , 1152);
    nSKLen = 1152;
    memset(bData, 0x42, 1);
    nDataLen = 1;
    memcpy(bSignExp,
           "\x94\xBA\x66\x55\xD9\x53\x75\x7F\x92\x02\xF9\xFE\xFE\xA3\x5C\x23"
           "\xCA\xD6\x81\x73\x01\x51\xA5\x4E\xE6\xB2\x59\xC5\x8D\x7C\xB9\xD7"
           "\xA3\x85\xA9\xA1\xAB\x1B\x48\xDA\x3B\xF0\x7D\x8B\xF3\x02\x1C\xF1"
           "\x1C\x89\x0A\x35\x59\xFC\x25\x3F\x85\x41\x94\x90\x0A\xE9\x59\x44"
           "\x53\x0E\x1F\x6F\xCD\x60\x16\xE0\xC0\x99\xDB\x5D\x1F\x50\xBF\x2A"
           "\x8A\xC1\xF1\x49\xAD\x93\x40\x9A\xE6\x7E\xA9\x8E\x86\x4E\xC2\x20"
           "\xAB\x07\xC6\x41\xC2\x2F\x5B\x44\xA3\x14\xA0\x9A\x42\x65\x45\x99"
           "\x56\xDF\x2C\x67\x75\x1A\x3F\x6B\x96\x0C\x9B\x13\x5F\x83\xD0\x82"
           "\xAB\x7D\x83\x25\xFC\x6E\x26\xE9\x88\x6C\xF4\x27\x9E\x28\xCC\xBE"
           "\xAC\x7A\xF3\x46\x73\x23\x2A\xEC\xEA\x3B\x04\x9A\xA5\x8C\x98\x1E"
           "\xCE\x5B\xC6\x3D\xEE\xB7\x13\x3C\x0A\x9D\xEC\x28\x17\x5A\xFE\x4B"
           "\x09\x12\xE4\x82\x1B\x3E\x53\x89\xDB\xBE\x9A\xE9\x33\x65\x5E\x24"
           "\x52\xE7\x36\x61\xDE\x0A\x07\x47\x4D\x87\xEB\xB5\x09\xB0\x07\x35"
           "\xF7\x91\xB7\x59\xF9\x27\x71\x55\x42\x16\x50\x80\x4C\x14\x92\x4F"
           "\xA4\xC4\x90\x49\xD0\x96\x3C\xB6\xBC\xF2\x2A\xBC\xE8\x2D\x39\x5F"
           "\xFF\xD1\x79\x57\x3A\xAC\x25\x9A"
           , 248);
    nSignLenExp = 248;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 1152);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 1);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1984，MD5，PKCS#1填充，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bSign    =", bSign, 248);
    DspHex("[OUT]bSignExp =", bSignExp, 248);
    ASSERT_OUT_HEX(bSign, bSignExp, 248);
    ASSERT_OUT(nSignLen, nSignLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_26(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 1;
    nPadMode = 1;
    memcpy(bSK,
           "\x6C\x18\x21\x1D\x3D\xDC\x38\xA8\xBA\x10\x33\x70\x83\x41\xB5\x37"
           "\xFE\x97\x6F\xB1\xF4\x21\x1A\xAD\x35\x77\xBD\x28\xB2\x57\x20\x10"
           "\x16\x13\x93\x89\x47\xC3\x73\xFC\xB9\x76\x48\x3A\x77\xCD\xA7\x0C"
           "\x17\xE9\xF1\x4C\xD0\xA7\xE1\xAA\x0D\x9A\x8C\x38\xD1\xE6\x83\xA6"
           "\x93\xD4\x55\x28\x6B\xB9\x0F\x81\x02\x7A\x78\x54\x00\x84\x94\xFB"
           "\x82\xCC\x8A\x78\xFC\x93\x45\x6E\xD3\x13\xD3\x1F\x18\x69\x73\x2A"
           "\x70\x86\x1F\xFB\x25\xE6\x2A\x64\xCC\x6F\x1F\x18\x26\x0D\x1C\x40"
           "\xAA\x5E\x52\x50\x22\x5A\xE4\x3C\xBC\x29\xFA\xCA\x30\xE3\x53\x40"
           "\x34\x35\xF1\xD0\xE2\x69\x1D\x34\x8E\x83\x96\xAC\xAA\xCF\x6C\x98"
           "\x3F\x4F\x8C\xEF\x8C\xB3\x3A\x04\xF5\x7C\xB1\x76\xA3\x32\x1B\xC1"
           "\x83\xAD\x70\xA5\xF9\x08\xB8\xD9\x2E\xED\x15\x65\xB0\x33\x30\x04"
           "\x1F\x69\x87\x1D\xFF\xBF\x0F\x59\xE3\x62\xE1\xE8\x2C\x03\x4B\x72"
           "\xB6\xAA\x8F\x73\xBA\xFE\xEE\xCC\xAF\x50\x87\x3D\xA0\x5F\x66\xA0"
           "\x88\x3A\x7F\xDF\xA1\x8E\x06\x08\x18\x2C\x1A\x16\xCE\x0C\x6E\x13"
           "\x4F\x2E\x26\x3B\xB8\xAF\x70\x5E\x70\x48\xED\xCE\x8D\x6C\x9B\x26"
           "\xD7\xFE\x95\x5F\xC6\x91\xB6\x81\x3F\x7C\x9A\xF1\x6D\x1B\xAB\x6E"
           "\x84\x10\x94\x5A\x07\x38\x56\x75\xF0\xEB\x3C\x5E\xA3\x0E\x85\x17"
           "\xFB\x5B\xD0\xFA\x84\x3D\x58\x4C\xFD\xF0\xE5\x37\x77\x29\xE2\x5A"
           "\x7C\x74\x87\x04\x9C\xF0\x7A\x2C\xE4\xD2\x0A\x1C\xD8\x8B\x37\x8C"
           "\x7F\x1C\x10\x6E\x73\xB2\x69\x4C\xBE\x1A\x84\x3C\xC8\xA7\xA3\x68"
           "\x48\x7E\x2F\xFD\x9B\x5F\x12\xAD\x15\x49\x3F\xC4\x10\x86\xAF\x56"
           "\x4D\xCB\xC6\xE8\xAD\x35\x72\x21\x24\xD9\xC3\xA3\x82\xF1\xB2\xAF"
           "\xD9\x88\xBF\xFB\xCB\x81\xF9\xF6\x3B\xC6\x1C\x34\xF0\x5A\x33\xE5"
           "\x41\x9B\xC2\xF9\xE2\x23\x0E\x2D\x11\xC5\xBF\x41\x91\x7B\xE9\x36"
           "\x07\xD8\x60\x00\x09\xDD\xD5\x86\xD7\x65\x50\x98\xBC\x5C\x0E\x60"
           "\xA0\xE5\x53\xEC\xA6\x9D\x11\x99\xEA\x25\x44\xF4\x50\x76\x0D\x4D"
           "\xE7\x72\x87\xCF\x6F\x7C\xF2\x27\xED\x73\xD7\xEF\x53\x6D\x0B\x99"
           "\x6B\x38\x44\xBC\xC0\x12\xF5\xD6\x92\x3F\x64\x81\x54\xC1\xEF\x04"
           "\x5C\x1F\x23\x7E\xF5\x38\xA7\x80\xFC\x17\xEF\x00\x3C\x8D\x09\xAB"
           "\xAA\xD0\x40\x14\xD7\xCB\xAC\xA1\x29\xE0\x12\xD5\xD4\xFF\x1B\xDD"
           "\xCA\x78\x2B\x1D\xEC\x9F\xA5\xAC\x67\x74\x31\x8C\xF6\x8F\x9A\x59"
           "\x7D\x84\xF1\x7E\x5D\xA4\xC9\x53\xEF\x58\x2D\x1F\x0F\x3A\x6D\x66"
           "\xFF\x06\x61\x1A\xDC\xDB\x19\x0C\xE6\x43\xC4\x4A\x2B\x3D\x8E\x79"
           "\xD4\x93\xA8\x9A\x1A\xF7\x91\x45\x77\x78\xAB\xE1\x77\x33\x26\xFF"
           "\x92\x0B\x96\xD5\xF3\xAF\x05\x0B\xC4\x53\x1B\x89\xEC\xDC\xD0\x12"
           "\x4A\x65\xF3\xAD\x43\x8C\x23\x35\x13\x79\x4E\xD8\x0D\x21\xC9\x61"
           "\x49\xCA\x48\x53\x48\xC6\xA1\x7E\xF0\x28\xA5\x97\x11\xB8\x18\x33"
           "\xAD\xEC\xEF\x6B\x5C\x71\x4A\xBE\x9F\x31\xB8\xA3\x98\xC5\x0C\x0B"
           "\x46\x51\xA2\xAE\x02\x6F\x98\x35\xF7\x4D\x21\x5E\xC3\xED\x61\xB0"
           "\x6B\x59\x79\x5A\xB9\xA8\x1C\xB0\xBA\x82\x67\xB9\x97\xBB\xD4\x4D"
           "\xF1\xA1\x56\x5C\x7D\xCB\x77\xD0\x28\xE0\xFF\x1C\xAA\x22\x07\x68"
           "\x9B\xF3\x80\xDE\x96\x1D\x03\xDD\x97\x8A\x69\xDA\x5C\x54\xD4\x80"
           "\x93\xB2\x0D\xCD\x43\xBA\xFC\xDF\x11\xCF\xFE\xCE\x3B\x74\x8E\x67"
           "\x17\x74\x8E\x29\xF9\x64\x97\x52\x8C\x7B\xC9\x71\xB3\x5E\x59\x86"
           "\x63\x38\xF6\x9E\x79\x43\x56\xD6\x6F\xE6\x26\x45\x62\x64\x26\xE0"
           "\xA7\xDC\x70\xCA\x5B\xCD\xE7\xC6\xE1\x1F\xFC\x97\x57\xA1\x2B\xC5"
           "\x12\xB6\x9E\x85\x37\x9E\x58\x48\x2F\x9A\x91\xB7\xB6\x7C\x28\x47"
           "\x1A\x73\x45\x41\xD4\x6E\xBE\xB5\xB7\x60\x1A\xF2\x8B\x04\x78\x38"
           "\x4B\xB6\x45\x8C\xA9\x3E\xE5\x7A\xBF\x1F\xC4\x86\x30\xB4\x0C\xB1"
           "\xC6\x9D\x80\x88\xD2\x49\xD9\x89\xD9\x50\xA8\xDE\xEC\xA5\x04\x7F"
           "\xFF\xEA\xC0\x2F\xCB\x37\x7A\xB6\x97\x59\xAD\x53\x29\x34\xB3\x79"
           "\x16\x3B\x3E\xF5\x7F\x14\xB3\x77\xF9\x2E\xE8\x3F\x04\xAE\xDE\x89"
           "\x73\x04\x32\xA7\x4C\xC0\x4D\x43\x0D\xC1\xE5\x21\x48\x32\xAA\xE1"
           "\x5E\x81\xB6\x23\x6A\x80\xCA\x17\x23\xFC\x5F\x47\xE1\x57\x14\x59"
           "\x46\x67\x0F\xBF\x6A\x57\x53\x10\x8E\xAB\xAA\x9C\x8A\xDD\xE0\x9D"
           "\xA2\xAC\x94\x87\x6A\x71\xD0\xAF\xE4\x8A\xCF\xEB\x23\x27\x00\xC2"
           "\x8B\x11\xA9\x2C\x02\xB5\x05\x03\x30\x7A\x0C\xEF\x7F\x5B\x1C\xE7"
           "\x64\xFF\x1E\x68\x78\x28\x1C\x6D\xA0\x16\x75\x36\x7F\x9F\xF9\xCD"
           "\x15\x3B\x8E\x26\xC3\xF1\x7A\xBC\x17\x42\x92\x7D\xA8\x4E\x22\x5F"
           "\xB9\x55\xF5\xB7\x2C\x10\x5E\x79\xBB\x81\x54\x32\xDC\x8D\xE7\x4B"
           "\xE3\xCB\xDB\x1D\x34\xA4\xBA\x5F\x1A\xFE\x43\x48\x46\xEF\x88\x67"
           "\xD5\xB6\xDD\x06\x99\x5C\xB3\x38\x45\xED\xD0\x21\x77\x22\xF4\xF3"
           "\x68\xD6\x90\x53\xB5\x1E\x36\x3C\x35\x08\xCF\xBE\x53\x8F\x59\xDB"
           "\x4D\xAA\xA2\xB4\xF9\x93\xAC\x4C\x0C\xE4\x5D\xDF\x79\x57\x3C\x8F"
           "\x42\x44\xEC\x0C\x09\xA9\xC6\xE8\xF9\xF0\x80\x2E\x76\x25\x2E\xC1"
           "\x72\x0E\x55\xD6\xB9\x78\x9A\xAE\x56\xFE\x8B\x35\x38\xAF\xE3\x80"
           "\x78\x57\x55\x15\xC9\xEC\xCC\xCB\x42\xC3\xC5\xDF\x8A\xAE\x67\xB0"
           "\xCD\x63\x8E\xFC\x28\x77\x7F\xD1\x31\xFD\x9D\xD2\x79\xC8\x0A\xE0"
           "\x1A\x86\x0D\xEB\x3B\xB4\x64\x49\xAA\x6B\x7B\x73\x27\xEC\x7D\x66"
           "\x6A\x4C\x37\xB3\xCD\x4E\x97\x97\x3C\xEF\x7E\x13\x45\x36\xAA\xFE"
           "\x2E\x16\x48\x90\x5F\x53\x63\x62\xC7\xAB\xC9\xC7\xB5\x9E\xFD\xA5"
           "\x8B\x0C\xCA\xD0\x1E\xBD\x51\x67\x98\x94\x63\x08\x13\xCC\x05\xB9"
           , 1152);
    nSKLen = 1152;
    memset(bData, 0x42, 248);
    bData[0] = 0x30;
    bData[247] = 0x39;
    nDataLen = 248;
    memcpy(bSignExp,
           "\x63\x26\xC7\xF0\x7A\xAF\x63\x7A\x05\x17\xDF\x76\x8A\x63\x8A\x2D"
           "\xAD\xCA\xA0\x41\x37\x61\xBA\xE7\xD4\x03\xD4\x42\x46\xAC\x59\xC2"
           "\x2D\x11\x6E\x81\x6A\x63\xFC\xA7\x58\x23\xD0\x04\x47\xF3\x01\xBC"
           "\xA2\x06\x70\x1F\xE1\x4A\xFF\xDC\x98\x3A\xB7\x98\x1A\x68\x2D\x8E"
           "\xF6\x7E\x18\xB4\xCF\x8E\x65\xB0\x5C\x1B\x38\xB3\xAA\xBF\xC5\xEA"
           "\x77\x7C\xFA\x5B\xAA\x78\xAE\x8C\x6E\x92\x27\x1C\x37\x43\x3F\x3A"
           "\x95\xEE\xD7\x70\xBF\x93\x6B\xCB\x7D\x27\x2A\xFC\x1F\x33\xF9\x3F"
           "\x0E\xD0\xBE\x19\x10\x1A\x3B\x0F\x63\xB6\xD6\xDE\x8B\x56\x5C\xE6"
           "\xD6\xCE\x1A\x3A\x13\x91\x80\x21\x09\xA8\x8B\x18\x2F\xE3\xFD\xBC"
           "\x97\x25\x0F\xA0\xCB\x73\x7D\xE0\x55\x98\x5C\x00\x29\x5C\x18\xE8"
           "\xCB\xEE\x4D\x1B\xD9\x2E\x96\xD0\x32\x8F\x68\xB9\x95\xBF\xBD\xF0"
           "\x87\xC6\x27\x6B\x38\x6E\x2B\xF6\xFD\xE3\x74\xF6\xD5\x40\x9A\x05"
           "\x17\x79\xE1\x0A\x08\xB1\x22\x47\xDB\x5C\x6F\x36\x81\xE8\xC8\x1D"
           "\x71\xCD\xCD\x78\x5E\x42\x48\x16\xAA\xA0\xB7\x1B\x44\x25\xD8\x43"
           "\x9C\xCA\x97\xAE\xE3\x9D\x72\xAC\x71\xF2\x55\x88\xC9\xF8\x2A\xC6"
           "\x61\x69\xEE\x99\x2F\xD9\x07\xCF"
           , 248);
    nSignLenExp = 248;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 1152);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 248);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1984，SHA-1，PKCS#1填充，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bSign    =", bSign, 248);
    DspHex("[OUT]bSignExp =", bSignExp, 248);
    ASSERT_OUT_HEX(bSign, bSignExp, 248);
    ASSERT_OUT(nSignLen, nSignLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_27(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 2;
    nPadMode = 1;
    memcpy(bSK,
           "\x6C\x18\x21\x1D\x3D\xDC\x38\xA8\xBA\x10\x33\x70\x83\x41\xB5\x37"
           "\xFE\x97\x6F\xB1\xF4\x21\x1A\xAD\x35\x77\xBD\x28\xB2\x57\x20\x10"
           "\x16\x13\x93\x89\x47\xC3\x73\xFC\xB9\x76\x48\x3A\x77\xCD\xA7\x0C"
           "\x17\xE9\xF1\x4C\xD0\xA7\xE1\xAA\x0D\x9A\x8C\x38\xD1\xE6\x83\xA6"
           "\x93\xD4\x55\x28\x6B\xB9\x0F\x81\x02\x7A\x78\x54\x00\x84\x94\xFB"
           "\x82\xCC\x8A\x78\xFC\x93\x45\x6E\xD3\x13\xD3\x1F\x18\x69\x73\x2A"
           "\x70\x86\x1F\xFB\x25\xE6\x2A\x64\xCC\x6F\x1F\x18\x26\x0D\x1C\x40"
           "\xAA\x5E\x52\x50\x22\x5A\xE4\x3C\xBC\x29\xFA\xCA\x30\xE3\x53\x40"
           "\x34\x35\xF1\xD0\xE2\x69\x1D\x34\x8E\x83\x96\xAC\xAA\xCF\x6C\x98"
           "\x3F\x4F\x8C\xEF\x8C\xB3\x3A\x04\xF5\x7C\xB1\x76\xA3\x32\x1B\xC1"
           "\x83\xAD\x70\xA5\xF9\x08\xB8\xD9\x2E\xED\x15\x65\xB0\x33\x30\x04"
           "\x1F\x69\x87\x1D\xFF\xBF\x0F\x59\xE3\x62\xE1\xE8\x2C\x03\x4B\x72"
           "\xB6\xAA\x8F\x73\xBA\xFE\xEE\xCC\xAF\x50\x87\x3D\xA0\x5F\x66\xA0"
           "\x88\x3A\x7F\xDF\xA1\x8E\x06\x08\x18\x2C\x1A\x16\xCE\x0C\x6E\x13"
           "\x4F\x2E\x26\x3B\xB8\xAF\x70\x5E\x70\x48\xED\xCE\x8D\x6C\x9B\x26"
           "\xD7\xFE\x95\x5F\xC6\x91\xB6\x81\x3F\x7C\x9A\xF1\x6D\x1B\xAB\x6E"
           "\x84\x10\x94\x5A\x07\x38\x56\x75\xF0\xEB\x3C\x5E\xA3\x0E\x85\x17"
           "\xFB\x5B\xD0\xFA\x84\x3D\x58\x4C\xFD\xF0\xE5\x37\x77\x29\xE2\x5A"
           "\x7C\x74\x87\x04\x9C\xF0\x7A\x2C\xE4\xD2\x0A\x1C\xD8\x8B\x37\x8C"
           "\x7F\x1C\x10\x6E\x73\xB2\x69\x4C\xBE\x1A\x84\x3C\xC8\xA7\xA3\x68"
           "\x48\x7E\x2F\xFD\x9B\x5F\x12\xAD\x15\x49\x3F\xC4\x10\x86\xAF\x56"
           "\x4D\xCB\xC6\xE8\xAD\x35\x72\x21\x24\xD9\xC3\xA3\x82\xF1\xB2\xAF"
           "\xD9\x88\xBF\xFB\xCB\x81\xF9\xF6\x3B\xC6\x1C\x34\xF0\x5A\x33\xE5"
           "\x41\x9B\xC2\xF9\xE2\x23\x0E\x2D\x11\xC5\xBF\x41\x91\x7B\xE9\x36"
           "\x07\xD8\x60\x00\x09\xDD\xD5\x86\xD7\x65\x50\x98\xBC\x5C\x0E\x60"
           "\xA0\xE5\x53\xEC\xA6\x9D\x11\x99\xEA\x25\x44\xF4\x50\x76\x0D\x4D"
           "\xE7\x72\x87\xCF\x6F\x7C\xF2\x27\xED\x73\xD7\xEF\x53\x6D\x0B\x99"
           "\x6B\x38\x44\xBC\xC0\x12\xF5\xD6\x92\x3F\x64\x81\x54\xC1\xEF\x04"
           "\x5C\x1F\x23\x7E\xF5\x38\xA7\x80\xFC\x17\xEF\x00\x3C\x8D\x09\xAB"
           "\xAA\xD0\x40\x14\xD7\xCB\xAC\xA1\x29\xE0\x12\xD5\xD4\xFF\x1B\xDD"
           "\xCA\x78\x2B\x1D\xEC\x9F\xA5\xAC\x67\x74\x31\x8C\xF6\x8F\x9A\x59"
           "\x7D\x84\xF1\x7E\x5D\xA4\xC9\x53\xEF\x58\x2D\x1F\x0F\x3A\x6D\x66"
           "\xFF\x06\x61\x1A\xDC\xDB\x19\x0C\xE6\x43\xC4\x4A\x2B\x3D\x8E\x79"
           "\xD4\x93\xA8\x9A\x1A\xF7\x91\x45\x77\x78\xAB\xE1\x77\x33\x26\xFF"
           "\x92\x0B\x96\xD5\xF3\xAF\x05\x0B\xC4\x53\x1B\x89\xEC\xDC\xD0\x12"
           "\x4A\x65\xF3\xAD\x43\x8C\x23\x35\x13\x79\x4E\xD8\x0D\x21\xC9\x61"
           "\x49\xCA\x48\x53\x48\xC6\xA1\x7E\xF0\x28\xA5\x97\x11\xB8\x18\x33"
           "\xAD\xEC\xEF\x6B\x5C\x71\x4A\xBE\x9F\x31\xB8\xA3\x98\xC5\x0C\x0B"
           "\x46\x51\xA2\xAE\x02\x6F\x98\x35\xF7\x4D\x21\x5E\xC3\xED\x61\xB0"
           "\x6B\x59\x79\x5A\xB9\xA8\x1C\xB0\xBA\x82\x67\xB9\x97\xBB\xD4\x4D"
           "\xF1\xA1\x56\x5C\x7D\xCB\x77\xD0\x28\xE0\xFF\x1C\xAA\x22\x07\x68"
           "\x9B\xF3\x80\xDE\x96\x1D\x03\xDD\x97\x8A\x69\xDA\x5C\x54\xD4\x80"
           "\x93\xB2\x0D\xCD\x43\xBA\xFC\xDF\x11\xCF\xFE\xCE\x3B\x74\x8E\x67"
           "\x17\x74\x8E\x29\xF9\x64\x97\x52\x8C\x7B\xC9\x71\xB3\x5E\x59\x86"
           "\x63\x38\xF6\x9E\x79\x43\x56\xD6\x6F\xE6\x26\x45\x62\x64\x26\xE0"
           "\xA7\xDC\x70\xCA\x5B\xCD\xE7\xC6\xE1\x1F\xFC\x97\x57\xA1\x2B\xC5"
           "\x12\xB6\x9E\x85\x37\x9E\x58\x48\x2F\x9A\x91\xB7\xB6\x7C\x28\x47"
           "\x1A\x73\x45\x41\xD4\x6E\xBE\xB5\xB7\x60\x1A\xF2\x8B\x04\x78\x38"
           "\x4B\xB6\x45\x8C\xA9\x3E\xE5\x7A\xBF\x1F\xC4\x86\x30\xB4\x0C\xB1"
           "\xC6\x9D\x80\x88\xD2\x49\xD9\x89\xD9\x50\xA8\xDE\xEC\xA5\x04\x7F"
           "\xFF\xEA\xC0\x2F\xCB\x37\x7A\xB6\x97\x59\xAD\x53\x29\x34\xB3\x79"
           "\x16\x3B\x3E\xF5\x7F\x14\xB3\x77\xF9\x2E\xE8\x3F\x04\xAE\xDE\x89"
           "\x73\x04\x32\xA7\x4C\xC0\x4D\x43\x0D\xC1\xE5\x21\x48\x32\xAA\xE1"
           "\x5E\x81\xB6\x23\x6A\x80\xCA\x17\x23\xFC\x5F\x47\xE1\x57\x14\x59"
           "\x46\x67\x0F\xBF\x6A\x57\x53\x10\x8E\xAB\xAA\x9C\x8A\xDD\xE0\x9D"
           "\xA2\xAC\x94\x87\x6A\x71\xD0\xAF\xE4\x8A\xCF\xEB\x23\x27\x00\xC2"
           "\x8B\x11\xA9\x2C\x02\xB5\x05\x03\x30\x7A\x0C\xEF\x7F\x5B\x1C\xE7"
           "\x64\xFF\x1E\x68\x78\x28\x1C\x6D\xA0\x16\x75\x36\x7F\x9F\xF9\xCD"
           "\x15\x3B\x8E\x26\xC3\xF1\x7A\xBC\x17\x42\x92\x7D\xA8\x4E\x22\x5F"
           "\xB9\x55\xF5\xB7\x2C\x10\x5E\x79\xBB\x81\x54\x32\xDC\x8D\xE7\x4B"
           "\xE3\xCB\xDB\x1D\x34\xA4\xBA\x5F\x1A\xFE\x43\x48\x46\xEF\x88\x67"
           "\xD5\xB6\xDD\x06\x99\x5C\xB3\x38\x45\xED\xD0\x21\x77\x22\xF4\xF3"
           "\x68\xD6\x90\x53\xB5\x1E\x36\x3C\x35\x08\xCF\xBE\x53\x8F\x59\xDB"
           "\x4D\xAA\xA2\xB4\xF9\x93\xAC\x4C\x0C\xE4\x5D\xDF\x79\x57\x3C\x8F"
           "\x42\x44\xEC\x0C\x09\xA9\xC6\xE8\xF9\xF0\x80\x2E\x76\x25\x2E\xC1"
           "\x72\x0E\x55\xD6\xB9\x78\x9A\xAE\x56\xFE\x8B\x35\x38\xAF\xE3\x80"
           "\x78\x57\x55\x15\xC9\xEC\xCC\xCB\x42\xC3\xC5\xDF\x8A\xAE\x67\xB0"
           "\xCD\x63\x8E\xFC\x28\x77\x7F\xD1\x31\xFD\x9D\xD2\x79\xC8\x0A\xE0"
           "\x1A\x86\x0D\xEB\x3B\xB4\x64\x49\xAA\x6B\x7B\x73\x27\xEC\x7D\x66"
           "\x6A\x4C\x37\xB3\xCD\x4E\x97\x97\x3C\xEF\x7E\x13\x45\x36\xAA\xFE"
           "\x2E\x16\x48\x90\x5F\x53\x63\x62\xC7\xAB\xC9\xC7\xB5\x9E\xFD\xA5"
           "\x8B\x0C\xCA\xD0\x1E\xBD\x51\x67\x98\x94\x63\x08\x13\xCC\x05\xB9"
           , 1152);
    nSKLen = 1152;
    memset(bData, 0x42, 248);
    bData[0] = 0x30;
    bData[247] = 0x39;
    nDataLen = 248;
    memcpy(bSignExp,
           "\x86\x38\x02\xC3\xBB\x6D\xAC\x57\x7A\xB8\x30\x7E\x98\x59\xB8\xDB"
           "\x9E\xE6\x14\x00\x56\xC4\x58\xC6\x12\x39\xC5\x96\xFE\x71\x4B\x8B"
           "\xE6\xCE\x32\x16\x50\xCA\x56\x01\xA6\xE5\xFF\xCF\x04\x8E\x41\xEC"
           "\x73\x64\x19\x89\x89\x47\x38\x14\x1B\x4C\x48\x4A\x1E\x56\x3F\xD0"
           "\x8C\xA3\xBF\xC0\xFD\x22\xDD\x18\x8A\x9C\xB4\xDF\x38\x9B\x79\xD7"
           "\xE5\x14\xFF\x04\x7E\x1F\x78\x92\x5F\xF1\x16\x5B\x0C\x6F\x0A\x9B"
           "\x8F\x0D\xE2\xE2\xEB\xC9\xC1\x70\x88\x16\x70\x47\xA9\x69\x1F\x6D"
           "\x3E\xBE\xB8\xFD\x73\x63\xCF\x86\x56\x7E\x33\xC5\x9D\xBF\x2A\xAE"
           "\x2D\x37\xBB\x09\x71\x37\x6D\x7E\x59\x7B\x9D\x89\x66\x7A\x58\x8C"
           "\xD3\xB6\x20\xAA\x8A\x9C\xD2\x00\xC1\xA2\x6D\x2E\x3C\xCF\xC6\xDD"
           "\x42\xCA\xCB\x6E\x51\x3D\x3F\x9D\xBC\x24\x37\xE8\x76\xBB\x8E\xEF"
           "\x38\x81\x91\x20\x39\xFC\x86\xDE\x3C\xE4\x06\x30\xF1\x3A\x4A\xD2"
           "\xD5\x59\x9A\x03\x55\xE0\xE0\x72\x8C\xFC\x9C\x22\xF0\x9D\x64\x76"
           "\x88\x03\xFB\x27\x0E\x8D\x72\x80\x7A\x73\x88\x61\x67\xB4\x52\x32"
           "\xC7\xF1\xE1\x76\xA1\x5A\xAA\x5D\x86\x24\x3B\x6C\x2B\xAD\xB2\xCD"
           "\x85\xA1\x05\x99\xC1\x48\x53\xA5"
           , 248);
    nSignLenExp = 248;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 1152);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 248);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1984，SHA-224，PKCS#1填充，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bSign    =", bSign, 248);
    DspHex("[OUT]bSignExp =", bSignExp, 248);
    ASSERT_OUT_HEX(bSign, bSignExp, 248);
    ASSERT_OUT(nSignLen, nSignLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_28(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 3;
    nPadMode = 1;
    memcpy(bSK,
           "\x6C\x18\x21\x1D\x3D\xDC\x38\xA8\xBA\x10\x33\x70\x83\x41\xB5\x37"
           "\xFE\x97\x6F\xB1\xF4\x21\x1A\xAD\x35\x77\xBD\x28\xB2\x57\x20\x10"
           "\x16\x13\x93\x89\x47\xC3\x73\xFC\xB9\x76\x48\x3A\x77\xCD\xA7\x0C"
           "\x17\xE9\xF1\x4C\xD0\xA7\xE1\xAA\x0D\x9A\x8C\x38\xD1\xE6\x83\xA6"
           "\x93\xD4\x55\x28\x6B\xB9\x0F\x81\x02\x7A\x78\x54\x00\x84\x94\xFB"
           "\x82\xCC\x8A\x78\xFC\x93\x45\x6E\xD3\x13\xD3\x1F\x18\x69\x73\x2A"
           "\x70\x86\x1F\xFB\x25\xE6\x2A\x64\xCC\x6F\x1F\x18\x26\x0D\x1C\x40"
           "\xAA\x5E\x52\x50\x22\x5A\xE4\x3C\xBC\x29\xFA\xCA\x30\xE3\x53\x40"
           "\x34\x35\xF1\xD0\xE2\x69\x1D\x34\x8E\x83\x96\xAC\xAA\xCF\x6C\x98"
           "\x3F\x4F\x8C\xEF\x8C\xB3\x3A\x04\xF5\x7C\xB1\x76\xA3\x32\x1B\xC1"
           "\x83\xAD\x70\xA5\xF9\x08\xB8\xD9\x2E\xED\x15\x65\xB0\x33\x30\x04"
           "\x1F\x69\x87\x1D\xFF\xBF\x0F\x59\xE3\x62\xE1\xE8\x2C\x03\x4B\x72"
           "\xB6\xAA\x8F\x73\xBA\xFE\xEE\xCC\xAF\x50\x87\x3D\xA0\x5F\x66\xA0"
           "\x88\x3A\x7F\xDF\xA1\x8E\x06\x08\x18\x2C\x1A\x16\xCE\x0C\x6E\x13"
           "\x4F\x2E\x26\x3B\xB8\xAF\x70\x5E\x70\x48\xED\xCE\x8D\x6C\x9B\x26"
           "\xD7\xFE\x95\x5F\xC6\x91\xB6\x81\x3F\x7C\x9A\xF1\x6D\x1B\xAB\x6E"
           "\x84\x10\x94\x5A\x07\x38\x56\x75\xF0\xEB\x3C\x5E\xA3\x0E\x85\x17"
           "\xFB\x5B\xD0\xFA\x84\x3D\x58\x4C\xFD\xF0\xE5\x37\x77\x29\xE2\x5A"
           "\x7C\x74\x87\x04\x9C\xF0\x7A\x2C\xE4\xD2\x0A\x1C\xD8\x8B\x37\x8C"
           "\x7F\x1C\x10\x6E\x73\xB2\x69\x4C\xBE\x1A\x84\x3C\xC8\xA7\xA3\x68"
           "\x48\x7E\x2F\xFD\x9B\x5F\x12\xAD\x15\x49\x3F\xC4\x10\x86\xAF\x56"
           "\x4D\xCB\xC6\xE8\xAD\x35\x72\x21\x24\xD9\xC3\xA3\x82\xF1\xB2\xAF"
           "\xD9\x88\xBF\xFB\xCB\x81\xF9\xF6\x3B\xC6\x1C\x34\xF0\x5A\x33\xE5"
           "\x41\x9B\xC2\xF9\xE2\x23\x0E\x2D\x11\xC5\xBF\x41\x91\x7B\xE9\x36"
           "\x07\xD8\x60\x00\x09\xDD\xD5\x86\xD7\x65\x50\x98\xBC\x5C\x0E\x60"
           "\xA0\xE5\x53\xEC\xA6\x9D\x11\x99\xEA\x25\x44\xF4\x50\x76\x0D\x4D"
           "\xE7\x72\x87\xCF\x6F\x7C\xF2\x27\xED\x73\xD7\xEF\x53\x6D\x0B\x99"
           "\x6B\x38\x44\xBC\xC0\x12\xF5\xD6\x92\x3F\x64\x81\x54\xC1\xEF\x04"
           "\x5C\x1F\x23\x7E\xF5\x38\xA7\x80\xFC\x17\xEF\x00\x3C\x8D\x09\xAB"
           "\xAA\xD0\x40\x14\xD7\xCB\xAC\xA1\x29\xE0\x12\xD5\xD4\xFF\x1B\xDD"
           "\xCA\x78\x2B\x1D\xEC\x9F\xA5\xAC\x67\x74\x31\x8C\xF6\x8F\x9A\x59"
           "\x7D\x84\xF1\x7E\x5D\xA4\xC9\x53\xEF\x58\x2D\x1F\x0F\x3A\x6D\x66"
           "\xFF\x06\x61\x1A\xDC\xDB\x19\x0C\xE6\x43\xC4\x4A\x2B\x3D\x8E\x79"
           "\xD4\x93\xA8\x9A\x1A\xF7\x91\x45\x77\x78\xAB\xE1\x77\x33\x26\xFF"
           "\x92\x0B\x96\xD5\xF3\xAF\x05\x0B\xC4\x53\x1B\x89\xEC\xDC\xD0\x12"
           "\x4A\x65\xF3\xAD\x43\x8C\x23\x35\x13\x79\x4E\xD8\x0D\x21\xC9\x61"
           "\x49\xCA\x48\x53\x48\xC6\xA1\x7E\xF0\x28\xA5\x97\x11\xB8\x18\x33"
           "\xAD\xEC\xEF\x6B\x5C\x71\x4A\xBE\x9F\x31\xB8\xA3\x98\xC5\x0C\x0B"
           "\x46\x51\xA2\xAE\x02\x6F\x98\x35\xF7\x4D\x21\x5E\xC3\xED\x61\xB0"
           "\x6B\x59\x79\x5A\xB9\xA8\x1C\xB0\xBA\x82\x67\xB9\x97\xBB\xD4\x4D"
           "\xF1\xA1\x56\x5C\x7D\xCB\x77\xD0\x28\xE0\xFF\x1C\xAA\x22\x07\x68"
           "\x9B\xF3\x80\xDE\x96\x1D\x03\xDD\x97\x8A\x69\xDA\x5C\x54\xD4\x80"
           "\x93\xB2\x0D\xCD\x43\xBA\xFC\xDF\x11\xCF\xFE\xCE\x3B\x74\x8E\x67"
           "\x17\x74\x8E\x29\xF9\x64\x97\x52\x8C\x7B\xC9\x71\xB3\x5E\x59\x86"
           "\x63\x38\xF6\x9E\x79\x43\x56\xD6\x6F\xE6\x26\x45\x62\x64\x26\xE0"
           "\xA7\xDC\x70\xCA\x5B\xCD\xE7\xC6\xE1\x1F\xFC\x97\x57\xA1\x2B\xC5"
           "\x12\xB6\x9E\x85\x37\x9E\x58\x48\x2F\x9A\x91\xB7\xB6\x7C\x28\x47"
           "\x1A\x73\x45\x41\xD4\x6E\xBE\xB5\xB7\x60\x1A\xF2\x8B\x04\x78\x38"
           "\x4B\xB6\x45\x8C\xA9\x3E\xE5\x7A\xBF\x1F\xC4\x86\x30\xB4\x0C\xB1"
           "\xC6\x9D\x80\x88\xD2\x49\xD9\x89\xD9\x50\xA8\xDE\xEC\xA5\x04\x7F"
           "\xFF\xEA\xC0\x2F\xCB\x37\x7A\xB6\x97\x59\xAD\x53\x29\x34\xB3\x79"
           "\x16\x3B\x3E\xF5\x7F\x14\xB3\x77\xF9\x2E\xE8\x3F\x04\xAE\xDE\x89"
           "\x73\x04\x32\xA7\x4C\xC0\x4D\x43\x0D\xC1\xE5\x21\x48\x32\xAA\xE1"
           "\x5E\x81\xB6\x23\x6A\x80\xCA\x17\x23\xFC\x5F\x47\xE1\x57\x14\x59"
           "\x46\x67\x0F\xBF\x6A\x57\x53\x10\x8E\xAB\xAA\x9C\x8A\xDD\xE0\x9D"
           "\xA2\xAC\x94\x87\x6A\x71\xD0\xAF\xE4\x8A\xCF\xEB\x23\x27\x00\xC2"
           "\x8B\x11\xA9\x2C\x02\xB5\x05\x03\x30\x7A\x0C\xEF\x7F\x5B\x1C\xE7"
           "\x64\xFF\x1E\x68\x78\x28\x1C\x6D\xA0\x16\x75\x36\x7F\x9F\xF9\xCD"
           "\x15\x3B\x8E\x26\xC3\xF1\x7A\xBC\x17\x42\x92\x7D\xA8\x4E\x22\x5F"
           "\xB9\x55\xF5\xB7\x2C\x10\x5E\x79\xBB\x81\x54\x32\xDC\x8D\xE7\x4B"
           "\xE3\xCB\xDB\x1D\x34\xA4\xBA\x5F\x1A\xFE\x43\x48\x46\xEF\x88\x67"
           "\xD5\xB6\xDD\x06\x99\x5C\xB3\x38\x45\xED\xD0\x21\x77\x22\xF4\xF3"
           "\x68\xD6\x90\x53\xB5\x1E\x36\x3C\x35\x08\xCF\xBE\x53\x8F\x59\xDB"
           "\x4D\xAA\xA2\xB4\xF9\x93\xAC\x4C\x0C\xE4\x5D\xDF\x79\x57\x3C\x8F"
           "\x42\x44\xEC\x0C\x09\xA9\xC6\xE8\xF9\xF0\x80\x2E\x76\x25\x2E\xC1"
           "\x72\x0E\x55\xD6\xB9\x78\x9A\xAE\x56\xFE\x8B\x35\x38\xAF\xE3\x80"
           "\x78\x57\x55\x15\xC9\xEC\xCC\xCB\x42\xC3\xC5\xDF\x8A\xAE\x67\xB0"
           "\xCD\x63\x8E\xFC\x28\x77\x7F\xD1\x31\xFD\x9D\xD2\x79\xC8\x0A\xE0"
           "\x1A\x86\x0D\xEB\x3B\xB4\x64\x49\xAA\x6B\x7B\x73\x27\xEC\x7D\x66"
           "\x6A\x4C\x37\xB3\xCD\x4E\x97\x97\x3C\xEF\x7E\x13\x45\x36\xAA\xFE"
           "\x2E\x16\x48\x90\x5F\x53\x63\x62\xC7\xAB\xC9\xC7\xB5\x9E\xFD\xA5"
           "\x8B\x0C\xCA\xD0\x1E\xBD\x51\x67\x98\x94\x63\x08\x13\xCC\x05\xB9"
           , 1152);
    nSKLen = 1152;
    memset(bData, 0x42, 248);
    bData[0] = 0x30;
    bData[247] = 0x39;
    nDataLen = 248;
    memcpy(bSignExp,
           "\x70\x9F\x1E\x8F\xEE\xB6\x22\x89\x2B\x47\x20\x3F\xF2\x98\xE1\x9B"
           "\xA3\x67\x20\xF1\x52\xE5\x5E\x60\xC1\x70\x28\x72\x1F\x26\x01\xFA"
           "\x31\x52\x99\x21\x98\xD9\x6A\xA3\x1D\xC0\xBE\xBC\x58\x06\x4A\x67"
           "\x5B\x97\x4E\xDA\xF6\xA9\xD1\x89\x5E\xC2\x54\x84\xCC\x47\xF8\xD1"
           "\x26\x06\xDE\x3D\x7E\x3F\x4C\x39\xFC\xCB\x4B\x9C\x86\x3D\x3D\xDE"
           "\xF4\x15\x9B\x1A\x28\xA5\x9F\xDC\xAF\x84\x4E\x83\x2E\x69\x93\x25"
           "\xF3\xC7\x47\x01\xFF\xC7\xC9\x6A\x5F\xE6\x95\x50\xA9\x6F\x2A\x86"
           "\x7B\xA5\x28\x95\x26\x6F\xDC\x96\x38\x16\xFE\x6C\x14\x33\x75\xA3"
           "\xFD\xAE\x5E\xD2\x99\x9F\x04\x67\x80\xD5\xD0\x04\xA9\xD3\xC4\x60"
           "\xE4\xB5\x78\x7E\xDB\xF5\x11\x74\x1F\x13\x74\x3D\xA1\xB6\xB7\x71"
           "\xF5\xB5\x8B\x6B\xE3\x44\x4A\x3C\x01\xF8\xBC\x6A\x9E\xBA\x28\x16"
           "\x6D\x32\xA3\xE4\xD4\x84\x03\xAF\x47\xD9\xD3\x53\x6D\x6D\xBD\x75"
           "\x9B\xBA\xCB\xCF\xB4\x07\x22\x2E\xF1\x9F\x94\x46\xDD\x4C\x38\x92"
           "\x7D\x48\x7B\xB9\xA8\xD7\xE4\xD3\xAD\x1F\x53\x06\x5E\x0D\x02\xC4"
           "\x06\xF9\xAD\x4B\x0B\x4B\x83\x7B\x94\x47\x6E\x39\x72\x77\xA1\xE7"
           "\xC7\xB6\x3A\xE2\x17\x48\xA3\x17"
           , 248);
    nSignLenExp = 248;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 1152);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 248);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1984，SHA-256，PKCS#1填充，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bSign    =", bSign, 248);
    DspHex("[OUT]bSignExp =", bSignExp, 248);
    ASSERT_OUT_HEX(bSign, bSignExp, 248);
    ASSERT_OUT(nSignLen, nSignLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_29(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 4;
    nPadMode = 1;
    memcpy(bSK,
           "\x6C\x18\x21\x1D\x3D\xDC\x38\xA8\xBA\x10\x33\x70\x83\x41\xB5\x37"
           "\xFE\x97\x6F\xB1\xF4\x21\x1A\xAD\x35\x77\xBD\x28\xB2\x57\x20\x10"
           "\x16\x13\x93\x89\x47\xC3\x73\xFC\xB9\x76\x48\x3A\x77\xCD\xA7\x0C"
           "\x17\xE9\xF1\x4C\xD0\xA7\xE1\xAA\x0D\x9A\x8C\x38\xD1\xE6\x83\xA6"
           "\x93\xD4\x55\x28\x6B\xB9\x0F\x81\x02\x7A\x78\x54\x00\x84\x94\xFB"
           "\x82\xCC\x8A\x78\xFC\x93\x45\x6E\xD3\x13\xD3\x1F\x18\x69\x73\x2A"
           "\x70\x86\x1F\xFB\x25\xE6\x2A\x64\xCC\x6F\x1F\x18\x26\x0D\x1C\x40"
           "\xAA\x5E\x52\x50\x22\x5A\xE4\x3C\xBC\x29\xFA\xCA\x30\xE3\x53\x40"
           "\x34\x35\xF1\xD0\xE2\x69\x1D\x34\x8E\x83\x96\xAC\xAA\xCF\x6C\x98"
           "\x3F\x4F\x8C\xEF\x8C\xB3\x3A\x04\xF5\x7C\xB1\x76\xA3\x32\x1B\xC1"
           "\x83\xAD\x70\xA5\xF9\x08\xB8\xD9\x2E\xED\x15\x65\xB0\x33\x30\x04"
           "\x1F\x69\x87\x1D\xFF\xBF\x0F\x59\xE3\x62\xE1\xE8\x2C\x03\x4B\x72"
           "\xB6\xAA\x8F\x73\xBA\xFE\xEE\xCC\xAF\x50\x87\x3D\xA0\x5F\x66\xA0"
           "\x88\x3A\x7F\xDF\xA1\x8E\x06\x08\x18\x2C\x1A\x16\xCE\x0C\x6E\x13"
           "\x4F\x2E\x26\x3B\xB8\xAF\x70\x5E\x70\x48\xED\xCE\x8D\x6C\x9B\x26"
           "\xD7\xFE\x95\x5F\xC6\x91\xB6\x81\x3F\x7C\x9A\xF1\x6D\x1B\xAB\x6E"
           "\x84\x10\x94\x5A\x07\x38\x56\x75\xF0\xEB\x3C\x5E\xA3\x0E\x85\x17"
           "\xFB\x5B\xD0\xFA\x84\x3D\x58\x4C\xFD\xF0\xE5\x37\x77\x29\xE2\x5A"
           "\x7C\x74\x87\x04\x9C\xF0\x7A\x2C\xE4\xD2\x0A\x1C\xD8\x8B\x37\x8C"
           "\x7F\x1C\x10\x6E\x73\xB2\x69\x4C\xBE\x1A\x84\x3C\xC8\xA7\xA3\x68"
           "\x48\x7E\x2F\xFD\x9B\x5F\x12\xAD\x15\x49\x3F\xC4\x10\x86\xAF\x56"
           "\x4D\xCB\xC6\xE8\xAD\x35\x72\x21\x24\xD9\xC3\xA3\x82\xF1\xB2\xAF"
           "\xD9\x88\xBF\xFB\xCB\x81\xF9\xF6\x3B\xC6\x1C\x34\xF0\x5A\x33\xE5"
           "\x41\x9B\xC2\xF9\xE2\x23\x0E\x2D\x11\xC5\xBF\x41\x91\x7B\xE9\x36"
           "\x07\xD8\x60\x00\x09\xDD\xD5\x86\xD7\x65\x50\x98\xBC\x5C\x0E\x60"
           "\xA0\xE5\x53\xEC\xA6\x9D\x11\x99\xEA\x25\x44\xF4\x50\x76\x0D\x4D"
           "\xE7\x72\x87\xCF\x6F\x7C\xF2\x27\xED\x73\xD7\xEF\x53\x6D\x0B\x99"
           "\x6B\x38\x44\xBC\xC0\x12\xF5\xD6\x92\x3F\x64\x81\x54\xC1\xEF\x04"
           "\x5C\x1F\x23\x7E\xF5\x38\xA7\x80\xFC\x17\xEF\x00\x3C\x8D\x09\xAB"
           "\xAA\xD0\x40\x14\xD7\xCB\xAC\xA1\x29\xE0\x12\xD5\xD4\xFF\x1B\xDD"
           "\xCA\x78\x2B\x1D\xEC\x9F\xA5\xAC\x67\x74\x31\x8C\xF6\x8F\x9A\x59"
           "\x7D\x84\xF1\x7E\x5D\xA4\xC9\x53\xEF\x58\x2D\x1F\x0F\x3A\x6D\x66"
           "\xFF\x06\x61\x1A\xDC\xDB\x19\x0C\xE6\x43\xC4\x4A\x2B\x3D\x8E\x79"
           "\xD4\x93\xA8\x9A\x1A\xF7\x91\x45\x77\x78\xAB\xE1\x77\x33\x26\xFF"
           "\x92\x0B\x96\xD5\xF3\xAF\x05\x0B\xC4\x53\x1B\x89\xEC\xDC\xD0\x12"
           "\x4A\x65\xF3\xAD\x43\x8C\x23\x35\x13\x79\x4E\xD8\x0D\x21\xC9\x61"
           "\x49\xCA\x48\x53\x48\xC6\xA1\x7E\xF0\x28\xA5\x97\x11\xB8\x18\x33"
           "\xAD\xEC\xEF\x6B\x5C\x71\x4A\xBE\x9F\x31\xB8\xA3\x98\xC5\x0C\x0B"
           "\x46\x51\xA2\xAE\x02\x6F\x98\x35\xF7\x4D\x21\x5E\xC3\xED\x61\xB0"
           "\x6B\x59\x79\x5A\xB9\xA8\x1C\xB0\xBA\x82\x67\xB9\x97\xBB\xD4\x4D"
           "\xF1\xA1\x56\x5C\x7D\xCB\x77\xD0\x28\xE0\xFF\x1C\xAA\x22\x07\x68"
           "\x9B\xF3\x80\xDE\x96\x1D\x03\xDD\x97\x8A\x69\xDA\x5C\x54\xD4\x80"
           "\x93\xB2\x0D\xCD\x43\xBA\xFC\xDF\x11\xCF\xFE\xCE\x3B\x74\x8E\x67"
           "\x17\x74\x8E\x29\xF9\x64\x97\x52\x8C\x7B\xC9\x71\xB3\x5E\x59\x86"
           "\x63\x38\xF6\x9E\x79\x43\x56\xD6\x6F\xE6\x26\x45\x62\x64\x26\xE0"
           "\xA7\xDC\x70\xCA\x5B\xCD\xE7\xC6\xE1\x1F\xFC\x97\x57\xA1\x2B\xC5"
           "\x12\xB6\x9E\x85\x37\x9E\x58\x48\x2F\x9A\x91\xB7\xB6\x7C\x28\x47"
           "\x1A\x73\x45\x41\xD4\x6E\xBE\xB5\xB7\x60\x1A\xF2\x8B\x04\x78\x38"
           "\x4B\xB6\x45\x8C\xA9\x3E\xE5\x7A\xBF\x1F\xC4\x86\x30\xB4\x0C\xB1"
           "\xC6\x9D\x80\x88\xD2\x49\xD9\x89\xD9\x50\xA8\xDE\xEC\xA5\x04\x7F"
           "\xFF\xEA\xC0\x2F\xCB\x37\x7A\xB6\x97\x59\xAD\x53\x29\x34\xB3\x79"
           "\x16\x3B\x3E\xF5\x7F\x14\xB3\x77\xF9\x2E\xE8\x3F\x04\xAE\xDE\x89"
           "\x73\x04\x32\xA7\x4C\xC0\x4D\x43\x0D\xC1\xE5\x21\x48\x32\xAA\xE1"
           "\x5E\x81\xB6\x23\x6A\x80\xCA\x17\x23\xFC\x5F\x47\xE1\x57\x14\x59"
           "\x46\x67\x0F\xBF\x6A\x57\x53\x10\x8E\xAB\xAA\x9C\x8A\xDD\xE0\x9D"
           "\xA2\xAC\x94\x87\x6A\x71\xD0\xAF\xE4\x8A\xCF\xEB\x23\x27\x00\xC2"
           "\x8B\x11\xA9\x2C\x02\xB5\x05\x03\x30\x7A\x0C\xEF\x7F\x5B\x1C\xE7"
           "\x64\xFF\x1E\x68\x78\x28\x1C\x6D\xA0\x16\x75\x36\x7F\x9F\xF9\xCD"
           "\x15\x3B\x8E\x26\xC3\xF1\x7A\xBC\x17\x42\x92\x7D\xA8\x4E\x22\x5F"
           "\xB9\x55\xF5\xB7\x2C\x10\x5E\x79\xBB\x81\x54\x32\xDC\x8D\xE7\x4B"
           "\xE3\xCB\xDB\x1D\x34\xA4\xBA\x5F\x1A\xFE\x43\x48\x46\xEF\x88\x67"
           "\xD5\xB6\xDD\x06\x99\x5C\xB3\x38\x45\xED\xD0\x21\x77\x22\xF4\xF3"
           "\x68\xD6\x90\x53\xB5\x1E\x36\x3C\x35\x08\xCF\xBE\x53\x8F\x59\xDB"
           "\x4D\xAA\xA2\xB4\xF9\x93\xAC\x4C\x0C\xE4\x5D\xDF\x79\x57\x3C\x8F"
           "\x42\x44\xEC\x0C\x09\xA9\xC6\xE8\xF9\xF0\x80\x2E\x76\x25\x2E\xC1"
           "\x72\x0E\x55\xD6\xB9\x78\x9A\xAE\x56\xFE\x8B\x35\x38\xAF\xE3\x80"
           "\x78\x57\x55\x15\xC9\xEC\xCC\xCB\x42\xC3\xC5\xDF\x8A\xAE\x67\xB0"
           "\xCD\x63\x8E\xFC\x28\x77\x7F\xD1\x31\xFD\x9D\xD2\x79\xC8\x0A\xE0"
           "\x1A\x86\x0D\xEB\x3B\xB4\x64\x49\xAA\x6B\x7B\x73\x27\xEC\x7D\x66"
           "\x6A\x4C\x37\xB3\xCD\x4E\x97\x97\x3C\xEF\x7E\x13\x45\x36\xAA\xFE"
           "\x2E\x16\x48\x90\x5F\x53\x63\x62\xC7\xAB\xC9\xC7\xB5\x9E\xFD\xA5"
           "\x8B\x0C\xCA\xD0\x1E\xBD\x51\x67\x98\x94\x63\x08\x13\xCC\x05\xB9"
           , 1152);
    nSKLen = 1152;
    memset(bData, 0x42, 248);
    bData[0] = 0x30;
    bData[247] = 0x39;
    nDataLen = 248;
    memcpy(bSignExp,
           "\x80\xFE\x00\xE3\x54\xE5\x69\x4C\x78\x46\x12\xF4\xBD\x75\xE4\x9D"
           "\xB2\x6A\xC2\xEA\xA5\xEE\xBF\x9D\xDA\x04\x96\x66\x6A\x1C\xC9\xA0"
           "\xDB\x01\x8D\x47\x2A\x74\x5B\x21\x49\x1A\xAC\xE3\xF6\x3F\xD2\x0A"
           "\x43\xF8\x98\xB9\xB3\x14\x57\x5F\x5B\x26\x81\x02\xB3\x14\x33\xCE"
           "\x3D\x9E\xF4\xF5\xA2\x5C\xC4\xC4\xFA\x79\x46\x25\xAE\x74\xE6\x84"
           "\xAC\x9B\xE8\xA7\x7C\x81\xA1\x87\x54\x1F\x0E\xA2\xC0\x88\x5F\x15"
           "\x72\x81\x41\x55\x26\x36\x7F\xDA\x74\xEB\x40\xB2\x3B\xEF\xA7\x1F"
           "\xB9\x60\xB7\x65\x64\xDA\xDE\x6E\xB6\xA2\xDB\x85\xCF\x20\xC5\x13"
           "\x23\x5F\x69\x99\x18\x5E\x4E\xA6\x20\x54\x80\xAD\xF9\xD0\x2C\x7C"
           "\xE6\x8B\x42\x85\xC3\xEE\x91\xD9\x2D\xC5\x0E\xF8\xE5\x5C\x0B\x23"
           "\xF0\xC3\x3F\xD4\x53\x2B\xD8\x78\x60\xEC\x42\xAD\x42\xB2\xCA\x68"
           "\xB7\xAC\x77\x1C\x22\xEF\xAC\x5B\xB8\xEE\xB6\x4A\x9F\x38\xBA\x79"
           "\x97\x89\xDF\x5C\x49\x2A\xA4\x09\xFC\x77\x80\xFF\x06\x45\xF4\xF1"
           "\x3D\x99\x8C\xB6\x3B\xE9\xE8\x62\x6E\x5C\xCF\x5E\x9E\xDA\xF5\xB8"
           "\x2C\x81\xBA\x20\x32\x44\x71\xC2\xF6\xD4\xFF\xCF\x63\x6C\x97\x03"
           "\xCB\xD9\xA8\x68\x81\xB0\xE4\xBE"
           , 248);
    nSignLenExp = 248;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 1152);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 248);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1984，SHA-384，PKCS#1填充，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bSign    =", bSign, 248);
    DspHex("[OUT]bSignExp =", bSignExp, 248);
    ASSERT_OUT_HEX(bSign, bSignExp, 248);
    ASSERT_OUT(nSignLen, nSignLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_30(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 5;
    nPadMode = 1;
    memcpy(bSK,
           "\x6C\x18\x21\x1D\x3D\xDC\x38\xA8\xBA\x10\x33\x70\x83\x41\xB5\x37"
           "\xFE\x97\x6F\xB1\xF4\x21\x1A\xAD\x35\x77\xBD\x28\xB2\x57\x20\x10"
           "\x16\x13\x93\x89\x47\xC3\x73\xFC\xB9\x76\x48\x3A\x77\xCD\xA7\x0C"
           "\x17\xE9\xF1\x4C\xD0\xA7\xE1\xAA\x0D\x9A\x8C\x38\xD1\xE6\x83\xA6"
           "\x93\xD4\x55\x28\x6B\xB9\x0F\x81\x02\x7A\x78\x54\x00\x84\x94\xFB"
           "\x82\xCC\x8A\x78\xFC\x93\x45\x6E\xD3\x13\xD3\x1F\x18\x69\x73\x2A"
           "\x70\x86\x1F\xFB\x25\xE6\x2A\x64\xCC\x6F\x1F\x18\x26\x0D\x1C\x40"
           "\xAA\x5E\x52\x50\x22\x5A\xE4\x3C\xBC\x29\xFA\xCA\x30\xE3\x53\x40"
           "\x34\x35\xF1\xD0\xE2\x69\x1D\x34\x8E\x83\x96\xAC\xAA\xCF\x6C\x98"
           "\x3F\x4F\x8C\xEF\x8C\xB3\x3A\x04\xF5\x7C\xB1\x76\xA3\x32\x1B\xC1"
           "\x83\xAD\x70\xA5\xF9\x08\xB8\xD9\x2E\xED\x15\x65\xB0\x33\x30\x04"
           "\x1F\x69\x87\x1D\xFF\xBF\x0F\x59\xE3\x62\xE1\xE8\x2C\x03\x4B\x72"
           "\xB6\xAA\x8F\x73\xBA\xFE\xEE\xCC\xAF\x50\x87\x3D\xA0\x5F\x66\xA0"
           "\x88\x3A\x7F\xDF\xA1\x8E\x06\x08\x18\x2C\x1A\x16\xCE\x0C\x6E\x13"
           "\x4F\x2E\x26\x3B\xB8\xAF\x70\x5E\x70\x48\xED\xCE\x8D\x6C\x9B\x26"
           "\xD7\xFE\x95\x5F\xC6\x91\xB6\x81\x3F\x7C\x9A\xF1\x6D\x1B\xAB\x6E"
           "\x84\x10\x94\x5A\x07\x38\x56\x75\xF0\xEB\x3C\x5E\xA3\x0E\x85\x17"
           "\xFB\x5B\xD0\xFA\x84\x3D\x58\x4C\xFD\xF0\xE5\x37\x77\x29\xE2\x5A"
           "\x7C\x74\x87\x04\x9C\xF0\x7A\x2C\xE4\xD2\x0A\x1C\xD8\x8B\x37\x8C"
           "\x7F\x1C\x10\x6E\x73\xB2\x69\x4C\xBE\x1A\x84\x3C\xC8\xA7\xA3\x68"
           "\x48\x7E\x2F\xFD\x9B\x5F\x12\xAD\x15\x49\x3F\xC4\x10\x86\xAF\x56"
           "\x4D\xCB\xC6\xE8\xAD\x35\x72\x21\x24\xD9\xC3\xA3\x82\xF1\xB2\xAF"
           "\xD9\x88\xBF\xFB\xCB\x81\xF9\xF6\x3B\xC6\x1C\x34\xF0\x5A\x33\xE5"
           "\x41\x9B\xC2\xF9\xE2\x23\x0E\x2D\x11\xC5\xBF\x41\x91\x7B\xE9\x36"
           "\x07\xD8\x60\x00\x09\xDD\xD5\x86\xD7\x65\x50\x98\xBC\x5C\x0E\x60"
           "\xA0\xE5\x53\xEC\xA6\x9D\x11\x99\xEA\x25\x44\xF4\x50\x76\x0D\x4D"
           "\xE7\x72\x87\xCF\x6F\x7C\xF2\x27\xED\x73\xD7\xEF\x53\x6D\x0B\x99"
           "\x6B\x38\x44\xBC\xC0\x12\xF5\xD6\x92\x3F\x64\x81\x54\xC1\xEF\x04"
           "\x5C\x1F\x23\x7E\xF5\x38\xA7\x80\xFC\x17\xEF\x00\x3C\x8D\x09\xAB"
           "\xAA\xD0\x40\x14\xD7\xCB\xAC\xA1\x29\xE0\x12\xD5\xD4\xFF\x1B\xDD"
           "\xCA\x78\x2B\x1D\xEC\x9F\xA5\xAC\x67\x74\x31\x8C\xF6\x8F\x9A\x59"
           "\x7D\x84\xF1\x7E\x5D\xA4\xC9\x53\xEF\x58\x2D\x1F\x0F\x3A\x6D\x66"
           "\xFF\x06\x61\x1A\xDC\xDB\x19\x0C\xE6\x43\xC4\x4A\x2B\x3D\x8E\x79"
           "\xD4\x93\xA8\x9A\x1A\xF7\x91\x45\x77\x78\xAB\xE1\x77\x33\x26\xFF"
           "\x92\x0B\x96\xD5\xF3\xAF\x05\x0B\xC4\x53\x1B\x89\xEC\xDC\xD0\x12"
           "\x4A\x65\xF3\xAD\x43\x8C\x23\x35\x13\x79\x4E\xD8\x0D\x21\xC9\x61"
           "\x49\xCA\x48\x53\x48\xC6\xA1\x7E\xF0\x28\xA5\x97\x11\xB8\x18\x33"
           "\xAD\xEC\xEF\x6B\x5C\x71\x4A\xBE\x9F\x31\xB8\xA3\x98\xC5\x0C\x0B"
           "\x46\x51\xA2\xAE\x02\x6F\x98\x35\xF7\x4D\x21\x5E\xC3\xED\x61\xB0"
           "\x6B\x59\x79\x5A\xB9\xA8\x1C\xB0\xBA\x82\x67\xB9\x97\xBB\xD4\x4D"
           "\xF1\xA1\x56\x5C\x7D\xCB\x77\xD0\x28\xE0\xFF\x1C\xAA\x22\x07\x68"
           "\x9B\xF3\x80\xDE\x96\x1D\x03\xDD\x97\x8A\x69\xDA\x5C\x54\xD4\x80"
           "\x93\xB2\x0D\xCD\x43\xBA\xFC\xDF\x11\xCF\xFE\xCE\x3B\x74\x8E\x67"
           "\x17\x74\x8E\x29\xF9\x64\x97\x52\x8C\x7B\xC9\x71\xB3\x5E\x59\x86"
           "\x63\x38\xF6\x9E\x79\x43\x56\xD6\x6F\xE6\x26\x45\x62\x64\x26\xE0"
           "\xA7\xDC\x70\xCA\x5B\xCD\xE7\xC6\xE1\x1F\xFC\x97\x57\xA1\x2B\xC5"
           "\x12\xB6\x9E\x85\x37\x9E\x58\x48\x2F\x9A\x91\xB7\xB6\x7C\x28\x47"
           "\x1A\x73\x45\x41\xD4\x6E\xBE\xB5\xB7\x60\x1A\xF2\x8B\x04\x78\x38"
           "\x4B\xB6\x45\x8C\xA9\x3E\xE5\x7A\xBF\x1F\xC4\x86\x30\xB4\x0C\xB1"
           "\xC6\x9D\x80\x88\xD2\x49\xD9\x89\xD9\x50\xA8\xDE\xEC\xA5\x04\x7F"
           "\xFF\xEA\xC0\x2F\xCB\x37\x7A\xB6\x97\x59\xAD\x53\x29\x34\xB3\x79"
           "\x16\x3B\x3E\xF5\x7F\x14\xB3\x77\xF9\x2E\xE8\x3F\x04\xAE\xDE\x89"
           "\x73\x04\x32\xA7\x4C\xC0\x4D\x43\x0D\xC1\xE5\x21\x48\x32\xAA\xE1"
           "\x5E\x81\xB6\x23\x6A\x80\xCA\x17\x23\xFC\x5F\x47\xE1\x57\x14\x59"
           "\x46\x67\x0F\xBF\x6A\x57\x53\x10\x8E\xAB\xAA\x9C\x8A\xDD\xE0\x9D"
           "\xA2\xAC\x94\x87\x6A\x71\xD0\xAF\xE4\x8A\xCF\xEB\x23\x27\x00\xC2"
           "\x8B\x11\xA9\x2C\x02\xB5\x05\x03\x30\x7A\x0C\xEF\x7F\x5B\x1C\xE7"
           "\x64\xFF\x1E\x68\x78\x28\x1C\x6D\xA0\x16\x75\x36\x7F\x9F\xF9\xCD"
           "\x15\x3B\x8E\x26\xC3\xF1\x7A\xBC\x17\x42\x92\x7D\xA8\x4E\x22\x5F"
           "\xB9\x55\xF5\xB7\x2C\x10\x5E\x79\xBB\x81\x54\x32\xDC\x8D\xE7\x4B"
           "\xE3\xCB\xDB\x1D\x34\xA4\xBA\x5F\x1A\xFE\x43\x48\x46\xEF\x88\x67"
           "\xD5\xB6\xDD\x06\x99\x5C\xB3\x38\x45\xED\xD0\x21\x77\x22\xF4\xF3"
           "\x68\xD6\x90\x53\xB5\x1E\x36\x3C\x35\x08\xCF\xBE\x53\x8F\x59\xDB"
           "\x4D\xAA\xA2\xB4\xF9\x93\xAC\x4C\x0C\xE4\x5D\xDF\x79\x57\x3C\x8F"
           "\x42\x44\xEC\x0C\x09\xA9\xC6\xE8\xF9\xF0\x80\x2E\x76\x25\x2E\xC1"
           "\x72\x0E\x55\xD6\xB9\x78\x9A\xAE\x56\xFE\x8B\x35\x38\xAF\xE3\x80"
           "\x78\x57\x55\x15\xC9\xEC\xCC\xCB\x42\xC3\xC5\xDF\x8A\xAE\x67\xB0"
           "\xCD\x63\x8E\xFC\x28\x77\x7F\xD1\x31\xFD\x9D\xD2\x79\xC8\x0A\xE0"
           "\x1A\x86\x0D\xEB\x3B\xB4\x64\x49\xAA\x6B\x7B\x73\x27\xEC\x7D\x66"
           "\x6A\x4C\x37\xB3\xCD\x4E\x97\x97\x3C\xEF\x7E\x13\x45\x36\xAA\xFE"
           "\x2E\x16\x48\x90\x5F\x53\x63\x62\xC7\xAB\xC9\xC7\xB5\x9E\xFD\xA5"
           "\x8B\x0C\xCA\xD0\x1E\xBD\x51\x67\x98\x94\x63\x08\x13\xCC\x05\xB9"
           , 1152);
    nSKLen = 1152;
    memset(bData, 0x42, 2048);
    bData[0] = 0x30;
    bData[2047] = 0x39;
    nDataLen = 2048;
    memcpy(bSignExp,
           "\x4A\xAB\x83\x64\x9A\x96\x2D\x33\x9C\xC3\x2F\x3C\x61\x30\x8A\xDF"
           "\x7B\x85\x6A\x20\xD5\xD4\x73\x6E\x72\xDD\x60\x2A\x90\x12\xDA\xD5"
           "\x8A\xB4\x32\xD4\x12\x69\x85\xBF\x39\x69\x42\x55\x64\x41\x33\x31"
           "\x79\x7D\x23\x4D\x1C\x0F\x0D\xA6\xF8\x1C\x12\x70\xE9\x99\xA8\x65"
           "\xE0\x92\xB5\x90\x6A\x0C\x0B\x90\xE1\x50\xEC\x2F\x73\xD1\xCB\x43"
           "\xAE\x23\x41\x55\xC6\x5D\x1B\xC3\xAD\x4E\x58\xC2\xC1\x8D\x02\x66"
           "\x5B\x39\x8A\x5C\xA6\xAB\x91\xB0\xE4\x3E\x15\x84\x08\x11\xE6\xF4"
           "\xD8\xDE\x62\xB2\x6A\x75\xAE\xA4\xC7\x45\x75\x82\x5E\x24\x68\xA7"
           "\x65\x77\x14\xC3\x60\x1C\x8A\x6C\x14\x0C\x41\x1C\xAB\xBA\xFA\x14"
           "\xC7\x67\x45\x84\x85\x67\x24\x6A\x82\x69\x26\x57\x37\xC0\x50\x15"
           "\x72\x62\xE0\x42\x1D\xDB\x6F\x85\x8E\x5E\x1B\x12\xC7\x94\x9E\x31"
           "\x48\xCD\x3E\x99\x28\x89\x57\x00\x82\x48\xF2\x72\x4D\x8D\x9B\x70"
           "\xB7\xC7\x39\xF6\xC4\x93\x9F\xC5\xA8\x77\x13\xE3\x1F\xCD\x52\xB3"
           "\x87\x88\x84\xA0\x28\xD2\x0E\x78\x5E\x92\x62\x34\x92\xBD\xBA\x34"
           "\xCB\xFC\x22\xF9\x42\xD7\x96\x9A\x62\x70\xDE\x0D\x48\xC1\xD8\x7F"
           "\x4E\xD2\x4E\x82\xF9\x47\xD3\x3F"
           , 248);
    nSignLenExp = 248;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 1152);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 2048);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1984，SHA-512，PKCS#1填充，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bSign    =", bSign, 248);
    DspHex("[OUT]bSignExp =", bSignExp, 248);
    ASSERT_OUT_HEX(bSign, bSignExp, 248);
    ASSERT_OUT(nSignLen, nSignLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_31(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 0;
    nPadMode = 1;
    memcpy(bSK,
           "\xB6\xF8\xDC\x3E\x12\x98\x52\xB8\xB1\x84\xC0\x51\x97\xD1\xBE\x87"
           "\x70\x24\xD7\xE1\x4A\x71\xC3\x20\xA9\xEE\x78\x93\xF8\x99\x5C\x1A"
           "\xE5\x32\x78\x65\x85\x07\xEB\x5E\x26\x79\x2F\x1E\xE1\x6E\x6E\xB9"
           "\xF7\x6A\x23\x46\x09\x92\xD0\x54\xD2\xCA\x6C\xB6\xCE\xB0\x0B\x1C"
           "\x83\xD3\xEB\x1B\x6F\x47\x05\x82\xBF\x68\x23\x24\x90\xDD\xA0\x4C"
           "\xAD\x00\xC2\xD6\xBE\x7D\x8C\x5C\xBF\x1B\xF6\xE1\x73\x51\x9E\x6D"
           "\x62\x46\xBF\x62\xD5\xA6\xD6\x93\x17\x5D\xEE\xEF\x03\x82\x5E\x89"
           "\xA5\x42\xF3\x09\xB1\x20\x11\x48\x39\x90\x8A\xBD\xAA\xE3\xA8\x12"
           "\x4E\xD2\x36\x25\x16\x60\x73\x35\x44\x99\x56\xFE\xED\xF1\xC7\x48"
           "\x57\x57\x56\x27\x7C\x94\xC5\x2D\x6B\x77\xFB\xDC\x82\xD8\xD0\xE0"
           "\x2D\x0E\x4D\x64\x5B\x98\x07\x49\x8A\x29\x70\xD9\xDE\xA9\x44\xC5"
           "\xDE\x71\xCE\xF5\xE0\x63\x40\x28\xF4\xD6\x6D\x86\x14\xCF\x70\x24"
           "\x5B\x05\xAE\xC7\xE9\x69\x7B\x42\xAB\xF6\x53\xA3\x97\x1C\x93\x61"
           "\xCE\x7E\x8F\x38\xF1\x85\xC6\xB8\x2C\x6F\x11\x3E\xA6\xF1\x18\xF8"
           "\x85\xAD\xF2\xE3\x32\x82\x51\x0D\xEB\x12\x68\xC0\x1B\xCD\xF2\x3A"
           "\xB5\x55\xCD\x1A\x92\x9D\x31\xDF\xA6\xB2\x7A\xEE\x99\xA1\x39\x62"
           "\xC9\xE5\xFD\x47\xD0\x37\xCE\x6C\x08\x33\x31\x58\x38\x7B\x3F\x77"
           "\xFF\x4B\x01\xFC\x24\x58\x33\x24\xEB\xA6\xE2\xEE\x33\x1B\x67\x52"
           "\x81\x19\x16\x3A\xFA\x23\x82\x1B\x61\xEE\x5B\xDD\x08\x83\xA4\x5D"
           "\xCC\x57\x5A\xBF\xA5\x5C\x6E\xD7\xB0\xA2\xB6\x73\x52\x92\x9E\x5C"
           "\x46\x8D\x3E\xFB\x15\x1C\xB2\x7E\xD0\x90\x09\x61\x4F\x98\xFF\xEE"
           "\x8C\x40\x99\x83\x62\x1C\x2A\x29\xA9\x35\x58\x08\xF7\x97\xE6\xC7"
           "\x74\x50\xC9\x7D\xBF\xA2\x61\x51\x57\xD2\xDB\xDD\xE7\x19\xEF\x75"
           "\x26\xC0\x48\x56\xD9\x38\xFC\xF6\xF1\xEC\x6E\x96\x72\xCE\x2F\x19"
           "\xCA\x17\x76\x25\xFA\xDB\x0A\xBF\x4E\xD3\x6F\x65\xE2\xA3\x53\x9F"
           "\x0F\x91\xCF\xA8\x32\x9D\x83\xF1\x62\x54\xA3\x3E\x89\xF9\xD3\x20"
           "\xE8\x10\xE5\xE8\x6A\x73\x40\x90\x9A\x9D\x21\xD0\x9E\xEE\xFA\x44"
           "\x29\x42\x36\x61\xF0\x89\x9E\xE2\xFA\xBE\x06\x74\x7A\xAC\x2A\xF6"
           "\xA6\xFE\xE0\x7E\x17\x7C\xDA\xA7\x4B\xA3\x33\xD0\x66\x40\x56\x07"
           "\xB5\x21\x1A\x1E\x17\x3B\x43\x62\x9C\x0D\x16\xFA\xF3\x09\x93\x99"
           "\x56\x6C\xFD\x6A\xB7\x64\x04\x77\x33\x61\x13\x13\xD0\x93\x30\xD7"
           "\x78\xAE\xD3\x91\x30\xC2\x2C\x81\x39\x88\x9F\xE3\x9B\x4F\xF0\xC8"
           "\xFF\xA0\xA7\xED\x5F\xC3\xD7\xFE\x9C\xA7\x85\x7D\x1E\x7E\xA6\x7C"
           "\xD7\x6C\xEF\x3A\xAD\xE2\xFE\x2E\xAD\x45\x17\x9E\xC8\xA9\x71\xAB"
           "\xBF\xB6\xE3\x16\xEC\x4B\xF5\xA7\x9D\x20\x72\x87\xB4\x7E\x80\x89"
           "\xD6\xEF\x8C\xEA\x5D\xD5\xD2\x26\x9B\x3E\x58\x2C\xEB\xE6\x07\x1A"
           "\x05\x01\xD6\xBB\xFB\xA4\x2C\x31\x7A\xC0\x03\xB2\x14\x3D\x95\x41"
           "\xB5\xE3\x35\xA8\x86\xCF\x8C\x68\xFE\x01\x75\x0F\x3B\x77\x56\xA2"
           "\xCF\x29\x24\xFE\x99\x37\x02\x75\x65\x0E\xD6\xD2\x82\x9A\x93\x74"
           "\xAD\xBE\x1E\x56\x13\xC4\x29\x53\x35\x57\x4B\x46\x22\x4B\xB8\x50"
           "\x53\x71\x44\x27\xA8\xBC\x5B\x31\x0A\x32\xD4\x0F\xFF\xB2\x32\x5F"
           "\x39\xCD\xB1\x90\x77\x70\x23\xF9\xF4\x85\xDA\xE9\x16\x9D\xD5\xA0"
           "\x2A\x71\xF9\xF4\x40\x7D\xD1\x24\x5D\xBF\x93\xB3\x7F\x0D\x95\x67"
           "\x19\x51\x18\xA0\x99\x7A\x84\x44\x71\x9A\x08\x0D\x98\x25\x2E\xA6"
           "\x55\x6B\xEC\xA9\xA0\x72\xA4\xEF\x41\xC4\x20\x67\xA8\x86\xC9\x82"
           "\x86\xE8\x58\x5B\xA6\x8B\xCB\x30\xED\xF7\x7B\x0E\x6A\x6F\x6C\x39"
           "\x7A\x48\xA8\xE1\x9C\xEE\xC5\xDF\x08\x4B\xC9\x0A\x5D\xA0\x34\x42"
           "\xB5\x79\x5C\x29\xAF\xA9\xF8\x84\x31\xBE\x94\x21\x29\x17\x82\x99"
           "\x81\xB4\x9E\x2B\xC9\x78\xC5\xA6\x25\xD7\x28\xEE\x3A\xD2\x3B\xD8"
           "\x05\xCE\xEA\x07\x92\xD4\x8B\x4D\x64\xB4\x7F\x57\x9D\x2A\xFB\x80"
           "\xFF\x16\x09\xE2\x9A\xAC\x7E\x32\x2D\x2B\xE7\xA2\x9F\x9F\x63\xAF"
           "\x59\x62\xC6\x8D\x51\xD9\x2F\x6B\xF2\xB8\xEA\x9B\xAE\x30\x7A\xBB"
           "\x76\xC7\xDE\xB7\xF8\xF0\x33\x2E\x69\x65\xC0\x89\x2B\x82\x72\xAE"
           "\x8B\x65\x53\xEF\x96\xA4\xCC\xE6\xAB\x80\x9D\x23\x51\xCB\x77\x5B"
           "\xAB\x75\x5A\x70\x7B\x9C\xBE\xD6\x44\xCD\x0A\x3A\x1C\xF8\xD7\xC8"
           "\x9E\x68\x2B\xA2\xB6\x30\xC4\xE7\x3A\xF2\xDA\xE4\x15\xDE\x80\xD5"
           "\x03\xF6\x06\x3E\x19\x0B\x09\xF5\xE1\xED\xE9\x82\x79\x02\xD7\x21"
           "\x5C\x71\xFE\x15\xCB\xB5\x85\xB1\x12\x75\xF2\x94\xFC\xB7\x24\x14"
           "\xFF\xDE\xA6\x49\x7D\x61\xF8\xAE\x83\x40\x97\xC6\x13\x8F\xD6\xE2"
           "\xDA\xE8\x9D\x66\x71\x4A\x22\x1F\xF9\x55\x79\xAA\xE0\xE6\xD7\x29"
           "\x3D\x44\x2E\xC0\xB9\x4D\x64\x65\x2A\x0E\x4A\xB8\x62\xC1\x84\x2E"
           "\x3F\x6F\xEB\x79\xDF\xCF\xAA\x83\xB9\x7C\x73\x7E\x48\x88\x44\x03"
           "\xEA\x4F\x09\xCD\x72\x37\xA7\x49\x37\x6E\x52\x57\xFC\x64\x17\xE5"
           "\x9E\x36\x4D\xD7\x33\x82\xA5\x42\x3F\x37\x96\xE9\x00\x70\x91\x7E"
           "\x1F\xFF\xCD\xD3\x39\xD8\x27\x8F\x67\x81\x51\xF8\x03\xB5\x3A\xB9"
           "\x57\x64\x16\xBF\x7F\x0C\xD6\x74\xE7\x37\xB2\xFD\xF4\x20\x1B\x4C"
           "\xFD\xFC\x5C\xEF\x78\x30\x05\x38\xD7\x51\xE8\xD3\x16\x0A\x7D\x8C"
           "\xBA\x84\x9D\x1F\xF5\x6F\xE7\x15\x41\x1D\x3E\x40\x4D\x98\x64\x46"
           "\x43\x35\xA6\xBB\x0B\x0D\xF3\x39\x1D\xF9\x2B\x8C\x8E\xBD\x43\x9B"
           "\x39\x39\x10\x04\x06\x0B\x31\x7C\xF0\x1E\xE1\x70\xB1\x55\xD1\x59"
           "\xBE\x38\x24\xC8\x3E\x53\x30\xF7\x0F\xCE\x37\xCD\x5C\xF7\x90\x33"
           "\x85\x7F\x4D\x02\xAB\xEA\x50\x12\x18\xF3\x6E\x56\xA8\xEE\x38\x08"
           "\x8F\x94\x95\xAE\xE3\x74\x54\xCF\x0B\x88\x16\x7D\x2E\xBA\xAB\xCE"
           "\xCD\x7B\xA5\x62\x51\x84\x6A\x30\x0E\xF6\x44\x6C\x62\xDB\x9B\x21"
           "\xCA\x09\x0C\xBD\xE5\x09\x1C\xFA\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78"
           , 1200);
    nSKLen = 1200;
    memset(bData, 0x42, 1);
    nDataLen = 1;
    memcpy(bSignExp,
           "\x76\x23\x83\x2C\xDD\xC4\x9A\xC3\xD7\x08\xB9\x11\xA6\x89\x06\xF2"
           "\x0A\x0D\x5D\x2D\xC0\xBF\xCC\xE9\xC8\x42\xD0\x97\x45\x12\x10\x88"
           "\x50\x3D\x54\x64\x33\xC3\x4A\xE6\x18\xC4\xB0\xCB\x41\x79\xEF\x49"
           "\xD0\x59\x95\x8A\x25\xBA\x61\x78\x5D\xF7\x1E\xB0\x31\xED\xAF\x15"
           "\x77\xF8\xD6\x11\xD5\xC0\xC8\x88\x9A\xB5\x52\xAC\x1F\xEE\x45\x54"
           "\x35\x76\x2E\x81\xED\x1B\x61\xE6\x86\x39\xB5\x46\xBD\xD1\x73\x68"
           "\x19\xBC\xE4\x05\x79\xF0\xBF\xBC\xD9\xA0\xDE\x97\x3C\x7F\x88\x21"
           "\x82\xC5\xE6\xF4\x0D\x21\x6A\x39\xF2\xEA\x1A\x9F\x70\x72\xD8\xEE"
           "\xEA\xE0\xD3\x8C\xA6\x61\x18\xD7\x67\x07\xC1\xA5\x44\x94\x2E\x6A"
           "\x43\x64\xAD\x4F\x84\x00\xD7\x8E\x65\x6A\x73\x54\x4B\x75\x3B\xE7"
           "\x41\x87\x5F\x62\x77\x03\xF7\x2E\xA1\x70\xF7\xC5\xA4\xF4\xF1\x9D"
           "\x5C\x48\x79\x2A\x32\x10\xDE\xFA\xED\xEB\x5E\x2B\x46\x0C\x6A\xA2"
           "\xB3\x6E\x3E\x44\xCC\x11\xA1\xD2\x67\x98\x7F\xB2\xBA\xD4\x22\x62"
           "\xEC\xDB\xE7\x80\x0A\x35\x97\x49\xC9\x22\x20\x80\x12\x4F\x0F\x19"
           "\xF0\x29\xDA\x20\x71\xE4\xA9\x21\x87\x56\xF1\x97\x7F\xFE\x04\x95"
           "\xE0\xBD\xFF\x1D\xEC\x13\xA0\x41\x63\x0B\xC5\x78\x06\x20\x20\xDB"
           , 256);
    nSignLenExp = 256;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 1200);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 1);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-2048，MD5，PKCS#1填充，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bSign    =", bSign, 256);
    DspHex("[OUT]bSignExp =", bSignExp, 256);
    ASSERT_OUT_HEX(bSign, bSignExp, 256);
    ASSERT_OUT(nSignLen, nSignLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_32(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 1;
    nPadMode = 1;
    memcpy(bSK,
           "\xB6\xF8\xDC\x3E\x12\x98\x52\xB8\xB1\x84\xC0\x51\x97\xD1\xBE\x87"
           "\x70\x24\xD7\xE1\x4A\x71\xC3\x20\xA9\xEE\x78\x93\xF8\x99\x5C\x1A"
           "\xE5\x32\x78\x65\x85\x07\xEB\x5E\x26\x79\x2F\x1E\xE1\x6E\x6E\xB9"
           "\xF7\x6A\x23\x46\x09\x92\xD0\x54\xD2\xCA\x6C\xB6\xCE\xB0\x0B\x1C"
           "\x83\xD3\xEB\x1B\x6F\x47\x05\x82\xBF\x68\x23\x24\x90\xDD\xA0\x4C"
           "\xAD\x00\xC2\xD6\xBE\x7D\x8C\x5C\xBF\x1B\xF6\xE1\x73\x51\x9E\x6D"
           "\x62\x46\xBF\x62\xD5\xA6\xD6\x93\x17\x5D\xEE\xEF\x03\x82\x5E\x89"
           "\xA5\x42\xF3\x09\xB1\x20\x11\x48\x39\x90\x8A\xBD\xAA\xE3\xA8\x12"
           "\x4E\xD2\x36\x25\x16\x60\x73\x35\x44\x99\x56\xFE\xED\xF1\xC7\x48"
           "\x57\x57\x56\x27\x7C\x94\xC5\x2D\x6B\x77\xFB\xDC\x82\xD8\xD0\xE0"
           "\x2D\x0E\x4D\x64\x5B\x98\x07\x49\x8A\x29\x70\xD9\xDE\xA9\x44\xC5"
           "\xDE\x71\xCE\xF5\xE0\x63\x40\x28\xF4\xD6\x6D\x86\x14\xCF\x70\x24"
           "\x5B\x05\xAE\xC7\xE9\x69\x7B\x42\xAB\xF6\x53\xA3\x97\x1C\x93\x61"
           "\xCE\x7E\x8F\x38\xF1\x85\xC6\xB8\x2C\x6F\x11\x3E\xA6\xF1\x18\xF8"
           "\x85\xAD\xF2\xE3\x32\x82\x51\x0D\xEB\x12\x68\xC0\x1B\xCD\xF2\x3A"
           "\xB5\x55\xCD\x1A\x92\x9D\x31\xDF\xA6\xB2\x7A\xEE\x99\xA1\x39\x62"
           "\xC9\xE5\xFD\x47\xD0\x37\xCE\x6C\x08\x33\x31\x58\x38\x7B\x3F\x77"
           "\xFF\x4B\x01\xFC\x24\x58\x33\x24\xEB\xA6\xE2\xEE\x33\x1B\x67\x52"
           "\x81\x19\x16\x3A\xFA\x23\x82\x1B\x61\xEE\x5B\xDD\x08\x83\xA4\x5D"
           "\xCC\x57\x5A\xBF\xA5\x5C\x6E\xD7\xB0\xA2\xB6\x73\x52\x92\x9E\x5C"
           "\x46\x8D\x3E\xFB\x15\x1C\xB2\x7E\xD0\x90\x09\x61\x4F\x98\xFF\xEE"
           "\x8C\x40\x99\x83\x62\x1C\x2A\x29\xA9\x35\x58\x08\xF7\x97\xE6\xC7"
           "\x74\x50\xC9\x7D\xBF\xA2\x61\x51\x57\xD2\xDB\xDD\xE7\x19\xEF\x75"
           "\x26\xC0\x48\x56\xD9\x38\xFC\xF6\xF1\xEC\x6E\x96\x72\xCE\x2F\x19"
           "\xCA\x17\x76\x25\xFA\xDB\x0A\xBF\x4E\xD3\x6F\x65\xE2\xA3\x53\x9F"
           "\x0F\x91\xCF\xA8\x32\x9D\x83\xF1\x62\x54\xA3\x3E\x89\xF9\xD3\x20"
           "\xE8\x10\xE5\xE8\x6A\x73\x40\x90\x9A\x9D\x21\xD0\x9E\xEE\xFA\x44"
           "\x29\x42\x36\x61\xF0\x89\x9E\xE2\xFA\xBE\x06\x74\x7A\xAC\x2A\xF6"
           "\xA6\xFE\xE0\x7E\x17\x7C\xDA\xA7\x4B\xA3\x33\xD0\x66\x40\x56\x07"
           "\xB5\x21\x1A\x1E\x17\x3B\x43\x62\x9C\x0D\x16\xFA\xF3\x09\x93\x99"
           "\x56\x6C\xFD\x6A\xB7\x64\x04\x77\x33\x61\x13\x13\xD0\x93\x30\xD7"
           "\x78\xAE\xD3\x91\x30\xC2\x2C\x81\x39\x88\x9F\xE3\x9B\x4F\xF0\xC8"
           "\xFF\xA0\xA7\xED\x5F\xC3\xD7\xFE\x9C\xA7\x85\x7D\x1E\x7E\xA6\x7C"
           "\xD7\x6C\xEF\x3A\xAD\xE2\xFE\x2E\xAD\x45\x17\x9E\xC8\xA9\x71\xAB"
           "\xBF\xB6\xE3\x16\xEC\x4B\xF5\xA7\x9D\x20\x72\x87\xB4\x7E\x80\x89"
           "\xD6\xEF\x8C\xEA\x5D\xD5\xD2\x26\x9B\x3E\x58\x2C\xEB\xE6\x07\x1A"
           "\x05\x01\xD6\xBB\xFB\xA4\x2C\x31\x7A\xC0\x03\xB2\x14\x3D\x95\x41"
           "\xB5\xE3\x35\xA8\x86\xCF\x8C\x68\xFE\x01\x75\x0F\x3B\x77\x56\xA2"
           "\xCF\x29\x24\xFE\x99\x37\x02\x75\x65\x0E\xD6\xD2\x82\x9A\x93\x74"
           "\xAD\xBE\x1E\x56\x13\xC4\x29\x53\x35\x57\x4B\x46\x22\x4B\xB8\x50"
           "\x53\x71\x44\x27\xA8\xBC\x5B\x31\x0A\x32\xD4\x0F\xFF\xB2\x32\x5F"
           "\x39\xCD\xB1\x90\x77\x70\x23\xF9\xF4\x85\xDA\xE9\x16\x9D\xD5\xA0"
           "\x2A\x71\xF9\xF4\x40\x7D\xD1\x24\x5D\xBF\x93\xB3\x7F\x0D\x95\x67"
           "\x19\x51\x18\xA0\x99\x7A\x84\x44\x71\x9A\x08\x0D\x98\x25\x2E\xA6"
           "\x55\x6B\xEC\xA9\xA0\x72\xA4\xEF\x41\xC4\x20\x67\xA8\x86\xC9\x82"
           "\x86\xE8\x58\x5B\xA6\x8B\xCB\x30\xED\xF7\x7B\x0E\x6A\x6F\x6C\x39"
           "\x7A\x48\xA8\xE1\x9C\xEE\xC5\xDF\x08\x4B\xC9\x0A\x5D\xA0\x34\x42"
           "\xB5\x79\x5C\x29\xAF\xA9\xF8\x84\x31\xBE\x94\x21\x29\x17\x82\x99"
           "\x81\xB4\x9E\x2B\xC9\x78\xC5\xA6\x25\xD7\x28\xEE\x3A\xD2\x3B\xD8"
           "\x05\xCE\xEA\x07\x92\xD4\x8B\x4D\x64\xB4\x7F\x57\x9D\x2A\xFB\x80"
           "\xFF\x16\x09\xE2\x9A\xAC\x7E\x32\x2D\x2B\xE7\xA2\x9F\x9F\x63\xAF"
           "\x59\x62\xC6\x8D\x51\xD9\x2F\x6B\xF2\xB8\xEA\x9B\xAE\x30\x7A\xBB"
           "\x76\xC7\xDE\xB7\xF8\xF0\x33\x2E\x69\x65\xC0\x89\x2B\x82\x72\xAE"
           "\x8B\x65\x53\xEF\x96\xA4\xCC\xE6\xAB\x80\x9D\x23\x51\xCB\x77\x5B"
           "\xAB\x75\x5A\x70\x7B\x9C\xBE\xD6\x44\xCD\x0A\x3A\x1C\xF8\xD7\xC8"
           "\x9E\x68\x2B\xA2\xB6\x30\xC4\xE7\x3A\xF2\xDA\xE4\x15\xDE\x80\xD5"
           "\x03\xF6\x06\x3E\x19\x0B\x09\xF5\xE1\xED\xE9\x82\x79\x02\xD7\x21"
           "\x5C\x71\xFE\x15\xCB\xB5\x85\xB1\x12\x75\xF2\x94\xFC\xB7\x24\x14"
           "\xFF\xDE\xA6\x49\x7D\x61\xF8\xAE\x83\x40\x97\xC6\x13\x8F\xD6\xE2"
           "\xDA\xE8\x9D\x66\x71\x4A\x22\x1F\xF9\x55\x79\xAA\xE0\xE6\xD7\x29"
           "\x3D\x44\x2E\xC0\xB9\x4D\x64\x65\x2A\x0E\x4A\xB8\x62\xC1\x84\x2E"
           "\x3F\x6F\xEB\x79\xDF\xCF\xAA\x83\xB9\x7C\x73\x7E\x48\x88\x44\x03"
           "\xEA\x4F\x09\xCD\x72\x37\xA7\x49\x37\x6E\x52\x57\xFC\x64\x17\xE5"
           "\x9E\x36\x4D\xD7\x33\x82\xA5\x42\x3F\x37\x96\xE9\x00\x70\x91\x7E"
           "\x1F\xFF\xCD\xD3\x39\xD8\x27\x8F\x67\x81\x51\xF8\x03\xB5\x3A\xB9"
           "\x57\x64\x16\xBF\x7F\x0C\xD6\x74\xE7\x37\xB2\xFD\xF4\x20\x1B\x4C"
           "\xFD\xFC\x5C\xEF\x78\x30\x05\x38\xD7\x51\xE8\xD3\x16\x0A\x7D\x8C"
           "\xBA\x84\x9D\x1F\xF5\x6F\xE7\x15\x41\x1D\x3E\x40\x4D\x98\x64\x46"
           "\x43\x35\xA6\xBB\x0B\x0D\xF3\x39\x1D\xF9\x2B\x8C\x8E\xBD\x43\x9B"
           "\x39\x39\x10\x04\x06\x0B\x31\x7C\xF0\x1E\xE1\x70\xB1\x55\xD1\x59"
           "\xBE\x38\x24\xC8\x3E\x53\x30\xF7\x0F\xCE\x37\xCD\x5C\xF7\x90\x33"
           "\x85\x7F\x4D\x02\xAB\xEA\x50\x12\x18\xF3\x6E\x56\xA8\xEE\x38\x08"
           "\x8F\x94\x95\xAE\xE3\x74\x54\xCF\x0B\x88\x16\x7D\x2E\xBA\xAB\xCE"
           "\xCD\x7B\xA5\x62\x51\x84\x6A\x30\x0E\xF6\x44\x6C\x62\xDB\x9B\x21"
           "\xCA\x09\x0C\xBD\xE5\x09\x1C\xFA\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78"
           , 1200);
    nSKLen = 1200;
    memset(bData, 0x42, 256);
    bData[0] = 0x30;
    bData[255] = 0x39;
    nDataLen = 256;
    memcpy(bSignExp,
           "\x37\xEF\xBD\xE4\x64\x3A\xA4\x33\xCE\x26\x5C\xE9\x37\x3C\xAC\x52"
           "\x7F\x20\x63\xE0\x10\xCA\x96\xBB\x41\xA9\xA1\x47\xF6\xBA\xB5\x6D"
           "\x93\x06\x41\x33\x16\xE7\xF8\xBD\x13\xBD\x83\x32\x4F\x22\x46\x75"
           "\xB3\x20\x13\x92\x74\x3C\x20\xB1\x44\xBF\x0E\xE1\xDE\x1C\x0C\xF3"
           "\xD5\x2B\x7C\x5E\xC6\x10\xCA\x2D\x51\xA1\x4B\x6B\xA3\x67\xED\x24"
           "\x9F\xE2\xD0\x49\x41\x73\xA9\x0C\x35\xF2\xE7\xB2\x70\xF0\x26\x4D"
           "\xEE\x96\x55\x0F\x2F\x2F\x63\x1E\x92\x05\xE1\xFA\x33\xC2\x23\xF8"
           "\x13\xC4\x2B\xE0\x0F\x18\xB0\x59\x53\xBB\x96\xBE\x61\x28\x13\x63"
           "\x1A\x8D\x5D\xB1\xF4\x9C\x87\x2D\xDE\x47\xAD\x79\xCB\xC2\x2F\x17"
           "\x19\x6A\xA7\x08\x1F\x01\xE6\x3C\x35\xBF\xA5\x7B\x85\x2B\x7D\x1E"
           "\x59\x0A\xD4\x30\x12\x5A\x1B\x41\xEA\x56\x01\x60\x4E\x89\xF2\xCE"
           "\x83\xB7\xD2\x50\xA6\x15\xC5\x54\xA7\xC2\x89\x8D\x3D\xB9\x4D\x69"
           "\x6B\x8A\xD0\xBF\xA2\xA5\x48\xD2\x42\x2A\x86\x33\x4B\xCD\x38\xAA"
           "\xC9\xA3\xBF\x4E\x92\x76\x4A\xFE\xA1\x7A\x55\x00\x4A\xCD\x73\xF9"
           "\xB7\xF7\x57\xCA\x19\xCA\xA0\x48\xF8\x1F\xC4\x30\xC3\x6D\xD9\x4A"
           "\x10\x87\x86\xB9\x18\xB2\xE3\x0C\x46\xC4\x70\xB6\x5C\xF4\x5D\x12"
           , 256);
    nSignLenExp = 256;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 1200);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 256);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-2048，SHA-1，PKCS#1填充，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bSign    =", bSign, 256);
    DspHex("[OUT]bSignExp =", bSignExp, 256);
    ASSERT_OUT_HEX(bSign, bSignExp, 256);
    ASSERT_OUT(nSignLen, nSignLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_33(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 2;
    nPadMode = 1;
    memcpy(bSK,
           "\xB6\xF8\xDC\x3E\x12\x98\x52\xB8\xB1\x84\xC0\x51\x97\xD1\xBE\x87"
           "\x70\x24\xD7\xE1\x4A\x71\xC3\x20\xA9\xEE\x78\x93\xF8\x99\x5C\x1A"
           "\xE5\x32\x78\x65\x85\x07\xEB\x5E\x26\x79\x2F\x1E\xE1\x6E\x6E\xB9"
           "\xF7\x6A\x23\x46\x09\x92\xD0\x54\xD2\xCA\x6C\xB6\xCE\xB0\x0B\x1C"
           "\x83\xD3\xEB\x1B\x6F\x47\x05\x82\xBF\x68\x23\x24\x90\xDD\xA0\x4C"
           "\xAD\x00\xC2\xD6\xBE\x7D\x8C\x5C\xBF\x1B\xF6\xE1\x73\x51\x9E\x6D"
           "\x62\x46\xBF\x62\xD5\xA6\xD6\x93\x17\x5D\xEE\xEF\x03\x82\x5E\x89"
           "\xA5\x42\xF3\x09\xB1\x20\x11\x48\x39\x90\x8A\xBD\xAA\xE3\xA8\x12"
           "\x4E\xD2\x36\x25\x16\x60\x73\x35\x44\x99\x56\xFE\xED\xF1\xC7\x48"
           "\x57\x57\x56\x27\x7C\x94\xC5\x2D\x6B\x77\xFB\xDC\x82\xD8\xD0\xE0"
           "\x2D\x0E\x4D\x64\x5B\x98\x07\x49\x8A\x29\x70\xD9\xDE\xA9\x44\xC5"
           "\xDE\x71\xCE\xF5\xE0\x63\x40\x28\xF4\xD6\x6D\x86\x14\xCF\x70\x24"
           "\x5B\x05\xAE\xC7\xE9\x69\x7B\x42\xAB\xF6\x53\xA3\x97\x1C\x93\x61"
           "\xCE\x7E\x8F\x38\xF1\x85\xC6\xB8\x2C\x6F\x11\x3E\xA6\xF1\x18\xF8"
           "\x85\xAD\xF2\xE3\x32\x82\x51\x0D\xEB\x12\x68\xC0\x1B\xCD\xF2\x3A"
           "\xB5\x55\xCD\x1A\x92\x9D\x31\xDF\xA6\xB2\x7A\xEE\x99\xA1\x39\x62"
           "\xC9\xE5\xFD\x47\xD0\x37\xCE\x6C\x08\x33\x31\x58\x38\x7B\x3F\x77"
           "\xFF\x4B\x01\xFC\x24\x58\x33\x24\xEB\xA6\xE2\xEE\x33\x1B\x67\x52"
           "\x81\x19\x16\x3A\xFA\x23\x82\x1B\x61\xEE\x5B\xDD\x08\x83\xA4\x5D"
           "\xCC\x57\x5A\xBF\xA5\x5C\x6E\xD7\xB0\xA2\xB6\x73\x52\x92\x9E\x5C"
           "\x46\x8D\x3E\xFB\x15\x1C\xB2\x7E\xD0\x90\x09\x61\x4F\x98\xFF\xEE"
           "\x8C\x40\x99\x83\x62\x1C\x2A\x29\xA9\x35\x58\x08\xF7\x97\xE6\xC7"
           "\x74\x50\xC9\x7D\xBF\xA2\x61\x51\x57\xD2\xDB\xDD\xE7\x19\xEF\x75"
           "\x26\xC0\x48\x56\xD9\x38\xFC\xF6\xF1\xEC\x6E\x96\x72\xCE\x2F\x19"
           "\xCA\x17\x76\x25\xFA\xDB\x0A\xBF\x4E\xD3\x6F\x65\xE2\xA3\x53\x9F"
           "\x0F\x91\xCF\xA8\x32\x9D\x83\xF1\x62\x54\xA3\x3E\x89\xF9\xD3\x20"
           "\xE8\x10\xE5\xE8\x6A\x73\x40\x90\x9A\x9D\x21\xD0\x9E\xEE\xFA\x44"
           "\x29\x42\x36\x61\xF0\x89\x9E\xE2\xFA\xBE\x06\x74\x7A\xAC\x2A\xF6"
           "\xA6\xFE\xE0\x7E\x17\x7C\xDA\xA7\x4B\xA3\x33\xD0\x66\x40\x56\x07"
           "\xB5\x21\x1A\x1E\x17\x3B\x43\x62\x9C\x0D\x16\xFA\xF3\x09\x93\x99"
           "\x56\x6C\xFD\x6A\xB7\x64\x04\x77\x33\x61\x13\x13\xD0\x93\x30\xD7"
           "\x78\xAE\xD3\x91\x30\xC2\x2C\x81\x39\x88\x9F\xE3\x9B\x4F\xF0\xC8"
           "\xFF\xA0\xA7\xED\x5F\xC3\xD7\xFE\x9C\xA7\x85\x7D\x1E\x7E\xA6\x7C"
           "\xD7\x6C\xEF\x3A\xAD\xE2\xFE\x2E\xAD\x45\x17\x9E\xC8\xA9\x71\xAB"
           "\xBF\xB6\xE3\x16\xEC\x4B\xF5\xA7\x9D\x20\x72\x87\xB4\x7E\x80\x89"
           "\xD6\xEF\x8C\xEA\x5D\xD5\xD2\x26\x9B\x3E\x58\x2C\xEB\xE6\x07\x1A"
           "\x05\x01\xD6\xBB\xFB\xA4\x2C\x31\x7A\xC0\x03\xB2\x14\x3D\x95\x41"
           "\xB5\xE3\x35\xA8\x86\xCF\x8C\x68\xFE\x01\x75\x0F\x3B\x77\x56\xA2"
           "\xCF\x29\x24\xFE\x99\x37\x02\x75\x65\x0E\xD6\xD2\x82\x9A\x93\x74"
           "\xAD\xBE\x1E\x56\x13\xC4\x29\x53\x35\x57\x4B\x46\x22\x4B\xB8\x50"
           "\x53\x71\x44\x27\xA8\xBC\x5B\x31\x0A\x32\xD4\x0F\xFF\xB2\x32\x5F"
           "\x39\xCD\xB1\x90\x77\x70\x23\xF9\xF4\x85\xDA\xE9\x16\x9D\xD5\xA0"
           "\x2A\x71\xF9\xF4\x40\x7D\xD1\x24\x5D\xBF\x93\xB3\x7F\x0D\x95\x67"
           "\x19\x51\x18\xA0\x99\x7A\x84\x44\x71\x9A\x08\x0D\x98\x25\x2E\xA6"
           "\x55\x6B\xEC\xA9\xA0\x72\xA4\xEF\x41\xC4\x20\x67\xA8\x86\xC9\x82"
           "\x86\xE8\x58\x5B\xA6\x8B\xCB\x30\xED\xF7\x7B\x0E\x6A\x6F\x6C\x39"
           "\x7A\x48\xA8\xE1\x9C\xEE\xC5\xDF\x08\x4B\xC9\x0A\x5D\xA0\x34\x42"
           "\xB5\x79\x5C\x29\xAF\xA9\xF8\x84\x31\xBE\x94\x21\x29\x17\x82\x99"
           "\x81\xB4\x9E\x2B\xC9\x78\xC5\xA6\x25\xD7\x28\xEE\x3A\xD2\x3B\xD8"
           "\x05\xCE\xEA\x07\x92\xD4\x8B\x4D\x64\xB4\x7F\x57\x9D\x2A\xFB\x80"
           "\xFF\x16\x09\xE2\x9A\xAC\x7E\x32\x2D\x2B\xE7\xA2\x9F\x9F\x63\xAF"
           "\x59\x62\xC6\x8D\x51\xD9\x2F\x6B\xF2\xB8\xEA\x9B\xAE\x30\x7A\xBB"
           "\x76\xC7\xDE\xB7\xF8\xF0\x33\x2E\x69\x65\xC0\x89\x2B\x82\x72\xAE"
           "\x8B\x65\x53\xEF\x96\xA4\xCC\xE6\xAB\x80\x9D\x23\x51\xCB\x77\x5B"
           "\xAB\x75\x5A\x70\x7B\x9C\xBE\xD6\x44\xCD\x0A\x3A\x1C\xF8\xD7\xC8"
           "\x9E\x68\x2B\xA2\xB6\x30\xC4\xE7\x3A\xF2\xDA\xE4\x15\xDE\x80\xD5"
           "\x03\xF6\x06\x3E\x19\x0B\x09\xF5\xE1\xED\xE9\x82\x79\x02\xD7\x21"
           "\x5C\x71\xFE\x15\xCB\xB5\x85\xB1\x12\x75\xF2\x94\xFC\xB7\x24\x14"
           "\xFF\xDE\xA6\x49\x7D\x61\xF8\xAE\x83\x40\x97\xC6\x13\x8F\xD6\xE2"
           "\xDA\xE8\x9D\x66\x71\x4A\x22\x1F\xF9\x55\x79\xAA\xE0\xE6\xD7\x29"
           "\x3D\x44\x2E\xC0\xB9\x4D\x64\x65\x2A\x0E\x4A\xB8\x62\xC1\x84\x2E"
           "\x3F\x6F\xEB\x79\xDF\xCF\xAA\x83\xB9\x7C\x73\x7E\x48\x88\x44\x03"
           "\xEA\x4F\x09\xCD\x72\x37\xA7\x49\x37\x6E\x52\x57\xFC\x64\x17\xE5"
           "\x9E\x36\x4D\xD7\x33\x82\xA5\x42\x3F\x37\x96\xE9\x00\x70\x91\x7E"
           "\x1F\xFF\xCD\xD3\x39\xD8\x27\x8F\x67\x81\x51\xF8\x03\xB5\x3A\xB9"
           "\x57\x64\x16\xBF\x7F\x0C\xD6\x74\xE7\x37\xB2\xFD\xF4\x20\x1B\x4C"
           "\xFD\xFC\x5C\xEF\x78\x30\x05\x38\xD7\x51\xE8\xD3\x16\x0A\x7D\x8C"
           "\xBA\x84\x9D\x1F\xF5\x6F\xE7\x15\x41\x1D\x3E\x40\x4D\x98\x64\x46"
           "\x43\x35\xA6\xBB\x0B\x0D\xF3\x39\x1D\xF9\x2B\x8C\x8E\xBD\x43\x9B"
           "\x39\x39\x10\x04\x06\x0B\x31\x7C\xF0\x1E\xE1\x70\xB1\x55\xD1\x59"
           "\xBE\x38\x24\xC8\x3E\x53\x30\xF7\x0F\xCE\x37\xCD\x5C\xF7\x90\x33"
           "\x85\x7F\x4D\x02\xAB\xEA\x50\x12\x18\xF3\x6E\x56\xA8\xEE\x38\x08"
           "\x8F\x94\x95\xAE\xE3\x74\x54\xCF\x0B\x88\x16\x7D\x2E\xBA\xAB\xCE"
           "\xCD\x7B\xA5\x62\x51\x84\x6A\x30\x0E\xF6\x44\x6C\x62\xDB\x9B\x21"
           "\xCA\x09\x0C\xBD\xE5\x09\x1C\xFA\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78"
           , 1200);
    nSKLen = 1200;
    memset(bData, 0x42, 256);
    bData[0] = 0x30;
    bData[255] = 0x39;
    nDataLen = 256;
    memcpy(bSignExp,
           "\x2F\x3C\x39\xEF\x79\x76\x3F\x86\x6B\x97\x76\x8A\x23\x9B\xBE\x9A"
           "\x4C\x7D\x44\xB6\x11\xDD\xC5\xF1\xD2\xBF\xBB\xF5\xF0\x46\x5D\xE3"
           "\xDF\x9A\x6A\x47\x75\x0D\x9D\x82\x7A\xB2\x02\x9D\x91\x6E\x17\x12"
           "\x2B\xA6\x42\xB6\xA6\x1E\x29\x4C\x71\xE8\xE5\xB3\xDE\x37\x42\x49"
           "\x03\x3F\x8F\x1F\xBF\xDB\x4E\x8A\x33\xCC\x7E\x58\x9C\xD7\x5B\xF3"
           "\xDB\x41\x9D\x0A\xFC\x93\xCB\x75\xE6\x17\xA9\xBA\x10\xBA\xDA\xBF"
           "\x2F\x79\xAF\x7F\x39\xA6\x75\x02\xAE\x07\x88\x96\x62\x72\x7B\xC4"
           "\x5B\x24\x57\xDB\x7B\x0D\x1C\x4D\x7F\xA9\x8B\xF5\x7F\x0A\x44\xE7"
           "\xDD\x02\x44\x9C\xB3\xA6\xB8\xFE\x0E\xCF\xCD\xFB\x63\xD1\xC4\xC5"
           "\x59\xAB\xFF\xCA\xC9\x1A\x53\x06\xE6\x39\x81\x84\xFA\xC6\xAB\xB8"
           "\x95\x93\x29\xCF\xEF\x81\x41\x0B\x12\x69\x4C\x58\x5B\x7A\x1D\x6D"
           "\xD9\x18\x1B\x3B\xEC\x7B\xCE\x36\x38\x4C\xEA\x7D\xDD\xC1\x4D\x88"
           "\x70\xF6\x20\xFF\x18\x8D\x8D\xC9\xD7\x3B\xE8\xBE\x80\x04\xD3\x3D"
           "\x24\x84\xF7\xD8\x16\x44\x87\xA6\x0E\x16\x1A\x9C\x1B\xD9\x16\x7F"
           "\x74\xF2\x66\x81\xAA\xD7\xA0\x4F\x00\x80\xD6\x58\x23\x23\x77\xF3"
           "\x44\x45\x1E\x92\x03\x29\x13\x37\x9B\xD3\x60\x88\xB7\x0A\x87\x7C"
           , 256);
    nSignLenExp = 256;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 1200);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 256);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-2048，SHA-224，PKCS#1填充，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bSign    =", bSign, 256);
    DspHex("[OUT]bSignExp =", bSignExp, 256);
    ASSERT_OUT_HEX(bSign, bSignExp, 256);
    ASSERT_OUT(nSignLen, nSignLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_34(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 3;
    nPadMode = 1;
    memcpy(bSK,
           "\xB6\xF8\xDC\x3E\x12\x98\x52\xB8\xB1\x84\xC0\x51\x97\xD1\xBE\x87"
           "\x70\x24\xD7\xE1\x4A\x71\xC3\x20\xA9\xEE\x78\x93\xF8\x99\x5C\x1A"
           "\xE5\x32\x78\x65\x85\x07\xEB\x5E\x26\x79\x2F\x1E\xE1\x6E\x6E\xB9"
           "\xF7\x6A\x23\x46\x09\x92\xD0\x54\xD2\xCA\x6C\xB6\xCE\xB0\x0B\x1C"
           "\x83\xD3\xEB\x1B\x6F\x47\x05\x82\xBF\x68\x23\x24\x90\xDD\xA0\x4C"
           "\xAD\x00\xC2\xD6\xBE\x7D\x8C\x5C\xBF\x1B\xF6\xE1\x73\x51\x9E\x6D"
           "\x62\x46\xBF\x62\xD5\xA6\xD6\x93\x17\x5D\xEE\xEF\x03\x82\x5E\x89"
           "\xA5\x42\xF3\x09\xB1\x20\x11\x48\x39\x90\x8A\xBD\xAA\xE3\xA8\x12"
           "\x4E\xD2\x36\x25\x16\x60\x73\x35\x44\x99\x56\xFE\xED\xF1\xC7\x48"
           "\x57\x57\x56\x27\x7C\x94\xC5\x2D\x6B\x77\xFB\xDC\x82\xD8\xD0\xE0"
           "\x2D\x0E\x4D\x64\x5B\x98\x07\x49\x8A\x29\x70\xD9\xDE\xA9\x44\xC5"
           "\xDE\x71\xCE\xF5\xE0\x63\x40\x28\xF4\xD6\x6D\x86\x14\xCF\x70\x24"
           "\x5B\x05\xAE\xC7\xE9\x69\x7B\x42\xAB\xF6\x53\xA3\x97\x1C\x93\x61"
           "\xCE\x7E\x8F\x38\xF1\x85\xC6\xB8\x2C\x6F\x11\x3E\xA6\xF1\x18\xF8"
           "\x85\xAD\xF2\xE3\x32\x82\x51\x0D\xEB\x12\x68\xC0\x1B\xCD\xF2\x3A"
           "\xB5\x55\xCD\x1A\x92\x9D\x31\xDF\xA6\xB2\x7A\xEE\x99\xA1\x39\x62"
           "\xC9\xE5\xFD\x47\xD0\x37\xCE\x6C\x08\x33\x31\x58\x38\x7B\x3F\x77"
           "\xFF\x4B\x01\xFC\x24\x58\x33\x24\xEB\xA6\xE2\xEE\x33\x1B\x67\x52"
           "\x81\x19\x16\x3A\xFA\x23\x82\x1B\x61\xEE\x5B\xDD\x08\x83\xA4\x5D"
           "\xCC\x57\x5A\xBF\xA5\x5C\x6E\xD7\xB0\xA2\xB6\x73\x52\x92\x9E\x5C"
           "\x46\x8D\x3E\xFB\x15\x1C\xB2\x7E\xD0\x90\x09\x61\x4F\x98\xFF\xEE"
           "\x8C\x40\x99\x83\x62\x1C\x2A\x29\xA9\x35\x58\x08\xF7\x97\xE6\xC7"
           "\x74\x50\xC9\x7D\xBF\xA2\x61\x51\x57\xD2\xDB\xDD\xE7\x19\xEF\x75"
           "\x26\xC0\x48\x56\xD9\x38\xFC\xF6\xF1\xEC\x6E\x96\x72\xCE\x2F\x19"
           "\xCA\x17\x76\x25\xFA\xDB\x0A\xBF\x4E\xD3\x6F\x65\xE2\xA3\x53\x9F"
           "\x0F\x91\xCF\xA8\x32\x9D\x83\xF1\x62\x54\xA3\x3E\x89\xF9\xD3\x20"
           "\xE8\x10\xE5\xE8\x6A\x73\x40\x90\x9A\x9D\x21\xD0\x9E\xEE\xFA\x44"
           "\x29\x42\x36\x61\xF0\x89\x9E\xE2\xFA\xBE\x06\x74\x7A\xAC\x2A\xF6"
           "\xA6\xFE\xE0\x7E\x17\x7C\xDA\xA7\x4B\xA3\x33\xD0\x66\x40\x56\x07"
           "\xB5\x21\x1A\x1E\x17\x3B\x43\x62\x9C\x0D\x16\xFA\xF3\x09\x93\x99"
           "\x56\x6C\xFD\x6A\xB7\x64\x04\x77\x33\x61\x13\x13\xD0\x93\x30\xD7"
           "\x78\xAE\xD3\x91\x30\xC2\x2C\x81\x39\x88\x9F\xE3\x9B\x4F\xF0\xC8"
           "\xFF\xA0\xA7\xED\x5F\xC3\xD7\xFE\x9C\xA7\x85\x7D\x1E\x7E\xA6\x7C"
           "\xD7\x6C\xEF\x3A\xAD\xE2\xFE\x2E\xAD\x45\x17\x9E\xC8\xA9\x71\xAB"
           "\xBF\xB6\xE3\x16\xEC\x4B\xF5\xA7\x9D\x20\x72\x87\xB4\x7E\x80\x89"
           "\xD6\xEF\x8C\xEA\x5D\xD5\xD2\x26\x9B\x3E\x58\x2C\xEB\xE6\x07\x1A"
           "\x05\x01\xD6\xBB\xFB\xA4\x2C\x31\x7A\xC0\x03\xB2\x14\x3D\x95\x41"
           "\xB5\xE3\x35\xA8\x86\xCF\x8C\x68\xFE\x01\x75\x0F\x3B\x77\x56\xA2"
           "\xCF\x29\x24\xFE\x99\x37\x02\x75\x65\x0E\xD6\xD2\x82\x9A\x93\x74"
           "\xAD\xBE\x1E\x56\x13\xC4\x29\x53\x35\x57\x4B\x46\x22\x4B\xB8\x50"
           "\x53\x71\x44\x27\xA8\xBC\x5B\x31\x0A\x32\xD4\x0F\xFF\xB2\x32\x5F"
           "\x39\xCD\xB1\x90\x77\x70\x23\xF9\xF4\x85\xDA\xE9\x16\x9D\xD5\xA0"
           "\x2A\x71\xF9\xF4\x40\x7D\xD1\x24\x5D\xBF\x93\xB3\x7F\x0D\x95\x67"
           "\x19\x51\x18\xA0\x99\x7A\x84\x44\x71\x9A\x08\x0D\x98\x25\x2E\xA6"
           "\x55\x6B\xEC\xA9\xA0\x72\xA4\xEF\x41\xC4\x20\x67\xA8\x86\xC9\x82"
           "\x86\xE8\x58\x5B\xA6\x8B\xCB\x30\xED\xF7\x7B\x0E\x6A\x6F\x6C\x39"
           "\x7A\x48\xA8\xE1\x9C\xEE\xC5\xDF\x08\x4B\xC9\x0A\x5D\xA0\x34\x42"
           "\xB5\x79\x5C\x29\xAF\xA9\xF8\x84\x31\xBE\x94\x21\x29\x17\x82\x99"
           "\x81\xB4\x9E\x2B\xC9\x78\xC5\xA6\x25\xD7\x28\xEE\x3A\xD2\x3B\xD8"
           "\x05\xCE\xEA\x07\x92\xD4\x8B\x4D\x64\xB4\x7F\x57\x9D\x2A\xFB\x80"
           "\xFF\x16\x09\xE2\x9A\xAC\x7E\x32\x2D\x2B\xE7\xA2\x9F\x9F\x63\xAF"
           "\x59\x62\xC6\x8D\x51\xD9\x2F\x6B\xF2\xB8\xEA\x9B\xAE\x30\x7A\xBB"
           "\x76\xC7\xDE\xB7\xF8\xF0\x33\x2E\x69\x65\xC0\x89\x2B\x82\x72\xAE"
           "\x8B\x65\x53\xEF\x96\xA4\xCC\xE6\xAB\x80\x9D\x23\x51\xCB\x77\x5B"
           "\xAB\x75\x5A\x70\x7B\x9C\xBE\xD6\x44\xCD\x0A\x3A\x1C\xF8\xD7\xC8"
           "\x9E\x68\x2B\xA2\xB6\x30\xC4\xE7\x3A\xF2\xDA\xE4\x15\xDE\x80\xD5"
           "\x03\xF6\x06\x3E\x19\x0B\x09\xF5\xE1\xED\xE9\x82\x79\x02\xD7\x21"
           "\x5C\x71\xFE\x15\xCB\xB5\x85\xB1\x12\x75\xF2\x94\xFC\xB7\x24\x14"
           "\xFF\xDE\xA6\x49\x7D\x61\xF8\xAE\x83\x40\x97\xC6\x13\x8F\xD6\xE2"
           "\xDA\xE8\x9D\x66\x71\x4A\x22\x1F\xF9\x55\x79\xAA\xE0\xE6\xD7\x29"
           "\x3D\x44\x2E\xC0\xB9\x4D\x64\x65\x2A\x0E\x4A\xB8\x62\xC1\x84\x2E"
           "\x3F\x6F\xEB\x79\xDF\xCF\xAA\x83\xB9\x7C\x73\x7E\x48\x88\x44\x03"
           "\xEA\x4F\x09\xCD\x72\x37\xA7\x49\x37\x6E\x52\x57\xFC\x64\x17\xE5"
           "\x9E\x36\x4D\xD7\x33\x82\xA5\x42\x3F\x37\x96\xE9\x00\x70\x91\x7E"
           "\x1F\xFF\xCD\xD3\x39\xD8\x27\x8F\x67\x81\x51\xF8\x03\xB5\x3A\xB9"
           "\x57\x64\x16\xBF\x7F\x0C\xD6\x74\xE7\x37\xB2\xFD\xF4\x20\x1B\x4C"
           "\xFD\xFC\x5C\xEF\x78\x30\x05\x38\xD7\x51\xE8\xD3\x16\x0A\x7D\x8C"
           "\xBA\x84\x9D\x1F\xF5\x6F\xE7\x15\x41\x1D\x3E\x40\x4D\x98\x64\x46"
           "\x43\x35\xA6\xBB\x0B\x0D\xF3\x39\x1D\xF9\x2B\x8C\x8E\xBD\x43\x9B"
           "\x39\x39\x10\x04\x06\x0B\x31\x7C\xF0\x1E\xE1\x70\xB1\x55\xD1\x59"
           "\xBE\x38\x24\xC8\x3E\x53\x30\xF7\x0F\xCE\x37\xCD\x5C\xF7\x90\x33"
           "\x85\x7F\x4D\x02\xAB\xEA\x50\x12\x18\xF3\x6E\x56\xA8\xEE\x38\x08"
           "\x8F\x94\x95\xAE\xE3\x74\x54\xCF\x0B\x88\x16\x7D\x2E\xBA\xAB\xCE"
           "\xCD\x7B\xA5\x62\x51\x84\x6A\x30\x0E\xF6\x44\x6C\x62\xDB\x9B\x21"
           "\xCA\x09\x0C\xBD\xE5\x09\x1C\xFA\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78"
           , 1200);
    nSKLen = 1200;
    memset(bData, 0x42, 256);
    bData[0] = 0x30;
    bData[255] = 0x39;
    nDataLen = 256;
    memcpy(bSignExp,
           "\x75\xBE\x77\x32\x74\x86\x8F\xB2\x24\xE8\x69\x2D\x4D\x8D\xBF\xAC"
           "\x3B\x43\x71\x9B\xF0\x99\x80\xF9\x8E\x42\x5C\x87\x31\x86\x28\xD1"
           "\x92\x3A\xBF\xD0\xFC\x7F\x13\x7D\xDF\x7D\x0B\xD4\xA0\x24\xE1\x08"
           "\x91\x14\x70\xF1\xDF\x03\xDD\x99\xFC\xEB\xAF\x72\x19\xB3\x42\x6E"
           "\x56\x33\xFE\x8F\x31\xC0\xBF\x7C\x57\xCA\xFA\x2C\xD5\x8A\x70\xC5"
           "\x38\xED\xE9\x57\x7F\x75\x41\x5C\x76\x86\x77\x92\xF7\x07\xC2\x36"
           "\x7B\x33\xA2\x4A\xFD\xD4\x1F\xBC\x4F\x8B\x8D\x51\xDE\xCF\xDB\x2C"
           "\xE5\x65\x4D\x87\x90\x9C\xDD\x6E\x6A\xBA\xA0\x5D\x65\x85\x46\x43"
           "\x61\xF1\x90\x6D\x42\x03\xB0\x78\x4D\xF0\xAD\x5F\xA4\x89\x07\x51"
           "\x00\xCB\x46\xB9\x40\x7E\xEC\x67\xCE\x3E\x94\x9C\xF3\x2E\x47\x07"
           "\x8A\x82\xAB\xA4\xDD\xAC\xC3\xEE\xDB\xE5\x43\xE9\x7A\xE4\x7C\x0D"
           "\xDC\x3A\xA9\xBB\x89\x13\x75\x11\x3D\x16\x46\xFF\x1D\xDD\xC5\x51"
           "\x33\x6C\x76\xB3\x9C\x84\x9E\xE5\x5E\xFF\x67\x65\xEC\x31\xA5\xDA"
           "\x49\xE4\x09\xBE\x3D\xDF\x01\x33\x13\xB9\xB9\x24\x26\x6E\xA9\x25"
           "\xFA\xAE\xBC\x1D\x06\xF8\x33\xFC\x64\x7D\x07\x84\x06\xB0\xE4\xC2"
           "\x83\x17\x5B\xEB\xDA\xEE\x3E\x23\xF0\xB8\xC2\x5A\x44\x66\x35\x4A"
           , 256);
    nSignLenExp = 256;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 1200);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 256);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-2048，SHA-256，PKCS#1填充，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bSign    =", bSign, 256);
    DspHex("[OUT]bSignExp =", bSignExp, 256);
    ASSERT_OUT_HEX(bSign, bSignExp, 256);
    ASSERT_OUT(nSignLen, nSignLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_35(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 4;
    nPadMode = 1;
    memcpy(bSK,
           "\xB6\xF8\xDC\x3E\x12\x98\x52\xB8\xB1\x84\xC0\x51\x97\xD1\xBE\x87"
           "\x70\x24\xD7\xE1\x4A\x71\xC3\x20\xA9\xEE\x78\x93\xF8\x99\x5C\x1A"
           "\xE5\x32\x78\x65\x85\x07\xEB\x5E\x26\x79\x2F\x1E\xE1\x6E\x6E\xB9"
           "\xF7\x6A\x23\x46\x09\x92\xD0\x54\xD2\xCA\x6C\xB6\xCE\xB0\x0B\x1C"
           "\x83\xD3\xEB\x1B\x6F\x47\x05\x82\xBF\x68\x23\x24\x90\xDD\xA0\x4C"
           "\xAD\x00\xC2\xD6\xBE\x7D\x8C\x5C\xBF\x1B\xF6\xE1\x73\x51\x9E\x6D"
           "\x62\x46\xBF\x62\xD5\xA6\xD6\x93\x17\x5D\xEE\xEF\x03\x82\x5E\x89"
           "\xA5\x42\xF3\x09\xB1\x20\x11\x48\x39\x90\x8A\xBD\xAA\xE3\xA8\x12"
           "\x4E\xD2\x36\x25\x16\x60\x73\x35\x44\x99\x56\xFE\xED\xF1\xC7\x48"
           "\x57\x57\x56\x27\x7C\x94\xC5\x2D\x6B\x77\xFB\xDC\x82\xD8\xD0\xE0"
           "\x2D\x0E\x4D\x64\x5B\x98\x07\x49\x8A\x29\x70\xD9\xDE\xA9\x44\xC5"
           "\xDE\x71\xCE\xF5\xE0\x63\x40\x28\xF4\xD6\x6D\x86\x14\xCF\x70\x24"
           "\x5B\x05\xAE\xC7\xE9\x69\x7B\x42\xAB\xF6\x53\xA3\x97\x1C\x93\x61"
           "\xCE\x7E\x8F\x38\xF1\x85\xC6\xB8\x2C\x6F\x11\x3E\xA6\xF1\x18\xF8"
           "\x85\xAD\xF2\xE3\x32\x82\x51\x0D\xEB\x12\x68\xC0\x1B\xCD\xF2\x3A"
           "\xB5\x55\xCD\x1A\x92\x9D\x31\xDF\xA6\xB2\x7A\xEE\x99\xA1\x39\x62"
           "\xC9\xE5\xFD\x47\xD0\x37\xCE\x6C\x08\x33\x31\x58\x38\x7B\x3F\x77"
           "\xFF\x4B\x01\xFC\x24\x58\x33\x24\xEB\xA6\xE2\xEE\x33\x1B\x67\x52"
           "\x81\x19\x16\x3A\xFA\x23\x82\x1B\x61\xEE\x5B\xDD\x08\x83\xA4\x5D"
           "\xCC\x57\x5A\xBF\xA5\x5C\x6E\xD7\xB0\xA2\xB6\x73\x52\x92\x9E\x5C"
           "\x46\x8D\x3E\xFB\x15\x1C\xB2\x7E\xD0\x90\x09\x61\x4F\x98\xFF\xEE"
           "\x8C\x40\x99\x83\x62\x1C\x2A\x29\xA9\x35\x58\x08\xF7\x97\xE6\xC7"
           "\x74\x50\xC9\x7D\xBF\xA2\x61\x51\x57\xD2\xDB\xDD\xE7\x19\xEF\x75"
           "\x26\xC0\x48\x56\xD9\x38\xFC\xF6\xF1\xEC\x6E\x96\x72\xCE\x2F\x19"
           "\xCA\x17\x76\x25\xFA\xDB\x0A\xBF\x4E\xD3\x6F\x65\xE2\xA3\x53\x9F"
           "\x0F\x91\xCF\xA8\x32\x9D\x83\xF1\x62\x54\xA3\x3E\x89\xF9\xD3\x20"
           "\xE8\x10\xE5\xE8\x6A\x73\x40\x90\x9A\x9D\x21\xD0\x9E\xEE\xFA\x44"
           "\x29\x42\x36\x61\xF0\x89\x9E\xE2\xFA\xBE\x06\x74\x7A\xAC\x2A\xF6"
           "\xA6\xFE\xE0\x7E\x17\x7C\xDA\xA7\x4B\xA3\x33\xD0\x66\x40\x56\x07"
           "\xB5\x21\x1A\x1E\x17\x3B\x43\x62\x9C\x0D\x16\xFA\xF3\x09\x93\x99"
           "\x56\x6C\xFD\x6A\xB7\x64\x04\x77\x33\x61\x13\x13\xD0\x93\x30\xD7"
           "\x78\xAE\xD3\x91\x30\xC2\x2C\x81\x39\x88\x9F\xE3\x9B\x4F\xF0\xC8"
           "\xFF\xA0\xA7\xED\x5F\xC3\xD7\xFE\x9C\xA7\x85\x7D\x1E\x7E\xA6\x7C"
           "\xD7\x6C\xEF\x3A\xAD\xE2\xFE\x2E\xAD\x45\x17\x9E\xC8\xA9\x71\xAB"
           "\xBF\xB6\xE3\x16\xEC\x4B\xF5\xA7\x9D\x20\x72\x87\xB4\x7E\x80\x89"
           "\xD6\xEF\x8C\xEA\x5D\xD5\xD2\x26\x9B\x3E\x58\x2C\xEB\xE6\x07\x1A"
           "\x05\x01\xD6\xBB\xFB\xA4\x2C\x31\x7A\xC0\x03\xB2\x14\x3D\x95\x41"
           "\xB5\xE3\x35\xA8\x86\xCF\x8C\x68\xFE\x01\x75\x0F\x3B\x77\x56\xA2"
           "\xCF\x29\x24\xFE\x99\x37\x02\x75\x65\x0E\xD6\xD2\x82\x9A\x93\x74"
           "\xAD\xBE\x1E\x56\x13\xC4\x29\x53\x35\x57\x4B\x46\x22\x4B\xB8\x50"
           "\x53\x71\x44\x27\xA8\xBC\x5B\x31\x0A\x32\xD4\x0F\xFF\xB2\x32\x5F"
           "\x39\xCD\xB1\x90\x77\x70\x23\xF9\xF4\x85\xDA\xE9\x16\x9D\xD5\xA0"
           "\x2A\x71\xF9\xF4\x40\x7D\xD1\x24\x5D\xBF\x93\xB3\x7F\x0D\x95\x67"
           "\x19\x51\x18\xA0\x99\x7A\x84\x44\x71\x9A\x08\x0D\x98\x25\x2E\xA6"
           "\x55\x6B\xEC\xA9\xA0\x72\xA4\xEF\x41\xC4\x20\x67\xA8\x86\xC9\x82"
           "\x86\xE8\x58\x5B\xA6\x8B\xCB\x30\xED\xF7\x7B\x0E\x6A\x6F\x6C\x39"
           "\x7A\x48\xA8\xE1\x9C\xEE\xC5\xDF\x08\x4B\xC9\x0A\x5D\xA0\x34\x42"
           "\xB5\x79\x5C\x29\xAF\xA9\xF8\x84\x31\xBE\x94\x21\x29\x17\x82\x99"
           "\x81\xB4\x9E\x2B\xC9\x78\xC5\xA6\x25\xD7\x28\xEE\x3A\xD2\x3B\xD8"
           "\x05\xCE\xEA\x07\x92\xD4\x8B\x4D\x64\xB4\x7F\x57\x9D\x2A\xFB\x80"
           "\xFF\x16\x09\xE2\x9A\xAC\x7E\x32\x2D\x2B\xE7\xA2\x9F\x9F\x63\xAF"
           "\x59\x62\xC6\x8D\x51\xD9\x2F\x6B\xF2\xB8\xEA\x9B\xAE\x30\x7A\xBB"
           "\x76\xC7\xDE\xB7\xF8\xF0\x33\x2E\x69\x65\xC0\x89\x2B\x82\x72\xAE"
           "\x8B\x65\x53\xEF\x96\xA4\xCC\xE6\xAB\x80\x9D\x23\x51\xCB\x77\x5B"
           "\xAB\x75\x5A\x70\x7B\x9C\xBE\xD6\x44\xCD\x0A\x3A\x1C\xF8\xD7\xC8"
           "\x9E\x68\x2B\xA2\xB6\x30\xC4\xE7\x3A\xF2\xDA\xE4\x15\xDE\x80\xD5"
           "\x03\xF6\x06\x3E\x19\x0B\x09\xF5\xE1\xED\xE9\x82\x79\x02\xD7\x21"
           "\x5C\x71\xFE\x15\xCB\xB5\x85\xB1\x12\x75\xF2\x94\xFC\xB7\x24\x14"
           "\xFF\xDE\xA6\x49\x7D\x61\xF8\xAE\x83\x40\x97\xC6\x13\x8F\xD6\xE2"
           "\xDA\xE8\x9D\x66\x71\x4A\x22\x1F\xF9\x55\x79\xAA\xE0\xE6\xD7\x29"
           "\x3D\x44\x2E\xC0\xB9\x4D\x64\x65\x2A\x0E\x4A\xB8\x62\xC1\x84\x2E"
           "\x3F\x6F\xEB\x79\xDF\xCF\xAA\x83\xB9\x7C\x73\x7E\x48\x88\x44\x03"
           "\xEA\x4F\x09\xCD\x72\x37\xA7\x49\x37\x6E\x52\x57\xFC\x64\x17\xE5"
           "\x9E\x36\x4D\xD7\x33\x82\xA5\x42\x3F\x37\x96\xE9\x00\x70\x91\x7E"
           "\x1F\xFF\xCD\xD3\x39\xD8\x27\x8F\x67\x81\x51\xF8\x03\xB5\x3A\xB9"
           "\x57\x64\x16\xBF\x7F\x0C\xD6\x74\xE7\x37\xB2\xFD\xF4\x20\x1B\x4C"
           "\xFD\xFC\x5C\xEF\x78\x30\x05\x38\xD7\x51\xE8\xD3\x16\x0A\x7D\x8C"
           "\xBA\x84\x9D\x1F\xF5\x6F\xE7\x15\x41\x1D\x3E\x40\x4D\x98\x64\x46"
           "\x43\x35\xA6\xBB\x0B\x0D\xF3\x39\x1D\xF9\x2B\x8C\x8E\xBD\x43\x9B"
           "\x39\x39\x10\x04\x06\x0B\x31\x7C\xF0\x1E\xE1\x70\xB1\x55\xD1\x59"
           "\xBE\x38\x24\xC8\x3E\x53\x30\xF7\x0F\xCE\x37\xCD\x5C\xF7\x90\x33"
           "\x85\x7F\x4D\x02\xAB\xEA\x50\x12\x18\xF3\x6E\x56\xA8\xEE\x38\x08"
           "\x8F\x94\x95\xAE\xE3\x74\x54\xCF\x0B\x88\x16\x7D\x2E\xBA\xAB\xCE"
           "\xCD\x7B\xA5\x62\x51\x84\x6A\x30\x0E\xF6\x44\x6C\x62\xDB\x9B\x21"
           "\xCA\x09\x0C\xBD\xE5\x09\x1C\xFA\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78"
           , 1200);
    nSKLen = 1200;
    memset(bData, 0x42, 256);
    bData[0] = 0x30;
    bData[255] = 0x39;
    nDataLen = 256;
    memcpy(bSignExp,
           "\x73\x05\xD6\x00\xCA\x6B\x42\xB4\x68\x70\xAE\x87\x47\xE7\xC0\xE8"
           "\xA3\xA1\x92\x6A\x5F\x90\x07\xE0\xDF\xC6\x6B\xF4\x26\xDA\xE2\x16"
           "\x46\x58\xA5\xB2\xB9\x4A\x53\x5B\xA5\x91\xB1\x34\x8B\xBF\x77\x01"
           "\xD4\x62\xA1\x94\x92\x17\x3B\x51\xF0\xB9\xFF\x32\xD8\x22\xAB\x74"
           "\xCF\x4B\x30\x3F\x37\xBA\x31\x5D\x5E\xEB\x9C\x12\x27\x20\x99\xAB"
           "\x5E\x0B\x2A\x8A\x35\x5D\xD6\x50\xEF\xFF\x6B\x6C\xAC\x6F\xA5\xA6"
           "\xE6\xFC\x73\x4E\x78\xD5\x8B\x97\x74\x62\x87\xCD\x70\xAB\x71\xA7"
           "\xB9\x1D\xD1\xA9\x82\x47\x99\x6F\x17\x47\xE4\xE1\x3D\xED\xBE\x3A"
           "\x1C\xF4\x42\x54\x3A\x69\x19\x14\x04\x30\xE3\xF3\xB1\x60\xAF\x77"
           "\x59\x35\x40\x92\x0E\x23\x0B\x8A\xE2\xC1\xF8\xC2\x46\xFF\xF1\xC7"
           "\x5A\x64\x65\x95\xE7\x54\xA8\x19\xC2\x37\x37\xE6\xC8\x24\x6F\x67"
           "\x13\x1A\xF9\xB9\x61\x97\xCB\x2D\xBD\x48\xED\x0B\x32\x00\xB7\xE9"
           "\xFB\x30\xE6\xED\xDB\xC4\xEF\xC2\xFC\x97\x47\x13\xC6\xFF\xB2\x47"
           "\xAE\xED\x90\x80\x9B\x9B\x8B\xD7\x43\xB8\xF8\x85\x93\x7C\x8A\x5F"
           "\xA8\x65\x00\x5B\x11\x0C\xFB\xAC\xE0\xF5\xC7\xF1\x95\x1B\x0F\xF3"
           "\x4D\x7B\x1A\x59\x5D\x09\x0C\x5F\xCF\xA6\xAC\xA9\x76\x3E\x9F\x37"
           , 256);
    nSignLenExp = 256;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 1200);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 256);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-2048，SHA-384，PKCS#1填充，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bSign    =", bSign, 256);
    DspHex("[OUT]bSignExp =", bSignExp, 256);
    ASSERT_OUT_HEX(bSign, bSignExp, 256);
    ASSERT_OUT(nSignLen, nSignLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_36(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 5;
    nPadMode = 1;
    memcpy(bSK,
           "\xB6\xF8\xDC\x3E\x12\x98\x52\xB8\xB1\x84\xC0\x51\x97\xD1\xBE\x87"
           "\x70\x24\xD7\xE1\x4A\x71\xC3\x20\xA9\xEE\x78\x93\xF8\x99\x5C\x1A"
           "\xE5\x32\x78\x65\x85\x07\xEB\x5E\x26\x79\x2F\x1E\xE1\x6E\x6E\xB9"
           "\xF7\x6A\x23\x46\x09\x92\xD0\x54\xD2\xCA\x6C\xB6\xCE\xB0\x0B\x1C"
           "\x83\xD3\xEB\x1B\x6F\x47\x05\x82\xBF\x68\x23\x24\x90\xDD\xA0\x4C"
           "\xAD\x00\xC2\xD6\xBE\x7D\x8C\x5C\xBF\x1B\xF6\xE1\x73\x51\x9E\x6D"
           "\x62\x46\xBF\x62\xD5\xA6\xD6\x93\x17\x5D\xEE\xEF\x03\x82\x5E\x89"
           "\xA5\x42\xF3\x09\xB1\x20\x11\x48\x39\x90\x8A\xBD\xAA\xE3\xA8\x12"
           "\x4E\xD2\x36\x25\x16\x60\x73\x35\x44\x99\x56\xFE\xED\xF1\xC7\x48"
           "\x57\x57\x56\x27\x7C\x94\xC5\x2D\x6B\x77\xFB\xDC\x82\xD8\xD0\xE0"
           "\x2D\x0E\x4D\x64\x5B\x98\x07\x49\x8A\x29\x70\xD9\xDE\xA9\x44\xC5"
           "\xDE\x71\xCE\xF5\xE0\x63\x40\x28\xF4\xD6\x6D\x86\x14\xCF\x70\x24"
           "\x5B\x05\xAE\xC7\xE9\x69\x7B\x42\xAB\xF6\x53\xA3\x97\x1C\x93\x61"
           "\xCE\x7E\x8F\x38\xF1\x85\xC6\xB8\x2C\x6F\x11\x3E\xA6\xF1\x18\xF8"
           "\x85\xAD\xF2\xE3\x32\x82\x51\x0D\xEB\x12\x68\xC0\x1B\xCD\xF2\x3A"
           "\xB5\x55\xCD\x1A\x92\x9D\x31\xDF\xA6\xB2\x7A\xEE\x99\xA1\x39\x62"
           "\xC9\xE5\xFD\x47\xD0\x37\xCE\x6C\x08\x33\x31\x58\x38\x7B\x3F\x77"
           "\xFF\x4B\x01\xFC\x24\x58\x33\x24\xEB\xA6\xE2\xEE\x33\x1B\x67\x52"
           "\x81\x19\x16\x3A\xFA\x23\x82\x1B\x61\xEE\x5B\xDD\x08\x83\xA4\x5D"
           "\xCC\x57\x5A\xBF\xA5\x5C\x6E\xD7\xB0\xA2\xB6\x73\x52\x92\x9E\x5C"
           "\x46\x8D\x3E\xFB\x15\x1C\xB2\x7E\xD0\x90\x09\x61\x4F\x98\xFF\xEE"
           "\x8C\x40\x99\x83\x62\x1C\x2A\x29\xA9\x35\x58\x08\xF7\x97\xE6\xC7"
           "\x74\x50\xC9\x7D\xBF\xA2\x61\x51\x57\xD2\xDB\xDD\xE7\x19\xEF\x75"
           "\x26\xC0\x48\x56\xD9\x38\xFC\xF6\xF1\xEC\x6E\x96\x72\xCE\x2F\x19"
           "\xCA\x17\x76\x25\xFA\xDB\x0A\xBF\x4E\xD3\x6F\x65\xE2\xA3\x53\x9F"
           "\x0F\x91\xCF\xA8\x32\x9D\x83\xF1\x62\x54\xA3\x3E\x89\xF9\xD3\x20"
           "\xE8\x10\xE5\xE8\x6A\x73\x40\x90\x9A\x9D\x21\xD0\x9E\xEE\xFA\x44"
           "\x29\x42\x36\x61\xF0\x89\x9E\xE2\xFA\xBE\x06\x74\x7A\xAC\x2A\xF6"
           "\xA6\xFE\xE0\x7E\x17\x7C\xDA\xA7\x4B\xA3\x33\xD0\x66\x40\x56\x07"
           "\xB5\x21\x1A\x1E\x17\x3B\x43\x62\x9C\x0D\x16\xFA\xF3\x09\x93\x99"
           "\x56\x6C\xFD\x6A\xB7\x64\x04\x77\x33\x61\x13\x13\xD0\x93\x30\xD7"
           "\x78\xAE\xD3\x91\x30\xC2\x2C\x81\x39\x88\x9F\xE3\x9B\x4F\xF0\xC8"
           "\xFF\xA0\xA7\xED\x5F\xC3\xD7\xFE\x9C\xA7\x85\x7D\x1E\x7E\xA6\x7C"
           "\xD7\x6C\xEF\x3A\xAD\xE2\xFE\x2E\xAD\x45\x17\x9E\xC8\xA9\x71\xAB"
           "\xBF\xB6\xE3\x16\xEC\x4B\xF5\xA7\x9D\x20\x72\x87\xB4\x7E\x80\x89"
           "\xD6\xEF\x8C\xEA\x5D\xD5\xD2\x26\x9B\x3E\x58\x2C\xEB\xE6\x07\x1A"
           "\x05\x01\xD6\xBB\xFB\xA4\x2C\x31\x7A\xC0\x03\xB2\x14\x3D\x95\x41"
           "\xB5\xE3\x35\xA8\x86\xCF\x8C\x68\xFE\x01\x75\x0F\x3B\x77\x56\xA2"
           "\xCF\x29\x24\xFE\x99\x37\x02\x75\x65\x0E\xD6\xD2\x82\x9A\x93\x74"
           "\xAD\xBE\x1E\x56\x13\xC4\x29\x53\x35\x57\x4B\x46\x22\x4B\xB8\x50"
           "\x53\x71\x44\x27\xA8\xBC\x5B\x31\x0A\x32\xD4\x0F\xFF\xB2\x32\x5F"
           "\x39\xCD\xB1\x90\x77\x70\x23\xF9\xF4\x85\xDA\xE9\x16\x9D\xD5\xA0"
           "\x2A\x71\xF9\xF4\x40\x7D\xD1\x24\x5D\xBF\x93\xB3\x7F\x0D\x95\x67"
           "\x19\x51\x18\xA0\x99\x7A\x84\x44\x71\x9A\x08\x0D\x98\x25\x2E\xA6"
           "\x55\x6B\xEC\xA9\xA0\x72\xA4\xEF\x41\xC4\x20\x67\xA8\x86\xC9\x82"
           "\x86\xE8\x58\x5B\xA6\x8B\xCB\x30\xED\xF7\x7B\x0E\x6A\x6F\x6C\x39"
           "\x7A\x48\xA8\xE1\x9C\xEE\xC5\xDF\x08\x4B\xC9\x0A\x5D\xA0\x34\x42"
           "\xB5\x79\x5C\x29\xAF\xA9\xF8\x84\x31\xBE\x94\x21\x29\x17\x82\x99"
           "\x81\xB4\x9E\x2B\xC9\x78\xC5\xA6\x25\xD7\x28\xEE\x3A\xD2\x3B\xD8"
           "\x05\xCE\xEA\x07\x92\xD4\x8B\x4D\x64\xB4\x7F\x57\x9D\x2A\xFB\x80"
           "\xFF\x16\x09\xE2\x9A\xAC\x7E\x32\x2D\x2B\xE7\xA2\x9F\x9F\x63\xAF"
           "\x59\x62\xC6\x8D\x51\xD9\x2F\x6B\xF2\xB8\xEA\x9B\xAE\x30\x7A\xBB"
           "\x76\xC7\xDE\xB7\xF8\xF0\x33\x2E\x69\x65\xC0\x89\x2B\x82\x72\xAE"
           "\x8B\x65\x53\xEF\x96\xA4\xCC\xE6\xAB\x80\x9D\x23\x51\xCB\x77\x5B"
           "\xAB\x75\x5A\x70\x7B\x9C\xBE\xD6\x44\xCD\x0A\x3A\x1C\xF8\xD7\xC8"
           "\x9E\x68\x2B\xA2\xB6\x30\xC4\xE7\x3A\xF2\xDA\xE4\x15\xDE\x80\xD5"
           "\x03\xF6\x06\x3E\x19\x0B\x09\xF5\xE1\xED\xE9\x82\x79\x02\xD7\x21"
           "\x5C\x71\xFE\x15\xCB\xB5\x85\xB1\x12\x75\xF2\x94\xFC\xB7\x24\x14"
           "\xFF\xDE\xA6\x49\x7D\x61\xF8\xAE\x83\x40\x97\xC6\x13\x8F\xD6\xE2"
           "\xDA\xE8\x9D\x66\x71\x4A\x22\x1F\xF9\x55\x79\xAA\xE0\xE6\xD7\x29"
           "\x3D\x44\x2E\xC0\xB9\x4D\x64\x65\x2A\x0E\x4A\xB8\x62\xC1\x84\x2E"
           "\x3F\x6F\xEB\x79\xDF\xCF\xAA\x83\xB9\x7C\x73\x7E\x48\x88\x44\x03"
           "\xEA\x4F\x09\xCD\x72\x37\xA7\x49\x37\x6E\x52\x57\xFC\x64\x17\xE5"
           "\x9E\x36\x4D\xD7\x33\x82\xA5\x42\x3F\x37\x96\xE9\x00\x70\x91\x7E"
           "\x1F\xFF\xCD\xD3\x39\xD8\x27\x8F\x67\x81\x51\xF8\x03\xB5\x3A\xB9"
           "\x57\x64\x16\xBF\x7F\x0C\xD6\x74\xE7\x37\xB2\xFD\xF4\x20\x1B\x4C"
           "\xFD\xFC\x5C\xEF\x78\x30\x05\x38\xD7\x51\xE8\xD3\x16\x0A\x7D\x8C"
           "\xBA\x84\x9D\x1F\xF5\x6F\xE7\x15\x41\x1D\x3E\x40\x4D\x98\x64\x46"
           "\x43\x35\xA6\xBB\x0B\x0D\xF3\x39\x1D\xF9\x2B\x8C\x8E\xBD\x43\x9B"
           "\x39\x39\x10\x04\x06\x0B\x31\x7C\xF0\x1E\xE1\x70\xB1\x55\xD1\x59"
           "\xBE\x38\x24\xC8\x3E\x53\x30\xF7\x0F\xCE\x37\xCD\x5C\xF7\x90\x33"
           "\x85\x7F\x4D\x02\xAB\xEA\x50\x12\x18\xF3\x6E\x56\xA8\xEE\x38\x08"
           "\x8F\x94\x95\xAE\xE3\x74\x54\xCF\x0B\x88\x16\x7D\x2E\xBA\xAB\xCE"
           "\xCD\x7B\xA5\x62\x51\x84\x6A\x30\x0E\xF6\x44\x6C\x62\xDB\x9B\x21"
           "\xCA\x09\x0C\xBD\xE5\x09\x1C\xFA\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78"
           , 1200);
    nSKLen = 1200;
    memset(bData, 0x42, 2048);
    bData[0] = 0x30;
    bData[2047] = 0x39;
    nDataLen = 2048;
    memcpy(bSignExp,
           "\x41\xCC\x9E\x06\x06\x0A\x76\xED\xB8\xE3\x74\xC6\xEB\xCA\xBC\x0E"
           "\xA7\xE9\xE2\x2A\xC3\x53\x80\xAB\xAD\x3C\x30\x7B\x76\x14\xCF\xF2"
           "\x9F\xC0\xBB\x4A\x8B\xA2\x1F\x70\xC6\xD9\x20\x8C\xBF\xEE\x04\xD2"
           "\x06\xB7\xDD\x4C\x02\x52\xD1\xFC\x20\x8B\x29\xBB\xCF\x9B\xA5\xA1"
           "\x64\x65\xC4\x00\x35\xF4\xF1\xF3\x8F\x71\x43\x09\xE2\x54\xC6\x67"
           "\x85\x5B\xD1\x13\x7A\x52\x9E\xF8\xC1\xAB\x36\xE6\x4E\x8B\xCD\xDE"
           "\xD6\x2E\xA4\x4E\x58\x2D\x4B\xB7\xEB\x54\x85\xEF\x13\xEB\x49\x3B"
           "\xE5\x1F\x5B\x39\x8A\x50\xBB\x35\xD2\x67\x19\x38\xC0\x4B\xFC\x3D"
           "\xCA\x7C\x0F\x84\xE2\x18\x5F\x99\xF3\xE9\x66\xCA\x9F\x96\xA2\xC4"
           "\xE8\xFE\xAB\x36\xA4\x43\xB1\x4A\xE6\xF6\xB9\x9E\x34\x91\x82\xA6"
           "\x75\xBA\x9E\x18\xF5\x98\xA0\xB7\xEB\xE5\x87\x4F\x4B\x11\x1A\xE8"
           "\xF9\x9C\x29\x5F\xC9\x39\x14\xD4\x82\x02\x44\x50\x99\x34\x06\xB5"
           "\x4B\x3D\x61\x30\x8E\x27\xC8\x2E\x3D\xCB\x1B\xD0\x21\x82\x21\x6D"
           "\x7B\x55\x32\x51\xCD\x51\xDB\xBE\x4C\x3C\xF1\x7D\xC0\x48\x12\xE5"
           "\xA9\xC9\x83\x54\xE8\xE5\x35\x03\xB6\x02\x6E\x28\xCE\x29\xEB\x38"
           "\xBE\x21\x53\x9B\x9E\xB5\xDA\xE2\xA0\xD6\x3A\x2A\xB8\x64\xF3\x07"
           , 256);
    nSignLenExp = 256;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 1200);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 2048);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-2048，SHA-512，PKCS#1填充，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bSign    =", bSign, 256);
    DspHex("[OUT]bSignExp =", bSignExp, 256);
    ASSERT_OUT_HEX(bSign, bSignExp, 256);
    ASSERT_OUT(nSignLen, nSignLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_37(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nSock = -1;
    nAlgo = 0;
    nPadMode = 1;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    memset(bData, 0x42, 1);
    nDataLen = 1;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 320);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 1);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void PrivateSign_Test_38(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nSock = 8;
    nAlgo = 0;
    nPadMode = 1;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    memset(bData, 0x42, 1);
    nDataLen = 1;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 320);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 1);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[8]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void PrivateSign_Test_39(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = -1;
    nPadMode = 1;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    memset(bData, 0x42, 1);
    nDataLen = 1;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 320);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 1);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效摘要算法类型[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_40(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 6;
    nPadMode = 1;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    memset(bData, 0x42, 1);
    nDataLen = 1;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 320);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 1);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效摘要算法类型[6]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_41(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 0;
    nPadMode = 1;
    nSKLen = 0;
    memset(bData, 0x42, 1);
    nDataLen = 1;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 320);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 1);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效私钥，长度=0测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_42(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 0;
    nPadMode = 1;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 319);
    nSKLen = 319;
    memset(bData, 0x42, 1);
    nDataLen = 1;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 320);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 1);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效私钥，长度=319测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_43(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 0;
    nPadMode = 1;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 304);
    nSKLen = 304;
    memset(bData, 0x42, 1);
    nDataLen = 1;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 320);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 1);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效私钥，长度=304测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_44(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 0;
    nPadMode = 1;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    nDataLen = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 320);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 0);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "数据长度=0测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_45(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 0;
    nPadMode = 0;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    memset(bData, 0x42, 1);
    nDataLen = 1;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 320);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 1);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无填充，数据长度=1测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateSign_Test_46(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;
	  BYTE bSignExp[512];
	  int  nSignLenExp;

    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);
    bufclr(bSignExp);

    nAlgo = 0;
    nPadMode = 2;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    memset(bData, 0x42, 1);
    nDataLen = 1;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 320);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bData =", bData, 1);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateSign(nSock, nAlgo, nPadMode, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "OAEP填充，数据长度=1测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 0;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    memset(bData, 0x42, 1);
    nDataLen = 1;
    memcpy(bSign,
           "\x6A\xCC\xF7\x0F\x1B\xD2\x9B\xF3\x06\xEE\xE5\x23\x4D\x02\x5C\x47"
           "\x60\x8E\x88\xFA\x20\x57\x36\x31\x51\xA3\x83\x71\x23\x16\x0C\xEF"
           "\xA5\x53\xB0\xE9\xD7\xD4\xAB\xBA\xD7\xE0\xB4\xD5\x1A\x04\x45\xD4"
           "\x1A\xE1\xF2\x28\xE8\x78\xD3\xA6\xD7\x5E\x54\x46\x35\x81\xEB\x91"
           , 64);
    nSignLen = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 72);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 1);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-512，MD5，PKCS#1填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 1;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    memset(bData, 0x42, 64);
    bData[0] = 0x30;
    bData[63] = 0x39;
    nDataLen = 64;
    memcpy(bSign,
           "\x9B\xD4\xE1\x2E\x47\x40\x76\x3F\xAD\x3E\x39\xBC\xCF\xE9\xC3\xC0"
           "\xFF\x2F\x2D\x59\x96\x49\x68\x27\x82\x59\x3A\x51\x9B\xCF\x43\x8B"
           "\x96\xEF\xF0\x47\x80\xBB\x2A\x66\x58\x17\x72\x28\x62\xB3\xFB\xF9"
           "\x9B\x8C\x3C\x62\x24\xB0\xA9\xA6\xF8\x1C\x5E\xE0\xC0\x03\x8D\x88"
           , 64);
    nSignLen = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 72);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 64);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-512，SHA-1，PKCS#1填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 2;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    memset(bData, 0x42, 64);
    bData[0] = 0x30;
    bData[63] = 0x39;
    nDataLen = 64;
    memcpy(bSign,
           "\x0C\x6D\xDB\xB2\xC0\xC6\x66\x85\x2F\xD7\x3C\xD1\x76\xF5\x4E\xFB"
           "\x22\xF4\xB7\xEA\x3C\xAF\xD0\xFB\xAF\x7C\x27\xA4\xC6\x2E\x1A\x77"
           "\x68\x4A\x37\x43\x84\xCB\xD4\xE6\x80\x71\x00\x4D\x13\xEC\xCF\xB4"
           "\x29\x05\xEA\x03\x7C\xB2\x5C\xC3\xF2\x72\x63\xBC\xD9\x55\xDB\x37"
           , 64);
    nSignLen = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 72);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 64);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-512，SHA-224，PKCS#1填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 3;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    memset(bData, 0x42, 64);
    bData[0] = 0x30;
    bData[63] = 0x39;
    nDataLen = 64;
    memcpy(bSign,
           "\x56\x97\xCD\xB6\x93\xE6\x99\x84\x86\x42\xEF\x3A\xA9\x4F\x40\x1D"
           "\xB0\xA9\x7F\xD4\x8F\x1A\x5A\xF8\x79\x8A\x17\x2E\x93\xC7\x5E\x96"
           "\x68\x3D\x6C\x67\xD6\x5A\x53\x9D\x15\xF6\xF9\x2D\x26\x82\xCC\x3D"
           "\x9D\x9B\x88\xFA\xE4\x8F\xE5\x8C\xB6\xD8\xCF\xBE\x66\x8E\x68\x2C"
           , 64);
    nSignLen = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 72);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 64);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-512，SHA-256，PKCS#1填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 4;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    memset(bData, 0x42, 64);
    bData[0] = 0x30;
    bData[63] = 0x39;
    nDataLen = 64;
    memcpy(bSign,
           "\x4C\x0E\x30\x56\xF4\x2D\xF8\x2D\x97\xCF\xE4\x9D\xB1\x05\xE6\x10"
           "\x2C\xD5\x4F\x78\xE0\xF6\x56\x9F\x4B\x57\x86\x46\x80\xF8\x9E\xBF"
           "\x68\x4C\x8A\xDF\xA4\x87\xE6\x8D\x79\xCF\x38\xB8\x0A\xD0\xEB\xB2"
           "\x8D\xB1\x64\xAE\xCC\x51\x9F\xFD\x0B\x1D\x95\xCA\x45\x7B\xE2\xA7"
           , 64);
    nSignLen = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 72);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 64);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-512，SHA-384，PKCS#1填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 5;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    memset(bData, 0x42, 2048);
    bData[0] = 0x30;
    bData[2047] = 0x39;
    nDataLen = 2048;
    nSignLen = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 72);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 2048);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "RSA-512，SHA-512，PKCS#1填充，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_07(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 0;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\x87\x02\x81\x81\x00\xA6\xF5\x8A\x17\x12\x3F\x46\x59\x92"
           "\xC0\x92\x01\x7E\xD3\xA9\x67\x2A\x6A\x42\x8E\xDA\x6A\xC2\x53\x91"
           "\x83\x77\x1E\x25\xA2\xA8\x74\x9B\xF3\x49\xF6\x6C\x5B\xA7\xDA\xC6"
           "\x18\x4B\x49\x42\x80\x20\x7F\xD9\xBB\x29\xC0\xF0\xD8\x81\xDC\x0A"
           "\x95\x53\x80\xF5\xA7\x52\x7E\x1E\x1E\x16\xB9\x5B\x79\xEE\x1F\x33"
           "\x50\x3A\xCC\x4E\xA1\x01\xC4\x55\xA8\x3B\xCB\x2B\xC8\xEB\xC5\x27"
           "\x5C\x21\xE3\x5B\xA1\x33\x60\xC6\x82\x76\xDD\x7C\x5F\xF0\x03\x24"
           "\xA7\x8E\x9B\x50\x8C\x46\xD5\xEB\xF5\x37\x81\x9B\xCD\x38\x01\x10"
           "\x1F\x9F\x0F\xBD\x78\x37\xC7\x02\x01\x03"
           , 138);
    nPKLen = 138;
    memset(bData, 0x42, 1);
    nDataLen = 1;
    memcpy(bSign,
           "\x13\x90\x6D\x9D\x0C\x56\x96\x26\x88\xD3\xAB\x51\x91\x8B\x03\x7B"
           "\x26\xB2\x3D\x15\x99\x04\x41\xC0\xBB\x25\x4E\x99\x5C\xBA\xF0\xD3"
           "\xF5\x67\xEB\x26\xBB\x40\x79\xCC\x53\xE4\xD6\xAB\xC9\x5D\x6A\x77"
           "\xB8\x65\xC9\xFF\xB0\xE0\x7A\xBB\x83\xB7\x9F\x0C\x2B\xB1\x28\x45"
           "\x30\xAC\x49\xE3\x4C\x8A\xF9\x82\x73\xD1\xC0\x87\x18\x38\xEC\x43"
           "\x27\x3F\xC1\x3C\x70\x23\xC1\x4C\xB6\x5B\x9F\x9E\xDE\x2A\x0A\x1B"
           "\x58\x27\x9D\xA3\x9B\x61\x56\xB3\x87\x1D\xF9\x1A\x11\xCD\x06\x40"
           "\xB6\x2D\x64\x9D\x4F\x2A\x23\x1B\x14\x09\x9D\x65\xF3\x87\xCB\x50"
           , 128);
    nSignLen = 128;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 138);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 1);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1024，MD5，PKCS#1填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_08(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 1;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\x87\x02\x81\x81\x00\xA6\xF5\x8A\x17\x12\x3F\x46\x59\x92"
           "\xC0\x92\x01\x7E\xD3\xA9\x67\x2A\x6A\x42\x8E\xDA\x6A\xC2\x53\x91"
           "\x83\x77\x1E\x25\xA2\xA8\x74\x9B\xF3\x49\xF6\x6C\x5B\xA7\xDA\xC6"
           "\x18\x4B\x49\x42\x80\x20\x7F\xD9\xBB\x29\xC0\xF0\xD8\x81\xDC\x0A"
           "\x95\x53\x80\xF5\xA7\x52\x7E\x1E\x1E\x16\xB9\x5B\x79\xEE\x1F\x33"
           "\x50\x3A\xCC\x4E\xA1\x01\xC4\x55\xA8\x3B\xCB\x2B\xC8\xEB\xC5\x27"
           "\x5C\x21\xE3\x5B\xA1\x33\x60\xC6\x82\x76\xDD\x7C\x5F\xF0\x03\x24"
           "\xA7\x8E\x9B\x50\x8C\x46\xD5\xEB\xF5\x37\x81\x9B\xCD\x38\x01\x10"
           "\x1F\x9F\x0F\xBD\x78\x37\xC7\x02\x01\x03"
           , 138);
    nPKLen = 138;
    memset(bData, 0x42, 128);
    bData[0] = 0x30;
    bData[127] = 0x39;
    nDataLen = 128;
    memcpy(bSign,
           "\x4F\x6C\xBD\x21\x5B\xB0\xCE\x16\xB7\x59\x43\x14\x2B\x05\x5F\xB6"
           "\x01\x99\xE1\x83\x8F\x46\xA3\x4E\x38\x4A\xFA\xC9\xB5\xC5\x03\xB0"
           "\x8D\xC6\xEE\x18\x68\x9A\xCF\x54\x69\x11\x0C\xA6\x98\xA3\xDF\xBD"
           "\x1C\x28\x7A\xD7\xB0\xF5\xE2\x68\x97\xCB\xF3\xFA\x99\x28\x20\xD7"
           "\x2F\x04\x83\x16\xC6\xC6\x7C\xBE\x71\xF6\x99\x4D\xF7\x82\x7E\x1A"
           "\xB7\xDD\xA2\xAD\x9B\xB3\xC2\xDB\x9B\x1B\x42\x47\xC1\xB8\x6E\x6C"
           "\xE0\x1C\x77\x62\xCE\xB3\xBA\xDD\xB6\x9F\x55\xB6\x81\xB0\xAA\xEE"
           "\x69\x77\x8D\xB5\x8E\x0A\x75\x3B\x2F\x8B\x21\x6A\xEF\xCC\x46\xCD"
           , 128);
    nSignLen = 128;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 138);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 128);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1024，SHA-1，PKCS#1填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_09(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 2;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\x87\x02\x81\x81\x00\xA6\xF5\x8A\x17\x12\x3F\x46\x59\x92"
           "\xC0\x92\x01\x7E\xD3\xA9\x67\x2A\x6A\x42\x8E\xDA\x6A\xC2\x53\x91"
           "\x83\x77\x1E\x25\xA2\xA8\x74\x9B\xF3\x49\xF6\x6C\x5B\xA7\xDA\xC6"
           "\x18\x4B\x49\x42\x80\x20\x7F\xD9\xBB\x29\xC0\xF0\xD8\x81\xDC\x0A"
           "\x95\x53\x80\xF5\xA7\x52\x7E\x1E\x1E\x16\xB9\x5B\x79\xEE\x1F\x33"
           "\x50\x3A\xCC\x4E\xA1\x01\xC4\x55\xA8\x3B\xCB\x2B\xC8\xEB\xC5\x27"
           "\x5C\x21\xE3\x5B\xA1\x33\x60\xC6\x82\x76\xDD\x7C\x5F\xF0\x03\x24"
           "\xA7\x8E\x9B\x50\x8C\x46\xD5\xEB\xF5\x37\x81\x9B\xCD\x38\x01\x10"
           "\x1F\x9F\x0F\xBD\x78\x37\xC7\x02\x01\x03"
           , 138);
    nPKLen = 138;
    memset(bData, 0x42, 128);
    bData[0] = 0x30;
    bData[127] = 0x39;
    nDataLen = 128;
    memcpy(bSign,
           "\x35\x04\x68\x23\x0E\x26\x91\x1B\xD3\xB6\x0F\xAE\x92\x9D\xA9\x37"
           "\xD8\x6C\x72\x28\x6F\xB0\xAF\x43\x45\x0E\x5E\xF3\xC7\xB0\x70\x13"
           "\xF2\x41\xCF\xE9\x42\x0A\x21\xB6\x5C\xAD\x9F\x6E\xB5\x4E\xAB\x5B"
           "\x57\x6B\x3A\x84\x49\x67\x6B\x7E\xC8\x9A\x7F\xA4\x6E\x5D\x56\xFC"
           "\x44\x51\xA6\x7D\xDE\x74\xD1\x8B\x6A\x87\xB5\x92\x5B\xB8\x7E\x2B"
           "\xE0\xD4\x99\x37\xA8\xFC\x33\xBB\xD1\x11\x7D\xDC\x3B\x34\xA4\x87"
           "\x06\xBB\x6E\x2F\xA6\x5A\x31\xA8\x09\x36\x59\xB6\xCE\xFF\x5E\x96"
           "\x23\xC9\xA0\x11\x89\xBD\x38\x5A\xB1\xE4\x94\x61\xA9\x9F\x0A\x14"
           , 128);
    nSignLen = 128;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 138);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 128);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1024，SHA-224，PKCS#1填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_10(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 3;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\x87\x02\x81\x81\x00\xA6\xF5\x8A\x17\x12\x3F\x46\x59\x92"
           "\xC0\x92\x01\x7E\xD3\xA9\x67\x2A\x6A\x42\x8E\xDA\x6A\xC2\x53\x91"
           "\x83\x77\x1E\x25\xA2\xA8\x74\x9B\xF3\x49\xF6\x6C\x5B\xA7\xDA\xC6"
           "\x18\x4B\x49\x42\x80\x20\x7F\xD9\xBB\x29\xC0\xF0\xD8\x81\xDC\x0A"
           "\x95\x53\x80\xF5\xA7\x52\x7E\x1E\x1E\x16\xB9\x5B\x79\xEE\x1F\x33"
           "\x50\x3A\xCC\x4E\xA1\x01\xC4\x55\xA8\x3B\xCB\x2B\xC8\xEB\xC5\x27"
           "\x5C\x21\xE3\x5B\xA1\x33\x60\xC6\x82\x76\xDD\x7C\x5F\xF0\x03\x24"
           "\xA7\x8E\x9B\x50\x8C\x46\xD5\xEB\xF5\x37\x81\x9B\xCD\x38\x01\x10"
           "\x1F\x9F\x0F\xBD\x78\x37\xC7\x02\x01\x03"
           , 138);
    nPKLen = 138;
    memset(bData, 0x42, 128);
    bData[0] = 0x30;
    bData[127] = 0x39;
    nDataLen = 128;
    memcpy(bSign,
           "\x91\x3D\x05\xA6\xD5\x9A\xFA\xB7\x4F\x4D\x58\x0C\xE7\x2C\xF6\x79"
           "\x6C\xAE\x45\x8E\x38\x52\x3A\xB7\xE0\xCA\x1D\xF3\x69\x10\x56\x00"
           "\x0B\xC3\x12\x1B\x35\x94\x76\xE9\xDB\x24\xEB\xEB\x4C\x2C\x6C\x05"
           "\xFD\xA3\x4D\x4E\x3F\xCC\x4C\xC7\xA0\xB0\x91\x63\x4F\x3D\x7D\xB7"
           "\xD8\xAF\xBA\x38\x3D\x5F\xB7\xDC\x73\xD5\xC6\xD3\xEC\xF5\xB7\xE0"
           "\xCE\x73\x7B\xFF\xB1\x67\x4D\xAC\x34\x64\x6C\xD0\xE6\x61\x4E\x53"
           "\xC4\xC2\x54\x45\xD0\x53\x49\x65\xC1\xED\x5A\x76\x73\xE5\x0B\xA3"
           "\xD6\xAC\x9A\x56\xE0\x85\xD7\x01\xC7\x07\x8A\xE6\xC1\xD8\xAF\x7A"
           , 128);
    nSignLen = 128;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 138);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 128);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1024，SHA-256，PKCS#1填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_11(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 4;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\x87\x02\x81\x81\x00\xA6\xF5\x8A\x17\x12\x3F\x46\x59\x92"
           "\xC0\x92\x01\x7E\xD3\xA9\x67\x2A\x6A\x42\x8E\xDA\x6A\xC2\x53\x91"
           "\x83\x77\x1E\x25\xA2\xA8\x74\x9B\xF3\x49\xF6\x6C\x5B\xA7\xDA\xC6"
           "\x18\x4B\x49\x42\x80\x20\x7F\xD9\xBB\x29\xC0\xF0\xD8\x81\xDC\x0A"
           "\x95\x53\x80\xF5\xA7\x52\x7E\x1E\x1E\x16\xB9\x5B\x79\xEE\x1F\x33"
           "\x50\x3A\xCC\x4E\xA1\x01\xC4\x55\xA8\x3B\xCB\x2B\xC8\xEB\xC5\x27"
           "\x5C\x21\xE3\x5B\xA1\x33\x60\xC6\x82\x76\xDD\x7C\x5F\xF0\x03\x24"
           "\xA7\x8E\x9B\x50\x8C\x46\xD5\xEB\xF5\x37\x81\x9B\xCD\x38\x01\x10"
           "\x1F\x9F\x0F\xBD\x78\x37\xC7\x02\x01\x03"
           , 138);
    nPKLen = 138;
    memset(bData, 0x42, 128);
    bData[0] = 0x30;
    bData[127] = 0x39;
    nDataLen = 128;
    memcpy(bSign,
           "\x38\xBB\x1B\x0C\xBC\x24\x8E\x8E\x2D\x25\x22\x64\xF9\xEA\x75\x97"
           "\xCE\xFF\x5E\xCF\x8A\x94\x50\xA7\xCE\xA3\xC8\xAC\xF2\x8B\xD1\x50"
           "\x65\x68\x45\xC6\x6D\x3F\x48\x4B\x57\xB2\x81\xF4\x43\xE1\x29\x0A"
           "\xF4\x70\xBB\xB1\x82\x9F\xA5\x2E\x63\x6B\x2B\x8D\x90\x82\x1F\x94"
           "\xFC\x7B\x34\x07\xF5\xF8\x72\x68\x56\x3D\x66\x91\x26\x52\xEF\x60"
           "\x63\xAE\x22\x3E\x8F\x39\x27\xBB\x88\x20\x3F\x9E\x4B\x3E\x3C\x93"
           "\xF9\x83\x38\x3C\x4A\xB6\xC3\xDC\x43\xE7\x61\xBB\xD2\xC6\xB0\x0D"
           "\x74\x0A\xC2\xCA\x36\xCE\xB0\xC2\xD7\xAD\x06\x00\xBD\x88\x05\x7C"
           , 128);
    nSignLen = 128;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 138);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 128);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1024，SHA-384，PKCS#1填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_12(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 5;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\x87\x02\x81\x81\x00\xA6\xF5\x8A\x17\x12\x3F\x46\x59\x92"
           "\xC0\x92\x01\x7E\xD3\xA9\x67\x2A\x6A\x42\x8E\xDA\x6A\xC2\x53\x91"
           "\x83\x77\x1E\x25\xA2\xA8\x74\x9B\xF3\x49\xF6\x6C\x5B\xA7\xDA\xC6"
           "\x18\x4B\x49\x42\x80\x20\x7F\xD9\xBB\x29\xC0\xF0\xD8\x81\xDC\x0A"
           "\x95\x53\x80\xF5\xA7\x52\x7E\x1E\x1E\x16\xB9\x5B\x79\xEE\x1F\x33"
           "\x50\x3A\xCC\x4E\xA1\x01\xC4\x55\xA8\x3B\xCB\x2B\xC8\xEB\xC5\x27"
           "\x5C\x21\xE3\x5B\xA1\x33\x60\xC6\x82\x76\xDD\x7C\x5F\xF0\x03\x24"
           "\xA7\x8E\x9B\x50\x8C\x46\xD5\xEB\xF5\x37\x81\x9B\xCD\x38\x01\x10"
           "\x1F\x9F\x0F\xBD\x78\x37\xC7\x02\x01\x03"
           , 138);
    nPKLen = 138;
    memset(bData, 0x42, 2048);
    bData[0] = 0x30;
    bData[2047] = 0x39;
    nDataLen = 2048;
    memcpy(bSign,
           "\x00\xF6\xC3\xAB\x74\x47\x25\xE6\xFB\x4D\xF9\x0F\xC7\x43\x12\x37"
           "\x85\xA2\x5A\xB4\xFC\xBF\x40\x82\x75\x76\xF5\xAB\x9E\x75\x09\x91"
           "\xC8\xE8\x89\xB8\x91\xE8\x41\x7A\xC5\x37\xF8\x68\xC0\x35\x04\x87"
           "\x94\x8A\x97\xC4\x35\x34\x02\x1F\x60\xDF\x20\xB4\x91\x86\x30\xB5"
           "\xBD\x7C\x63\xF5\xEA\x72\x84\x9A\x68\x5D\x34\x8E\xE5\xB9\xFB\x6F"
           "\x9A\xEE\x7A\x30\x5F\x3C\xBA\x48\x77\x88\x2D\x3B\xCC\x00\x79\xC3"
           "\x68\xAD\xFD\x9A\xCB\x06\x2D\xC9\xD5\xD8\x5A\xBF\x73\x7D\x15\xDC"
           "\xFA\x88\x15\x58\x8F\xC0\xC7\x11\xFE\x70\xBB\x70\x61\x00\x03\xC1"
           , 128);
    nSignLen = 128;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 138);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 2048);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1024，SHA-512，PKCS#1填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_13(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 0;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\x97\x02\x81\x91\x00\xB4\xD4\xCD\x27\x2B\x0C\x7A\xBA\xA9"
           "\x32\x54\xA6\x0A\xD3\xDD\xAE\x80\x31\x47\x07\xC8\x48\x4F\x76\x03"
           "\x7C\x24\x4A\x59\x54\x0E\x99\x25\xD1\x3C\xB6\xE0\x20\xDB\xCB\x20"
           "\xB5\x23\x8F\x55\xDE\xF4\x31\xCD\x51\xE2\x1B\x07\xDC\xCC\x41\x6A"
           "\xAA\xBB\x0C\x5E\x3A\x61\x11\xA0\x90\xE0\xA9\x38\x86\x1C\x78\xE9"
           "\xAA\x75\xF2\x02\x38\x36\x19\x53\x4C\xE9\x21\x88\x43\x05\x8C\x7D"
           "\xDB\x60\x26\x36\x87\x24\xA7\xD5\x36\x39\x14\xD1\xEF\x66\x78\x1C"
           "\xBE\xD1\x56\xF9\x70\x77\xF7\xE0\xF1\x1B\x9D\x8D\x9C\xB6\x26\x5A"
           "\xE6\x3A\xC8\x18\x9F\x48\x03\x3D\x85\x06\x21\x71\xB2\x2C\x70\x98"
           "\x40\xA5\x39\xA0\xBD\x8D\xDB\x02\x01\x03"
           , 154);
    nPKLen = 154;
    memset(bData, 0x42, 1);
    nDataLen = 1;
    memcpy(bSign,
           "\x56\x33\x96\x77\x5D\xB7\xE1\xCA\x20\xFF\x60\x73\x3B\xF6\x19\xAD"
           "\xC2\x0A\xA7\x91\x0F\x9C\x67\x56\xCE\x63\xB6\x33\x85\x31\x32\x44"
           "\x0B\xA1\xA0\xA0\xC5\x0D\x91\x8B\xAA\x85\x01\xF5\xAF\xA2\xB0\xAA"
           "\x75\xD9\xC9\xF0\x4D\xEF\xF4\x1F\xE4\xCC\x26\x0C\xA0\x08\x83\x33"
           "\x7F\x16\xF5\x24\x76\x6B\x36\xE3\xAD\xA0\xCA\x11\x11\xE8\xD3\x65"
           "\x4B\x9F\x19\x5C\x53\xA2\x4B\x44\xAA\xC8\x67\x7D\x92\xB1\xD3\x10"
           "\xF9\x78\xD3\xE1\x57\x45\xC1\xC0\x8C\x1D\x60\xA0\xB3\x38\x8E\xE3"
           "\x8F\xBA\x5C\x36\xD0\xD1\x3F\x69\x5B\xA1\x42\x2C\xFC\x35\x8B\x92"
           "\x04\x8F\x7A\x45\x3C\x54\xC1\xA1\xFD\x25\x10\x85\xE6\x5B\x94\xC8"
           , 144);
    nSignLen = 144;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 154);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 1);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1152，MD5，PKCS#1填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_14(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 1;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\x97\x02\x81\x91\x00\xB4\xD4\xCD\x27\x2B\x0C\x7A\xBA\xA9"
           "\x32\x54\xA6\x0A\xD3\xDD\xAE\x80\x31\x47\x07\xC8\x48\x4F\x76\x03"
           "\x7C\x24\x4A\x59\x54\x0E\x99\x25\xD1\x3C\xB6\xE0\x20\xDB\xCB\x20"
           "\xB5\x23\x8F\x55\xDE\xF4\x31\xCD\x51\xE2\x1B\x07\xDC\xCC\x41\x6A"
           "\xAA\xBB\x0C\x5E\x3A\x61\x11\xA0\x90\xE0\xA9\x38\x86\x1C\x78\xE9"
           "\xAA\x75\xF2\x02\x38\x36\x19\x53\x4C\xE9\x21\x88\x43\x05\x8C\x7D"
           "\xDB\x60\x26\x36\x87\x24\xA7\xD5\x36\x39\x14\xD1\xEF\x66\x78\x1C"
           "\xBE\xD1\x56\xF9\x70\x77\xF7\xE0\xF1\x1B\x9D\x8D\x9C\xB6\x26\x5A"
           "\xE6\x3A\xC8\x18\x9F\x48\x03\x3D\x85\x06\x21\x71\xB2\x2C\x70\x98"
           "\x40\xA5\x39\xA0\xBD\x8D\xDB\x02\x01\x03"
           , 154);
    nPKLen = 154;
    memset(bData, 0x42, 144);
    bData[0] = 0x30;
    bData[143] = 0x39;
    nDataLen = 144;
    memcpy(bSign,
           "\x1A\x48\x83\x0E\xAC\x20\xB0\xAA\x6D\x8A\xEE\x3D\xE5\xF5\xD2\xB6"
           "\x09\xE1\x14\x43\x1D\x18\xDB\xED\x86\xA8\x7C\xAE\x29\x76\x86\x92"
           "\x39\x36\x37\x94\xBF\x45\x02\x70\xB8\x27\x4C\xDE\xA0\xDA\xB8\xD9"
           "\x42\x20\xB6\xEE\x59\x34\x52\x5F\x98\x5F\xD6\xE7\x18\x5B\x22\x85"
           "\xAB\x6E\xD6\x81\x9C\xCF\x75\xF5\x64\x9E\x5A\x1F\xD2\xEB\x48\x1E"
           "\x8B\x20\x7E\x4F\xB0\x06\x29\x71\x34\xBF\xBF\xD5\xA5\x4B\x3E\x2C"
           "\x44\xC2\xA6\xDE\x40\x3B\x51\xD2\x00\xF3\xEF\x77\x08\x9A\xB6\x91"
           "\xE8\x5D\xC4\xA6\xDF\xE5\x27\x05\x0F\x6A\xAB\x92\x51\xAD\xCE\x9A"
           "\xF1\x36\xFE\xFF\x96\xC8\x96\xB2\xFB\xEC\xEA\xE5\x5E\x64\x85\x9B"
           , 144);
    nSignLen = 144;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 154);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 144);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1152，SHA-1，PKCS#1填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_15(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 2;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\x97\x02\x81\x91\x00\xB4\xD4\xCD\x27\x2B\x0C\x7A\xBA\xA9"
           "\x32\x54\xA6\x0A\xD3\xDD\xAE\x80\x31\x47\x07\xC8\x48\x4F\x76\x03"
           "\x7C\x24\x4A\x59\x54\x0E\x99\x25\xD1\x3C\xB6\xE0\x20\xDB\xCB\x20"
           "\xB5\x23\x8F\x55\xDE\xF4\x31\xCD\x51\xE2\x1B\x07\xDC\xCC\x41\x6A"
           "\xAA\xBB\x0C\x5E\x3A\x61\x11\xA0\x90\xE0\xA9\x38\x86\x1C\x78\xE9"
           "\xAA\x75\xF2\x02\x38\x36\x19\x53\x4C\xE9\x21\x88\x43\x05\x8C\x7D"
           "\xDB\x60\x26\x36\x87\x24\xA7\xD5\x36\x39\x14\xD1\xEF\x66\x78\x1C"
           "\xBE\xD1\x56\xF9\x70\x77\xF7\xE0\xF1\x1B\x9D\x8D\x9C\xB6\x26\x5A"
           "\xE6\x3A\xC8\x18\x9F\x48\x03\x3D\x85\x06\x21\x71\xB2\x2C\x70\x98"
           "\x40\xA5\x39\xA0\xBD\x8D\xDB\x02\x01\x03"
           , 154);
    nPKLen = 154;
    memset(bData, 0x42, 144);
    bData[0] = 0x30;
    bData[143] = 0x39;
    nDataLen = 144;
    memcpy(bSign,
           "\x19\x06\x61\x75\x56\x03\xE3\xC2\x1F\xEC\xF9\x89\x9E\xB9\xD4\xCA"
           "\x9F\x19\x10\x62\xFB\xE5\x38\x17\xA6\xB6\x4F\x3E\x2E\x88\xED\x12"
           "\x6C\xCC\x9E\xB2\xB4\xD1\x6F\x4C\xA0\x3F\x41\xCF\xCC\x9D\xFC\x15"
           "\xCF\x54\x6B\xC6\x8C\x72\x77\xF8\xE1\x3D\x51\xC6\xC8\x38\xBE\xC8"
           "\x4D\x70\x78\x06\xEE\xC1\xF5\x12\xEB\xE7\x54\xBA\x11\x1E\xC5\x73"
           "\xD7\x8F\x0A\x27\xAE\x80\x63\xDC\xE9\xE2\x00\x7D\x9C\x06\xB6\xE4"
           "\xDE\x1C\x7A\xEC\xE1\x11\xCF\x93\x91\x56\x77\x38\x4E\x23\xB2\x72"
           "\x25\x13\xDF\x41\xF4\x03\xD5\xA9\x01\xEB\x02\x5E\x9C\xA5\xD0\x63"
           "\x01\x1D\xFB\x33\xC1\xFB\x1A\x59\xBE\xFB\xF1\x81\x47\xD8\x1F\x18"
           , 144);
    nSignLen = 144;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 154);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 144);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1152，SHA-224，PKCS#1填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_16(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 3;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\x97\x02\x81\x91\x00\xB4\xD4\xCD\x27\x2B\x0C\x7A\xBA\xA9"
           "\x32\x54\xA6\x0A\xD3\xDD\xAE\x80\x31\x47\x07\xC8\x48\x4F\x76\x03"
           "\x7C\x24\x4A\x59\x54\x0E\x99\x25\xD1\x3C\xB6\xE0\x20\xDB\xCB\x20"
           "\xB5\x23\x8F\x55\xDE\xF4\x31\xCD\x51\xE2\x1B\x07\xDC\xCC\x41\x6A"
           "\xAA\xBB\x0C\x5E\x3A\x61\x11\xA0\x90\xE0\xA9\x38\x86\x1C\x78\xE9"
           "\xAA\x75\xF2\x02\x38\x36\x19\x53\x4C\xE9\x21\x88\x43\x05\x8C\x7D"
           "\xDB\x60\x26\x36\x87\x24\xA7\xD5\x36\x39\x14\xD1\xEF\x66\x78\x1C"
           "\xBE\xD1\x56\xF9\x70\x77\xF7\xE0\xF1\x1B\x9D\x8D\x9C\xB6\x26\x5A"
           "\xE6\x3A\xC8\x18\x9F\x48\x03\x3D\x85\x06\x21\x71\xB2\x2C\x70\x98"
           "\x40\xA5\x39\xA0\xBD\x8D\xDB\x02\x01\x03"
           , 154);
    nPKLen = 154;
    memset(bData, 0x42, 144);
    bData[0] = 0x30;
    bData[143] = 0x39;
    nDataLen = 144;
    memcpy(bSign,
           "\x88\xF8\x24\x38\x51\x2B\xF7\x2F\xCD\x76\xE3\x1E\x7D\x42\xB4\x96"
           "\x51\x9C\x2B\xD9\x0D\xE8\x09\xDA\x6F\x60\x6E\xBF\x5A\x73\x81\xE2"
           "\x47\xAE\x2E\x7E\x8B\x77\x25\xC9\x65\x16\xC4\xF2\xA0\xB1\x23\xA3"
           "\xAB\x92\xA6\xA0\x6B\xFC\xB2\x9F\x44\x1E\x61\x37\xB7\xF2\x81\x69"
           "\xE5\xB0\xA0\xE1\xE1\x4D\xED\x1C\xF4\x87\x72\xB2\x0E\x39\xE7\xC0"
           "\x73\xA6\x32\x0B\xFF\x4F\x6B\xB7\xE1\x80\x4F\x0A\x04\xF0\x33\x87"
           "\x86\x45\xD5\xFB\xF0\xB6\x99\x75\xCF\x9B\x44\x07\x02\x75\xA3\x15"
           "\x7E\x17\x71\x70\x6A\xCD\xFE\xAA\x50\x6B\x79\x91\x2E\x50\x70\xCF"
           "\x13\x10\xD0\x12\x96\x7F\xAD\x03\xFD\x1E\x0C\xD7\x1D\x55\x8B\x85"
           , 144);
    nSignLen = 144;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 154);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 144);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1152，SHA-256，PKCS#1填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_17(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 4;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\x97\x02\x81\x91\x00\xB4\xD4\xCD\x27\x2B\x0C\x7A\xBA\xA9"
           "\x32\x54\xA6\x0A\xD3\xDD\xAE\x80\x31\x47\x07\xC8\x48\x4F\x76\x03"
           "\x7C\x24\x4A\x59\x54\x0E\x99\x25\xD1\x3C\xB6\xE0\x20\xDB\xCB\x20"
           "\xB5\x23\x8F\x55\xDE\xF4\x31\xCD\x51\xE2\x1B\x07\xDC\xCC\x41\x6A"
           "\xAA\xBB\x0C\x5E\x3A\x61\x11\xA0\x90\xE0\xA9\x38\x86\x1C\x78\xE9"
           "\xAA\x75\xF2\x02\x38\x36\x19\x53\x4C\xE9\x21\x88\x43\x05\x8C\x7D"
           "\xDB\x60\x26\x36\x87\x24\xA7\xD5\x36\x39\x14\xD1\xEF\x66\x78\x1C"
           "\xBE\xD1\x56\xF9\x70\x77\xF7\xE0\xF1\x1B\x9D\x8D\x9C\xB6\x26\x5A"
           "\xE6\x3A\xC8\x18\x9F\x48\x03\x3D\x85\x06\x21\x71\xB2\x2C\x70\x98"
           "\x40\xA5\x39\xA0\xBD\x8D\xDB\x02\x01\x03"
           , 154);
    nPKLen = 154;
    memset(bData, 0x42, 144);
    bData[0] = 0x30;
    bData[143] = 0x39;
    nDataLen = 144;
    memcpy(bSign,
           "\x58\x74\x13\x6A\xAC\x21\x01\x19\x49\xD8\x0B\x47\xF6\x46\xB4\x49"
           "\x6F\x4E\x3B\xF8\x1F\xA2\x76\xDC\xBD\x8E\x06\xCC\x07\x76\x17\x25"
           "\x05\x60\x32\x9E\xFA\x1F\x14\xA8\x9D\x45\xEC\x59\x40\x0F\xA1\xBA"
           "\x39\x4D\xE0\x14\xAC\x22\x84\x52\x56\x23\xED\xA2\xCA\x76\x3D\xA5"
           "\x75\xCC\x54\x2E\xEA\x91\x77\x16\x5A\x6A\x7A\xD7\xE8\xAA\x17\xE0"
           "\xDA\xD4\xCB\x18\xAF\x39\x43\x58\x5D\x15\xCC\x56\x58\x44\xB0\x51"
           "\x8A\x13\x02\x91\xEA\xA3\xBC\x8D\xB7\xB2\xD2\x4E\x26\xEA\xFF\xB9"
           "\xAC\xB7\x39\x2F\x2D\xCB\x8A\xD2\xBD\x29\xC1\xE9\x88\xC1\xD2\xC7"
           "\x4A\xDA\xB8\x54\x28\x9D\xA6\xC3\x1E\xDA\x87\x1F\xAC\x71\xE9\x7B"
           , 144);
    nSignLen = 144;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 154);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 144);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1152，SHA-384，PKCS#1填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_18(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 5;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\x97\x02\x81\x91\x00\xB4\xD4\xCD\x27\x2B\x0C\x7A\xBA\xA9"
           "\x32\x54\xA6\x0A\xD3\xDD\xAE\x80\x31\x47\x07\xC8\x48\x4F\x76\x03"
           "\x7C\x24\x4A\x59\x54\x0E\x99\x25\xD1\x3C\xB6\xE0\x20\xDB\xCB\x20"
           "\xB5\x23\x8F\x55\xDE\xF4\x31\xCD\x51\xE2\x1B\x07\xDC\xCC\x41\x6A"
           "\xAA\xBB\x0C\x5E\x3A\x61\x11\xA0\x90\xE0\xA9\x38\x86\x1C\x78\xE9"
           "\xAA\x75\xF2\x02\x38\x36\x19\x53\x4C\xE9\x21\x88\x43\x05\x8C\x7D"
           "\xDB\x60\x26\x36\x87\x24\xA7\xD5\x36\x39\x14\xD1\xEF\x66\x78\x1C"
           "\xBE\xD1\x56\xF9\x70\x77\xF7\xE0\xF1\x1B\x9D\x8D\x9C\xB6\x26\x5A"
           "\xE6\x3A\xC8\x18\x9F\x48\x03\x3D\x85\x06\x21\x71\xB2\x2C\x70\x98"
           "\x40\xA5\x39\xA0\xBD\x8D\xDB\x02\x01\x03"
           , 154);
    nPKLen = 154;
    memset(bData, 0x42, 2048);
    bData[0] = 0x30;
    bData[2047] = 0x39;
    nDataLen = 2048;
    memcpy(bSign,
           "\x50\xF6\x7F\x08\x75\x23\x88\x97\x4E\x07\x45\xC8\xA3\xDA\x95\x9A"
           "\xD7\xAA\xAA\x96\x1C\x98\x24\x8E\x2E\xCA\x29\xC3\xFD\xB7\x41\xDE"
           "\x29\x7E\xB7\xC6\x60\xF7\x53\x24\xCF\xAA\x20\x05\x93\xC1\x85\x28"
           "\xD1\x0A\x9A\x94\x03\x18\x94\xA7\x72\xFE\xD0\x8A\x1D\x35\x05\x3A"
           "\x0D\x82\x71\xE4\xFC\x40\x7F\x78\xB0\x8B\x8A\x62\xB4\x92\xD3\xE6"
           "\xC2\x9C\xF4\xA0\x79\xF7\xA7\x76\xA8\x84\xF5\x4F\x9F\x57\x3F\x72"
           "\x5B\x7F\xDB\x15\xEB\xEB\x6D\xF3\x54\x90\x85\x74\x4A\x09\x8C\x5B"
           "\x5C\x1C\xBB\x01\xE0\x8F\x45\xF1\x24\xDE\x79\x39\xE0\x9A\x16\x51"
           "\x00\x8E\x94\x12\x58\xF4\x45\x9E\x45\x7B\x71\x2D\x13\x8D\x54\x3D"
           , 144);
    nSignLen = 144;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 154);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 2048);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1152，SHA-512，PKCS#1填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_19(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 0;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\xB7\x02\x81\xB1\x00\x9C\xDB\xEA\x10\x4A\xEE\x30\xD8\x58"
           "\xE1\xC7\x10\x81\xC8\x32\x40\x80\x1C\x94\x1E\xF6\xE9\x05\xC8\x0E"
           "\x41\x94\xE8\x88\x59\x72\xA8\x21\x22\x0C\x7B\x5F\x52\x8D\x65\xF0"
           "\xDD\x09\x56\x01\x71\xB6\x43\x64\x9A\x6E\x1F\xE3\x85\x7D\x2A\x27"
           "\xF7\x5A\xA3\xDB\x73\xA2\x99\xD6\x85\xAF\x86\x91\x7F\x19\xF5\x65"
           "\x7C\xA9\x71\xC1\x72\x38\x03\x8B\xDD\x83\x62\x79\x60\xB2\xB3\xE2"
           "\x7E\x41\x0D\x36\x50\x7C\xFA\xB0\x6E\xAE\x9E\x05\x5A\x55\xF8\x9C"
           "\x69\x71\x90\x77\x4C\xA3\x95\x29\x7D\xC1\x79\xFE\x7C\xD7\x96\x84"
           "\x0D\xC6\x30\x3F\x14\xDA\x88\xCF\x4A\xED\x5A\x7A\x71\x91\x5D\x25"
           "\x93\xDA\x0C\xB6\xCC\xB6\xD8\xE7\xF0\x54\x55\xA3\x93\xBD\xC0\xE7"
           "\x3E\xF8\x26\xFC\x5B\x37\xA5\x91\x01\x4B\xA2\x58\xBB\x59\xC2\x1E"
           "\xC8\x32\x3B\x85\x16\x8E\xF3\x02\x01\x03"
           , 186);
    nPKLen = 186;
    memset(bData, 0x42, 1);
    nDataLen = 1;
    memcpy(bSign,
           "\x9A\x13\x07\x6E\xAF\x92\x98\xA5\x81\xA8\x7C\x4A\x74\xBC\x6A\x64"
           "\x98\x64\xBD\x93\x48\x60\x9B\xCC\x3F\x65\x7F\xC2\x76\x63\xA1\x53"
           "\x79\x74\x55\x17\xFF\xD6\x59\x59\xF3\xAF\x28\x30\x1A\x03\x95\x94"
           "\x82\x50\xF1\xAE\xD8\x84\xA9\xF7\x45\xA5\x51\x9E\x0F\x4D\xC2\xF0"
           "\x12\x26\x4D\xA3\x7E\xB1\x1A\xA3\x5B\xED\xBA\xB7\xA7\xAF\x37\x07"
           "\xFA\xA8\xCE\xB2\xDB\x0F\x85\x1C\xA1\xEA\x2D\x76\xCE\x0D\xBC\x92"
           "\x39\xD4\x0C\x2C\x82\x92\x05\xF2\xC1\x36\xB4\x16\x86\x39\x36\xF6"
           "\x66\x69\x83\x62\x36\x68\x03\x27\x1A\xB5\xEC\x7F\xC3\x87\x0D\x45"
           "\xCB\x9F\xB6\x72\xED\xAF\xE0\x21\x2E\x97\x55\x64\x29\x40\xFC\x81"
           "\x7B\xDF\x4A\x12\x7B\x78\x11\x29\x04\xE4\x46\x7F\xC0\x94\x97\xE0"
           "\x2F\x4B\x8D\x3A\x9A\x52\x7A\x64\x90\x4A\x85\x8B\x99\xD1\xBD\x90"
           , 176);
    nSignLen = 176;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 186);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 1);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1408，MD5，PKCS#1填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_20(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 1;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\xB7\x02\x81\xB1\x00\x9C\xDB\xEA\x10\x4A\xEE\x30\xD8\x58"
           "\xE1\xC7\x10\x81\xC8\x32\x40\x80\x1C\x94\x1E\xF6\xE9\x05\xC8\x0E"
           "\x41\x94\xE8\x88\x59\x72\xA8\x21\x22\x0C\x7B\x5F\x52\x8D\x65\xF0"
           "\xDD\x09\x56\x01\x71\xB6\x43\x64\x9A\x6E\x1F\xE3\x85\x7D\x2A\x27"
           "\xF7\x5A\xA3\xDB\x73\xA2\x99\xD6\x85\xAF\x86\x91\x7F\x19\xF5\x65"
           "\x7C\xA9\x71\xC1\x72\x38\x03\x8B\xDD\x83\x62\x79\x60\xB2\xB3\xE2"
           "\x7E\x41\x0D\x36\x50\x7C\xFA\xB0\x6E\xAE\x9E\x05\x5A\x55\xF8\x9C"
           "\x69\x71\x90\x77\x4C\xA3\x95\x29\x7D\xC1\x79\xFE\x7C\xD7\x96\x84"
           "\x0D\xC6\x30\x3F\x14\xDA\x88\xCF\x4A\xED\x5A\x7A\x71\x91\x5D\x25"
           "\x93\xDA\x0C\xB6\xCC\xB6\xD8\xE7\xF0\x54\x55\xA3\x93\xBD\xC0\xE7"
           "\x3E\xF8\x26\xFC\x5B\x37\xA5\x91\x01\x4B\xA2\x58\xBB\x59\xC2\x1E"
           "\xC8\x32\x3B\x85\x16\x8E\xF3\x02\x01\x03"
           , 186);
    nPKLen = 186;
    memset(bData, 0x42, 176);
    bData[0] = 0x30;
    bData[175] = 0x39;
    nDataLen = 176;
    memcpy(bSign,
           "\x26\x57\xD2\x2E\xA8\x97\x76\xEF\xB7\x77\x15\x64\xA2\x11\xEE\xD5"
           "\xA5\x7C\x71\x8A\x5B\x9B\xD7\xA1\xFE\x14\x3B\x09\xFB\x8F\x32\x45"
           "\x81\x35\xBF\x44\xFB\x3B\xE4\xDD\xD3\x78\x98\xC1\xDE\xC1\xC4\xC0"
           "\x09\x16\xCC\xE6\x3A\xA8\x19\x1A\xDE\x27\xB2\xE3\xF3\x35\x48\x36"
           "\x85\xF2\xDB\xCF\xDC\x6B\x3C\xC1\xA5\x8B\xFC\x4B\xC0\x96\x62\xC5"
           "\x11\x67\xF1\x96\xE0\x53\xA0\xC0\x8E\xA9\x3E\xAA\x40\x31\x58\xB3"
           "\x73\x60\x85\x8E\x3A\x0D\x92\x92\x70\xCE\xE1\xB0\xC1\xEE\xA6\xCD"
           "\x6F\xBB\x1F\xD1\x0F\x65\x5C\x8B\x65\xBF\x29\xFC\x6F\x1F\x87\x58"
           "\x78\x9F\x8B\x37\x33\x37\x0A\x4E\x1B\x46\x89\x5C\x2D\x89\x79\xE3"
           "\xB2\x42\x08\xC2\xD7\xF9\x76\xD6\xCB\x5C\xB5\xD3\xF6\xCE\xF3\x04"
           "\xAF\xE6\x22\xD9\x69\x35\x7D\x94\xC7\x09\xBB\x02\x1B\x86\x95\x2C"
           , 176);
    nSignLen = 176;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 186);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 176);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1408，SHA-1，PKCS#1填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_21(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 2;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\xB7\x02\x81\xB1\x00\x9C\xDB\xEA\x10\x4A\xEE\x30\xD8\x58"
           "\xE1\xC7\x10\x81\xC8\x32\x40\x80\x1C\x94\x1E\xF6\xE9\x05\xC8\x0E"
           "\x41\x94\xE8\x88\x59\x72\xA8\x21\x22\x0C\x7B\x5F\x52\x8D\x65\xF0"
           "\xDD\x09\x56\x01\x71\xB6\x43\x64\x9A\x6E\x1F\xE3\x85\x7D\x2A\x27"
           "\xF7\x5A\xA3\xDB\x73\xA2\x99\xD6\x85\xAF\x86\x91\x7F\x19\xF5\x65"
           "\x7C\xA9\x71\xC1\x72\x38\x03\x8B\xDD\x83\x62\x79\x60\xB2\xB3\xE2"
           "\x7E\x41\x0D\x36\x50\x7C\xFA\xB0\x6E\xAE\x9E\x05\x5A\x55\xF8\x9C"
           "\x69\x71\x90\x77\x4C\xA3\x95\x29\x7D\xC1\x79\xFE\x7C\xD7\x96\x84"
           "\x0D\xC6\x30\x3F\x14\xDA\x88\xCF\x4A\xED\x5A\x7A\x71\x91\x5D\x25"
           "\x93\xDA\x0C\xB6\xCC\xB6\xD8\xE7\xF0\x54\x55\xA3\x93\xBD\xC0\xE7"
           "\x3E\xF8\x26\xFC\x5B\x37\xA5\x91\x01\x4B\xA2\x58\xBB\x59\xC2\x1E"
           "\xC8\x32\x3B\x85\x16\x8E\xF3\x02\x01\x03"
           , 186);
    nPKLen = 186;
    memset(bData, 0x42, 176);
    bData[0] = 0x30;
    bData[175] = 0x39;
    nDataLen = 176;
    memcpy(bSign,
           "\x39\x3B\x49\x0A\x1B\x4B\x62\x4A\x01\x6C\xFD\x7D\x13\xFE\xE4\x4B"
           "\x42\x59\x5C\xDF\x9F\x32\x38\x6B\x78\x0E\xFF\x7C\x32\x53\xDA\x69"
           "\xAB\xF6\xC3\xD8\xF1\xCB\x16\xA1\x83\x71\x00\xDF\x0D\x10\x86\xEE"
           "\xDA\xBC\x34\x5A\x9C\x23\x93\x06\x4E\xEC\xC8\xEF\xB9\x47\xEF\x86"
           "\xED\x31\xA6\x6B\x52\xF7\x27\x13\x7E\x2F\x47\x29\x07\x9F\x8C\xC2"
           "\x00\xF0\x01\xE9\xBF\xCC\x49\xDA\x72\x3F\xA1\x98\xA4\x3E\x87\xE2"
           "\xC2\xEB\xA1\xA8\xED\x15\xE4\xC4\x91\xE6\xF9\x32\xD6\x7D\xD8\xFE"
           "\x81\x42\x7C\xDF\xD9\x14\xDD\x37\xFA\xAF\x4F\xEB\xB1\x94\x58\xDB"
           "\xFF\x1F\x46\xD9\x92\xE3\x59\xF5\xE9\xBA\xE8\xFC\x00\x97\x44\xEB"
           "\xE1\x83\x00\xE9\x02\x08\x7D\x80\x9A\xBB\x14\xE8\xAE\x41\xAF\x80"
           "\x8E\x93\x12\x76\xC8\x06\x4B\x0F\x57\xB7\xF6\x8A\x2E\x47\x62\x74"
           , 176);
    nSignLen = 176;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 186);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 176);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1408，SHA-224，PKCS#1填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_22(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 3;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\xB7\x02\x81\xB1\x00\x9C\xDB\xEA\x10\x4A\xEE\x30\xD8\x58"
           "\xE1\xC7\x10\x81\xC8\x32\x40\x80\x1C\x94\x1E\xF6\xE9\x05\xC8\x0E"
           "\x41\x94\xE8\x88\x59\x72\xA8\x21\x22\x0C\x7B\x5F\x52\x8D\x65\xF0"
           "\xDD\x09\x56\x01\x71\xB6\x43\x64\x9A\x6E\x1F\xE3\x85\x7D\x2A\x27"
           "\xF7\x5A\xA3\xDB\x73\xA2\x99\xD6\x85\xAF\x86\x91\x7F\x19\xF5\x65"
           "\x7C\xA9\x71\xC1\x72\x38\x03\x8B\xDD\x83\x62\x79\x60\xB2\xB3\xE2"
           "\x7E\x41\x0D\x36\x50\x7C\xFA\xB0\x6E\xAE\x9E\x05\x5A\x55\xF8\x9C"
           "\x69\x71\x90\x77\x4C\xA3\x95\x29\x7D\xC1\x79\xFE\x7C\xD7\x96\x84"
           "\x0D\xC6\x30\x3F\x14\xDA\x88\xCF\x4A\xED\x5A\x7A\x71\x91\x5D\x25"
           "\x93\xDA\x0C\xB6\xCC\xB6\xD8\xE7\xF0\x54\x55\xA3\x93\xBD\xC0\xE7"
           "\x3E\xF8\x26\xFC\x5B\x37\xA5\x91\x01\x4B\xA2\x58\xBB\x59\xC2\x1E"
           "\xC8\x32\x3B\x85\x16\x8E\xF3\x02\x01\x03"
           , 186);
    nPKLen = 186;
    memset(bData, 0x42, 176);
    bData[0] = 0x30;
    bData[175] = 0x39;
    nDataLen = 176;
    memcpy(bSign,
           "\x06\x15\x84\xB2\x28\xFC\x25\x45\x73\x4A\xE6\x57\xA9\x6C\xD4\x30"
           "\x94\xEC\x30\x2D\x61\x46\x4E\x86\x38\x22\x9A\x21\x14\x54\x52\x93"
           "\x7B\xA5\x7E\x38\xEA\x9B\x28\x34\x81\x26\x44\xB3\x9D\x90\xD3\x98"
           "\x08\x70\x33\x5E\x95\xA4\xDE\xA2\x6C\x3C\x3C\xFB\xB2\x85\xEB\xFA"
           "\xC4\x99\xEE\x1E\xDC\x47\xBC\x0D\x9F\xDD\x3D\xD0\x12\xFF\xCC\x90"
           "\x31\x59\x80\x7A\x4F\xE1\x8E\xE2\x11\xB8\x32\xD6\xF0\x7B\xCF\x31"
           "\x1B\x66\xC3\x9A\x60\x31\xC4\xF9\xDC\x04\x84\xB9\x3C\x49\x1F\x97"
           "\xCE\x11\xCF\xC0\xC0\x30\x4B\x68\x63\x3B\x47\x27\xE0\x76\xBE\xBC"
           "\xD2\x9D\x94\x78\x5D\xB3\x15\x40\x5C\xE2\xBB\xF5\xED\x4C\x20\x84"
           "\x6C\x88\x77\xC3\xCA\xD0\x74\xF5\x60\xA5\x83\xAB\xEE\x62\x78\x83"
           "\x29\xE7\xD8\x55\xD3\x23\xD6\x46\x4D\x1B\x56\xDB\xFC\x38\xFF\xB4"
           , 176);
    nSignLen = 176;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 186);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 176);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1408，SHA-256，PKCS#1填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_23(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 4;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\xB7\x02\x81\xB1\x00\x9C\xDB\xEA\x10\x4A\xEE\x30\xD8\x58"
           "\xE1\xC7\x10\x81\xC8\x32\x40\x80\x1C\x94\x1E\xF6\xE9\x05\xC8\x0E"
           "\x41\x94\xE8\x88\x59\x72\xA8\x21\x22\x0C\x7B\x5F\x52\x8D\x65\xF0"
           "\xDD\x09\x56\x01\x71\xB6\x43\x64\x9A\x6E\x1F\xE3\x85\x7D\x2A\x27"
           "\xF7\x5A\xA3\xDB\x73\xA2\x99\xD6\x85\xAF\x86\x91\x7F\x19\xF5\x65"
           "\x7C\xA9\x71\xC1\x72\x38\x03\x8B\xDD\x83\x62\x79\x60\xB2\xB3\xE2"
           "\x7E\x41\x0D\x36\x50\x7C\xFA\xB0\x6E\xAE\x9E\x05\x5A\x55\xF8\x9C"
           "\x69\x71\x90\x77\x4C\xA3\x95\x29\x7D\xC1\x79\xFE\x7C\xD7\x96\x84"
           "\x0D\xC6\x30\x3F\x14\xDA\x88\xCF\x4A\xED\x5A\x7A\x71\x91\x5D\x25"
           "\x93\xDA\x0C\xB6\xCC\xB6\xD8\xE7\xF0\x54\x55\xA3\x93\xBD\xC0\xE7"
           "\x3E\xF8\x26\xFC\x5B\x37\xA5\x91\x01\x4B\xA2\x58\xBB\x59\xC2\x1E"
           "\xC8\x32\x3B\x85\x16\x8E\xF3\x02\x01\x03"
           , 186);
    nPKLen = 186;
    memset(bData, 0x42, 176);
    bData[0] = 0x30;
    bData[175] = 0x39;
    nDataLen = 176;
    memcpy(bSign,
           "\x51\x30\xCA\xB0\xA3\x27\x24\x42\x08\x78\x84\x2F\xA2\xA1\x62\x82"
           "\xB8\x33\x74\xA9\xAB\x92\xB5\xA5\xDA\x95\x2A\xD0\x58\x0C\xF2\x18"
           "\xEE\xB8\x18\x2A\x38\xFE\xD6\xF5\x93\xA0\x20\xD7\xB6\xC7\x62\x1B"
           "\x68\x6A\x75\x59\x79\x85\x92\x6B\xB2\xE0\x4D\xA4\x8F\x15\x41\x2C"
           "\x8F\x6C\x9D\x2C\xCA\x0F\x4B\xFC\xF3\x77\xC8\x62\x2F\x9A\x6C\xD5"
           "\x73\x5E\x42\x77\xFF\x7F\x6B\xF1\x32\x1A\x0A\x93\xE6\x18\xB0\xD7"
           "\x01\x3D\xDC\x02\x76\xEF\x98\xDC\xD4\x44\x54\x95\xA2\xD2\xDD\x73"
           "\xBC\x28\xCE\xEA\x7D\xC1\x68\xDA\x21\xD5\xC0\x27\x6C\x26\xEE\x27"
           "\xB9\xE3\x4B\x18\x83\xE7\xB5\xA8\x5E\x34\xD7\x1F\xF6\x0A\xCE\xB6"
           "\xDF\xEA\x5D\x32\xF1\x0D\x71\xB6\x96\x06\x06\x87\xBD\xFF\x15\x17"
           "\xE9\x73\x8B\x7D\x1F\x9F\x7B\x76\xC8\xA5\x74\x07\x5B\xBE\x2C\xDC"
           , 176);
    nSignLen = 176;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 186);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 176);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1408，SHA-384，PKCS#1填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_24(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 5;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\xB7\x02\x81\xB1\x00\x9C\xDB\xEA\x10\x4A\xEE\x30\xD8\x58"
           "\xE1\xC7\x10\x81\xC8\x32\x40\x80\x1C\x94\x1E\xF6\xE9\x05\xC8\x0E"
           "\x41\x94\xE8\x88\x59\x72\xA8\x21\x22\x0C\x7B\x5F\x52\x8D\x65\xF0"
           "\xDD\x09\x56\x01\x71\xB6\x43\x64\x9A\x6E\x1F\xE3\x85\x7D\x2A\x27"
           "\xF7\x5A\xA3\xDB\x73\xA2\x99\xD6\x85\xAF\x86\x91\x7F\x19\xF5\x65"
           "\x7C\xA9\x71\xC1\x72\x38\x03\x8B\xDD\x83\x62\x79\x60\xB2\xB3\xE2"
           "\x7E\x41\x0D\x36\x50\x7C\xFA\xB0\x6E\xAE\x9E\x05\x5A\x55\xF8\x9C"
           "\x69\x71\x90\x77\x4C\xA3\x95\x29\x7D\xC1\x79\xFE\x7C\xD7\x96\x84"
           "\x0D\xC6\x30\x3F\x14\xDA\x88\xCF\x4A\xED\x5A\x7A\x71\x91\x5D\x25"
           "\x93\xDA\x0C\xB6\xCC\xB6\xD8\xE7\xF0\x54\x55\xA3\x93\xBD\xC0\xE7"
           "\x3E\xF8\x26\xFC\x5B\x37\xA5\x91\x01\x4B\xA2\x58\xBB\x59\xC2\x1E"
           "\xC8\x32\x3B\x85\x16\x8E\xF3\x02\x01\x03"
           , 186);
    nPKLen = 186;
    memset(bData, 0x42, 2048);
    bData[0] = 0x30;
    bData[2047] = 0x39;
    nDataLen = 2048;
    memcpy(bSign,
           "\x54\x03\xBF\xCD\x44\xBB\x12\x57\x41\x78\x8B\xAA\xDC\xE1\x49\x15"
           "\x08\xFE\xBD\xF4\x98\xBE\x3E\x74\xA7\xD5\x0D\x21\x36\xEC\x42\xD4"
           "\x10\x68\x1D\x66\xDC\xD3\xF9\xF5\x5B\x73\x01\xA5\xA7\x22\xF2\xBF"
           "\x10\x60\x86\xE9\xC9\x20\xED\x03\x23\x99\x6B\x9D\x87\xD7\x7C\xE4"
           "\x21\x2C\x8B\xCC\xB4\xB1\xE7\x84\x71\x54\xDE\x62\xAD\x95\xD5\x56"
           "\xCB\x88\x8E\x5F\xB5\xEC\x10\x93\xBF\xF2\x5D\xD8\xE1\x2E\x38\x7C"
           "\xA8\x12\xE0\xF8\xEC\x5E\x34\x68\xBD\x2A\xA5\xF8\xD6\x76\x8A\x31"
           "\x59\x5B\xCB\x9E\x2B\x50\x10\xD3\x58\x06\x90\xD8\xE6\x55\x02\x12"
           "\x7C\xC3\x85\x9F\x2C\x60\xC3\xB9\x12\x6C\x62\xFF\x5D\x09\x79\x5B"
           "\x8B\xF4\x1C\xC3\x21\x31\x04\x3E\x69\xA6\x93\xF7\xD6\xFA\xE8\x94"
           "\x24\x8D\xE3\x62\x0B\xB4\xE2\x1C\x02\xE3\x1D\xEF\x01\x15\x2B\x34"
           , 176);
    nSignLen = 176;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 186);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 2048);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1408，SHA-512，PKCS#1填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_25(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 0;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\xFF\x02\x81\xF9\x00\xBE\xF9\x74\x44\x9A\xC3\x01\x48\x0B"
           "\x0A\xCD\xE1\xE5\x52\xE7\x55\x60\x91\x64\x8A\x46\x34\xEA\x1D\xDA"
           "\xEE\x52\x7B\x13\x92\x5F\x27\xAE\xA2\x66\xB5\xA5\xBB\x79\x4B\x09"
           "\x81\x7E\x7D\x95\x29\x16\xC5\xEF\xE0\x42\xF7\x7D\x5E\xE1\x72\x88"
           "\x0C\x1F\xDC\x76\x48\xA5\xB0\x26\x41\x8D\x4F\x70\x41\xB2\xAA\x70"
           "\x84\xC0\xAB\xFA\x95\xE9\x07\x6F\x73\x89\xE9\xD5\xAC\xD3\xBF\x72"
           "\x31\xA3\x30\x1E\xCA\x13\xDB\x1F\x1F\x44\xD1\x08\xD2\xFB\xF2\xB1"
           "\x6C\xF4\xBA\xAB\xF3\xBA\x36\x18\x25\x39\xD6\x0E\x3B\x4E\xBA\x93"
           "\xB2\xB4\xFA\x40\x7D\xCA\xE3\x96\x64\x05\x24\x79\x57\x95\xC6\x9D"
           "\xC7\x48\xB7\xFF\x55\x42\x07\x8A\x48\x84\x99\x61\x29\x52\x73\x0D"
           "\x8A\x97\x42\x6E\x67\x7C\x0A\xB3\x8B\xA9\x7C\x9C\x21\x67\x27\xD8"
           "\xB9\xDD\x14\x2C\x10\x65\xB8\x6F\x78\xBB\x64\x8A\x24\xAA\x78\x45"
           "\x7A\xB3\x54\xE6\xDF\x62\xE8\x71\xE3\x3C\x0C\x74\xD1\xFF\x02\x93"
           "\xDC\xB0\x01\x26\xEC\xAE\xCD\x4A\x3D\x22\xF7\x74\x42\xA6\xA0\xF2"
           "\xA1\x22\x72\x1E\x9C\x0F\x8C\xAF\xA2\x51\x2A\x23\xFF\x22\x49\xDD"
           "\x6C\x20\x4A\xEE\x7A\xCE\x81\xFB\xD1\x94\xAA\xF6\x5B\xC0\xDB\x02"
           "\x01\x03"
           , 258);
    nPKLen = 258;
    memset(bData, 0x42, 1);
    nDataLen = 1;
    memcpy(bSign,
           "\x94\xBA\x66\x55\xD9\x53\x75\x7F\x92\x02\xF9\xFE\xFE\xA3\x5C\x23"
           "\xCA\xD6\x81\x73\x01\x51\xA5\x4E\xE6\xB2\x59\xC5\x8D\x7C\xB9\xD7"
           "\xA3\x85\xA9\xA1\xAB\x1B\x48\xDA\x3B\xF0\x7D\x8B\xF3\x02\x1C\xF1"
           "\x1C\x89\x0A\x35\x59\xFC\x25\x3F\x85\x41\x94\x90\x0A\xE9\x59\x44"
           "\x53\x0E\x1F\x6F\xCD\x60\x16\xE0\xC0\x99\xDB\x5D\x1F\x50\xBF\x2A"
           "\x8A\xC1\xF1\x49\xAD\x93\x40\x9A\xE6\x7E\xA9\x8E\x86\x4E\xC2\x20"
           "\xAB\x07\xC6\x41\xC2\x2F\x5B\x44\xA3\x14\xA0\x9A\x42\x65\x45\x99"
           "\x56\xDF\x2C\x67\x75\x1A\x3F\x6B\x96\x0C\x9B\x13\x5F\x83\xD0\x82"
           "\xAB\x7D\x83\x25\xFC\x6E\x26\xE9\x88\x6C\xF4\x27\x9E\x28\xCC\xBE"
           "\xAC\x7A\xF3\x46\x73\x23\x2A\xEC\xEA\x3B\x04\x9A\xA5\x8C\x98\x1E"
           "\xCE\x5B\xC6\x3D\xEE\xB7\x13\x3C\x0A\x9D\xEC\x28\x17\x5A\xFE\x4B"
           "\x09\x12\xE4\x82\x1B\x3E\x53\x89\xDB\xBE\x9A\xE9\x33\x65\x5E\x24"
           "\x52\xE7\x36\x61\xDE\x0A\x07\x47\x4D\x87\xEB\xB5\x09\xB0\x07\x35"
           "\xF7\x91\xB7\x59\xF9\x27\x71\x55\x42\x16\x50\x80\x4C\x14\x92\x4F"
           "\xA4\xC4\x90\x49\xD0\x96\x3C\xB6\xBC\xF2\x2A\xBC\xE8\x2D\x39\x5F"
           "\xFF\xD1\x79\x57\x3A\xAC\x25\x9A"
           , 248);
    nSignLen = 248;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 258);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 1);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1984，MD5，PKCS#1填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_26(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 1;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\xFF\x02\x81\xF9\x00\xBE\xF9\x74\x44\x9A\xC3\x01\x48\x0B"
           "\x0A\xCD\xE1\xE5\x52\xE7\x55\x60\x91\x64\x8A\x46\x34\xEA\x1D\xDA"
           "\xEE\x52\x7B\x13\x92\x5F\x27\xAE\xA2\x66\xB5\xA5\xBB\x79\x4B\x09"
           "\x81\x7E\x7D\x95\x29\x16\xC5\xEF\xE0\x42\xF7\x7D\x5E\xE1\x72\x88"
           "\x0C\x1F\xDC\x76\x48\xA5\xB0\x26\x41\x8D\x4F\x70\x41\xB2\xAA\x70"
           "\x84\xC0\xAB\xFA\x95\xE9\x07\x6F\x73\x89\xE9\xD5\xAC\xD3\xBF\x72"
           "\x31\xA3\x30\x1E\xCA\x13\xDB\x1F\x1F\x44\xD1\x08\xD2\xFB\xF2\xB1"
           "\x6C\xF4\xBA\xAB\xF3\xBA\x36\x18\x25\x39\xD6\x0E\x3B\x4E\xBA\x93"
           "\xB2\xB4\xFA\x40\x7D\xCA\xE3\x96\x64\x05\x24\x79\x57\x95\xC6\x9D"
           "\xC7\x48\xB7\xFF\x55\x42\x07\x8A\x48\x84\x99\x61\x29\x52\x73\x0D"
           "\x8A\x97\x42\x6E\x67\x7C\x0A\xB3\x8B\xA9\x7C\x9C\x21\x67\x27\xD8"
           "\xB9\xDD\x14\x2C\x10\x65\xB8\x6F\x78\xBB\x64\x8A\x24\xAA\x78\x45"
           "\x7A\xB3\x54\xE6\xDF\x62\xE8\x71\xE3\x3C\x0C\x74\xD1\xFF\x02\x93"
           "\xDC\xB0\x01\x26\xEC\xAE\xCD\x4A\x3D\x22\xF7\x74\x42\xA6\xA0\xF2"
           "\xA1\x22\x72\x1E\x9C\x0F\x8C\xAF\xA2\x51\x2A\x23\xFF\x22\x49\xDD"
           "\x6C\x20\x4A\xEE\x7A\xCE\x81\xFB\xD1\x94\xAA\xF6\x5B\xC0\xDB\x02"
           "\x01\x03"
           , 258);
    nPKLen = 258;
    memset(bData, 0x42, 248);
    bData[0] = 0x30;
    bData[247] = 0x39;
    nDataLen = 248;
    memcpy(bSign,
           "\x63\x26\xC7\xF0\x7A\xAF\x63\x7A\x05\x17\xDF\x76\x8A\x63\x8A\x2D"
           "\xAD\xCA\xA0\x41\x37\x61\xBA\xE7\xD4\x03\xD4\x42\x46\xAC\x59\xC2"
           "\x2D\x11\x6E\x81\x6A\x63\xFC\xA7\x58\x23\xD0\x04\x47\xF3\x01\xBC"
           "\xA2\x06\x70\x1F\xE1\x4A\xFF\xDC\x98\x3A\xB7\x98\x1A\x68\x2D\x8E"
           "\xF6\x7E\x18\xB4\xCF\x8E\x65\xB0\x5C\x1B\x38\xB3\xAA\xBF\xC5\xEA"
           "\x77\x7C\xFA\x5B\xAA\x78\xAE\x8C\x6E\x92\x27\x1C\x37\x43\x3F\x3A"
           "\x95\xEE\xD7\x70\xBF\x93\x6B\xCB\x7D\x27\x2A\xFC\x1F\x33\xF9\x3F"
           "\x0E\xD0\xBE\x19\x10\x1A\x3B\x0F\x63\xB6\xD6\xDE\x8B\x56\x5C\xE6"
           "\xD6\xCE\x1A\x3A\x13\x91\x80\x21\x09\xA8\x8B\x18\x2F\xE3\xFD\xBC"
           "\x97\x25\x0F\xA0\xCB\x73\x7D\xE0\x55\x98\x5C\x00\x29\x5C\x18\xE8"
           "\xCB\xEE\x4D\x1B\xD9\x2E\x96\xD0\x32\x8F\x68\xB9\x95\xBF\xBD\xF0"
           "\x87\xC6\x27\x6B\x38\x6E\x2B\xF6\xFD\xE3\x74\xF6\xD5\x40\x9A\x05"
           "\x17\x79\xE1\x0A\x08\xB1\x22\x47\xDB\x5C\x6F\x36\x81\xE8\xC8\x1D"
           "\x71\xCD\xCD\x78\x5E\x42\x48\x16\xAA\xA0\xB7\x1B\x44\x25\xD8\x43"
           "\x9C\xCA\x97\xAE\xE3\x9D\x72\xAC\x71\xF2\x55\x88\xC9\xF8\x2A\xC6"
           "\x61\x69\xEE\x99\x2F\xD9\x07\xCF"
           , 248);
    nSignLen = 248;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 258);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 248);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1984，SHA-1，PKCS#1填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_27(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 2;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\xFF\x02\x81\xF9\x00\xBE\xF9\x74\x44\x9A\xC3\x01\x48\x0B"
           "\x0A\xCD\xE1\xE5\x52\xE7\x55\x60\x91\x64\x8A\x46\x34\xEA\x1D\xDA"
           "\xEE\x52\x7B\x13\x92\x5F\x27\xAE\xA2\x66\xB5\xA5\xBB\x79\x4B\x09"
           "\x81\x7E\x7D\x95\x29\x16\xC5\xEF\xE0\x42\xF7\x7D\x5E\xE1\x72\x88"
           "\x0C\x1F\xDC\x76\x48\xA5\xB0\x26\x41\x8D\x4F\x70\x41\xB2\xAA\x70"
           "\x84\xC0\xAB\xFA\x95\xE9\x07\x6F\x73\x89\xE9\xD5\xAC\xD3\xBF\x72"
           "\x31\xA3\x30\x1E\xCA\x13\xDB\x1F\x1F\x44\xD1\x08\xD2\xFB\xF2\xB1"
           "\x6C\xF4\xBA\xAB\xF3\xBA\x36\x18\x25\x39\xD6\x0E\x3B\x4E\xBA\x93"
           "\xB2\xB4\xFA\x40\x7D\xCA\xE3\x96\x64\x05\x24\x79\x57\x95\xC6\x9D"
           "\xC7\x48\xB7\xFF\x55\x42\x07\x8A\x48\x84\x99\x61\x29\x52\x73\x0D"
           "\x8A\x97\x42\x6E\x67\x7C\x0A\xB3\x8B\xA9\x7C\x9C\x21\x67\x27\xD8"
           "\xB9\xDD\x14\x2C\x10\x65\xB8\x6F\x78\xBB\x64\x8A\x24\xAA\x78\x45"
           "\x7A\xB3\x54\xE6\xDF\x62\xE8\x71\xE3\x3C\x0C\x74\xD1\xFF\x02\x93"
           "\xDC\xB0\x01\x26\xEC\xAE\xCD\x4A\x3D\x22\xF7\x74\x42\xA6\xA0\xF2"
           "\xA1\x22\x72\x1E\x9C\x0F\x8C\xAF\xA2\x51\x2A\x23\xFF\x22\x49\xDD"
           "\x6C\x20\x4A\xEE\x7A\xCE\x81\xFB\xD1\x94\xAA\xF6\x5B\xC0\xDB\x02"
           "\x01\x03"
           , 258);
    nPKLen = 258;
    memset(bData, 0x42, 248);
    bData[0] = 0x30;
    bData[247] = 0x39;
    nDataLen = 248;
    memcpy(bSign,
           "\x86\x38\x02\xC3\xBB\x6D\xAC\x57\x7A\xB8\x30\x7E\x98\x59\xB8\xDB"
           "\x9E\xE6\x14\x00\x56\xC4\x58\xC6\x12\x39\xC5\x96\xFE\x71\x4B\x8B"
           "\xE6\xCE\x32\x16\x50\xCA\x56\x01\xA6\xE5\xFF\xCF\x04\x8E\x41\xEC"
           "\x73\x64\x19\x89\x89\x47\x38\x14\x1B\x4C\x48\x4A\x1E\x56\x3F\xD0"
           "\x8C\xA3\xBF\xC0\xFD\x22\xDD\x18\x8A\x9C\xB4\xDF\x38\x9B\x79\xD7"
           "\xE5\x14\xFF\x04\x7E\x1F\x78\x92\x5F\xF1\x16\x5B\x0C\x6F\x0A\x9B"
           "\x8F\x0D\xE2\xE2\xEB\xC9\xC1\x70\x88\x16\x70\x47\xA9\x69\x1F\x6D"
           "\x3E\xBE\xB8\xFD\x73\x63\xCF\x86\x56\x7E\x33\xC5\x9D\xBF\x2A\xAE"
           "\x2D\x37\xBB\x09\x71\x37\x6D\x7E\x59\x7B\x9D\x89\x66\x7A\x58\x8C"
           "\xD3\xB6\x20\xAA\x8A\x9C\xD2\x00\xC1\xA2\x6D\x2E\x3C\xCF\xC6\xDD"
           "\x42\xCA\xCB\x6E\x51\x3D\x3F\x9D\xBC\x24\x37\xE8\x76\xBB\x8E\xEF"
           "\x38\x81\x91\x20\x39\xFC\x86\xDE\x3C\xE4\x06\x30\xF1\x3A\x4A\xD2"
           "\xD5\x59\x9A\x03\x55\xE0\xE0\x72\x8C\xFC\x9C\x22\xF0\x9D\x64\x76"
           "\x88\x03\xFB\x27\x0E\x8D\x72\x80\x7A\x73\x88\x61\x67\xB4\x52\x32"
           "\xC7\xF1\xE1\x76\xA1\x5A\xAA\x5D\x86\x24\x3B\x6C\x2B\xAD\xB2\xCD"
           "\x85\xA1\x05\x99\xC1\x48\x53\xA5"
           , 248);
    nSignLen = 248;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 258);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 248);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1984，SHA-224，PKCS#1填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_28(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 3;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\xFF\x02\x81\xF9\x00\xBE\xF9\x74\x44\x9A\xC3\x01\x48\x0B"
           "\x0A\xCD\xE1\xE5\x52\xE7\x55\x60\x91\x64\x8A\x46\x34\xEA\x1D\xDA"
           "\xEE\x52\x7B\x13\x92\x5F\x27\xAE\xA2\x66\xB5\xA5\xBB\x79\x4B\x09"
           "\x81\x7E\x7D\x95\x29\x16\xC5\xEF\xE0\x42\xF7\x7D\x5E\xE1\x72\x88"
           "\x0C\x1F\xDC\x76\x48\xA5\xB0\x26\x41\x8D\x4F\x70\x41\xB2\xAA\x70"
           "\x84\xC0\xAB\xFA\x95\xE9\x07\x6F\x73\x89\xE9\xD5\xAC\xD3\xBF\x72"
           "\x31\xA3\x30\x1E\xCA\x13\xDB\x1F\x1F\x44\xD1\x08\xD2\xFB\xF2\xB1"
           "\x6C\xF4\xBA\xAB\xF3\xBA\x36\x18\x25\x39\xD6\x0E\x3B\x4E\xBA\x93"
           "\xB2\xB4\xFA\x40\x7D\xCA\xE3\x96\x64\x05\x24\x79\x57\x95\xC6\x9D"
           "\xC7\x48\xB7\xFF\x55\x42\x07\x8A\x48\x84\x99\x61\x29\x52\x73\x0D"
           "\x8A\x97\x42\x6E\x67\x7C\x0A\xB3\x8B\xA9\x7C\x9C\x21\x67\x27\xD8"
           "\xB9\xDD\x14\x2C\x10\x65\xB8\x6F\x78\xBB\x64\x8A\x24\xAA\x78\x45"
           "\x7A\xB3\x54\xE6\xDF\x62\xE8\x71\xE3\x3C\x0C\x74\xD1\xFF\x02\x93"
           "\xDC\xB0\x01\x26\xEC\xAE\xCD\x4A\x3D\x22\xF7\x74\x42\xA6\xA0\xF2"
           "\xA1\x22\x72\x1E\x9C\x0F\x8C\xAF\xA2\x51\x2A\x23\xFF\x22\x49\xDD"
           "\x6C\x20\x4A\xEE\x7A\xCE\x81\xFB\xD1\x94\xAA\xF6\x5B\xC0\xDB\x02"
           "\x01\x03"
           , 258);
    nPKLen = 258;
    memset(bData, 0x42, 248);
    bData[0] = 0x30;
    bData[247] = 0x39;
    nDataLen = 248;
    memcpy(bSign,
           "\x70\x9F\x1E\x8F\xEE\xB6\x22\x89\x2B\x47\x20\x3F\xF2\x98\xE1\x9B"
           "\xA3\x67\x20\xF1\x52\xE5\x5E\x60\xC1\x70\x28\x72\x1F\x26\x01\xFA"
           "\x31\x52\x99\x21\x98\xD9\x6A\xA3\x1D\xC0\xBE\xBC\x58\x06\x4A\x67"
           "\x5B\x97\x4E\xDA\xF6\xA9\xD1\x89\x5E\xC2\x54\x84\xCC\x47\xF8\xD1"
           "\x26\x06\xDE\x3D\x7E\x3F\x4C\x39\xFC\xCB\x4B\x9C\x86\x3D\x3D\xDE"
           "\xF4\x15\x9B\x1A\x28\xA5\x9F\xDC\xAF\x84\x4E\x83\x2E\x69\x93\x25"
           "\xF3\xC7\x47\x01\xFF\xC7\xC9\x6A\x5F\xE6\x95\x50\xA9\x6F\x2A\x86"
           "\x7B\xA5\x28\x95\x26\x6F\xDC\x96\x38\x16\xFE\x6C\x14\x33\x75\xA3"
           "\xFD\xAE\x5E\xD2\x99\x9F\x04\x67\x80\xD5\xD0\x04\xA9\xD3\xC4\x60"
           "\xE4\xB5\x78\x7E\xDB\xF5\x11\x74\x1F\x13\x74\x3D\xA1\xB6\xB7\x71"
           "\xF5\xB5\x8B\x6B\xE3\x44\x4A\x3C\x01\xF8\xBC\x6A\x9E\xBA\x28\x16"
           "\x6D\x32\xA3\xE4\xD4\x84\x03\xAF\x47\xD9\xD3\x53\x6D\x6D\xBD\x75"
           "\x9B\xBA\xCB\xCF\xB4\x07\x22\x2E\xF1\x9F\x94\x46\xDD\x4C\x38\x92"
           "\x7D\x48\x7B\xB9\xA8\xD7\xE4\xD3\xAD\x1F\x53\x06\x5E\x0D\x02\xC4"
           "\x06\xF9\xAD\x4B\x0B\x4B\x83\x7B\x94\x47\x6E\x39\x72\x77\xA1\xE7"
           "\xC7\xB6\x3A\xE2\x17\x48\xA3\x17"
           , 248);
    nSignLen = 248;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 258);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 248);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1984，SHA-256，PKCS#1填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_29(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 4;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\xFF\x02\x81\xF9\x00\xBE\xF9\x74\x44\x9A\xC3\x01\x48\x0B"
           "\x0A\xCD\xE1\xE5\x52\xE7\x55\x60\x91\x64\x8A\x46\x34\xEA\x1D\xDA"
           "\xEE\x52\x7B\x13\x92\x5F\x27\xAE\xA2\x66\xB5\xA5\xBB\x79\x4B\x09"
           "\x81\x7E\x7D\x95\x29\x16\xC5\xEF\xE0\x42\xF7\x7D\x5E\xE1\x72\x88"
           "\x0C\x1F\xDC\x76\x48\xA5\xB0\x26\x41\x8D\x4F\x70\x41\xB2\xAA\x70"
           "\x84\xC0\xAB\xFA\x95\xE9\x07\x6F\x73\x89\xE9\xD5\xAC\xD3\xBF\x72"
           "\x31\xA3\x30\x1E\xCA\x13\xDB\x1F\x1F\x44\xD1\x08\xD2\xFB\xF2\xB1"
           "\x6C\xF4\xBA\xAB\xF3\xBA\x36\x18\x25\x39\xD6\x0E\x3B\x4E\xBA\x93"
           "\xB2\xB4\xFA\x40\x7D\xCA\xE3\x96\x64\x05\x24\x79\x57\x95\xC6\x9D"
           "\xC7\x48\xB7\xFF\x55\x42\x07\x8A\x48\x84\x99\x61\x29\x52\x73\x0D"
           "\x8A\x97\x42\x6E\x67\x7C\x0A\xB3\x8B\xA9\x7C\x9C\x21\x67\x27\xD8"
           "\xB9\xDD\x14\x2C\x10\x65\xB8\x6F\x78\xBB\x64\x8A\x24\xAA\x78\x45"
           "\x7A\xB3\x54\xE6\xDF\x62\xE8\x71\xE3\x3C\x0C\x74\xD1\xFF\x02\x93"
           "\xDC\xB0\x01\x26\xEC\xAE\xCD\x4A\x3D\x22\xF7\x74\x42\xA6\xA0\xF2"
           "\xA1\x22\x72\x1E\x9C\x0F\x8C\xAF\xA2\x51\x2A\x23\xFF\x22\x49\xDD"
           "\x6C\x20\x4A\xEE\x7A\xCE\x81\xFB\xD1\x94\xAA\xF6\x5B\xC0\xDB\x02"
           "\x01\x03"
           , 258);
    nPKLen = 258;
    memset(bData, 0x42, 248);
    bData[0] = 0x30;
    bData[247] = 0x39;
    nDataLen = 248;
    memcpy(bSign,
           "\x80\xFE\x00\xE3\x54\xE5\x69\x4C\x78\x46\x12\xF4\xBD\x75\xE4\x9D"
           "\xB2\x6A\xC2\xEA\xA5\xEE\xBF\x9D\xDA\x04\x96\x66\x6A\x1C\xC9\xA0"
           "\xDB\x01\x8D\x47\x2A\x74\x5B\x21\x49\x1A\xAC\xE3\xF6\x3F\xD2\x0A"
           "\x43\xF8\x98\xB9\xB3\x14\x57\x5F\x5B\x26\x81\x02\xB3\x14\x33\xCE"
           "\x3D\x9E\xF4\xF5\xA2\x5C\xC4\xC4\xFA\x79\x46\x25\xAE\x74\xE6\x84"
           "\xAC\x9B\xE8\xA7\x7C\x81\xA1\x87\x54\x1F\x0E\xA2\xC0\x88\x5F\x15"
           "\x72\x81\x41\x55\x26\x36\x7F\xDA\x74\xEB\x40\xB2\x3B\xEF\xA7\x1F"
           "\xB9\x60\xB7\x65\x64\xDA\xDE\x6E\xB6\xA2\xDB\x85\xCF\x20\xC5\x13"
           "\x23\x5F\x69\x99\x18\x5E\x4E\xA6\x20\x54\x80\xAD\xF9\xD0\x2C\x7C"
           "\xE6\x8B\x42\x85\xC3\xEE\x91\xD9\x2D\xC5\x0E\xF8\xE5\x5C\x0B\x23"
           "\xF0\xC3\x3F\xD4\x53\x2B\xD8\x78\x60\xEC\x42\xAD\x42\xB2\xCA\x68"
           "\xB7\xAC\x77\x1C\x22\xEF\xAC\x5B\xB8\xEE\xB6\x4A\x9F\x38\xBA\x79"
           "\x97\x89\xDF\x5C\x49\x2A\xA4\x09\xFC\x77\x80\xFF\x06\x45\xF4\xF1"
           "\x3D\x99\x8C\xB6\x3B\xE9\xE8\x62\x6E\x5C\xCF\x5E\x9E\xDA\xF5\xB8"
           "\x2C\x81\xBA\x20\x32\x44\x71\xC2\xF6\xD4\xFF\xCF\x63\x6C\x97\x03"
           "\xCB\xD9\xA8\x68\x81\xB0\xE4\xBE"
           , 248);
    nSignLen = 248;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 258);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 248);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1984，SHA-384，PKCS#1填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_30(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 5;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\xFF\x02\x81\xF9\x00\xBE\xF9\x74\x44\x9A\xC3\x01\x48\x0B"
           "\x0A\xCD\xE1\xE5\x52\xE7\x55\x60\x91\x64\x8A\x46\x34\xEA\x1D\xDA"
           "\xEE\x52\x7B\x13\x92\x5F\x27\xAE\xA2\x66\xB5\xA5\xBB\x79\x4B\x09"
           "\x81\x7E\x7D\x95\x29\x16\xC5\xEF\xE0\x42\xF7\x7D\x5E\xE1\x72\x88"
           "\x0C\x1F\xDC\x76\x48\xA5\xB0\x26\x41\x8D\x4F\x70\x41\xB2\xAA\x70"
           "\x84\xC0\xAB\xFA\x95\xE9\x07\x6F\x73\x89\xE9\xD5\xAC\xD3\xBF\x72"
           "\x31\xA3\x30\x1E\xCA\x13\xDB\x1F\x1F\x44\xD1\x08\xD2\xFB\xF2\xB1"
           "\x6C\xF4\xBA\xAB\xF3\xBA\x36\x18\x25\x39\xD6\x0E\x3B\x4E\xBA\x93"
           "\xB2\xB4\xFA\x40\x7D\xCA\xE3\x96\x64\x05\x24\x79\x57\x95\xC6\x9D"
           "\xC7\x48\xB7\xFF\x55\x42\x07\x8A\x48\x84\x99\x61\x29\x52\x73\x0D"
           "\x8A\x97\x42\x6E\x67\x7C\x0A\xB3\x8B\xA9\x7C\x9C\x21\x67\x27\xD8"
           "\xB9\xDD\x14\x2C\x10\x65\xB8\x6F\x78\xBB\x64\x8A\x24\xAA\x78\x45"
           "\x7A\xB3\x54\xE6\xDF\x62\xE8\x71\xE3\x3C\x0C\x74\xD1\xFF\x02\x93"
           "\xDC\xB0\x01\x26\xEC\xAE\xCD\x4A\x3D\x22\xF7\x74\x42\xA6\xA0\xF2"
           "\xA1\x22\x72\x1E\x9C\x0F\x8C\xAF\xA2\x51\x2A\x23\xFF\x22\x49\xDD"
           "\x6C\x20\x4A\xEE\x7A\xCE\x81\xFB\xD1\x94\xAA\xF6\x5B\xC0\xDB\x02"
           "\x01\x03"
           , 258);
    nPKLen = 258;
    memset(bData, 0x42, 2048);
    bData[0] = 0x30;
    bData[2047] = 0x39;
    nDataLen = 2048;
    memcpy(bSign,
           "\x4A\xAB\x83\x64\x9A\x96\x2D\x33\x9C\xC3\x2F\x3C\x61\x30\x8A\xDF"
           "\x7B\x85\x6A\x20\xD5\xD4\x73\x6E\x72\xDD\x60\x2A\x90\x12\xDA\xD5"
           "\x8A\xB4\x32\xD4\x12\x69\x85\xBF\x39\x69\x42\x55\x64\x41\x33\x31"
           "\x79\x7D\x23\x4D\x1C\x0F\x0D\xA6\xF8\x1C\x12\x70\xE9\x99\xA8\x65"
           "\xE0\x92\xB5\x90\x6A\x0C\x0B\x90\xE1\x50\xEC\x2F\x73\xD1\xCB\x43"
           "\xAE\x23\x41\x55\xC6\x5D\x1B\xC3\xAD\x4E\x58\xC2\xC1\x8D\x02\x66"
           "\x5B\x39\x8A\x5C\xA6\xAB\x91\xB0\xE4\x3E\x15\x84\x08\x11\xE6\xF4"
           "\xD8\xDE\x62\xB2\x6A\x75\xAE\xA4\xC7\x45\x75\x82\x5E\x24\x68\xA7"
           "\x65\x77\x14\xC3\x60\x1C\x8A\x6C\x14\x0C\x41\x1C\xAB\xBA\xFA\x14"
           "\xC7\x67\x45\x84\x85\x67\x24\x6A\x82\x69\x26\x57\x37\xC0\x50\x15"
           "\x72\x62\xE0\x42\x1D\xDB\x6F\x85\x8E\x5E\x1B\x12\xC7\x94\x9E\x31"
           "\x48\xCD\x3E\x99\x28\x89\x57\x00\x82\x48\xF2\x72\x4D\x8D\x9B\x70"
           "\xB7\xC7\x39\xF6\xC4\x93\x9F\xC5\xA8\x77\x13\xE3\x1F\xCD\x52\xB3"
           "\x87\x88\x84\xA0\x28\xD2\x0E\x78\x5E\x92\x62\x34\x92\xBD\xBA\x34"
           "\xCB\xFC\x22\xF9\x42\xD7\x96\x9A\x62\x70\xDE\x0D\x48\xC1\xD8\x7F"
           "\x4E\xD2\x4E\x82\xF9\x47\xD3\x3F"
           , 248);
    nSignLen = 248;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 258);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 2048);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1984，SHA-512，PKCS#1填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_31(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 0;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x82\x01\x08\x02\x82\x01\x01\x00\xC9\xD5\xA7\x6F\x4E\x62\xAD"
           "\x7A\xD8\x19\x85\x19\xB4\xDC\xE8\x88\xBB\x00\x10\xFF\x54\xA8\xC9"
           "\x61\xB5\x44\x2E\x53\x7D\xA4\x98\x7F\x27\xD6\x8A\x3E\x64\x92\x73"
           "\x59\x49\xFA\x81\x61\x8E\xD6\x66\x3C\x7E\xC0\xB3\x5D\x4E\xBB\x11"
           "\x01\x5B\xEE\x25\x53\x92\x33\x75\xA0\x3F\xBD\x02\xAB\x69\xE8\x0E"
           "\xF8\xC1\x98\x76\xDA\x81\x32\x66\x16\xEF\x7A\x0D\x6E\x4D\xB1\x74"
           "\xC8\xE8\x93\xE8\x1F\x00\x29\x7F\x46\x3C\x7C\x37\x0C\x7B\xF0\x78"
           "\xBA\x7D\x5D\xF9\x88\x9A\x86\x1E\xB8\x13\x59\xAA\x55\x1E\x5C\xBD"
           "\x2B\x7C\x36\xD8\xE5\x49\x83\xB5\xCB\x14\x4B\x1F\xEA\x02\x93\x07"
           "\xF0\x40\x24\xCD\x51\x96\x71\x22\xF0\x4A\x68\x2C\xCD\xDE\xF5\x0F"
           "\xFC\x34\x4A\x64\xA3\x52\xA1\xBE\xEE\x2C\xE7\x5C\x1A\x95\x8E\xFC"
           "\xA4\xAB\x65\xEB\x96\xBE\x43\x0F\xBD\x78\xFE\x6A\xDF\x48\xB9\x68"
           "\x66\x69\x6C\x68\xCC\xA4\x35\xD3\x2B\xA4\x2C\xDD\xBD\xC3\x65\x7B"
           "\x5C\xD9\x56\x67\xB9\x2E\x40\xFE\xEF\x02\xEF\xBD\x91\xFC\x88\x61"
           "\xCA\x82\x3D\xCA\x59\x1F\xD7\x8E\xAC\xCF\x2E\xD5\xB2\x95\xB8\x73"
           "\x20\xC4\x0A\xD0\xA5\x87\xE4\xD0\x8F\x77\x1B\xDC\x05\xE1\x7A\x54"
           "\x7D\xB8\xA6\x8E\x1B\xA9\xF0\xF4\xED\x02\x01\x03"
           , 268);
    nPKLen = 268;
    memset(bData, 0x42, 1);
    nDataLen = 1;
    memcpy(bSign,
           "\x76\x23\x83\x2C\xDD\xC4\x9A\xC3\xD7\x08\xB9\x11\xA6\x89\x06\xF2"
           "\x0A\x0D\x5D\x2D\xC0\xBF\xCC\xE9\xC8\x42\xD0\x97\x45\x12\x10\x88"
           "\x50\x3D\x54\x64\x33\xC3\x4A\xE6\x18\xC4\xB0\xCB\x41\x79\xEF\x49"
           "\xD0\x59\x95\x8A\x25\xBA\x61\x78\x5D\xF7\x1E\xB0\x31\xED\xAF\x15"
           "\x77\xF8\xD6\x11\xD5\xC0\xC8\x88\x9A\xB5\x52\xAC\x1F\xEE\x45\x54"
           "\x35\x76\x2E\x81\xED\x1B\x61\xE6\x86\x39\xB5\x46\xBD\xD1\x73\x68"
           "\x19\xBC\xE4\x05\x79\xF0\xBF\xBC\xD9\xA0\xDE\x97\x3C\x7F\x88\x21"
           "\x82\xC5\xE6\xF4\x0D\x21\x6A\x39\xF2\xEA\x1A\x9F\x70\x72\xD8\xEE"
           "\xEA\xE0\xD3\x8C\xA6\x61\x18\xD7\x67\x07\xC1\xA5\x44\x94\x2E\x6A"
           "\x43\x64\xAD\x4F\x84\x00\xD7\x8E\x65\x6A\x73\x54\x4B\x75\x3B\xE7"
           "\x41\x87\x5F\x62\x77\x03\xF7\x2E\xA1\x70\xF7\xC5\xA4\xF4\xF1\x9D"
           "\x5C\x48\x79\x2A\x32\x10\xDE\xFA\xED\xEB\x5E\x2B\x46\x0C\x6A\xA2"
           "\xB3\x6E\x3E\x44\xCC\x11\xA1\xD2\x67\x98\x7F\xB2\xBA\xD4\x22\x62"
           "\xEC\xDB\xE7\x80\x0A\x35\x97\x49\xC9\x22\x20\x80\x12\x4F\x0F\x19"
           "\xF0\x29\xDA\x20\x71\xE4\xA9\x21\x87\x56\xF1\x97\x7F\xFE\x04\x95"
           "\xE0\xBD\xFF\x1D\xEC\x13\xA0\x41\x63\x0B\xC5\x78\x06\x20\x20\xDB"
           , 256);
    nSignLen = 256;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 268);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 1);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-2048，MD5，PKCS#1填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_32(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 1;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x82\x01\x08\x02\x82\x01\x01\x00\xC9\xD5\xA7\x6F\x4E\x62\xAD"
           "\x7A\xD8\x19\x85\x19\xB4\xDC\xE8\x88\xBB\x00\x10\xFF\x54\xA8\xC9"
           "\x61\xB5\x44\x2E\x53\x7D\xA4\x98\x7F\x27\xD6\x8A\x3E\x64\x92\x73"
           "\x59\x49\xFA\x81\x61\x8E\xD6\x66\x3C\x7E\xC0\xB3\x5D\x4E\xBB\x11"
           "\x01\x5B\xEE\x25\x53\x92\x33\x75\xA0\x3F\xBD\x02\xAB\x69\xE8\x0E"
           "\xF8\xC1\x98\x76\xDA\x81\x32\x66\x16\xEF\x7A\x0D\x6E\x4D\xB1\x74"
           "\xC8\xE8\x93\xE8\x1F\x00\x29\x7F\x46\x3C\x7C\x37\x0C\x7B\xF0\x78"
           "\xBA\x7D\x5D\xF9\x88\x9A\x86\x1E\xB8\x13\x59\xAA\x55\x1E\x5C\xBD"
           "\x2B\x7C\x36\xD8\xE5\x49\x83\xB5\xCB\x14\x4B\x1F\xEA\x02\x93\x07"
           "\xF0\x40\x24\xCD\x51\x96\x71\x22\xF0\x4A\x68\x2C\xCD\xDE\xF5\x0F"
           "\xFC\x34\x4A\x64\xA3\x52\xA1\xBE\xEE\x2C\xE7\x5C\x1A\x95\x8E\xFC"
           "\xA4\xAB\x65\xEB\x96\xBE\x43\x0F\xBD\x78\xFE\x6A\xDF\x48\xB9\x68"
           "\x66\x69\x6C\x68\xCC\xA4\x35\xD3\x2B\xA4\x2C\xDD\xBD\xC3\x65\x7B"
           "\x5C\xD9\x56\x67\xB9\x2E\x40\xFE\xEF\x02\xEF\xBD\x91\xFC\x88\x61"
           "\xCA\x82\x3D\xCA\x59\x1F\xD7\x8E\xAC\xCF\x2E\xD5\xB2\x95\xB8\x73"
           "\x20\xC4\x0A\xD0\xA5\x87\xE4\xD0\x8F\x77\x1B\xDC\x05\xE1\x7A\x54"
           "\x7D\xB8\xA6\x8E\x1B\xA9\xF0\xF4\xED\x02\x01\x03"
           , 268);
    nPKLen = 268;
    memset(bData, 0x42, 256);
    bData[0] = 0x30;
    bData[255] = 0x39;
    nDataLen = 256;
    memcpy(bSign,
           "\x37\xEF\xBD\xE4\x64\x3A\xA4\x33\xCE\x26\x5C\xE9\x37\x3C\xAC\x52"
           "\x7F\x20\x63\xE0\x10\xCA\x96\xBB\x41\xA9\xA1\x47\xF6\xBA\xB5\x6D"
           "\x93\x06\x41\x33\x16\xE7\xF8\xBD\x13\xBD\x83\x32\x4F\x22\x46\x75"
           "\xB3\x20\x13\x92\x74\x3C\x20\xB1\x44\xBF\x0E\xE1\xDE\x1C\x0C\xF3"
           "\xD5\x2B\x7C\x5E\xC6\x10\xCA\x2D\x51\xA1\x4B\x6B\xA3\x67\xED\x24"
           "\x9F\xE2\xD0\x49\x41\x73\xA9\x0C\x35\xF2\xE7\xB2\x70\xF0\x26\x4D"
           "\xEE\x96\x55\x0F\x2F\x2F\x63\x1E\x92\x05\xE1\xFA\x33\xC2\x23\xF8"
           "\x13\xC4\x2B\xE0\x0F\x18\xB0\x59\x53\xBB\x96\xBE\x61\x28\x13\x63"
           "\x1A\x8D\x5D\xB1\xF4\x9C\x87\x2D\xDE\x47\xAD\x79\xCB\xC2\x2F\x17"
           "\x19\x6A\xA7\x08\x1F\x01\xE6\x3C\x35\xBF\xA5\x7B\x85\x2B\x7D\x1E"
           "\x59\x0A\xD4\x30\x12\x5A\x1B\x41\xEA\x56\x01\x60\x4E\x89\xF2\xCE"
           "\x83\xB7\xD2\x50\xA6\x15\xC5\x54\xA7\xC2\x89\x8D\x3D\xB9\x4D\x69"
           "\x6B\x8A\xD0\xBF\xA2\xA5\x48\xD2\x42\x2A\x86\x33\x4B\xCD\x38\xAA"
           "\xC9\xA3\xBF\x4E\x92\x76\x4A\xFE\xA1\x7A\x55\x00\x4A\xCD\x73\xF9"
           "\xB7\xF7\x57\xCA\x19\xCA\xA0\x48\xF8\x1F\xC4\x30\xC3\x6D\xD9\x4A"
           "\x10\x87\x86\xB9\x18\xB2\xE3\x0C\x46\xC4\x70\xB6\x5C\xF4\x5D\x12"
           , 256);
    nSignLen = 256;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 268);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 256);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-2048，SHA-1，PKCS#1填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_33(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 2;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x82\x01\x08\x02\x82\x01\x01\x00\xC9\xD5\xA7\x6F\x4E\x62\xAD"
           "\x7A\xD8\x19\x85\x19\xB4\xDC\xE8\x88\xBB\x00\x10\xFF\x54\xA8\xC9"
           "\x61\xB5\x44\x2E\x53\x7D\xA4\x98\x7F\x27\xD6\x8A\x3E\x64\x92\x73"
           "\x59\x49\xFA\x81\x61\x8E\xD6\x66\x3C\x7E\xC0\xB3\x5D\x4E\xBB\x11"
           "\x01\x5B\xEE\x25\x53\x92\x33\x75\xA0\x3F\xBD\x02\xAB\x69\xE8\x0E"
           "\xF8\xC1\x98\x76\xDA\x81\x32\x66\x16\xEF\x7A\x0D\x6E\x4D\xB1\x74"
           "\xC8\xE8\x93\xE8\x1F\x00\x29\x7F\x46\x3C\x7C\x37\x0C\x7B\xF0\x78"
           "\xBA\x7D\x5D\xF9\x88\x9A\x86\x1E\xB8\x13\x59\xAA\x55\x1E\x5C\xBD"
           "\x2B\x7C\x36\xD8\xE5\x49\x83\xB5\xCB\x14\x4B\x1F\xEA\x02\x93\x07"
           "\xF0\x40\x24\xCD\x51\x96\x71\x22\xF0\x4A\x68\x2C\xCD\xDE\xF5\x0F"
           "\xFC\x34\x4A\x64\xA3\x52\xA1\xBE\xEE\x2C\xE7\x5C\x1A\x95\x8E\xFC"
           "\xA4\xAB\x65\xEB\x96\xBE\x43\x0F\xBD\x78\xFE\x6A\xDF\x48\xB9\x68"
           "\x66\x69\x6C\x68\xCC\xA4\x35\xD3\x2B\xA4\x2C\xDD\xBD\xC3\x65\x7B"
           "\x5C\xD9\x56\x67\xB9\x2E\x40\xFE\xEF\x02\xEF\xBD\x91\xFC\x88\x61"
           "\xCA\x82\x3D\xCA\x59\x1F\xD7\x8E\xAC\xCF\x2E\xD5\xB2\x95\xB8\x73"
           "\x20\xC4\x0A\xD0\xA5\x87\xE4\xD0\x8F\x77\x1B\xDC\x05\xE1\x7A\x54"
           "\x7D\xB8\xA6\x8E\x1B\xA9\xF0\xF4\xED\x02\x01\x03"
           , 268);
    nPKLen = 268;
    memset(bData, 0x42, 256);
    bData[0] = 0x30;
    bData[255] = 0x39;
    nDataLen = 256;
    memcpy(bSign,
           "\x2F\x3C\x39\xEF\x79\x76\x3F\x86\x6B\x97\x76\x8A\x23\x9B\xBE\x9A"
           "\x4C\x7D\x44\xB6\x11\xDD\xC5\xF1\xD2\xBF\xBB\xF5\xF0\x46\x5D\xE3"
           "\xDF\x9A\x6A\x47\x75\x0D\x9D\x82\x7A\xB2\x02\x9D\x91\x6E\x17\x12"
           "\x2B\xA6\x42\xB6\xA6\x1E\x29\x4C\x71\xE8\xE5\xB3\xDE\x37\x42\x49"
           "\x03\x3F\x8F\x1F\xBF\xDB\x4E\x8A\x33\xCC\x7E\x58\x9C\xD7\x5B\xF3"
           "\xDB\x41\x9D\x0A\xFC\x93\xCB\x75\xE6\x17\xA9\xBA\x10\xBA\xDA\xBF"
           "\x2F\x79\xAF\x7F\x39\xA6\x75\x02\xAE\x07\x88\x96\x62\x72\x7B\xC4"
           "\x5B\x24\x57\xDB\x7B\x0D\x1C\x4D\x7F\xA9\x8B\xF5\x7F\x0A\x44\xE7"
           "\xDD\x02\x44\x9C\xB3\xA6\xB8\xFE\x0E\xCF\xCD\xFB\x63\xD1\xC4\xC5"
           "\x59\xAB\xFF\xCA\xC9\x1A\x53\x06\xE6\x39\x81\x84\xFA\xC6\xAB\xB8"
           "\x95\x93\x29\xCF\xEF\x81\x41\x0B\x12\x69\x4C\x58\x5B\x7A\x1D\x6D"
           "\xD9\x18\x1B\x3B\xEC\x7B\xCE\x36\x38\x4C\xEA\x7D\xDD\xC1\x4D\x88"
           "\x70\xF6\x20\xFF\x18\x8D\x8D\xC9\xD7\x3B\xE8\xBE\x80\x04\xD3\x3D"
           "\x24\x84\xF7\xD8\x16\x44\x87\xA6\x0E\x16\x1A\x9C\x1B\xD9\x16\x7F"
           "\x74\xF2\x66\x81\xAA\xD7\xA0\x4F\x00\x80\xD6\x58\x23\x23\x77\xF3"
           "\x44\x45\x1E\x92\x03\x29\x13\x37\x9B\xD3\x60\x88\xB7\x0A\x87\x7C"
           , 256);
    nSignLen = 256;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 268);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 256);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-2048，SHA-224，PKCS#1填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_34(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 3;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x82\x01\x08\x02\x82\x01\x01\x00\xC9\xD5\xA7\x6F\x4E\x62\xAD"
           "\x7A\xD8\x19\x85\x19\xB4\xDC\xE8\x88\xBB\x00\x10\xFF\x54\xA8\xC9"
           "\x61\xB5\x44\x2E\x53\x7D\xA4\x98\x7F\x27\xD6\x8A\x3E\x64\x92\x73"
           "\x59\x49\xFA\x81\x61\x8E\xD6\x66\x3C\x7E\xC0\xB3\x5D\x4E\xBB\x11"
           "\x01\x5B\xEE\x25\x53\x92\x33\x75\xA0\x3F\xBD\x02\xAB\x69\xE8\x0E"
           "\xF8\xC1\x98\x76\xDA\x81\x32\x66\x16\xEF\x7A\x0D\x6E\x4D\xB1\x74"
           "\xC8\xE8\x93\xE8\x1F\x00\x29\x7F\x46\x3C\x7C\x37\x0C\x7B\xF0\x78"
           "\xBA\x7D\x5D\xF9\x88\x9A\x86\x1E\xB8\x13\x59\xAA\x55\x1E\x5C\xBD"
           "\x2B\x7C\x36\xD8\xE5\x49\x83\xB5\xCB\x14\x4B\x1F\xEA\x02\x93\x07"
           "\xF0\x40\x24\xCD\x51\x96\x71\x22\xF0\x4A\x68\x2C\xCD\xDE\xF5\x0F"
           "\xFC\x34\x4A\x64\xA3\x52\xA1\xBE\xEE\x2C\xE7\x5C\x1A\x95\x8E\xFC"
           "\xA4\xAB\x65\xEB\x96\xBE\x43\x0F\xBD\x78\xFE\x6A\xDF\x48\xB9\x68"
           "\x66\x69\x6C\x68\xCC\xA4\x35\xD3\x2B\xA4\x2C\xDD\xBD\xC3\x65\x7B"
           "\x5C\xD9\x56\x67\xB9\x2E\x40\xFE\xEF\x02\xEF\xBD\x91\xFC\x88\x61"
           "\xCA\x82\x3D\xCA\x59\x1F\xD7\x8E\xAC\xCF\x2E\xD5\xB2\x95\xB8\x73"
           "\x20\xC4\x0A\xD0\xA5\x87\xE4\xD0\x8F\x77\x1B\xDC\x05\xE1\x7A\x54"
           "\x7D\xB8\xA6\x8E\x1B\xA9\xF0\xF4\xED\x02\x01\x03"
           , 268);
    nPKLen = 268;
    memset(bData, 0x42, 256);
    bData[0] = 0x30;
    bData[255] = 0x39;
    nDataLen = 256;
    memcpy(bSign,
           "\x75\xBE\x77\x32\x74\x86\x8F\xB2\x24\xE8\x69\x2D\x4D\x8D\xBF\xAC"
           "\x3B\x43\x71\x9B\xF0\x99\x80\xF9\x8E\x42\x5C\x87\x31\x86\x28\xD1"
           "\x92\x3A\xBF\xD0\xFC\x7F\x13\x7D\xDF\x7D\x0B\xD4\xA0\x24\xE1\x08"
           "\x91\x14\x70\xF1\xDF\x03\xDD\x99\xFC\xEB\xAF\x72\x19\xB3\x42\x6E"
           "\x56\x33\xFE\x8F\x31\xC0\xBF\x7C\x57\xCA\xFA\x2C\xD5\x8A\x70\xC5"
           "\x38\xED\xE9\x57\x7F\x75\x41\x5C\x76\x86\x77\x92\xF7\x07\xC2\x36"
           "\x7B\x33\xA2\x4A\xFD\xD4\x1F\xBC\x4F\x8B\x8D\x51\xDE\xCF\xDB\x2C"
           "\xE5\x65\x4D\x87\x90\x9C\xDD\x6E\x6A\xBA\xA0\x5D\x65\x85\x46\x43"
           "\x61\xF1\x90\x6D\x42\x03\xB0\x78\x4D\xF0\xAD\x5F\xA4\x89\x07\x51"
           "\x00\xCB\x46\xB9\x40\x7E\xEC\x67\xCE\x3E\x94\x9C\xF3\x2E\x47\x07"
           "\x8A\x82\xAB\xA4\xDD\xAC\xC3\xEE\xDB\xE5\x43\xE9\x7A\xE4\x7C\x0D"
           "\xDC\x3A\xA9\xBB\x89\x13\x75\x11\x3D\x16\x46\xFF\x1D\xDD\xC5\x51"
           "\x33\x6C\x76\xB3\x9C\x84\x9E\xE5\x5E\xFF\x67\x65\xEC\x31\xA5\xDA"
           "\x49\xE4\x09\xBE\x3D\xDF\x01\x33\x13\xB9\xB9\x24\x26\x6E\xA9\x25"
           "\xFA\xAE\xBC\x1D\x06\xF8\x33\xFC\x64\x7D\x07\x84\x06\xB0\xE4\xC2"
           "\x83\x17\x5B\xEB\xDA\xEE\x3E\x23\xF0\xB8\xC2\x5A\x44\x66\x35\x4A"
           , 256);
    nSignLen = 256;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 268);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 256);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-2048，SHA-256，PKCS#1填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_35(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 4;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x82\x01\x08\x02\x82\x01\x01\x00\xC9\xD5\xA7\x6F\x4E\x62\xAD"
           "\x7A\xD8\x19\x85\x19\xB4\xDC\xE8\x88\xBB\x00\x10\xFF\x54\xA8\xC9"
           "\x61\xB5\x44\x2E\x53\x7D\xA4\x98\x7F\x27\xD6\x8A\x3E\x64\x92\x73"
           "\x59\x49\xFA\x81\x61\x8E\xD6\x66\x3C\x7E\xC0\xB3\x5D\x4E\xBB\x11"
           "\x01\x5B\xEE\x25\x53\x92\x33\x75\xA0\x3F\xBD\x02\xAB\x69\xE8\x0E"
           "\xF8\xC1\x98\x76\xDA\x81\x32\x66\x16\xEF\x7A\x0D\x6E\x4D\xB1\x74"
           "\xC8\xE8\x93\xE8\x1F\x00\x29\x7F\x46\x3C\x7C\x37\x0C\x7B\xF0\x78"
           "\xBA\x7D\x5D\xF9\x88\x9A\x86\x1E\xB8\x13\x59\xAA\x55\x1E\x5C\xBD"
           "\x2B\x7C\x36\xD8\xE5\x49\x83\xB5\xCB\x14\x4B\x1F\xEA\x02\x93\x07"
           "\xF0\x40\x24\xCD\x51\x96\x71\x22\xF0\x4A\x68\x2C\xCD\xDE\xF5\x0F"
           "\xFC\x34\x4A\x64\xA3\x52\xA1\xBE\xEE\x2C\xE7\x5C\x1A\x95\x8E\xFC"
           "\xA4\xAB\x65\xEB\x96\xBE\x43\x0F\xBD\x78\xFE\x6A\xDF\x48\xB9\x68"
           "\x66\x69\x6C\x68\xCC\xA4\x35\xD3\x2B\xA4\x2C\xDD\xBD\xC3\x65\x7B"
           "\x5C\xD9\x56\x67\xB9\x2E\x40\xFE\xEF\x02\xEF\xBD\x91\xFC\x88\x61"
           "\xCA\x82\x3D\xCA\x59\x1F\xD7\x8E\xAC\xCF\x2E\xD5\xB2\x95\xB8\x73"
           "\x20\xC4\x0A\xD0\xA5\x87\xE4\xD0\x8F\x77\x1B\xDC\x05\xE1\x7A\x54"
           "\x7D\xB8\xA6\x8E\x1B\xA9\xF0\xF4\xED\x02\x01\x03"
           , 268);
    nPKLen = 268;
    memset(bData, 0x42, 256);
    bData[0] = 0x30;
    bData[255] = 0x39;
    nDataLen = 256;
    memcpy(bSign,
           "\x73\x05\xD6\x00\xCA\x6B\x42\xB4\x68\x70\xAE\x87\x47\xE7\xC0\xE8"
           "\xA3\xA1\x92\x6A\x5F\x90\x07\xE0\xDF\xC6\x6B\xF4\x26\xDA\xE2\x16"
           "\x46\x58\xA5\xB2\xB9\x4A\x53\x5B\xA5\x91\xB1\x34\x8B\xBF\x77\x01"
           "\xD4\x62\xA1\x94\x92\x17\x3B\x51\xF0\xB9\xFF\x32\xD8\x22\xAB\x74"
           "\xCF\x4B\x30\x3F\x37\xBA\x31\x5D\x5E\xEB\x9C\x12\x27\x20\x99\xAB"
           "\x5E\x0B\x2A\x8A\x35\x5D\xD6\x50\xEF\xFF\x6B\x6C\xAC\x6F\xA5\xA6"
           "\xE6\xFC\x73\x4E\x78\xD5\x8B\x97\x74\x62\x87\xCD\x70\xAB\x71\xA7"
           "\xB9\x1D\xD1\xA9\x82\x47\x99\x6F\x17\x47\xE4\xE1\x3D\xED\xBE\x3A"
           "\x1C\xF4\x42\x54\x3A\x69\x19\x14\x04\x30\xE3\xF3\xB1\x60\xAF\x77"
           "\x59\x35\x40\x92\x0E\x23\x0B\x8A\xE2\xC1\xF8\xC2\x46\xFF\xF1\xC7"
           "\x5A\x64\x65\x95\xE7\x54\xA8\x19\xC2\x37\x37\xE6\xC8\x24\x6F\x67"
           "\x13\x1A\xF9\xB9\x61\x97\xCB\x2D\xBD\x48\xED\x0B\x32\x00\xB7\xE9"
           "\xFB\x30\xE6\xED\xDB\xC4\xEF\xC2\xFC\x97\x47\x13\xC6\xFF\xB2\x47"
           "\xAE\xED\x90\x80\x9B\x9B\x8B\xD7\x43\xB8\xF8\x85\x93\x7C\x8A\x5F"
           "\xA8\x65\x00\x5B\x11\x0C\xFB\xAC\xE0\xF5\xC7\xF1\x95\x1B\x0F\xF3"
           "\x4D\x7B\x1A\x59\x5D\x09\x0C\x5F\xCF\xA6\xAC\xA9\x76\x3E\x9F\x37"
           , 256);
    nSignLen = 256;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 268);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 256);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-2048，SHA-384，PKCS#1填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_36(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 5;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x82\x01\x08\x02\x82\x01\x01\x00\xC9\xD5\xA7\x6F\x4E\x62\xAD"
           "\x7A\xD8\x19\x85\x19\xB4\xDC\xE8\x88\xBB\x00\x10\xFF\x54\xA8\xC9"
           "\x61\xB5\x44\x2E\x53\x7D\xA4\x98\x7F\x27\xD6\x8A\x3E\x64\x92\x73"
           "\x59\x49\xFA\x81\x61\x8E\xD6\x66\x3C\x7E\xC0\xB3\x5D\x4E\xBB\x11"
           "\x01\x5B\xEE\x25\x53\x92\x33\x75\xA0\x3F\xBD\x02\xAB\x69\xE8\x0E"
           "\xF8\xC1\x98\x76\xDA\x81\x32\x66\x16\xEF\x7A\x0D\x6E\x4D\xB1\x74"
           "\xC8\xE8\x93\xE8\x1F\x00\x29\x7F\x46\x3C\x7C\x37\x0C\x7B\xF0\x78"
           "\xBA\x7D\x5D\xF9\x88\x9A\x86\x1E\xB8\x13\x59\xAA\x55\x1E\x5C\xBD"
           "\x2B\x7C\x36\xD8\xE5\x49\x83\xB5\xCB\x14\x4B\x1F\xEA\x02\x93\x07"
           "\xF0\x40\x24\xCD\x51\x96\x71\x22\xF0\x4A\x68\x2C\xCD\xDE\xF5\x0F"
           "\xFC\x34\x4A\x64\xA3\x52\xA1\xBE\xEE\x2C\xE7\x5C\x1A\x95\x8E\xFC"
           "\xA4\xAB\x65\xEB\x96\xBE\x43\x0F\xBD\x78\xFE\x6A\xDF\x48\xB9\x68"
           "\x66\x69\x6C\x68\xCC\xA4\x35\xD3\x2B\xA4\x2C\xDD\xBD\xC3\x65\x7B"
           "\x5C\xD9\x56\x67\xB9\x2E\x40\xFE\xEF\x02\xEF\xBD\x91\xFC\x88\x61"
           "\xCA\x82\x3D\xCA\x59\x1F\xD7\x8E\xAC\xCF\x2E\xD5\xB2\x95\xB8\x73"
           "\x20\xC4\x0A\xD0\xA5\x87\xE4\xD0\x8F\x77\x1B\xDC\x05\xE1\x7A\x54"
           "\x7D\xB8\xA6\x8E\x1B\xA9\xF0\xF4\xED\x02\x01\x03"
           , 268);
    nPKLen = 268;
    memset(bData, 0x42, 2048);
    bData[0] = 0x30;
    bData[2047] = 0x39;
    nDataLen = 2048;
    memcpy(bSign,
           "\x41\xCC\x9E\x06\x06\x0A\x76\xED\xB8\xE3\x74\xC6\xEB\xCA\xBC\x0E"
           "\xA7\xE9\xE2\x2A\xC3\x53\x80\xAB\xAD\x3C\x30\x7B\x76\x14\xCF\xF2"
           "\x9F\xC0\xBB\x4A\x8B\xA2\x1F\x70\xC6\xD9\x20\x8C\xBF\xEE\x04\xD2"
           "\x06\xB7\xDD\x4C\x02\x52\xD1\xFC\x20\x8B\x29\xBB\xCF\x9B\xA5\xA1"
           "\x64\x65\xC4\x00\x35\xF4\xF1\xF3\x8F\x71\x43\x09\xE2\x54\xC6\x67"
           "\x85\x5B\xD1\x13\x7A\x52\x9E\xF8\xC1\xAB\x36\xE6\x4E\x8B\xCD\xDE"
           "\xD6\x2E\xA4\x4E\x58\x2D\x4B\xB7\xEB\x54\x85\xEF\x13\xEB\x49\x3B"
           "\xE5\x1F\x5B\x39\x8A\x50\xBB\x35\xD2\x67\x19\x38\xC0\x4B\xFC\x3D"
           "\xCA\x7C\x0F\x84\xE2\x18\x5F\x99\xF3\xE9\x66\xCA\x9F\x96\xA2\xC4"
           "\xE8\xFE\xAB\x36\xA4\x43\xB1\x4A\xE6\xF6\xB9\x9E\x34\x91\x82\xA6"
           "\x75\xBA\x9E\x18\xF5\x98\xA0\xB7\xEB\xE5\x87\x4F\x4B\x11\x1A\xE8"
           "\xF9\x9C\x29\x5F\xC9\x39\x14\xD4\x82\x02\x44\x50\x99\x34\x06\xB5"
           "\x4B\x3D\x61\x30\x8E\x27\xC8\x2E\x3D\xCB\x1B\xD0\x21\x82\x21\x6D"
           "\x7B\x55\x32\x51\xCD\x51\xDB\xBE\x4C\x3C\xF1\x7D\xC0\x48\x12\xE5"
           "\xA9\xC9\x83\x54\xE8\xE5\x35\x03\xB6\x02\x6E\x28\xCE\x29\xEB\x38"
           "\xBE\x21\x53\x9B\x9E\xB5\xDA\xE2\xA0\xD6\x3A\x2A\xB8\x64\xF3\x07"
           , 256);
    nSignLen = 256;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 268);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 2048);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-2048，SHA-512，PKCS#1填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_37(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nSock = -1;
    nAlgo = 0;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    memset(bData, 0x42, 1);
    nDataLen = 1;
    memcpy(bSign,
           "\x6A\xCC\xF7\x0F\x1B\xD2\x9B\xF3\x06\xEE\xE5\x23\x4D\x02\x5C\x47"
           "\x60\x8E\x88\xFA\x20\x57\x36\x31\x51\xA3\x83\x71\x23\x16\x0C\xEF"
           "\xA5\x53\xB0\xE9\xD7\xD4\xAB\xBA\xD7\xE0\xB4\xD5\x1A\x04\x45\xD4"
           "\x1A\xE1\xF2\x28\xE8\x78\xD3\xA6\xD7\x5E\x54\x46\x35\x81\xEB\x91"
           , 64);
    nSignLen = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 72);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 1);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void VerifySign_Test_38(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nSock = 8;
    nAlgo = 0;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    memset(bData, 0x42, 1);
    nDataLen = 1;
    memcpy(bSign,
           "\x6A\xCC\xF7\x0F\x1B\xD2\x9B\xF3\x06\xEE\xE5\x23\x4D\x02\x5C\x47"
           "\x60\x8E\x88\xFA\x20\x57\x36\x31\x51\xA3\x83\x71\x23\x16\x0C\xEF"
           "\xA5\x53\xB0\xE9\xD7\xD4\xAB\xBA\xD7\xE0\xB4\xD5\x1A\x04\x45\xD4"
           "\x1A\xE1\xF2\x28\xE8\x78\xD3\xA6\xD7\x5E\x54\x46\x35\x81\xEB\x91"
           , 64);
    nSignLen = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 72);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 1);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[8]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void VerifySign_Test_39(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = -1;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    memset(bData, 0x42, 1);
    nDataLen = 1;
    memcpy(bSign,
           "\x6A\xCC\xF7\x0F\x1B\xD2\x9B\xF3\x06\xEE\xE5\x23\x4D\x02\x5C\x47"
           "\x60\x8E\x88\xFA\x20\x57\x36\x31\x51\xA3\x83\x71\x23\x16\x0C\xEF"
           "\xA5\x53\xB0\xE9\xD7\xD4\xAB\xBA\xD7\xE0\xB4\xD5\x1A\x04\x45\xD4"
           "\x1A\xE1\xF2\x28\xE8\x78\xD3\xA6\xD7\x5E\x54\x46\x35\x81\xEB\x91"
           , 64);
    nSignLen = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 72);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 1);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效摘要算法类型[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_40(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 6;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    memset(bData, 0x42, 1);
    nDataLen = 1;
    memcpy(bSign,
           "\x6A\xCC\xF7\x0F\x1B\xD2\x9B\xF3\x06\xEE\xE5\x23\x4D\x02\x5C\x47"
           "\x60\x8E\x88\xFA\x20\x57\x36\x31\x51\xA3\x83\x71\x23\x16\x0C\xEF"
           "\xA5\x53\xB0\xE9\xD7\xD4\xAB\xBA\xD7\xE0\xB4\xD5\x1A\x04\x45\xD4"
           "\x1A\xE1\xF2\x28\xE8\x78\xD3\xA6\xD7\x5E\x54\x46\x35\x81\xEB\x91"
           , 64);
    nSignLen = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 72);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 1);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效摘要算法类型[6]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_41(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 0;
    nPadMode = 1;
    nPKLen = 0;
    memset(bData, 0x42, 1);
    nDataLen = 1;
    memcpy(bSign,
           "\x6A\xCC\xF7\x0F\x1B\xD2\x9B\xF3\x06\xEE\xE5\x23\x4D\x02\x5C\x47"
           "\x60\x8E\x88\xFA\x20\x57\x36\x31\x51\xA3\x83\x71\x23\x16\x0C\xEF"
           "\xA5\x53\xB0\xE9\xD7\xD4\xAB\xBA\xD7\xE0\xB4\xD5\x1A\x04\x45\xD4"
           "\x1A\xE1\xF2\x28\xE8\x78\xD3\xA6\xD7\x5E\x54\x46\x35\x81\xEB\x91"
           , 64);
    nSignLen = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 72);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 1);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效公钥长度=0测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_42(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 0;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 71);
    nPKLen = 71;
    memset(bData, 0x42, 1);
    nDataLen = 1;
    memcpy(bSign,
           "\x6A\xCC\xF7\x0F\x1B\xD2\x9B\xF3\x06\xEE\xE5\x23\x4D\x02\x5C\x47"
           "\x60\x8E\x88\xFA\x20\x57\x36\x31\x51\xA3\x83\x71\x23\x16\x0C\xEF"
           "\xA5\x53\xB0\xE9\xD7\xD4\xAB\xBA\xD7\xE0\xB4\xD5\x1A\x04\x45\xD4"
           "\x1A\xE1\xF2\x28\xE8\x78\xD3\xA6\xD7\x5E\x54\x46\x35\x81\xEB\x91"
           , 64);
    nSignLen = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 72);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 1);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效公钥长度=71测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_43(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 0;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    nDataLen = 0;
    memcpy(bSign,
           "\x6A\xCC\xF7\x0F\x1B\xD2\x9B\xF3\x06\xEE\xE5\x23\x4D\x02\x5C\x47"
           "\x60\x8E\x88\xFA\x20\x57\x36\x31\x51\xA3\x83\x71\x23\x16\x0C\xEF"
           "\xA5\x53\xB0\xE9\xD7\xD4\xAB\xBA\xD7\xE0\xB4\xD5\x1A\x04\x45\xD4"
           "\x1A\xE1\xF2\x28\xE8\x78\xD3\xA6\xD7\x5E\x54\x46\x35\x81\xEB\x91"
           , 64);
    nSignLen = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 72);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 0);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效数据长度=0测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_44(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 0;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xExDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    memset(bData, 0x42, 1);
    nDataLen = 1;
    nSignLen = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 72);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 1);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效数据长度=1测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifySign_Test_45(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nAlgo;
	  int  nPadMode;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nAlgo = 0;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xExDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    memset(bData, 0x42, 1);
    nDataLen = 1;
    memcpy(bSign,
           "\x6A\xCC\xF7\x0F\x1B\xD2\x9B\xF3\x06\xEE\xE5\x23\x4D\x02\x5C\x47"
           "\x60\x8E\x88\xFA\x20\x57\x36\x31\x51\xA3\x83\x71\x23\x16\x0C\xEF"
           "\xA5\x53\xB0\xE9\xD7\xD4\xAB\xBA\xD7\xE0\xB4\xD5\x1A\x04\x45\xD4"
           "\x1A\xE1\xF2\x28\xE8\x78\xD3\xA6\xD7\x5E\x54\x46\x35\x81\xEB\x91"
           , 63);
    nSignLen = 63;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nAlgo = %d\n", nAlgo);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 72);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, 1);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIVerifySign(nSock, nAlgo, nPadMode, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效数据长度=63测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 0;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           , 64);
    nKeyLen = 64;
    memcpy(bKeyByPKExp,
           "\x70\xA7\xD9\xC5\xC0\x7A\x64\x5F\xFD\xDB\xBC\x91\x78\xB9\x25\xFF"
           "\x88\x7C\x08\xB7\xA9\x66\x23\xD4\xA0\xDB\xC0\x9E\x30\xD9\x2F\x46"
           "\xEF\xB5\x05\xD5\x96\x34\x6A\xCC\xD5\x99\x8E\xE3\x00\x61\xFE\xB9"
           "\x6C\x0E\x07\x0C\x75\x18\x65\x36\x80\x5C\xBA\x63\xAB\xAD\x56\xCB"
           , 64);
    nKeyByPKLenExp = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    printf("[IN ]nPadMode    = %d\n", nPadMode);
    DspHex("[IN ]bPK         =", bPK, 72);
    printf("[IN ]nPKLen      = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK   =", bKeyByHMK, 64);
    printf("[IN ]nKeyLen     = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-512，无填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKeyByPK    =", bKeyByPK, 64);
    DspHex("[OUT]bKeyByPKExp =", bKeyByPKExp, 64);
    ASSERT_OUT_HEX(bKeyByPK, bKeyByPKExp, 64);
    ASSERT_OUT(nKeyByPKLen, nKeyByPKLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 0;
    memcpy(bPK,
           "\x30\x81\x87\x02\x81\x81\x00\xA6\xF5\x8A\x17\x12\x3F\x46\x59\x92"
           "\xC0\x92\x01\x7E\xD3\xA9\x67\x2A\x6A\x42\x8E\xDA\x6A\xC2\x53\x91"
           "\x83\x77\x1E\x25\xA2\xA8\x74\x9B\xF3\x49\xF6\x6C\x5B\xA7\xDA\xC6"
           "\x18\x4B\x49\x42\x80\x20\x7F\xD9\xBB\x29\xC0\xF0\xD8\x81\xDC\x0A"
           "\x95\x53\x80\xF5\xA7\x52\x7E\x1E\x1E\x16\xB9\x5B\x79\xEE\x1F\x33"
           "\x50\x3A\xCC\x4E\xA1\x01\xC4\x55\xA8\x3B\xCB\x2B\xC8\xEB\xC5\x27"
           "\x5C\x21\xE3\x5B\xA1\x33\x60\xC6\x82\x76\xDD\x7C\x5F\xF0\x03\x24"
           "\xA7\x8E\x9B\x50\x8C\x46\xD5\xEB\xF5\x37\x81\x9B\xCD\x38\x01\x10"
           "\x1F\x9F\x0F\xBD\x78\x37\xC7\x02\x01\x03"
           , 138);
    nPKLen = 138;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           , 128);
    nKeyLen = 128;
    memcpy(bKeyByPKExp,
           "\x3B\xCE\xDA\x37\x10\xB5\x56\x2C\x1A\x46\xD1\xEE\x2E\x93\xED\xAF"
           "\xB2\xB8\xD3\x73\xFB\x35\x05\x88\x14\xCA\xC7\x52\x98\xED\x10\xB8"
           "\x1A\x9D\xBB\x3F\x22\x4F\x34\x46\x1E\x37\x9E\x75\xB2\xD3\x55\x67"
           "\x9A\x17\x93\x7E\x02\xCB\xA8\x5A\xA5\xFC\xA4\x11\xF5\x3D\x09\x53"
           "\xAF\x59\x04\x5B\x95\xDA\xC7\x29\x46\xB1\x25\x05\xF5\x75\x22\xB6"
           "\xB2\x2C\x4C\x41\x43\x1E\xD9\x72\x86\x5F\x81\x5C\x1F\xF8\xBB\xB5"
           "\x81\x84\xDE\x6D\xD0\xB0\x86\xD2\x57\xAB\xB1\x66\xD5\x84\x99\x0B"
           "\x76\x38\x6F\x96\x77\xF1\xE0\xC3\x7C\x0F\x32\x03\xDC\x95\x65\xE2"
           , 128);
    nKeyByPKLenExp = 128;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 138);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK =", bKeyByHMK, 128);
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1024，无填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKeyByPK    =", bKeyByPK, 128);
    DspHex("[OUT]bKeyByPKExp =", bKeyByPKExp, 128);
    ASSERT_OUT_HEX(bKeyByPK, bKeyByPKExp, 128);
    ASSERT_OUT(nKeyByPKLen, nKeyByPKLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 0;
    memcpy(bPK,
           "\x30\x81\x97\x02\x81\x91\x00\xB4\xD4\xCD\x27\x2B\x0C\x7A\xBA\xA9"
           "\x32\x54\xA6\x0A\xD3\xDD\xAE\x80\x31\x47\x07\xC8\x48\x4F\x76\x03"
           "\x7C\x24\x4A\x59\x54\x0E\x99\x25\xD1\x3C\xB6\xE0\x20\xDB\xCB\x20"
           "\xB5\x23\x8F\x55\xDE\xF4\x31\xCD\x51\xE2\x1B\x07\xDC\xCC\x41\x6A"
           "\xAA\xBB\x0C\x5E\x3A\x61\x11\xA0\x90\xE0\xA9\x38\x86\x1C\x78\xE9"
           "\xAA\x75\xF2\x02\x38\x36\x19\x53\x4C\xE9\x21\x88\x43\x05\x8C\x7D"
           "\xDB\x60\x26\x36\x87\x24\xA7\xD5\x36\x39\x14\xD1\xEF\x66\x78\x1C"
           "\xBE\xD1\x56\xF9\x70\x77\xF7\xE0\xF1\x1B\x9D\x8D\x9C\xB6\x26\x5A"
           "\xE6\x3A\xC8\x18\x9F\x48\x03\x3D\x85\x06\x21\x71\xB2\x2C\x70\x98"
           "\x40\xA5\x39\xA0\xBD\x8D\xDB\x02\x01\x03"
           , 154);
    nPKLen = 154;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           , 144);
    nKeyLen = 144;
    memcpy(bKeyByPKExp,
           "\x1E\xC6\x70\x1F\xF1\x03\xDA\xB8\xC0\xD8\x21\xEE\xA7\xCC\xF2\x50"
           "\xA6\x85\xBD\xE5\x2D\x01\x74\x78\xE8\xB2\xBF\xA4\xA0\x51\x86\x24"
           "\xF8\x04\xD3\xC4\xC4\x85\x48\xA2\x4D\x66\xE5\xA0\x59\x97\x48\xE7"
           "\x10\x61\x63\x37\x46\x68\xF1\x5A\x54\x6C\x19\x7E\xBA\xF9\x44\xAA"
           "\x62\xB3\xFE\xDC\x06\x40\x21\xAA\xA8\x16\x25\x99\x18\x43\x01\xD2"
           "\x62\x26\xB5\x76\x71\xF9\x04\x71\xC5\xCF\x99\x56\x8E\x8C\xF2\xB2"
           "\x5A\x8E\x66\x3F\x11\x9A\xFC\xAE\xB9\xDA\x29\x2E\x1F\x5F\x9D\x69"
           "\x47\x57\x12\xB7\x38\xBD\x2A\x7E\xD6\x85\x71\xA9\xC4\xC2\x51\x54"
           "\xC0\xC3\xAB\x67\x80\xA9\x74\xFC\x4C\xF1\x6F\x41\x36\x12\x51\xF2"
           , 144);
    nKeyByPKLenExp = 144;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 154);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK =", bKeyByHMK, 144);
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1152，无填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKeyByPK    =", bKeyByPK, 144);
    DspHex("[OUT]bKeyByPKExp =", bKeyByPKExp, 144);
    ASSERT_OUT_HEX(bKeyByPK, bKeyByPKExp, 144);
    ASSERT_OUT(nKeyByPKLen, nKeyByPKLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 0;
    memcpy(bPK,
           "\x30\x81\xB7\x02\x81\xB1\x00\x9C\xDB\xEA\x10\x4A\xEE\x30\xD8\x58"
           "\xE1\xC7\x10\x81\xC8\x32\x40\x80\x1C\x94\x1E\xF6\xE9\x05\xC8\x0E"
           "\x41\x94\xE8\x88\x59\x72\xA8\x21\x22\x0C\x7B\x5F\x52\x8D\x65\xF0"
           "\xDD\x09\x56\x01\x71\xB6\x43\x64\x9A\x6E\x1F\xE3\x85\x7D\x2A\x27"
           "\xF7\x5A\xA3\xDB\x73\xA2\x99\xD6\x85\xAF\x86\x91\x7F\x19\xF5\x65"
           "\x7C\xA9\x71\xC1\x72\x38\x03\x8B\xDD\x83\x62\x79\x60\xB2\xB3\xE2"
           "\x7E\x41\x0D\x36\x50\x7C\xFA\xB0\x6E\xAE\x9E\x05\x5A\x55\xF8\x9C"
           "\x69\x71\x90\x77\x4C\xA3\x95\x29\x7D\xC1\x79\xFE\x7C\xD7\x96\x84"
           "\x0D\xC6\x30\x3F\x14\xDA\x88\xCF\x4A\xED\x5A\x7A\x71\x91\x5D\x25"
           "\x93\xDA\x0C\xB6\xCC\xB6\xD8\xE7\xF0\x54\x55\xA3\x93\xBD\xC0\xE7"
           "\x3E\xF8\x26\xFC\x5B\x37\xA5\x91\x01\x4B\xA2\x58\xBB\x59\xC2\x1E"
           "\xC8\x32\x3B\x85\x16\x8E\xF3\x02\x01\x03"
           , 186);
    nPKLen = 186;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           , 176);
    nKeyLen = 176;
    memcpy(bKeyByPKExp,
           "\x16\x31\xB3\x98\xDC\xA8\xF8\x93\x8D\x68\xF4\x35\x0F\x63\xB3\x22"
           "\xCE\xF5\x2D\xE4\x88\xCE\x1C\xD9\x0C\x22\x24\xF3\xE5\xE1\x41\xB3"
           "\x68\x12\x9A\xA7\xA9\x7B\x35\xE8\x11\x96\x82\x29\x21\x6B\x13\x81"
           "\x6C\x0F\xF2\xCC\x02\x57\xE2\x2C\x19\xBF\xF4\xD6\x32\x0D\x20\x40"
           "\x81\x8B\x8E\x7D\x9B\x4A\x8A\x5C\x5F\xB6\x92\x43\x0D\x50\xD5\x0C"
           "\xCE\x2E\x8A\xE4\x0C\x13\x37\xBA\xFA\x4B\x64\x16\xB7\x0F\xA1\x94"
           "\x86\x95\xD6\x69\x19\xE6\x4E\x2C\x9A\xD5\x2C\x53\xB4\xAE\xD4\x4C"
           "\xE4\xB1\x4F\x11\x2A\xB5\xC5\xC4\x76\x9B\xB5\xF5\x9D\xB5\x10\x29"
           "\x88\xE7\x39\xE4\x8B\x77\x20\x03\x41\x8D\x00\x34\xE1\xCB\x14\x5B"
           "\x3F\xD1\xA8\x86\x89\xA7\xD9\x05\xF1\x3F\xA1\x4F\x54\x03\xE4\x4B"
           "\xB0\x61\x88\x7F\x95\xF7\xD2\x20\xE9\xEF\xEA\x88\xE2\x6E\x2F\x91"
           , 176);
    nKeyByPKLenExp = 176;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 186);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK =", bKeyByHMK, 176);
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1408，无填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKeyByPK    =", bKeyByPK, 176);
    DspHex("[OUT]bKeyByPKExp =", bKeyByPKExp, 176);
    ASSERT_OUT_HEX(bKeyByPK, bKeyByPKExp, 176);
    ASSERT_OUT(nKeyByPKLen, nKeyByPKLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 0;
    memcpy(bPK,
           "\x30\x81\xFF\x02\x81\xF9\x00\xBE\xF9\x74\x44\x9A\xC3\x01\x48\x0B"
           "\x0A\xCD\xE1\xE5\x52\xE7\x55\x60\x91\x64\x8A\x46\x34\xEA\x1D\xDA"
           "\xEE\x52\x7B\x13\x92\x5F\x27\xAE\xA2\x66\xB5\xA5\xBB\x79\x4B\x09"
           "\x81\x7E\x7D\x95\x29\x16\xC5\xEF\xE0\x42\xF7\x7D\x5E\xE1\x72\x88"
           "\x0C\x1F\xDC\x76\x48\xA5\xB0\x26\x41\x8D\x4F\x70\x41\xB2\xAA\x70"
           "\x84\xC0\xAB\xFA\x95\xE9\x07\x6F\x73\x89\xE9\xD5\xAC\xD3\xBF\x72"
           "\x31\xA3\x30\x1E\xCA\x13\xDB\x1F\x1F\x44\xD1\x08\xD2\xFB\xF2\xB1"
           "\x6C\xF4\xBA\xAB\xF3\xBA\x36\x18\x25\x39\xD6\x0E\x3B\x4E\xBA\x93"
           "\xB2\xB4\xFA\x40\x7D\xCA\xE3\x96\x64\x05\x24\x79\x57\x95\xC6\x9D"
           "\xC7\x48\xB7\xFF\x55\x42\x07\x8A\x48\x84\x99\x61\x29\x52\x73\x0D"
           "\x8A\x97\x42\x6E\x67\x7C\x0A\xB3\x8B\xA9\x7C\x9C\x21\x67\x27\xD8"
           "\xB9\xDD\x14\x2C\x10\x65\xB8\x6F\x78\xBB\x64\x8A\x24\xAA\x78\x45"
           "\x7A\xB3\x54\xE6\xDF\x62\xE8\x71\xE3\x3C\x0C\x74\xD1\xFF\x02\x93"
           "\xDC\xB0\x01\x26\xEC\xAE\xCD\x4A\x3D\x22\xF7\x74\x42\xA6\xA0\xF2"
           "\xA1\x22\x72\x1E\x9C\x0F\x8C\xAF\xA2\x51\x2A\x23\xFF\x22\x49\xDD"
           "\x6C\x20\x4A\xEE\x7A\xCE\x81\xFB\xD1\x94\xAA\xF6\x5B\xC0\xDB\x02"
           "\x01\x03"
           , 258);
    nPKLen = 258;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           , 248);
    nKeyLen = 248;
    memcpy(bKeyByPKExp,
           "\xB1\x06\x2E\xFB\xAE\xB1\xE8\x91\xCD\x0A\xB1\x09\x49\xE2\x60\x5A"
           "\x64\xFE\x1A\x07\x4C\x48\x3C\x73\x2A\x8A\xEB\xFD\x8D\xC7\x76\x56"
           "\x90\x5B\x65\xC5\xBF\xF8\x8A\xA6\x97\x06\xAF\x5D\x52\xE0\x00\x8A"
           "\x4C\xFD\x88\xB0\x84\x13\xA5\x61\x77\x15\x73\xE9\xF7\xAF\x09\xA7"
           "\xB1\x6E\x7E\x0A\x1C\x08\x6E\xB1\xD8\x91\x89\xAD\x9D\xAF\x12\x71"
           "\x47\x58\x2A\x1E\x49\x96\x12\xD8\x8A\x46\x40\xAA\xC0\x80\x1D\x5A"
           "\xEC\xD9\xC5\x1C\xCA\x8F\xD3\x06\x71\xCE\xAD\x58\x04\x05\x67\x56"
           "\xA0\x4A\x0A\xA4\x91\xA9\x5F\xE9\x99\xD3\x97\x79\xC9\xBA\x0A\xF0"
           "\xA3\x9E\xD1\xF7\x19\x01\x7C\x69\x61\x91\x63\x68\x3F\x43\x07\x02"
           "\x1E\x17\x02\x66\xD4\xCD\xE3\x1C\x20\xCB\x90\x36\x9E\xD2\xE6\x04"
           "\xC6\x56\xE2\xC9\xE8\x89\x78\x4B\x7E\x12\x4E\x93\x16\x5B\x21\x6E"
           "\x10\x18\xED\x1A\x84\xC0\x97\x95\x45\xFF\xAE\xC5\x25\xBB\x88\x8C"
           "\xB7\x29\x2C\x40\x20\x01\xFD\x28\xB5\xF7\x93\xC3\x7A\x15\xB1\xE4"
           "\x9E\x0E\x5F\x82\x43\x7E\x5D\xDC\x1C\x27\x86\xAD\x96\x63\xDA\x7F"
           "\xD7\xE7\x18\x65\x22\xC6\x53\xCE\x24\x8D\xAF\xB3\x70\x2B\x35\xAD"
           "\x88\x81\x73\x08\xF1\x38\xC8\xD2"
           , 248);
    nKeyByPKLenExp = 248;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 258);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK =", bKeyByHMK, 248);
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1984，无填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKeyByPK    =", bKeyByPK, 248);
    DspHex("[OUT]bKeyByPKExp =", bKeyByPKExp, 248);
    ASSERT_OUT_HEX(bKeyByPK, bKeyByPKExp, 248);
    ASSERT_OUT(nKeyByPKLen, nKeyByPKLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 0;
    memcpy(bPK,
           "\x30\x82\x01\x08\x02\x82\x01\x01\x00\xC9\xD5\xA7\x6F\x4E\x62\xAD"
           "\x7A\xD8\x19\x85\x19\xB4\xDC\xE8\x88\xBB\x00\x10\xFF\x54\xA8\xC9"
           "\x61\xB5\x44\x2E\x53\x7D\xA4\x98\x7F\x27\xD6\x8A\x3E\x64\x92\x73"
           "\x59\x49\xFA\x81\x61\x8E\xD6\x66\x3C\x7E\xC0\xB3\x5D\x4E\xBB\x11"
           "\x01\x5B\xEE\x25\x53\x92\x33\x75\xA0\x3F\xBD\x02\xAB\x69\xE8\x0E"
           "\xF8\xC1\x98\x76\xDA\x81\x32\x66\x16\xEF\x7A\x0D\x6E\x4D\xB1\x74"
           "\xC8\xE8\x93\xE8\x1F\x00\x29\x7F\x46\x3C\x7C\x37\x0C\x7B\xF0\x78"
           "\xBA\x7D\x5D\xF9\x88\x9A\x86\x1E\xB8\x13\x59\xAA\x55\x1E\x5C\xBD"
           "\x2B\x7C\x36\xD8\xE5\x49\x83\xB5\xCB\x14\x4B\x1F\xEA\x02\x93\x07"
           "\xF0\x40\x24\xCD\x51\x96\x71\x22\xF0\x4A\x68\x2C\xCD\xDE\xF5\x0F"
           "\xFC\x34\x4A\x64\xA3\x52\xA1\xBE\xEE\x2C\xE7\x5C\x1A\x95\x8E\xFC"
           "\xA4\xAB\x65\xEB\x96\xBE\x43\x0F\xBD\x78\xFE\x6A\xDF\x48\xB9\x68"
           "\x66\x69\x6C\x68\xCC\xA4\x35\xD3\x2B\xA4\x2C\xDD\xBD\xC3\x65\x7B"
           "\x5C\xD9\x56\x67\xB9\x2E\x40\xFE\xEF\x02\xEF\xBD\x91\xFC\x88\x61"
           "\xCA\x82\x3D\xCA\x59\x1F\xD7\x8E\xAC\xCF\x2E\xD5\xB2\x95\xB8\x73"
           "\x20\xC4\x0A\xD0\xA5\x87\xE4\xD0\x8F\x77\x1B\xDC\x05\xE1\x7A\x54"
           "\x7D\xB8\xA6\x8E\x1B\xA9\xF0\xF4\xED\x02\x01\x03"
           , 268);
    nPKLen = 268;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           , 256);
    nKeyLen = 256;
    memcpy(bKeyByPKExp,
           "\x10\xD4\xC6\x86\x03\xC1\xC3\xC5\xC2\xA9\xCE\xFF\x38\xEC\xB4\xD1"
           "\xC9\x53\xE0\xD7\x6E\x91\x0F\xCF\x1C\x32\xC5\xDF\x07\x84\x54\x6F"
           "\x5D\x88\x43\x95\x89\x0C\x2D\x6A\xE1\x0C\xFA\x6C\x5C\x79\x6C\x95"
           "\xD3\x4E\x1C\xE4\x29\xFC\x62\xE7\xD1\xC1\x30\x63\x30\x23\x35\xE2"
           "\xCC\x11\x53\x8A\x21\xB1\x8E\x87\x26\x54\xC9\x00\x28\x13\x7E\x0C"
           "\xC5\xA5\x00\x41\xF6\xB2\xA2\x92\xD5\xAB\xBD\x47\x78\xA7\xBD\x8C"
           "\xEC\x35\xB6\x5A\x94\x12\x2C\xF1\x4C\x5F\x7A\x0C\xD8\x4D\x1E\x79"
           "\xE9\x08\x9F\xE6\x10\x8F\xD5\x82\x32\xDC\x9E\x61\x6D\x84\x6B\x65"
           "\x4E\x33\x33\x3B\xB3\x26\xD5\x14\xA6\xE1\x67\x5C\xEF\x38\xEA\x43"
           "\x9C\x63\x3E\xCE\x3D\xFC\x6B\xC5\x8A\xAB\x15\x5C\xFF\xEA\x95\x67"
           "\xAB\x4D\x5A\xCD\x3B\x6B\xC7\x29\x78\x81\x78\x28\x05\xE3\x7A\xF9"
           "\x1C\xC5\x20\xF3\x96\x6C\xDA\x16\xEA\x34\x14\x4D\x88\xD4\x26\x42"
           "\x7B\xAA\x2B\xAB\x41\x30\x6C\x78\x90\x49\xFC\x18\x90\x2B\x3A\xF0"
           "\xB3\x04\x73\x89\x90\x8D\x21\x5E\x66\x89\x69\x2B\xDC\xA5\x58\x80"
           "\xEE\x61\x91\x85\x5A\xAC\xBC\x42\x2F\xD6\x81\x91\x69\x7F\xE0\x66"
           "\xD6\x6E\x6B\x0E\x65\xD2\x4A\xAF\x19\xB2\xB1\x8C\x8C\xE2\x6E\x77"
           , 256);
    nKeyByPKLenExp = 256;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 268);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK =", bKeyByHMK, 256);
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-2048，无填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKeyByPK    =", bKeyByPK, 256);
    DspHex("[OUT]bKeyByPKExp =", bKeyByPKExp, 256);
    ASSERT_OUT_HEX(bKeyByPK, bKeyByPKExp, 256);
    ASSERT_OUT(nKeyByPKLen, nKeyByPKLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_07(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 1;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           , 8);
    nKeyLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    printf("[IN ]nPadMode    = %d\n", nPadMode);
    DspHexExt("[IN ]bPK         =", bPK, 72);
    printf("[IN ]nPKLen      = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK   =", bKeyByHMK, 8);
    printf("[IN ]nKeyLen     = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-512，PKCS#1填充，单倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bKeyByPK    =", bKeyByPK, 64);
    ASSERT_OUT(nKeyByPKLen, 64);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_08(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\x87\x02\x81\x81\x00\xA6\xF5\x8A\x17\x12\x3F\x46\x59\x92"
           "\xC0\x92\x01\x7E\xD3\xA9\x67\x2A\x6A\x42\x8E\xDA\x6A\xC2\x53\x91"
           "\x83\x77\x1E\x25\xA2\xA8\x74\x9B\xF3\x49\xF6\x6C\x5B\xA7\xDA\xC6"
           "\x18\x4B\x49\x42\x80\x20\x7F\xD9\xBB\x29\xC0\xF0\xD8\x81\xDC\x0A"
           "\x95\x53\x80\xF5\xA7\x52\x7E\x1E\x1E\x16\xB9\x5B\x79\xEE\x1F\x33"
           "\x50\x3A\xCC\x4E\xA1\x01\xC4\x55\xA8\x3B\xCB\x2B\xC8\xEB\xC5\x27"
           "\x5C\x21\xE3\x5B\xA1\x33\x60\xC6\x82\x76\xDD\x7C\x5F\xF0\x03\x24"
           "\xA7\x8E\x9B\x50\x8C\x46\xD5\xEB\xF5\x37\x81\x9B\xCD\x38\x01\x10"
           "\x1F\x9F\x0F\xBD\x78\x37\xC7\x02\x01\x03"
           , 138);
    nPKLen = 138;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           , 8);
    nKeyLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 138);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK =", bKeyByHMK, 8);
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1024，PKCS#1填充，单倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bKeyByPK    =", bKeyByPK, 128);
    ASSERT_OUT(nKeyByPKLen, 128);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_09(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\x97\x02\x81\x91\x00\xB4\xD4\xCD\x27\x2B\x0C\x7A\xBA\xA9"
           "\x32\x54\xA6\x0A\xD3\xDD\xAE\x80\x31\x47\x07\xC8\x48\x4F\x76\x03"
           "\x7C\x24\x4A\x59\x54\x0E\x99\x25\xD1\x3C\xB6\xE0\x20\xDB\xCB\x20"
           "\xB5\x23\x8F\x55\xDE\xF4\x31\xCD\x51\xE2\x1B\x07\xDC\xCC\x41\x6A"
           "\xAA\xBB\x0C\x5E\x3A\x61\x11\xA0\x90\xE0\xA9\x38\x86\x1C\x78\xE9"
           "\xAA\x75\xF2\x02\x38\x36\x19\x53\x4C\xE9\x21\x88\x43\x05\x8C\x7D"
           "\xDB\x60\x26\x36\x87\x24\xA7\xD5\x36\x39\x14\xD1\xEF\x66\x78\x1C"
           "\xBE\xD1\x56\xF9\x70\x77\xF7\xE0\xF1\x1B\x9D\x8D\x9C\xB6\x26\x5A"
           "\xE6\x3A\xC8\x18\x9F\x48\x03\x3D\x85\x06\x21\x71\xB2\x2C\x70\x98"
           "\x40\xA5\x39\xA0\xBD\x8D\xDB\x02\x01\x03"
           , 154);
    nPKLen = 154;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           , 8);
    nKeyLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 154);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK =", bKeyByHMK, 8);
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1152，PKCS#1填充，单倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bKeyByPK    =", bKeyByPK, 144);
    ASSERT_OUT(nKeyByPKLen, 144);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_10(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\xB7\x02\x81\xB1\x00\x9C\xDB\xEA\x10\x4A\xEE\x30\xD8\x58"
           "\xE1\xC7\x10\x81\xC8\x32\x40\x80\x1C\x94\x1E\xF6\xE9\x05\xC8\x0E"
           "\x41\x94\xE8\x88\x59\x72\xA8\x21\x22\x0C\x7B\x5F\x52\x8D\x65\xF0"
           "\xDD\x09\x56\x01\x71\xB6\x43\x64\x9A\x6E\x1F\xE3\x85\x7D\x2A\x27"
           "\xF7\x5A\xA3\xDB\x73\xA2\x99\xD6\x85\xAF\x86\x91\x7F\x19\xF5\x65"
           "\x7C\xA9\x71\xC1\x72\x38\x03\x8B\xDD\x83\x62\x79\x60\xB2\xB3\xE2"
           "\x7E\x41\x0D\x36\x50\x7C\xFA\xB0\x6E\xAE\x9E\x05\x5A\x55\xF8\x9C"
           "\x69\x71\x90\x77\x4C\xA3\x95\x29\x7D\xC1\x79\xFE\x7C\xD7\x96\x84"
           "\x0D\xC6\x30\x3F\x14\xDA\x88\xCF\x4A\xED\x5A\x7A\x71\x91\x5D\x25"
           "\x93\xDA\x0C\xB6\xCC\xB6\xD8\xE7\xF0\x54\x55\xA3\x93\xBD\xC0\xE7"
           "\x3E\xF8\x26\xFC\x5B\x37\xA5\x91\x01\x4B\xA2\x58\xBB\x59\xC2\x1E"
           "\xC8\x32\x3B\x85\x16\x8E\xF3\x02\x01\x03"
           , 186);
    nPKLen = 186;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           , 8);
    nKeyLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 186);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK =", bKeyByHMK, 8);
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1408，PKCS#1填充，单倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bKeyByPK    =", bKeyByPK, 176);
    ASSERT_OUT(nKeyByPKLen, 176);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_11(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\xFF\x02\x81\xF9\x00\xBE\xF9\x74\x44\x9A\xC3\x01\x48\x0B"
           "\x0A\xCD\xE1\xE5\x52\xE7\x55\x60\x91\x64\x8A\x46\x34\xEA\x1D\xDA"
           "\xEE\x52\x7B\x13\x92\x5F\x27\xAE\xA2\x66\xB5\xA5\xBB\x79\x4B\x09"
           "\x81\x7E\x7D\x95\x29\x16\xC5\xEF\xE0\x42\xF7\x7D\x5E\xE1\x72\x88"
           "\x0C\x1F\xDC\x76\x48\xA5\xB0\x26\x41\x8D\x4F\x70\x41\xB2\xAA\x70"
           "\x84\xC0\xAB\xFA\x95\xE9\x07\x6F\x73\x89\xE9\xD5\xAC\xD3\xBF\x72"
           "\x31\xA3\x30\x1E\xCA\x13\xDB\x1F\x1F\x44\xD1\x08\xD2\xFB\xF2\xB1"
           "\x6C\xF4\xBA\xAB\xF3\xBA\x36\x18\x25\x39\xD6\x0E\x3B\x4E\xBA\x93"
           "\xB2\xB4\xFA\x40\x7D\xCA\xE3\x96\x64\x05\x24\x79\x57\x95\xC6\x9D"
           "\xC7\x48\xB7\xFF\x55\x42\x07\x8A\x48\x84\x99\x61\x29\x52\x73\x0D"
           "\x8A\x97\x42\x6E\x67\x7C\x0A\xB3\x8B\xA9\x7C\x9C\x21\x67\x27\xD8"
           "\xB9\xDD\x14\x2C\x10\x65\xB8\x6F\x78\xBB\x64\x8A\x24\xAA\x78\x45"
           "\x7A\xB3\x54\xE6\xDF\x62\xE8\x71\xE3\x3C\x0C\x74\xD1\xFF\x02\x93"
           "\xDC\xB0\x01\x26\xEC\xAE\xCD\x4A\x3D\x22\xF7\x74\x42\xA6\xA0\xF2"
           "\xA1\x22\x72\x1E\x9C\x0F\x8C\xAF\xA2\x51\x2A\x23\xFF\x22\x49\xDD"
           "\x6C\x20\x4A\xEE\x7A\xCE\x81\xFB\xD1\x94\xAA\xF6\x5B\xC0\xDB\x02"
           "\x01\x03"
           , 258);
    nPKLen = 258;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           , 8);
    nKeyLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 258);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK =", bKeyByHMK, 8);
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1984，PKCS#1填充，单倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bKeyByPK    =", bKeyByPK, 248);
    ASSERT_OUT(nKeyByPKLen, 248);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_12(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 1;
    memcpy(bPK,
           "\x30\x82\x01\x08\x02\x82\x01\x01\x00\xC9\xD5\xA7\x6F\x4E\x62\xAD"
           "\x7A\xD8\x19\x85\x19\xB4\xDC\xE8\x88\xBB\x00\x10\xFF\x54\xA8\xC9"
           "\x61\xB5\x44\x2E\x53\x7D\xA4\x98\x7F\x27\xD6\x8A\x3E\x64\x92\x73"
           "\x59\x49\xFA\x81\x61\x8E\xD6\x66\x3C\x7E\xC0\xB3\x5D\x4E\xBB\x11"
           "\x01\x5B\xEE\x25\x53\x92\x33\x75\xA0\x3F\xBD\x02\xAB\x69\xE8\x0E"
           "\xF8\xC1\x98\x76\xDA\x81\x32\x66\x16\xEF\x7A\x0D\x6E\x4D\xB1\x74"
           "\xC8\xE8\x93\xE8\x1F\x00\x29\x7F\x46\x3C\x7C\x37\x0C\x7B\xF0\x78"
           "\xBA\x7D\x5D\xF9\x88\x9A\x86\x1E\xB8\x13\x59\xAA\x55\x1E\x5C\xBD"
           "\x2B\x7C\x36\xD8\xE5\x49\x83\xB5\xCB\x14\x4B\x1F\xEA\x02\x93\x07"
           "\xF0\x40\x24\xCD\x51\x96\x71\x22\xF0\x4A\x68\x2C\xCD\xDE\xF5\x0F"
           "\xFC\x34\x4A\x64\xA3\x52\xA1\xBE\xEE\x2C\xE7\x5C\x1A\x95\x8E\xFC"
           "\xA4\xAB\x65\xEB\x96\xBE\x43\x0F\xBD\x78\xFE\x6A\xDF\x48\xB9\x68"
           "\x66\x69\x6C\x68\xCC\xA4\x35\xD3\x2B\xA4\x2C\xDD\xBD\xC3\x65\x7B"
           "\x5C\xD9\x56\x67\xB9\x2E\x40\xFE\xEF\x02\xEF\xBD\x91\xFC\x88\x61"
           "\xCA\x82\x3D\xCA\x59\x1F\xD7\x8E\xAC\xCF\x2E\xD5\xB2\x95\xB8\x73"
           "\x20\xC4\x0A\xD0\xA5\x87\xE4\xD0\x8F\x77\x1B\xDC\x05\xE1\x7A\x54"
           "\x7D\xB8\xA6\x8E\x1B\xA9\xF0\xF4\xED\x02\x01\x03"
           , 268);
    nPKLen = 268;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           , 8);
    nKeyLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 268);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK =", bKeyByHMK, 8);
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-2048，PKCS#1填充，单倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bKeyByPK    =", bKeyByPK, 256);
    ASSERT_OUT(nKeyByPKLen, 256);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_13(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 2;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           , 8);
    nKeyLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    printf("[IN ]nPadMode    = %d\n", nPadMode);
    DspHexExt("[IN ]bPK         =", bPK, 72);
    printf("[IN ]nPKLen      = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK   =", bKeyByHMK, 8);
    printf("[IN ]nKeyLen     = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-512，OAEP填充，单倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bKeyByPK    =", bKeyByPK, 64);
    ASSERT_OUT(nKeyByPKLen, 64);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_14(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 2;
    memcpy(bPK,
           "\x30\x81\x87\x02\x81\x81\x00\xA6\xF5\x8A\x17\x12\x3F\x46\x59\x92"
           "\xC0\x92\x01\x7E\xD3\xA9\x67\x2A\x6A\x42\x8E\xDA\x6A\xC2\x53\x91"
           "\x83\x77\x1E\x25\xA2\xA8\x74\x9B\xF3\x49\xF6\x6C\x5B\xA7\xDA\xC6"
           "\x18\x4B\x49\x42\x80\x20\x7F\xD9\xBB\x29\xC0\xF0\xD8\x81\xDC\x0A"
           "\x95\x53\x80\xF5\xA7\x52\x7E\x1E\x1E\x16\xB9\x5B\x79\xEE\x1F\x33"
           "\x50\x3A\xCC\x4E\xA1\x01\xC4\x55\xA8\x3B\xCB\x2B\xC8\xEB\xC5\x27"
           "\x5C\x21\xE3\x5B\xA1\x33\x60\xC6\x82\x76\xDD\x7C\x5F\xF0\x03\x24"
           "\xA7\x8E\x9B\x50\x8C\x46\xD5\xEB\xF5\x37\x81\x9B\xCD\x38\x01\x10"
           "\x1F\x9F\x0F\xBD\x78\x37\xC7\x02\x01\x03"
           , 138);
    nPKLen = 138;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           , 8);
    nKeyLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 138);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK =", bKeyByHMK, 8);
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1024，OAEP填充，单倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bKeyByPK    =", bKeyByPK, 128);
    ASSERT_OUT(nKeyByPKLen, 128);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_15(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 2;
    memcpy(bPK,
           "\x30\x81\x97\x02\x81\x91\x00\xB4\xD4\xCD\x27\x2B\x0C\x7A\xBA\xA9"
           "\x32\x54\xA6\x0A\xD3\xDD\xAE\x80\x31\x47\x07\xC8\x48\x4F\x76\x03"
           "\x7C\x24\x4A\x59\x54\x0E\x99\x25\xD1\x3C\xB6\xE0\x20\xDB\xCB\x20"
           "\xB5\x23\x8F\x55\xDE\xF4\x31\xCD\x51\xE2\x1B\x07\xDC\xCC\x41\x6A"
           "\xAA\xBB\x0C\x5E\x3A\x61\x11\xA0\x90\xE0\xA9\x38\x86\x1C\x78\xE9"
           "\xAA\x75\xF2\x02\x38\x36\x19\x53\x4C\xE9\x21\x88\x43\x05\x8C\x7D"
           "\xDB\x60\x26\x36\x87\x24\xA7\xD5\x36\x39\x14\xD1\xEF\x66\x78\x1C"
           "\xBE\xD1\x56\xF9\x70\x77\xF7\xE0\xF1\x1B\x9D\x8D\x9C\xB6\x26\x5A"
           "\xE6\x3A\xC8\x18\x9F\x48\x03\x3D\x85\x06\x21\x71\xB2\x2C\x70\x98"
           "\x40\xA5\x39\xA0\xBD\x8D\xDB\x02\x01\x03"
           , 154);
    nPKLen = 154;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           , 8);
    nKeyLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 154);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK =", bKeyByHMK, 8);
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1152，OAEP填充，单倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bKeyByPK    =", bKeyByPK, 144);
    ASSERT_OUT(nKeyByPKLen, 144);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_16(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 2;
    memcpy(bPK,
           "\x30\x81\xB7\x02\x81\xB1\x00\x9C\xDB\xEA\x10\x4A\xEE\x30\xD8\x58"
           "\xE1\xC7\x10\x81\xC8\x32\x40\x80\x1C\x94\x1E\xF6\xE9\x05\xC8\x0E"
           "\x41\x94\xE8\x88\x59\x72\xA8\x21\x22\x0C\x7B\x5F\x52\x8D\x65\xF0"
           "\xDD\x09\x56\x01\x71\xB6\x43\x64\x9A\x6E\x1F\xE3\x85\x7D\x2A\x27"
           "\xF7\x5A\xA3\xDB\x73\xA2\x99\xD6\x85\xAF\x86\x91\x7F\x19\xF5\x65"
           "\x7C\xA9\x71\xC1\x72\x38\x03\x8B\xDD\x83\x62\x79\x60\xB2\xB3\xE2"
           "\x7E\x41\x0D\x36\x50\x7C\xFA\xB0\x6E\xAE\x9E\x05\x5A\x55\xF8\x9C"
           "\x69\x71\x90\x77\x4C\xA3\x95\x29\x7D\xC1\x79\xFE\x7C\xD7\x96\x84"
           "\x0D\xC6\x30\x3F\x14\xDA\x88\xCF\x4A\xED\x5A\x7A\x71\x91\x5D\x25"
           "\x93\xDA\x0C\xB6\xCC\xB6\xD8\xE7\xF0\x54\x55\xA3\x93\xBD\xC0\xE7"
           "\x3E\xF8\x26\xFC\x5B\x37\xA5\x91\x01\x4B\xA2\x58\xBB\x59\xC2\x1E"
           "\xC8\x32\x3B\x85\x16\x8E\xF3\x02\x01\x03"
           , 186);
    nPKLen = 186;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           , 8);
    nKeyLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 186);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK =", bKeyByHMK, 8);
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1408，OAEP填充，单倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bKeyByPK    =", bKeyByPK, 176);
    ASSERT_OUT(nKeyByPKLen, 176);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_17(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 2;
    memcpy(bPK,
           "\x30\x81\xFF\x02\x81\xF9\x00\xBE\xF9\x74\x44\x9A\xC3\x01\x48\x0B"
           "\x0A\xCD\xE1\xE5\x52\xE7\x55\x60\x91\x64\x8A\x46\x34\xEA\x1D\xDA"
           "\xEE\x52\x7B\x13\x92\x5F\x27\xAE\xA2\x66\xB5\xA5\xBB\x79\x4B\x09"
           "\x81\x7E\x7D\x95\x29\x16\xC5\xEF\xE0\x42\xF7\x7D\x5E\xE1\x72\x88"
           "\x0C\x1F\xDC\x76\x48\xA5\xB0\x26\x41\x8D\x4F\x70\x41\xB2\xAA\x70"
           "\x84\xC0\xAB\xFA\x95\xE9\x07\x6F\x73\x89\xE9\xD5\xAC\xD3\xBF\x72"
           "\x31\xA3\x30\x1E\xCA\x13\xDB\x1F\x1F\x44\xD1\x08\xD2\xFB\xF2\xB1"
           "\x6C\xF4\xBA\xAB\xF3\xBA\x36\x18\x25\x39\xD6\x0E\x3B\x4E\xBA\x93"
           "\xB2\xB4\xFA\x40\x7D\xCA\xE3\x96\x64\x05\x24\x79\x57\x95\xC6\x9D"
           "\xC7\x48\xB7\xFF\x55\x42\x07\x8A\x48\x84\x99\x61\x29\x52\x73\x0D"
           "\x8A\x97\x42\x6E\x67\x7C\x0A\xB3\x8B\xA9\x7C\x9C\x21\x67\x27\xD8"
           "\xB9\xDD\x14\x2C\x10\x65\xB8\x6F\x78\xBB\x64\x8A\x24\xAA\x78\x45"
           "\x7A\xB3\x54\xE6\xDF\x62\xE8\x71\xE3\x3C\x0C\x74\xD1\xFF\x02\x93"
           "\xDC\xB0\x01\x26\xEC\xAE\xCD\x4A\x3D\x22\xF7\x74\x42\xA6\xA0\xF2"
           "\xA1\x22\x72\x1E\x9C\x0F\x8C\xAF\xA2\x51\x2A\x23\xFF\x22\x49\xDD"
           "\x6C\x20\x4A\xEE\x7A\xCE\x81\xFB\xD1\x94\xAA\xF6\x5B\xC0\xDB\x02"
           "\x01\x03"
           , 258);
    nPKLen = 258;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           , 8);
    nKeyLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 258);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK =", bKeyByHMK, 8);
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1984，OAEP填充，单倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bKeyByPK    =", bKeyByPK, 248);
    ASSERT_OUT(nKeyByPKLen, 248);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_18(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 2;
    memcpy(bPK,
           "\x30\x82\x01\x08\x02\x82\x01\x01\x00\xC9\xD5\xA7\x6F\x4E\x62\xAD"
           "\x7A\xD8\x19\x85\x19\xB4\xDC\xE8\x88\xBB\x00\x10\xFF\x54\xA8\xC9"
           "\x61\xB5\x44\x2E\x53\x7D\xA4\x98\x7F\x27\xD6\x8A\x3E\x64\x92\x73"
           "\x59\x49\xFA\x81\x61\x8E\xD6\x66\x3C\x7E\xC0\xB3\x5D\x4E\xBB\x11"
           "\x01\x5B\xEE\x25\x53\x92\x33\x75\xA0\x3F\xBD\x02\xAB\x69\xE8\x0E"
           "\xF8\xC1\x98\x76\xDA\x81\x32\x66\x16\xEF\x7A\x0D\x6E\x4D\xB1\x74"
           "\xC8\xE8\x93\xE8\x1F\x00\x29\x7F\x46\x3C\x7C\x37\x0C\x7B\xF0\x78"
           "\xBA\x7D\x5D\xF9\x88\x9A\x86\x1E\xB8\x13\x59\xAA\x55\x1E\x5C\xBD"
           "\x2B\x7C\x36\xD8\xE5\x49\x83\xB5\xCB\x14\x4B\x1F\xEA\x02\x93\x07"
           "\xF0\x40\x24\xCD\x51\x96\x71\x22\xF0\x4A\x68\x2C\xCD\xDE\xF5\x0F"
           "\xFC\x34\x4A\x64\xA3\x52\xA1\xBE\xEE\x2C\xE7\x5C\x1A\x95\x8E\xFC"
           "\xA4\xAB\x65\xEB\x96\xBE\x43\x0F\xBD\x78\xFE\x6A\xDF\x48\xB9\x68"
           "\x66\x69\x6C\x68\xCC\xA4\x35\xD3\x2B\xA4\x2C\xDD\xBD\xC3\x65\x7B"
           "\x5C\xD9\x56\x67\xB9\x2E\x40\xFE\xEF\x02\xEF\xBD\x91\xFC\x88\x61"
           "\xCA\x82\x3D\xCA\x59\x1F\xD7\x8E\xAC\xCF\x2E\xD5\xB2\x95\xB8\x73"
           "\x20\xC4\x0A\xD0\xA5\x87\xE4\xD0\x8F\x77\x1B\xDC\x05\xE1\x7A\x54"
           "\x7D\xB8\xA6\x8E\x1B\xA9\xF0\xF4\xED\x02\x01\x03"
           , 268);
    nPKLen = 268;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           , 8);
    nKeyLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 268);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK =", bKeyByHMK, 8);
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-2048，OAEP填充，单倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bKeyByPK    =", bKeyByPK, 256);
    ASSERT_OUT(nKeyByPKLen, 256);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_19(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 1;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           , 16);
    nKeyLen = 16;

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    printf("[IN ]nPadMode    = %d\n", nPadMode);
    DspHexExt("[IN ]bPK         =", bPK, 72);
    printf("[IN ]nPKLen      = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK   =", bKeyByHMK, 16);
    printf("[IN ]nKeyLen     = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-512，PKCS#1填充，双倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bKeyByPK    =", bKeyByPK, 64);
    ASSERT_OUT(nKeyByPKLen, 64);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_20(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\x87\x02\x81\x81\x00\xA6\xF5\x8A\x17\x12\x3F\x46\x59\x92"
           "\xC0\x92\x01\x7E\xD3\xA9\x67\x2A\x6A\x42\x8E\xDA\x6A\xC2\x53\x91"
           "\x83\x77\x1E\x25\xA2\xA8\x74\x9B\xF3\x49\xF6\x6C\x5B\xA7\xDA\xC6"
           "\x18\x4B\x49\x42\x80\x20\x7F\xD9\xBB\x29\xC0\xF0\xD8\x81\xDC\x0A"
           "\x95\x53\x80\xF5\xA7\x52\x7E\x1E\x1E\x16\xB9\x5B\x79\xEE\x1F\x33"
           "\x50\x3A\xCC\x4E\xA1\x01\xC4\x55\xA8\x3B\xCB\x2B\xC8\xEB\xC5\x27"
           "\x5C\x21\xE3\x5B\xA1\x33\x60\xC6\x82\x76\xDD\x7C\x5F\xF0\x03\x24"
           "\xA7\x8E\x9B\x50\x8C\x46\xD5\xEB\xF5\x37\x81\x9B\xCD\x38\x01\x10"
           "\x1F\x9F\x0F\xBD\x78\x37\xC7\x02\x01\x03"
           , 138);
    nPKLen = 138;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           , 16);
    nKeyLen = 16;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 138);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK =", bKeyByHMK, 16);
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1024，PKCS#1填充，双倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bKeyByPK    =", bKeyByPK, 128);
    ASSERT_OUT(nKeyByPKLen, 128);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_21(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\x97\x02\x81\x91\x00\xB4\xD4\xCD\x27\x2B\x0C\x7A\xBA\xA9"
           "\x32\x54\xA6\x0A\xD3\xDD\xAE\x80\x31\x47\x07\xC8\x48\x4F\x76\x03"
           "\x7C\x24\x4A\x59\x54\x0E\x99\x25\xD1\x3C\xB6\xE0\x20\xDB\xCB\x20"
           "\xB5\x23\x8F\x55\xDE\xF4\x31\xCD\x51\xE2\x1B\x07\xDC\xCC\x41\x6A"
           "\xAA\xBB\x0C\x5E\x3A\x61\x11\xA0\x90\xE0\xA9\x38\x86\x1C\x78\xE9"
           "\xAA\x75\xF2\x02\x38\x36\x19\x53\x4C\xE9\x21\x88\x43\x05\x8C\x7D"
           "\xDB\x60\x26\x36\x87\x24\xA7\xD5\x36\x39\x14\xD1\xEF\x66\x78\x1C"
           "\xBE\xD1\x56\xF9\x70\x77\xF7\xE0\xF1\x1B\x9D\x8D\x9C\xB6\x26\x5A"
           "\xE6\x3A\xC8\x18\x9F\x48\x03\x3D\x85\x06\x21\x71\xB2\x2C\x70\x98"
           "\x40\xA5\x39\xA0\xBD\x8D\xDB\x02\x01\x03"
           , 154);
    nPKLen = 154;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           , 16);
    nKeyLen = 16;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 154);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK =", bKeyByHMK, 16);
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1152，PKCS#1填充，双倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bKeyByPK    =", bKeyByPK, 144);
    ASSERT_OUT(nKeyByPKLen, 144);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_22(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\xB7\x02\x81\xB1\x00\x9C\xDB\xEA\x10\x4A\xEE\x30\xD8\x58"
           "\xE1\xC7\x10\x81\xC8\x32\x40\x80\x1C\x94\x1E\xF6\xE9\x05\xC8\x0E"
           "\x41\x94\xE8\x88\x59\x72\xA8\x21\x22\x0C\x7B\x5F\x52\x8D\x65\xF0"
           "\xDD\x09\x56\x01\x71\xB6\x43\x64\x9A\x6E\x1F\xE3\x85\x7D\x2A\x27"
           "\xF7\x5A\xA3\xDB\x73\xA2\x99\xD6\x85\xAF\x86\x91\x7F\x19\xF5\x65"
           "\x7C\xA9\x71\xC1\x72\x38\x03\x8B\xDD\x83\x62\x79\x60\xB2\xB3\xE2"
           "\x7E\x41\x0D\x36\x50\x7C\xFA\xB0\x6E\xAE\x9E\x05\x5A\x55\xF8\x9C"
           "\x69\x71\x90\x77\x4C\xA3\x95\x29\x7D\xC1\x79\xFE\x7C\xD7\x96\x84"
           "\x0D\xC6\x30\x3F\x14\xDA\x88\xCF\x4A\xED\x5A\x7A\x71\x91\x5D\x25"
           "\x93\xDA\x0C\xB6\xCC\xB6\xD8\xE7\xF0\x54\x55\xA3\x93\xBD\xC0\xE7"
           "\x3E\xF8\x26\xFC\x5B\x37\xA5\x91\x01\x4B\xA2\x58\xBB\x59\xC2\x1E"
           "\xC8\x32\x3B\x85\x16\x8E\xF3\x02\x01\x03"
           , 186);
    nPKLen = 186;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           , 16);
    nKeyLen = 16;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 186);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK =", bKeyByHMK, 16);
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1408，PKCS#1填充，双倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bKeyByPK    =", bKeyByPK, 176);
    ASSERT_OUT(nKeyByPKLen, 176);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_23(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\xFF\x02\x81\xF9\x00\xBE\xF9\x74\x44\x9A\xC3\x01\x48\x0B"
           "\x0A\xCD\xE1\xE5\x52\xE7\x55\x60\x91\x64\x8A\x46\x34\xEA\x1D\xDA"
           "\xEE\x52\x7B\x13\x92\x5F\x27\xAE\xA2\x66\xB5\xA5\xBB\x79\x4B\x09"
           "\x81\x7E\x7D\x95\x29\x16\xC5\xEF\xE0\x42\xF7\x7D\x5E\xE1\x72\x88"
           "\x0C\x1F\xDC\x76\x48\xA5\xB0\x26\x41\x8D\x4F\x70\x41\xB2\xAA\x70"
           "\x84\xC0\xAB\xFA\x95\xE9\x07\x6F\x73\x89\xE9\xD5\xAC\xD3\xBF\x72"
           "\x31\xA3\x30\x1E\xCA\x13\xDB\x1F\x1F\x44\xD1\x08\xD2\xFB\xF2\xB1"
           "\x6C\xF4\xBA\xAB\xF3\xBA\x36\x18\x25\x39\xD6\x0E\x3B\x4E\xBA\x93"
           "\xB2\xB4\xFA\x40\x7D\xCA\xE3\x96\x64\x05\x24\x79\x57\x95\xC6\x9D"
           "\xC7\x48\xB7\xFF\x55\x42\x07\x8A\x48\x84\x99\x61\x29\x52\x73\x0D"
           "\x8A\x97\x42\x6E\x67\x7C\x0A\xB3\x8B\xA9\x7C\x9C\x21\x67\x27\xD8"
           "\xB9\xDD\x14\x2C\x10\x65\xB8\x6F\x78\xBB\x64\x8A\x24\xAA\x78\x45"
           "\x7A\xB3\x54\xE6\xDF\x62\xE8\x71\xE3\x3C\x0C\x74\xD1\xFF\x02\x93"
           "\xDC\xB0\x01\x26\xEC\xAE\xCD\x4A\x3D\x22\xF7\x74\x42\xA6\xA0\xF2"
           "\xA1\x22\x72\x1E\x9C\x0F\x8C\xAF\xA2\x51\x2A\x23\xFF\x22\x49\xDD"
           "\x6C\x20\x4A\xEE\x7A\xCE\x81\xFB\xD1\x94\xAA\xF6\x5B\xC0\xDB\x02"
           "\x01\x03"
           , 258);
    nPKLen = 258;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           , 16);
    nKeyLen = 16;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 258);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK =", bKeyByHMK, 16);
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1984，PKCS#1填充，双倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bKeyByPK    =", bKeyByPK, 248);
    ASSERT_OUT(nKeyByPKLen, 248);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_24(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 1;
    memcpy(bPK,
           "\x30\x82\x01\x08\x02\x82\x01\x01\x00\xC9\xD5\xA7\x6F\x4E\x62\xAD"
           "\x7A\xD8\x19\x85\x19\xB4\xDC\xE8\x88\xBB\x00\x10\xFF\x54\xA8\xC9"
           "\x61\xB5\x44\x2E\x53\x7D\xA4\x98\x7F\x27\xD6\x8A\x3E\x64\x92\x73"
           "\x59\x49\xFA\x81\x61\x8E\xD6\x66\x3C\x7E\xC0\xB3\x5D\x4E\xBB\x11"
           "\x01\x5B\xEE\x25\x53\x92\x33\x75\xA0\x3F\xBD\x02\xAB\x69\xE8\x0E"
           "\xF8\xC1\x98\x76\xDA\x81\x32\x66\x16\xEF\x7A\x0D\x6E\x4D\xB1\x74"
           "\xC8\xE8\x93\xE8\x1F\x00\x29\x7F\x46\x3C\x7C\x37\x0C\x7B\xF0\x78"
           "\xBA\x7D\x5D\xF9\x88\x9A\x86\x1E\xB8\x13\x59\xAA\x55\x1E\x5C\xBD"
           "\x2B\x7C\x36\xD8\xE5\x49\x83\xB5\xCB\x14\x4B\x1F\xEA\x02\x93\x07"
           "\xF0\x40\x24\xCD\x51\x96\x71\x22\xF0\x4A\x68\x2C\xCD\xDE\xF5\x0F"
           "\xFC\x34\x4A\x64\xA3\x52\xA1\xBE\xEE\x2C\xE7\x5C\x1A\x95\x8E\xFC"
           "\xA4\xAB\x65\xEB\x96\xBE\x43\x0F\xBD\x78\xFE\x6A\xDF\x48\xB9\x68"
           "\x66\x69\x6C\x68\xCC\xA4\x35\xD3\x2B\xA4\x2C\xDD\xBD\xC3\x65\x7B"
           "\x5C\xD9\x56\x67\xB9\x2E\x40\xFE\xEF\x02\xEF\xBD\x91\xFC\x88\x61"
           "\xCA\x82\x3D\xCA\x59\x1F\xD7\x8E\xAC\xCF\x2E\xD5\xB2\x95\xB8\x73"
           "\x20\xC4\x0A\xD0\xA5\x87\xE4\xD0\x8F\x77\x1B\xDC\x05\xE1\x7A\x54"
           "\x7D\xB8\xA6\x8E\x1B\xA9\xF0\xF4\xED\x02\x01\x03"
           , 268);
    nPKLen = 268;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           , 16);
    nKeyLen = 16;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 268);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK =", bKeyByHMK, 16);
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-2048，PKCS#1填充，双倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bKeyByPK    =", bKeyByPK, 256);
    ASSERT_OUT(nKeyByPKLen, 256);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_25(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 2;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           , 16);
    nKeyLen = 16;

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    printf("[IN ]nPadMode    = %d\n", nPadMode);
    DspHexExt("[IN ]bPK         =", bPK, 72);
    printf("[IN ]nPKLen      = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK   =", bKeyByHMK, 16);
    printf("[IN ]nKeyLen     = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-512，OAEP填充，双倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bKeyByPK    =", bKeyByPK, 64);
    ASSERT_OUT(nKeyByPKLen, 64);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_26(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 2;
    memcpy(bPK,
           "\x30\x81\x87\x02\x81\x81\x00\xA6\xF5\x8A\x17\x12\x3F\x46\x59\x92"
           "\xC0\x92\x01\x7E\xD3\xA9\x67\x2A\x6A\x42\x8E\xDA\x6A\xC2\x53\x91"
           "\x83\x77\x1E\x25\xA2\xA8\x74\x9B\xF3\x49\xF6\x6C\x5B\xA7\xDA\xC6"
           "\x18\x4B\x49\x42\x80\x20\x7F\xD9\xBB\x29\xC0\xF0\xD8\x81\xDC\x0A"
           "\x95\x53\x80\xF5\xA7\x52\x7E\x1E\x1E\x16\xB9\x5B\x79\xEE\x1F\x33"
           "\x50\x3A\xCC\x4E\xA1\x01\xC4\x55\xA8\x3B\xCB\x2B\xC8\xEB\xC5\x27"
           "\x5C\x21\xE3\x5B\xA1\x33\x60\xC6\x82\x76\xDD\x7C\x5F\xF0\x03\x24"
           "\xA7\x8E\x9B\x50\x8C\x46\xD5\xEB\xF5\x37\x81\x9B\xCD\x38\x01\x10"
           "\x1F\x9F\x0F\xBD\x78\x37\xC7\x02\x01\x03"
           , 138);
    nPKLen = 138;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           , 16);
    nKeyLen = 16;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 138);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK =", bKeyByHMK, 16);
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1024，OAEP填充，双倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bKeyByPK    =", bKeyByPK, 128);
    ASSERT_OUT(nKeyByPKLen, 128);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_27(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 2;
    memcpy(bPK,
           "\x30\x81\x97\x02\x81\x91\x00\xB4\xD4\xCD\x27\x2B\x0C\x7A\xBA\xA9"
           "\x32\x54\xA6\x0A\xD3\xDD\xAE\x80\x31\x47\x07\xC8\x48\x4F\x76\x03"
           "\x7C\x24\x4A\x59\x54\x0E\x99\x25\xD1\x3C\xB6\xE0\x20\xDB\xCB\x20"
           "\xB5\x23\x8F\x55\xDE\xF4\x31\xCD\x51\xE2\x1B\x07\xDC\xCC\x41\x6A"
           "\xAA\xBB\x0C\x5E\x3A\x61\x11\xA0\x90\xE0\xA9\x38\x86\x1C\x78\xE9"
           "\xAA\x75\xF2\x02\x38\x36\x19\x53\x4C\xE9\x21\x88\x43\x05\x8C\x7D"
           "\xDB\x60\x26\x36\x87\x24\xA7\xD5\x36\x39\x14\xD1\xEF\x66\x78\x1C"
           "\xBE\xD1\x56\xF9\x70\x77\xF7\xE0\xF1\x1B\x9D\x8D\x9C\xB6\x26\x5A"
           "\xE6\x3A\xC8\x18\x9F\x48\x03\x3D\x85\x06\x21\x71\xB2\x2C\x70\x98"
           "\x40\xA5\x39\xA0\xBD\x8D\xDB\x02\x01\x03"
           , 154);
    nPKLen = 154;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           , 16);
    nKeyLen = 16;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 154);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK =", bKeyByHMK, 16);
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1152，OAEP填充，双倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bKeyByPK    =", bKeyByPK, 144);
    ASSERT_OUT(nKeyByPKLen, 144);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_28(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 2;
    memcpy(bPK,
           "\x30\x81\xB7\x02\x81\xB1\x00\x9C\xDB\xEA\x10\x4A\xEE\x30\xD8\x58"
           "\xE1\xC7\x10\x81\xC8\x32\x40\x80\x1C\x94\x1E\xF6\xE9\x05\xC8\x0E"
           "\x41\x94\xE8\x88\x59\x72\xA8\x21\x22\x0C\x7B\x5F\x52\x8D\x65\xF0"
           "\xDD\x09\x56\x01\x71\xB6\x43\x64\x9A\x6E\x1F\xE3\x85\x7D\x2A\x27"
           "\xF7\x5A\xA3\xDB\x73\xA2\x99\xD6\x85\xAF\x86\x91\x7F\x19\xF5\x65"
           "\x7C\xA9\x71\xC1\x72\x38\x03\x8B\xDD\x83\x62\x79\x60\xB2\xB3\xE2"
           "\x7E\x41\x0D\x36\x50\x7C\xFA\xB0\x6E\xAE\x9E\x05\x5A\x55\xF8\x9C"
           "\x69\x71\x90\x77\x4C\xA3\x95\x29\x7D\xC1\x79\xFE\x7C\xD7\x96\x84"
           "\x0D\xC6\x30\x3F\x14\xDA\x88\xCF\x4A\xED\x5A\x7A\x71\x91\x5D\x25"
           "\x93\xDA\x0C\xB6\xCC\xB6\xD8\xE7\xF0\x54\x55\xA3\x93\xBD\xC0\xE7"
           "\x3E\xF8\x26\xFC\x5B\x37\xA5\x91\x01\x4B\xA2\x58\xBB\x59\xC2\x1E"
           "\xC8\x32\x3B\x85\x16\x8E\xF3\x02\x01\x03"
           , 186);
    nPKLen = 186;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           , 16);
    nKeyLen = 16;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 186);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK =", bKeyByHMK, 16);
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1408，OAEP填充，双倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bKeyByPK    =", bKeyByPK, 176);
    ASSERT_OUT(nKeyByPKLen, 176);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_29(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 2;
    memcpy(bPK,
           "\x30\x81\xFF\x02\x81\xF9\x00\xBE\xF9\x74\x44\x9A\xC3\x01\x48\x0B"
           "\x0A\xCD\xE1\xE5\x52\xE7\x55\x60\x91\x64\x8A\x46\x34\xEA\x1D\xDA"
           "\xEE\x52\x7B\x13\x92\x5F\x27\xAE\xA2\x66\xB5\xA5\xBB\x79\x4B\x09"
           "\x81\x7E\x7D\x95\x29\x16\xC5\xEF\xE0\x42\xF7\x7D\x5E\xE1\x72\x88"
           "\x0C\x1F\xDC\x76\x48\xA5\xB0\x26\x41\x8D\x4F\x70\x41\xB2\xAA\x70"
           "\x84\xC0\xAB\xFA\x95\xE9\x07\x6F\x73\x89\xE9\xD5\xAC\xD3\xBF\x72"
           "\x31\xA3\x30\x1E\xCA\x13\xDB\x1F\x1F\x44\xD1\x08\xD2\xFB\xF2\xB1"
           "\x6C\xF4\xBA\xAB\xF3\xBA\x36\x18\x25\x39\xD6\x0E\x3B\x4E\xBA\x93"
           "\xB2\xB4\xFA\x40\x7D\xCA\xE3\x96\x64\x05\x24\x79\x57\x95\xC6\x9D"
           "\xC7\x48\xB7\xFF\x55\x42\x07\x8A\x48\x84\x99\x61\x29\x52\x73\x0D"
           "\x8A\x97\x42\x6E\x67\x7C\x0A\xB3\x8B\xA9\x7C\x9C\x21\x67\x27\xD8"
           "\xB9\xDD\x14\x2C\x10\x65\xB8\x6F\x78\xBB\x64\x8A\x24\xAA\x78\x45"
           "\x7A\xB3\x54\xE6\xDF\x62\xE8\x71\xE3\x3C\x0C\x74\xD1\xFF\x02\x93"
           "\xDC\xB0\x01\x26\xEC\xAE\xCD\x4A\x3D\x22\xF7\x74\x42\xA6\xA0\xF2"
           "\xA1\x22\x72\x1E\x9C\x0F\x8C\xAF\xA2\x51\x2A\x23\xFF\x22\x49\xDD"
           "\x6C\x20\x4A\xEE\x7A\xCE\x81\xFB\xD1\x94\xAA\xF6\x5B\xC0\xDB\x02"
           "\x01\x03"
           , 258);
    nPKLen = 258;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           , 16);
    nKeyLen = 16;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 258);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK =", bKeyByHMK, 16);
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1984，OAEP填充，双倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bKeyByPK    =", bKeyByPK, 248);
    ASSERT_OUT(nKeyByPKLen, 248);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_30(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 2;
    memcpy(bPK,
           "\x30\x82\x01\x08\x02\x82\x01\x01\x00\xC9\xD5\xA7\x6F\x4E\x62\xAD"
           "\x7A\xD8\x19\x85\x19\xB4\xDC\xE8\x88\xBB\x00\x10\xFF\x54\xA8\xC9"
           "\x61\xB5\x44\x2E\x53\x7D\xA4\x98\x7F\x27\xD6\x8A\x3E\x64\x92\x73"
           "\x59\x49\xFA\x81\x61\x8E\xD6\x66\x3C\x7E\xC0\xB3\x5D\x4E\xBB\x11"
           "\x01\x5B\xEE\x25\x53\x92\x33\x75\xA0\x3F\xBD\x02\xAB\x69\xE8\x0E"
           "\xF8\xC1\x98\x76\xDA\x81\x32\x66\x16\xEF\x7A\x0D\x6E\x4D\xB1\x74"
           "\xC8\xE8\x93\xE8\x1F\x00\x29\x7F\x46\x3C\x7C\x37\x0C\x7B\xF0\x78"
           "\xBA\x7D\x5D\xF9\x88\x9A\x86\x1E\xB8\x13\x59\xAA\x55\x1E\x5C\xBD"
           "\x2B\x7C\x36\xD8\xE5\x49\x83\xB5\xCB\x14\x4B\x1F\xEA\x02\x93\x07"
           "\xF0\x40\x24\xCD\x51\x96\x71\x22\xF0\x4A\x68\x2C\xCD\xDE\xF5\x0F"
           "\xFC\x34\x4A\x64\xA3\x52\xA1\xBE\xEE\x2C\xE7\x5C\x1A\x95\x8E\xFC"
           "\xA4\xAB\x65\xEB\x96\xBE\x43\x0F\xBD\x78\xFE\x6A\xDF\x48\xB9\x68"
           "\x66\x69\x6C\x68\xCC\xA4\x35\xD3\x2B\xA4\x2C\xDD\xBD\xC3\x65\x7B"
           "\x5C\xD9\x56\x67\xB9\x2E\x40\xFE\xEF\x02\xEF\xBD\x91\xFC\x88\x61"
           "\xCA\x82\x3D\xCA\x59\x1F\xD7\x8E\xAC\xCF\x2E\xD5\xB2\x95\xB8\x73"
           "\x20\xC4\x0A\xD0\xA5\x87\xE4\xD0\x8F\x77\x1B\xDC\x05\xE1\x7A\x54"
           "\x7D\xB8\xA6\x8E\x1B\xA9\xF0\xF4\xED\x02\x01\x03"
           , 268);
    nPKLen = 268;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           , 16);
    nKeyLen = 16;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 268);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK =", bKeyByHMK, 16);
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-2048，OAEP填充，双倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bKeyByPK    =", bKeyByPK, 256);
    ASSERT_OUT(nKeyByPKLen, 256);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_31(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 1;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8796 A5B4 C3D2 E1F0 */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           "\x59\x99\xC3\x06\xAB\x84\x01\xB2"
           , 24);
    nKeyLen = 24;

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    printf("[IN ]nPadMode    = %d\n", nPadMode);
    DspHexExt("[IN ]bPK         =", bPK, 72);
    printf("[IN ]nPKLen      = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK   =", bKeyByHMK, 24);
    printf("[IN ]nKeyLen     = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-512，PKCS#1填充，三倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bKeyByPK    =", bKeyByPK, 64);
    ASSERT_OUT(nKeyByPKLen, 64);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_32(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\x87\x02\x81\x81\x00\xA6\xF5\x8A\x17\x12\x3F\x46\x59\x92"
           "\xC0\x92\x01\x7E\xD3\xA9\x67\x2A\x6A\x42\x8E\xDA\x6A\xC2\x53\x91"
           "\x83\x77\x1E\x25\xA2\xA8\x74\x9B\xF3\x49\xF6\x6C\x5B\xA7\xDA\xC6"
           "\x18\x4B\x49\x42\x80\x20\x7F\xD9\xBB\x29\xC0\xF0\xD8\x81\xDC\x0A"
           "\x95\x53\x80\xF5\xA7\x52\x7E\x1E\x1E\x16\xB9\x5B\x79\xEE\x1F\x33"
           "\x50\x3A\xCC\x4E\xA1\x01\xC4\x55\xA8\x3B\xCB\x2B\xC8\xEB\xC5\x27"
           "\x5C\x21\xE3\x5B\xA1\x33\x60\xC6\x82\x76\xDD\x7C\x5F\xF0\x03\x24"
           "\xA7\x8E\x9B\x50\x8C\x46\xD5\xEB\xF5\x37\x81\x9B\xCD\x38\x01\x10"
           "\x1F\x9F\x0F\xBD\x78\x37\xC7\x02\x01\x03"
           , 138);
    nPKLen = 138;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8796 A5B4 C3D2 E1F0 */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           "\x59\x99\xC3\x06\xAB\x84\x01\xB2"
           , 24);
    nKeyLen = 24;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 138);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK =", bKeyByHMK, 24);
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1024，PKCS#1填充，三倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bKeyByPK    =", bKeyByPK, 128);
    ASSERT_OUT(nKeyByPKLen, 128);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_33(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\x97\x02\x81\x91\x00\xB4\xD4\xCD\x27\x2B\x0C\x7A\xBA\xA9"
           "\x32\x54\xA6\x0A\xD3\xDD\xAE\x80\x31\x47\x07\xC8\x48\x4F\x76\x03"
           "\x7C\x24\x4A\x59\x54\x0E\x99\x25\xD1\x3C\xB6\xE0\x20\xDB\xCB\x20"
           "\xB5\x23\x8F\x55\xDE\xF4\x31\xCD\x51\xE2\x1B\x07\xDC\xCC\x41\x6A"
           "\xAA\xBB\x0C\x5E\x3A\x61\x11\xA0\x90\xE0\xA9\x38\x86\x1C\x78\xE9"
           "\xAA\x75\xF2\x02\x38\x36\x19\x53\x4C\xE9\x21\x88\x43\x05\x8C\x7D"
           "\xDB\x60\x26\x36\x87\x24\xA7\xD5\x36\x39\x14\xD1\xEF\x66\x78\x1C"
           "\xBE\xD1\x56\xF9\x70\x77\xF7\xE0\xF1\x1B\x9D\x8D\x9C\xB6\x26\x5A"
           "\xE6\x3A\xC8\x18\x9F\x48\x03\x3D\x85\x06\x21\x71\xB2\x2C\x70\x98"
           "\x40\xA5\x39\xA0\xBD\x8D\xDB\x02\x01\x03"
           , 154);
    nPKLen = 154;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8796 A5B4 C3D2 E1F0 */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           "\x59\x99\xC3\x06\xAB\x84\x01\xB2"
           , 24);
    nKeyLen = 24;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 154);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK =", bKeyByHMK, 24);
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1152，PKCS#1填充，三倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bKeyByPK    =", bKeyByPK, 144);
    ASSERT_OUT(nKeyByPKLen, 144);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_34(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\xB7\x02\x81\xB1\x00\x9C\xDB\xEA\x10\x4A\xEE\x30\xD8\x58"
           "\xE1\xC7\x10\x81\xC8\x32\x40\x80\x1C\x94\x1E\xF6\xE9\x05\xC8\x0E"
           "\x41\x94\xE8\x88\x59\x72\xA8\x21\x22\x0C\x7B\x5F\x52\x8D\x65\xF0"
           "\xDD\x09\x56\x01\x71\xB6\x43\x64\x9A\x6E\x1F\xE3\x85\x7D\x2A\x27"
           "\xF7\x5A\xA3\xDB\x73\xA2\x99\xD6\x85\xAF\x86\x91\x7F\x19\xF5\x65"
           "\x7C\xA9\x71\xC1\x72\x38\x03\x8B\xDD\x83\x62\x79\x60\xB2\xB3\xE2"
           "\x7E\x41\x0D\x36\x50\x7C\xFA\xB0\x6E\xAE\x9E\x05\x5A\x55\xF8\x9C"
           "\x69\x71\x90\x77\x4C\xA3\x95\x29\x7D\xC1\x79\xFE\x7C\xD7\x96\x84"
           "\x0D\xC6\x30\x3F\x14\xDA\x88\xCF\x4A\xED\x5A\x7A\x71\x91\x5D\x25"
           "\x93\xDA\x0C\xB6\xCC\xB6\xD8\xE7\xF0\x54\x55\xA3\x93\xBD\xC0\xE7"
           "\x3E\xF8\x26\xFC\x5B\x37\xA5\x91\x01\x4B\xA2\x58\xBB\x59\xC2\x1E"
           "\xC8\x32\x3B\x85\x16\x8E\xF3\x02\x01\x03"
           , 186);
    nPKLen = 186;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8796 A5B4 C3D2 E1F0 */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           "\x59\x99\xC3\x06\xAB\x84\x01\xB2"
           , 24);
    nKeyLen = 24;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 186);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK =", bKeyByHMK, 24);
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1408，PKCS#1填充，三倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bKeyByPK    =", bKeyByPK, 176);
    ASSERT_OUT(nKeyByPKLen, 176);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_35(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\xFF\x02\x81\xF9\x00\xBE\xF9\x74\x44\x9A\xC3\x01\x48\x0B"
           "\x0A\xCD\xE1\xE5\x52\xE7\x55\x60\x91\x64\x8A\x46\x34\xEA\x1D\xDA"
           "\xEE\x52\x7B\x13\x92\x5F\x27\xAE\xA2\x66\xB5\xA5\xBB\x79\x4B\x09"
           "\x81\x7E\x7D\x95\x29\x16\xC5\xEF\xE0\x42\xF7\x7D\x5E\xE1\x72\x88"
           "\x0C\x1F\xDC\x76\x48\xA5\xB0\x26\x41\x8D\x4F\x70\x41\xB2\xAA\x70"
           "\x84\xC0\xAB\xFA\x95\xE9\x07\x6F\x73\x89\xE9\xD5\xAC\xD3\xBF\x72"
           "\x31\xA3\x30\x1E\xCA\x13\xDB\x1F\x1F\x44\xD1\x08\xD2\xFB\xF2\xB1"
           "\x6C\xF4\xBA\xAB\xF3\xBA\x36\x18\x25\x39\xD6\x0E\x3B\x4E\xBA\x93"
           "\xB2\xB4\xFA\x40\x7D\xCA\xE3\x96\x64\x05\x24\x79\x57\x95\xC6\x9D"
           "\xC7\x48\xB7\xFF\x55\x42\x07\x8A\x48\x84\x99\x61\x29\x52\x73\x0D"
           "\x8A\x97\x42\x6E\x67\x7C\x0A\xB3\x8B\xA9\x7C\x9C\x21\x67\x27\xD8"
           "\xB9\xDD\x14\x2C\x10\x65\xB8\x6F\x78\xBB\x64\x8A\x24\xAA\x78\x45"
           "\x7A\xB3\x54\xE6\xDF\x62\xE8\x71\xE3\x3C\x0C\x74\xD1\xFF\x02\x93"
           "\xDC\xB0\x01\x26\xEC\xAE\xCD\x4A\x3D\x22\xF7\x74\x42\xA6\xA0\xF2"
           "\xA1\x22\x72\x1E\x9C\x0F\x8C\xAF\xA2\x51\x2A\x23\xFF\x22\x49\xDD"
           "\x6C\x20\x4A\xEE\x7A\xCE\x81\xFB\xD1\x94\xAA\xF6\x5B\xC0\xDB\x02"
           "\x01\x03"
           , 258);
    nPKLen = 258;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8796 A5B4 C3D2 E1F0 */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           "\x59\x99\xC3\x06\xAB\x84\x01\xB2"
           , 24);
    nKeyLen = 24;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 258);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK =", bKeyByHMK, 24);
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1984，PKCS#1填充，三倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bKeyByPK    =", bKeyByPK, 248);
    ASSERT_OUT(nKeyByPKLen, 248);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_36(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 1;
    memcpy(bPK,
           "\x30\x82\x01\x08\x02\x82\x01\x01\x00\xC9\xD5\xA7\x6F\x4E\x62\xAD"
           "\x7A\xD8\x19\x85\x19\xB4\xDC\xE8\x88\xBB\x00\x10\xFF\x54\xA8\xC9"
           "\x61\xB5\x44\x2E\x53\x7D\xA4\x98\x7F\x27\xD6\x8A\x3E\x64\x92\x73"
           "\x59\x49\xFA\x81\x61\x8E\xD6\x66\x3C\x7E\xC0\xB3\x5D\x4E\xBB\x11"
           "\x01\x5B\xEE\x25\x53\x92\x33\x75\xA0\x3F\xBD\x02\xAB\x69\xE8\x0E"
           "\xF8\xC1\x98\x76\xDA\x81\x32\x66\x16\xEF\x7A\x0D\x6E\x4D\xB1\x74"
           "\xC8\xE8\x93\xE8\x1F\x00\x29\x7F\x46\x3C\x7C\x37\x0C\x7B\xF0\x78"
           "\xBA\x7D\x5D\xF9\x88\x9A\x86\x1E\xB8\x13\x59\xAA\x55\x1E\x5C\xBD"
           "\x2B\x7C\x36\xD8\xE5\x49\x83\xB5\xCB\x14\x4B\x1F\xEA\x02\x93\x07"
           "\xF0\x40\x24\xCD\x51\x96\x71\x22\xF0\x4A\x68\x2C\xCD\xDE\xF5\x0F"
           "\xFC\x34\x4A\x64\xA3\x52\xA1\xBE\xEE\x2C\xE7\x5C\x1A\x95\x8E\xFC"
           "\xA4\xAB\x65\xEB\x96\xBE\x43\x0F\xBD\x78\xFE\x6A\xDF\x48\xB9\x68"
           "\x66\x69\x6C\x68\xCC\xA4\x35\xD3\x2B\xA4\x2C\xDD\xBD\xC3\x65\x7B"
           "\x5C\xD9\x56\x67\xB9\x2E\x40\xFE\xEF\x02\xEF\xBD\x91\xFC\x88\x61"
           "\xCA\x82\x3D\xCA\x59\x1F\xD7\x8E\xAC\xCF\x2E\xD5\xB2\x95\xB8\x73"
           "\x20\xC4\x0A\xD0\xA5\x87\xE4\xD0\x8F\x77\x1B\xDC\x05\xE1\x7A\x54"
           "\x7D\xB8\xA6\x8E\x1B\xA9\xF0\xF4\xED\x02\x01\x03"
           , 268);
    nPKLen = 268;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8796 A5B4 C3D2 E1F0 */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           "\x59\x99\xC3\x06\xAB\x84\x01\xB2"
           , 24);
    nKeyLen = 24;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 268);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK =", bKeyByHMK, 24);
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-2048，PKCS#1填充，三倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bKeyByPK    =", bKeyByPK, 256);
    ASSERT_OUT(nKeyByPKLen, 256);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_37(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 2;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8796 A5B4 C3D2 E1F0 */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           "\x59\x99\xC3\x06\xAB\x84\x01\xB2"
           , 24);
    nKeyLen = 24;

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    printf("[IN ]nPadMode    = %d\n", nPadMode);
    DspHex("[IN ]bPK         =", bPK, 72);
    printf("[IN ]nPKLen      = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK   =", bKeyByHMK, 24);
    printf("[IN ]nKeyLen     = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "RSA-512，OAEP填充，三倍长密钥，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_38(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 2;
    memcpy(bPK,
           "\x30\x81\x87\x02\x81\x81\x00\xA6\xF5\x8A\x17\x12\x3F\x46\x59\x92"
           "\xC0\x92\x01\x7E\xD3\xA9\x67\x2A\x6A\x42\x8E\xDA\x6A\xC2\x53\x91"
           "\x83\x77\x1E\x25\xA2\xA8\x74\x9B\xF3\x49\xF6\x6C\x5B\xA7\xDA\xC6"
           "\x18\x4B\x49\x42\x80\x20\x7F\xD9\xBB\x29\xC0\xF0\xD8\x81\xDC\x0A"
           "\x95\x53\x80\xF5\xA7\x52\x7E\x1E\x1E\x16\xB9\x5B\x79\xEE\x1F\x33"
           "\x50\x3A\xCC\x4E\xA1\x01\xC4\x55\xA8\x3B\xCB\x2B\xC8\xEB\xC5\x27"
           "\x5C\x21\xE3\x5B\xA1\x33\x60\xC6\x82\x76\xDD\x7C\x5F\xF0\x03\x24"
           "\xA7\x8E\x9B\x50\x8C\x46\xD5\xEB\xF5\x37\x81\x9B\xCD\x38\x01\x10"
           "\x1F\x9F\x0F\xBD\x78\x37\xC7\x02\x01\x03"
           , 138);
    nPKLen = 138;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8796 A5B4 C3D2 E1F0 */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           "\x59\x99\xC3\x06\xAB\x84\x01\xB2"
           , 24);
    nKeyLen = 24;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 138);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK =", bKeyByHMK, 24);
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1024，OAEP填充，三倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bKeyByPK    =", bKeyByPK, 128);
    ASSERT_OUT(nKeyByPKLen, 128);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_39(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 2;
    memcpy(bPK,
           "\x30\x81\x97\x02\x81\x91\x00\xB4\xD4\xCD\x27\x2B\x0C\x7A\xBA\xA9"
           "\x32\x54\xA6\x0A\xD3\xDD\xAE\x80\x31\x47\x07\xC8\x48\x4F\x76\x03"
           "\x7C\x24\x4A\x59\x54\x0E\x99\x25\xD1\x3C\xB6\xE0\x20\xDB\xCB\x20"
           "\xB5\x23\x8F\x55\xDE\xF4\x31\xCD\x51\xE2\x1B\x07\xDC\xCC\x41\x6A"
           "\xAA\xBB\x0C\x5E\x3A\x61\x11\xA0\x90\xE0\xA9\x38\x86\x1C\x78\xE9"
           "\xAA\x75\xF2\x02\x38\x36\x19\x53\x4C\xE9\x21\x88\x43\x05\x8C\x7D"
           "\xDB\x60\x26\x36\x87\x24\xA7\xD5\x36\x39\x14\xD1\xEF\x66\x78\x1C"
           "\xBE\xD1\x56\xF9\x70\x77\xF7\xE0\xF1\x1B\x9D\x8D\x9C\xB6\x26\x5A"
           "\xE6\x3A\xC8\x18\x9F\x48\x03\x3D\x85\x06\x21\x71\xB2\x2C\x70\x98"
           "\x40\xA5\x39\xA0\xBD\x8D\xDB\x02\x01\x03"
           , 154);
    nPKLen = 154;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8796 A5B4 C3D2 E1F0 */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           "\x59\x99\xC3\x06\xAB\x84\x01\xB2"
           , 24);
    nKeyLen = 24;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 154);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK =", bKeyByHMK, 24);
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1152，OAEP填充，三倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bKeyByPK    =", bKeyByPK, 144);
    ASSERT_OUT(nKeyByPKLen, 144);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_40(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 2;
    memcpy(bPK,
           "\x30\x81\xB7\x02\x81\xB1\x00\x9C\xDB\xEA\x10\x4A\xEE\x30\xD8\x58"
           "\xE1\xC7\x10\x81\xC8\x32\x40\x80\x1C\x94\x1E\xF6\xE9\x05\xC8\x0E"
           "\x41\x94\xE8\x88\x59\x72\xA8\x21\x22\x0C\x7B\x5F\x52\x8D\x65\xF0"
           "\xDD\x09\x56\x01\x71\xB6\x43\x64\x9A\x6E\x1F\xE3\x85\x7D\x2A\x27"
           "\xF7\x5A\xA3\xDB\x73\xA2\x99\xD6\x85\xAF\x86\x91\x7F\x19\xF5\x65"
           "\x7C\xA9\x71\xC1\x72\x38\x03\x8B\xDD\x83\x62\x79\x60\xB2\xB3\xE2"
           "\x7E\x41\x0D\x36\x50\x7C\xFA\xB0\x6E\xAE\x9E\x05\x5A\x55\xF8\x9C"
           "\x69\x71\x90\x77\x4C\xA3\x95\x29\x7D\xC1\x79\xFE\x7C\xD7\x96\x84"
           "\x0D\xC6\x30\x3F\x14\xDA\x88\xCF\x4A\xED\x5A\x7A\x71\x91\x5D\x25"
           "\x93\xDA\x0C\xB6\xCC\xB6\xD8\xE7\xF0\x54\x55\xA3\x93\xBD\xC0\xE7"
           "\x3E\xF8\x26\xFC\x5B\x37\xA5\x91\x01\x4B\xA2\x58\xBB\x59\xC2\x1E"
           "\xC8\x32\x3B\x85\x16\x8E\xF3\x02\x01\x03"
           , 186);
    nPKLen = 186;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8796 A5B4 C3D2 E1F0 */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           "\x59\x99\xC3\x06\xAB\x84\x01\xB2"
           , 24);
    nKeyLen = 24;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 186);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK =", bKeyByHMK, 24);
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1408，OAEP填充，三倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bKeyByPK    =", bKeyByPK, 176);
    ASSERT_OUT(nKeyByPKLen, 176);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_41(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 2;
    memcpy(bPK,
           "\x30\x81\xFF\x02\x81\xF9\x00\xBE\xF9\x74\x44\x9A\xC3\x01\x48\x0B"
           "\x0A\xCD\xE1\xE5\x52\xE7\x55\x60\x91\x64\x8A\x46\x34\xEA\x1D\xDA"
           "\xEE\x52\x7B\x13\x92\x5F\x27\xAE\xA2\x66\xB5\xA5\xBB\x79\x4B\x09"
           "\x81\x7E\x7D\x95\x29\x16\xC5\xEF\xE0\x42\xF7\x7D\x5E\xE1\x72\x88"
           "\x0C\x1F\xDC\x76\x48\xA5\xB0\x26\x41\x8D\x4F\x70\x41\xB2\xAA\x70"
           "\x84\xC0\xAB\xFA\x95\xE9\x07\x6F\x73\x89\xE9\xD5\xAC\xD3\xBF\x72"
           "\x31\xA3\x30\x1E\xCA\x13\xDB\x1F\x1F\x44\xD1\x08\xD2\xFB\xF2\xB1"
           "\x6C\xF4\xBA\xAB\xF3\xBA\x36\x18\x25\x39\xD6\x0E\x3B\x4E\xBA\x93"
           "\xB2\xB4\xFA\x40\x7D\xCA\xE3\x96\x64\x05\x24\x79\x57\x95\xC6\x9D"
           "\xC7\x48\xB7\xFF\x55\x42\x07\x8A\x48\x84\x99\x61\x29\x52\x73\x0D"
           "\x8A\x97\x42\x6E\x67\x7C\x0A\xB3\x8B\xA9\x7C\x9C\x21\x67\x27\xD8"
           "\xB9\xDD\x14\x2C\x10\x65\xB8\x6F\x78\xBB\x64\x8A\x24\xAA\x78\x45"
           "\x7A\xB3\x54\xE6\xDF\x62\xE8\x71\xE3\x3C\x0C\x74\xD1\xFF\x02\x93"
           "\xDC\xB0\x01\x26\xEC\xAE\xCD\x4A\x3D\x22\xF7\x74\x42\xA6\xA0\xF2"
           "\xA1\x22\x72\x1E\x9C\x0F\x8C\xAF\xA2\x51\x2A\x23\xFF\x22\x49\xDD"
           "\x6C\x20\x4A\xEE\x7A\xCE\x81\xFB\xD1\x94\xAA\xF6\x5B\xC0\xDB\x02"
           "\x01\x03"
           , 258);
    nPKLen = 258;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8796 A5B4 C3D2 E1F0 */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           "\x59\x99\xC3\x06\xAB\x84\x01\xB2"
           , 24);
    nKeyLen = 24;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 258);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK =", bKeyByHMK, 24);
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1984，OAEP填充，三倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bKeyByPK    =", bKeyByPK, 248);
    ASSERT_OUT(nKeyByPKLen, 248);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_42(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 2;
    memcpy(bPK,
           "\x30\x82\x01\x08\x02\x82\x01\x01\x00\xC9\xD5\xA7\x6F\x4E\x62\xAD"
           "\x7A\xD8\x19\x85\x19\xB4\xDC\xE8\x88\xBB\x00\x10\xFF\x54\xA8\xC9"
           "\x61\xB5\x44\x2E\x53\x7D\xA4\x98\x7F\x27\xD6\x8A\x3E\x64\x92\x73"
           "\x59\x49\xFA\x81\x61\x8E\xD6\x66\x3C\x7E\xC0\xB3\x5D\x4E\xBB\x11"
           "\x01\x5B\xEE\x25\x53\x92\x33\x75\xA0\x3F\xBD\x02\xAB\x69\xE8\x0E"
           "\xF8\xC1\x98\x76\xDA\x81\x32\x66\x16\xEF\x7A\x0D\x6E\x4D\xB1\x74"
           "\xC8\xE8\x93\xE8\x1F\x00\x29\x7F\x46\x3C\x7C\x37\x0C\x7B\xF0\x78"
           "\xBA\x7D\x5D\xF9\x88\x9A\x86\x1E\xB8\x13\x59\xAA\x55\x1E\x5C\xBD"
           "\x2B\x7C\x36\xD8\xE5\x49\x83\xB5\xCB\x14\x4B\x1F\xEA\x02\x93\x07"
           "\xF0\x40\x24\xCD\x51\x96\x71\x22\xF0\x4A\x68\x2C\xCD\xDE\xF5\x0F"
           "\xFC\x34\x4A\x64\xA3\x52\xA1\xBE\xEE\x2C\xE7\x5C\x1A\x95\x8E\xFC"
           "\xA4\xAB\x65\xEB\x96\xBE\x43\x0F\xBD\x78\xFE\x6A\xDF\x48\xB9\x68"
           "\x66\x69\x6C\x68\xCC\xA4\x35\xD3\x2B\xA4\x2C\xDD\xBD\xC3\x65\x7B"
           "\x5C\xD9\x56\x67\xB9\x2E\x40\xFE\xEF\x02\xEF\xBD\x91\xFC\x88\x61"
           "\xCA\x82\x3D\xCA\x59\x1F\xD7\x8E\xAC\xCF\x2E\xD5\xB2\x95\xB8\x73"
           "\x20\xC4\x0A\xD0\xA5\x87\xE4\xD0\x8F\x77\x1B\xDC\x05\xE1\x7A\x54"
           "\x7D\xB8\xA6\x8E\x1B\xA9\xF0\xF4\xED\x02\x01\x03"
           , 268);
    nPKLen = 268;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8796 A5B4 C3D2 E1F0 */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           "\x59\x99\xC3\x06\xAB\x84\x01\xB2"
           , 24);
    nKeyLen = 24;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHexExt("[IN ]bPK =", bPK, 268);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK =", bKeyByHMK, 24);
    printf("[IN ]nKeyLen = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-2048，OAEP填充，三倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bKeyByPK    =", bKeyByPK, 256);
    ASSERT_OUT(nKeyByPKLen, 256);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_43(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nSock = -1;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           , 8);
    nKeyLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    printf("[IN ]nPadMode    = %d\n", nPadMode);
    DspHex("[IN ]bPK         =", bPK, 72);
    printf("[IN ]nPKLen      = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK   =", bKeyByHMK, 8);
    printf("[IN ]nKeyLen     = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_44(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nSock = 8;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           , 8);
    nKeyLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    printf("[IN ]nPadMode    = %d\n", nPadMode);
    DspHex("[IN ]bPK         =", bPK, 72);
    printf("[IN ]nPKLen      = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK   =", bKeyByHMK, 8);
    printf("[IN ]nKeyLen     = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[8]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_45(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = -1;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           , 8);
    nKeyLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    printf("[IN ]nPadMode    = %d\n", nPadMode);
    DspHex("[IN ]bPK         =", bPK, 72);
    printf("[IN ]nPKLen      = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK   =", bKeyByHMK, 8);
    printf("[IN ]nKeyLen     = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效填充模式[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_46(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 3;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           , 8);
    nKeyLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    printf("[IN ]nPadMode    = %d\n", nPadMode);
    DspHex("[IN ]bPK         =", bPK, 72);
    printf("[IN ]nPKLen      = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK   =", bKeyByHMK, 8);
    printf("[IN ]nKeyLen     = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效填充模式[3]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_47(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 1;
    nPKLen = 0;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           , 8);
    nKeyLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    printf("[IN ]nPadMode    = %d\n", nPadMode);
    DspHex("[IN ]bPK         =", bPK, 0);
    printf("[IN ]nPKLen      = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK   =", bKeyByHMK, 8);
    printf("[IN ]nKeyLen     = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效公钥长度=0测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_48(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 1;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 71);
    nPKLen = 71;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           , 8);
    nKeyLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    printf("[IN ]nPadMode    = %d\n", nPadMode);
    DspHex("[IN ]bPK         =", bPK, 71);
    printf("[IN ]nPKLen      = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK   =", bKeyByHMK, 8);
    printf("[IN ]nKeyLen     = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效公钥长度=71测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_49(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 1;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    nKeyLen = 0;

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    printf("[IN ]nPadMode    = %d\n", nPadMode);
    DspHex("[IN ]bPK         =", bPK, 72);
    printf("[IN ]nPKLen      = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK   =", bKeyByHMK, 0);
    printf("[IN ]nKeyLen     = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效数据长度=0测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyOutofPK_Test_50(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);

    nPadMode = 1;
    memcpy(bPK,
           "\x30\x46\x02\x41\x00\xD2\x95\x1E\x73\x28\xAF\x7A\x32\xF6\x06\x61"
           "\x0A\x0E\x5B\x2B\xE9\x03\x1F\x0B\xDA\xE6\x55\x95\xAD\x6F\xC7\xF6"
           "\x52\x94\x18\xDE\x5A\xAF\x54\xE4\x75\x83\x54\x08\x1D\x09\xCE\x3F"
           "\x41\xC5\x2E\xDB\x2D\xE2\x09\x8B\x82\x19\xF1\xED\x1B\x9E\x52\xDE"
           "\x2C\xEB\xFB\x3F\xB3\x02\x01\x03"
           , 72);
    nPKLen = 72;
    /* 0123 4567 89AB CDEF */
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           , 8);
    nKeyLen = 2056;

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    printf("[IN ]nPadMode    = %d\n", nPadMode);
    DspHex("[IN ]bPK         =", bPK, 72);
    printf("[IN ]nPKLen      = %d\n", nPKLen);
    DspHex("[IN ]bKeyByHMK   =", bKeyByHMK, 2056);
    printf("[IN ]nKeyLen     = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyOutofPK(nSock, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效数据长度=2056测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DisreteSubKey_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int nDivNum;
	  int nIccType;
	  int nAlgo;
	  unsigned char  bKek[32];
	  unsigned char  bMasterKey[32];
	  unsigned char  bCardFactor[8];
	  unsigned char  bSessionFactor[4];
	  unsigned char  bSubKey[32];
	  unsigned char  szCheckValue[16];
	  unsigned char  bSubKeyExp[32];
	  unsigned char  szCheckValueExp[16];

    bufclr(bKek);
    bufclr(bMasterKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bSubKey);
    bufclr(szCheckValue);

    nDivNum = 1;
    nIccType = 0x00000000;	
    nAlgo = 2;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKek,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           , 16);
    /* F431 623E 4997 89C8 C2F1 F725 AD7F 8949 */
    memcpy(bMasterKey,
           "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
           , 16);
    memcpy(bCardFactor,
           "\x25\x00\x00\x00\x00\x00\x89\x01"
           , 8);
    memcpy(bSessionFactor,
           "\x00\x02"
           , 2);
    /* 89E9 1FCB 266D 7C51 A437 AE51 2F10 5225 */
    memcpy(bSubKeyExp,
           "\xB9\x80\xE9\x91\xA7\xC6\x6F\x30\x21\x2C\xDE\x6F\xB4\x7A\x59\xD9"
           , 16);
    /* 09F1 C278 E411 C078 */
    memcpy(szCheckValueExp,
           "09F1C278"
           , 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nDivNum        = %d\n", nDivNum);
    printf("[IN ]nIccType       = %x\n", nIccType);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKek           =", bKek, 16);
    DspHex("[IN ]bMasterKey     =", bMasterKey, 16);
    DspHex("[IN ]bCardFactor    =", bCardFactor, 8);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 2);
    XXX_INPUT_XXX


    /* Call Test Target Function Start */
    nRet = SMAPIDisreteSubKey(nSock, nDivNum, nIccType, nAlgo, bKek, \
                              bMasterKey, bCardFactor, bSessionFactor, \
                              bSubKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "PBOC卡，二倍KEK，一次离散测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bSubKey, bSubKeyExp, 16);
    ASSERT_OUT_HEX(szCheckValue, szCheckValueExp, 8);
    XXX_OUTPUT_XXX

    DspHex("[RESULT ]expected subkey    =", bSubKeyExp, 16);
    DspHex("[RESULT ]disreted subkey =", bSubKey, 16);
    DspHex("[RESULT ]expected checkvalue    =", szCheckValueExp, 8);
    DspHex("[RESULT]disreted checkvalue =", szCheckValue, 8);

    XXX_TEST_END_XXX
}

void DisreteSubKey_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int nDivNum;
	  int nIccType;
	  int nAlgo;
	  unsigned char  bKek[32];
	  unsigned char  bMasterKey[32];
	  unsigned char  bCardFactor[8];
	  unsigned char  bSessionFactor[4];
	  unsigned char  bSubKey[32];
	  unsigned char  szCheckValue[16];
	  unsigned char  bSubKeyExp[32];
	  unsigned char  szCheckValueExp[16];

    bufclr(bKek);
    bufclr(bMasterKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bSubKey);
    bufclr(szCheckValue);

    nDivNum = 2;
    nIccType = 0x00000000;
    nAlgo = 2;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKek,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           , 16);
    /* F431 623E 4997 89C8 C2F1 F725 AD7F 8949 */
    memcpy(bMasterKey,
           "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
           , 16);
    memcpy(bCardFactor,
           "\x25\x00\x00\x00\x00\x00\x89\x01"
           , 8);
    memcpy(bSessionFactor,
           "\x00\x02"
           , 2);
    /* 4FA1 BA64 DC85 58BF EC43 C210 F4FD 4610 */
    memcpy(bSubKeyExp,
           "\xAE\x75\x8D\x48\xCC\x51\x5A\x30\xE9\x5F\x0C\x2F\x62\x34\xD2\xF1"
           , 16);
    /* 04BC 620F 4E58 684D */
    memcpy(szCheckValueExp,
           "04BC620F"
           , 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nDivNum        = %d\n", nDivNum);
    printf("[IN ]nIccType       = %x\n", nIccType);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKek           =", bKek, 16);
    DspHex("[IN ]bMasterKey     =", bMasterKey, 16);
    DspHex("[IN ]bCardFactor    =", bCardFactor, 8);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 2);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDisreteSubKey(nSock, nDivNum, nIccType, nAlgo, bKek, \
                              bMasterKey, bCardFactor, bSessionFactor, \
                              bSubKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "PBOC卡，二倍KEK，二次离散测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bSubKey, bSubKeyExp, 16);
    ASSERT_OUT_HEX(szCheckValue, szCheckValueExp, 8);
    XXX_OUTPUT_XXX
		
    DspHex("[RESULT ]expected subkey	=", bSubKeyExp, 16);
    DspHex("[RESULT ]disreted subkey =", bSubKey, 16);
    DspHex("[RESULT ]expected checkvalue	=", szCheckValueExp, 8);
    DspHex("[RESULT]disreted checkvalue =", szCheckValue, 8);

    XXX_TEST_END_XXX
}

void DisreteSubKey_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int nDivNum;
	  int nIccType;
	  int nAlgo;
	  unsigned char  bKek[32];
	  unsigned char  bMasterKey[32];
	  unsigned char  bCardFactor[16];
	  unsigned char  bLeftCardFactor[8];
	  unsigned char bRightCardFactor[8];
	  unsigned char  bSessionFactor[4];
	  unsigned char  bSubKey[32];
	  unsigned char  szCheckValue[16];
	  unsigned char  bSubKeyExp[32];
	  unsigned char  szCheckValueExp[16];

    bufclr(bKek);
    bufclr(bMasterKey);
    bufclr(bCardFactor);
    bufclr(bLeftCardFactor);
    bufclr(bRightCardFactor);
    bufclr(bSessionFactor);
    bufclr(bSubKey);
    bufclr(szCheckValue);

    nDivNum = 1;
    nIccType = 0x0001000A;
    nAlgo = 2;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKek,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           , 16);
    /* F431 623E 4997 89C8 C2F1 F725 AD7F 8949 */
    memcpy(bMasterKey,
           "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
           , 16);
    memcpy(bLeftCardFactor,  "\x25\x00\x00\x00\x00\x00\x89\x01" ,8);
    memcpy(bRightCardFactor,   "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF" ,8); 
    SSMBinStrXOR(bRightCardFactor, bLeftCardFactor, bRightCardFactor, 8);
    memcpy(&bCardFactor[0], bLeftCardFactor, 8);
    memcpy(&bCardFactor[8], bRightCardFactor, 8);

     /*89E8 1ECA 276C 7D50 A537 AE51 2E11 5224*/
    memcpy(bSubKeyExp,
           "\xDA\x5E\x25\x93\x43\xEE\x5C\x9D\x79\xB1\xC5\xAD\x1D\xB4\x6A\x23"
           , 16);
	
    /* 09F1 C278 E411 C078 */
    memcpy(szCheckValueExp,
           "09F1C278"
           , 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nDivNum        = %d\n", nDivNum);
    printf("[IN ]nIccType       = %x\n", nIccType);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKek           =", bKek, 16);
    DspHex("[IN ]bMasterKey     =", bMasterKey, 16);
    DspHex("[IN ]bCardFactor    =", bCardFactor, 16);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 2);	
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDisreteSubKey(nSock, nDivNum, nIccType, nAlgo, bKek, \
                              bMasterKey, bCardFactor, bSessionFactor, \
                              bSubKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "VISA卡，二倍KEK，一次离散测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bSubKey, bSubKeyExp, 16);
    ASSERT_OUT_HEX(szCheckValue, szCheckValueExp, 8);
    XXX_OUTPUT_XXX

    DspHex("[RESULT ]expected subkey	=", bSubKeyExp, 16);
    DspHex("[RESULT ]disreted subkey =", bSubKey, 16);
    DspHex("[RESULT ]expected checkvalue	=", szCheckValueExp, 8);
    DspHex("[RESULT]disreted checkvalue =", szCheckValue, 8);

    XXX_TEST_END_XXX
}

void DisreteSubKey_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int nDivNum;
	  int nIccType;
	  int nAlgo;
	  unsigned char  bKek[32];
	  unsigned char  bMasterKey[32];
	  unsigned char  bCardFactor[16];
	  unsigned char  bSubCardKey[16];
	  unsigned char  bATC[4];
	  unsigned char bSessionSeed[16];
	  unsigned char  bSubKey[16];
	  unsigned char  szCheckValue[16];
	  unsigned char  bSubKeyExp[32];
	  unsigned char  szCheckValueExp[16];

    bufclr(bKek);
    bufclr(bMasterKey);
    bufclr(bCardFactor);
    bufclr(bSubCardKey);
    bufclr(bATC);
    memset(bSessionSeed,0,16);
    bufclr(bSubKey);
    bufclr(szCheckValue);

    nDivNum = 2;
    nIccType = 0x0001000A;
    nAlgo = 2;
	
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKek,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           , 16);
    /* F431 623E 4997 89C8 C2F1 F725 AD7F 8949 */
    memcpy(bMasterKey,
           "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
           , 16);
    memcpy(bCardFactor,
           "\x25\x00\x00\x00\x00\x00\x89\x01"
           , 8);	
   memset(&bCardFactor[8], 0xFF, 8);
   SSMBinStrXOR(&bCardFactor[8], &bCardFactor[8],  bCardFactor,  8);
   
    memcpy(bSubCardKey, 
		"\x89\xE8\x1E\xCA\x27\x6C\x7D\x50\xA5\x37\xAE\x51\x2E\x11\x52\x24"
	  ,16);
	
    memcpy(bATC,  "\x00\x02", 2);
    memcpy(&bSessionSeed[6], bATC, 2);
    memset(&bSessionSeed[14], 0xFF, 2);
    SSMBinStrXOR(&bSessionSeed[14], bATC,  &bSessionSeed[14], 2);

    //SSMBinStrXOR(bSubKeyExp, bSessionSeed, bSubCardKey, 16);
    /* 89 E8 1E CA 27 6C 7D 52 A5 37 AE 51 2E 11 AD D9 */
    memcpy(bSubKeyExp,
           "\x1B\x25\x40\xE5\x2E\x2C\xDA\xE4\x42\x0D\xC8\x5A\x1C\xB7\x5B\x28"
           , 16);
	
    /* D701 16E2 503E 3CC8 */
    memcpy(szCheckValueExp,
           "D70116E2"
           , 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nDivNum        = %d\n", nDivNum);
    printf("[IN ]nIccType       = %x\n", nIccType);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKek           =", bKek, 16);
    DspHex("[IN ]bMasterKey     =", bMasterKey, 16);
    DspHex("[IN ]bCardFactor    =", bCardFactor, 16);
    DspHex("[IN ]bSubCardKey    =", bSubCardKey, 16);
    DspHex("[IN ]bATC =", bATC, 2);
    DspHex("[IN ]bSessionSeed =", bSessionSeed, 16);
    DspHex("[OUT] bSubKeyExp=", bSubKeyExp, 16);	
    XXX_INPUT_XXX
	
    /* Call Test Target Function Start */
    nRet = SMAPIDisreteSubKey(nSock, nDivNum, nIccType, nAlgo, bKek, \
                              bMasterKey, bCardFactor, bSessionSeed, \
                              bSubKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "VISA卡，二倍KEK，二次离散脚本会话密钥未成功");
    XXX_RESULT_XXX
		
    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bSubKey, bSubKeyExp, 16);
    ASSERT_OUT_HEX(szCheckValue, szCheckValueExp, 8);
    XXX_OUTPUT_XXX

    DspHex("[RESULT ]expected subkey	=", bSubKeyExp, 16);
    DspHex("[RESULT ]disreted subkey =", bSubKey, 16);
    DspHex("[RESULT ]expected checkvalue	=", szCheckValueExp, 8);
    DspHex("[RESULT]disreted checkvalue =", szCheckValue, 8);

    XXX_TEST_END_XXX
}

void DisreteSubKey_Test_05(void)
{
    XXX_TEST_START_XXX
    int nRet;
    int nSock = SM_SOCK;

	  int nDivNum;
	  int nIccType;
	  int nAlgo;
	  unsigned char  bKek[32];
	  unsigned char  bMasterKey[32];
	  unsigned char  bCardFactor[8];
	  unsigned char  bSessionFactor[4];
	  unsigned char  bSubKey[32];
	  unsigned char  szCheckValue[16];
	  unsigned char  bSubKeyExp[32];
	  unsigned char  szCheckValueExp[16];

    bufclr(bKek);
    bufclr(bMasterKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bSubKey);
    bufclr(szCheckValue);

    nDivNum = 1;
    nIccType = 0x00000000;
    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKek,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           , 8);
    /* F431 623E 4997 89C8 C2F1 F725 AD7F 8949 */
    memcpy(bMasterKey,
           "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
           , 16);
    memcpy(bCardFactor,
           "\x25\x00\x00\x00\x00\x00\x89\x01"
           , 8);
    memcpy(bSessionFactor,
           "\x00\x02"
           , 2);
    /* 89E9 1FCB 266D 7C51 A437 AE51 2F10 5225 */
    memcpy(bSubKeyExp,
           "\x4C\xFF\x06\xC4\xDF\xE3\x28\x29\xF7\x12\x38\x90\xE0\x3A\x2E\xDE"
           , 16);
    /* 09F1 C278 E411 C078 */
    memcpy(szCheckValueExp,
           "09F1C278"
           , 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nDivNum        = %d\n", nDivNum);
    printf("[IN ]nIccType       = %d\n", nIccType);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKek           =", bKek, 16);
    DspHex("[IN ]bMasterKey     =", bMasterKey, 16);
    DspHex("[IN ]bCardFactor    =", bCardFactor, 8);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 2);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDisreteSubKey(nSock, nDivNum, nIccType, nAlgo, bKek, \
                              bMasterKey, bCardFactor, bSessionFactor, \
                              bSubKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "PBOC卡，单倍KEK，一次离散测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bSubKey, bSubKeyExp, 16);
    ASSERT_OUT_HEX(szCheckValue, szCheckValueExp, 8);
    XXX_OUTPUT_XXX

    DspHex("[RESULT ]expected subkey	=", bSubKeyExp, 16);
    DspHex("[RESULT ]disreted subkey =", bSubKey, 16);
    DspHex("[RESULT ]expected checkvalue	=", szCheckValueExp, 8);
    DspHex("[RESULT]disreted checkvalue =", szCheckValue, 8);

    XXX_TEST_END_XXX
}

void DisreteSubKey_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int nDivNum;
	  int nIccType;
	  int nAlgo;
	  unsigned char  bKek[32];
	  unsigned char  bMasterKey[32];
	  unsigned char  bCardFactor[8];
	  unsigned char  bSessionFactor[4];
	  unsigned char  bSubKey[32];
	  unsigned char  szCheckValue[16];
	  unsigned char  bSubKeyExp[32];
	  unsigned char  szCheckValueExp[16];

    bufclr(bKek);
    bufclr(bMasterKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bSubKey);
    bufclr(szCheckValue);

    nDivNum = 2;
    nIccType = 0x00000000;
    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKek,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           , 8);
    /* F431 623E 4997 89C8 C2F1 F725 AD7F 8949 */
    memcpy(bMasterKey,
           "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
           , 16);
    memcpy(bCardFactor,
           "\x25\x00\x00\x00\x00\x00\x89\x01"
           , 8);
    memcpy(bSessionFactor,
           "\x00\x02"
           , 2);
    /* 4FA1 BA64 DC85 58BF EC43 C210 F4FD 4610 */
    memcpy(bSubKeyExp,
           "\x2C\x52\xE0\x25\xF9\x6B\xF0\x2F\x13\xF2\x52\x1E\xBF\x37\x73\x7F"
           , 16);
    /* 04BC 620F 4E58 684D */
    memcpy(szCheckValueExp,
           "04BC620F"
           , 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nDivNum        = %d\n", nDivNum);
    printf("[IN ]nIccType       = %d\n", nIccType);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKek           =", bKek, 16);
    DspHex("[IN ]bMasterKey     =", bMasterKey, 16);
    DspHex("[IN ]bCardFactor    =", bCardFactor, 8);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 2);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDisreteSubKey(nSock, nDivNum, nIccType, nAlgo, bKek, \
                              bMasterKey, bCardFactor, bSessionFactor, \
                              bSubKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "PBOC卡，单倍KEK，二次离散测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bSubKey, bSubKeyExp, 16);
    ASSERT_OUT_HEX(szCheckValue, szCheckValueExp, 8);
    XXX_OUTPUT_XXX

    DspHex("[RESULT ]expected subkey	=", bSubKeyExp, 16);
    DspHex("[RESULT ]disreted subkey =", bSubKey, 16);
    DspHex("[RESULT ]expected checkvalue	=", szCheckValueExp, 8);
    DspHex("[RESULT]disreted checkvalue =", szCheckValue, 8);

    XXX_TEST_END_XXX
}

void DisreteSubKey_Test_07(void)
{
    XXX_TEST_START_XXX
    int nRet;
    int nSock = SM_SOCK;

	  int nDivNum;
	  int nIccType;
	  int nAlgo;
	  unsigned char  bKek[32];
	  unsigned char  bMasterKey[32];
	  unsigned char  bCardFactor[8];
	  unsigned char  bSessionFactor[4];
	  unsigned char  bSubKey[32];
	  unsigned char  szCheckValue[16];
	  unsigned char  bSubKeyExp[32];
	  unsigned char  szCheckValueExp[16];

    bufclr(bKek);
    bufclr(bMasterKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bSubKey);
    bufclr(szCheckValue);

    nDivNum = 1;
    nIccType = 0x00000000;
    nAlgo = 3;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8796 A5B4 C3D2 E1F0 */
    memcpy(bKek,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           "\x59\x99\xC3\x06\xAB\x84\x01\xB2"
           , 24);
    /* F431 623E 4997 89C8 C2F1 F725 AD7F 8949 */
    memcpy(bMasterKey,
           "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
           , 16);
    memcpy(bCardFactor,
           "\x25\x00\x00\x00\x00\x00\x89\x01"
           , 8);
    memcpy(bSessionFactor,
           "\x00\x02"
           , 2);
    /* 89E9 1FCB 266D 7C51 A437 AE51 2F10 5225 */
    memcpy(bSubKeyExp,
           "\x97\xC0\xB3\xE6\x38\x60\x7D\xB7\x89\x95\xC6\x37\xE4\x69\xAC\x74"
           , 16);
    /* 09F1 C278 E411 C078 */
    memcpy(szCheckValueExp,
           "09F1C278"
           , 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nDivNum        = %d\n", nDivNum);
    printf("[IN ]nIccType       = %d\n", nIccType);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKek           =", bKek, 16);
    DspHex("[IN ]bMasterKey     =", bMasterKey, 16);
    DspHex("[IN ]bCardFactor    =", bCardFactor, 8);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 2);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDisreteSubKey(nSock, nDivNum, nIccType, nAlgo, bKek, \
                              bMasterKey, bCardFactor, bSessionFactor, \
                              bSubKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "PBOC卡，三倍长密钥，一次离散测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bSubKey, bSubKeyExp, 16);
    ASSERT_OUT_HEX(szCheckValue, szCheckValueExp, 8);
    XXX_OUTPUT_XXX
		
    DspHex("[RESULT ]expected subkey	=", bSubKeyExp, 16);
    DspHex("[RESULT ]disreted subkey =", bSubKey, 16);
    DspHex("[RESULT ]expected checkvalue	=", szCheckValueExp, 8);
    DspHex("[RESULT]disreted checkvalue =", szCheckValue, 8);

    XXX_TEST_END_XXX
}

void DisreteSubKey_Test_08(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int nDivNum;
	  int nIccType;
	  int nAlgo;
	  unsigned char  bKek[32];
	  unsigned char  bMasterKey[32];
	  unsigned char  bCardFactor[8];
	  unsigned char  bSessionFactor[4];
	  unsigned char  bSubKey[32];
	  unsigned char  szCheckValue[16];
	  unsigned char  bSubKeyExp[32];
	  unsigned char  szCheckValueExp[16];

    bufclr(bKek);
    bufclr(bMasterKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bSubKey);
    bufclr(szCheckValue);

    nDivNum = 2;
    nIccType = 0x00000000;
    nAlgo = 3;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8796 A5B4 C3D2 E1F0 */
    memcpy(bKek,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           "\x59\x99\xC3\x06\xAB\x84\x01\xB2"
           , 24);
    /* F431 623E 4997 89C8 C2F1 F725 AD7F 8949 */
    memcpy(bMasterKey,
           "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
           , 16);
    memcpy(bCardFactor,
           "\x25\x00\x00\x00\x00\x00\x89\x01"
           , 8);
    memcpy(bSessionFactor,
           "\x00\x02"
           , 2);
    /* 4FA1 BA64 DC85 58BF EC43 C210 F4FD 4610 */
    memcpy(bSubKeyExp,
           "\x08\xB6\x5B\x2F\x55\x95\x20\xC4\xC4\x64\x84\xA5\x10\xB4\x68\x9B"
           , 16);
    /* 04BC 620F 4E58 684D */
    memcpy(szCheckValueExp,
           "04BC620F"
           , 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nDivNum        = %d\n", nDivNum);
    printf("[IN ]nIccType       = %d\n", nIccType);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKek           =", bKek, 16);
    DspHex("[IN ]bMasterKey     =", bMasterKey, 16);
    DspHex("[IN ]bCardFactor    =", bCardFactor, 8);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 2);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDisreteSubKey(nSock, nDivNum, nIccType, nAlgo, bKek, \
                              bMasterKey, bCardFactor, bSessionFactor, \
                              bSubKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "PBOC卡，三倍长密钥，二次离散测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bSubKey, bSubKeyExp, 16);
    ASSERT_OUT_HEX(szCheckValue, szCheckValueExp, 8);
    XXX_OUTPUT_XXX
		
    DspHex("[RESULT ]expected subkey	=", bSubKeyExp, 16);
    DspHex("[RESULT ]disreted subkey =", bSubKey, 16);
    DspHex("[RESULT ]expected checkvalue	=", szCheckValueExp, 8);
    DspHex("[RESULT]disreted checkvalue =", szCheckValue, 8);

    XXX_TEST_END_XXX
}

void DisreteSubKey_Test_09(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int nDivNum;
	  int nIccType;
	  int nAlgo;
	  unsigned char  bKek[32];
	  unsigned char  bMasterKey[32];
	  unsigned char  bCardFactor[8];
	  unsigned char  bSessionFactor[4];
	  unsigned char  bSubKey[32];
	  unsigned char  szCheckValue[16];
	  unsigned char  bSubKeyExp[32];
	  unsigned char  szCheckValueExp[16];

    bufclr(bKek);
    bufclr(bMasterKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bSubKey);
    bufclr(szCheckValue);

    nSock = -1;
    nDivNum = 1;
    nIccType = 0x00000000;
    nAlgo = 2;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKek,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           , 16);
    /* F431 623E 4997 89C8 C2F1 F725 AD7F 8949 */
    memcpy(bMasterKey,
           "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
           , 16);
    memcpy(bCardFactor,
           "\x25\x00\x00\x00\x00\x00\x89\x01"
           , 8);
    memcpy(bSessionFactor,
           "\x00\x02"
           , 2);
    /* 89E9 1FCB 266D 7C51 A437 AE51 2F10 5225 */
    memcpy(bSubKeyExp,
           "\xB9\x80\xE9\x91\xA7\xC6\x6F\x30\x21\x2C\xDE\x6F\xB4\x7A\x59\xD9"
           , 16);
    /* 09F1 C278 E411 C078 */
    memcpy(szCheckValueExp,
           "09F1C278"
           , 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nDivNum        = %d\n", nDivNum);
    printf("[IN ]nIccType       = %d\n", nIccType);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKek           =", bKek, 16);
    DspHex("[IN ]bMasterKey     =", bMasterKey, 16);
    DspHex("[IN ]bCardFactor    =", bCardFactor, 8);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 2);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDisreteSubKey(nSock, nDivNum, nIccType, nAlgo, bKek, \
                              bMasterKey, bCardFactor, bSessionFactor, \
                              bSubKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效Socket ID[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void DisreteSubKey_Test_10(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int nDivNum;
	  int nIccType;
	  int nAlgo;
	  unsigned char  bKek[32];
	  unsigned char  bMasterKey[32];
	  unsigned char  bCardFactor[8];
	  unsigned char  bSessionFactor[4];
	  unsigned char  bSubKey[32];
	  unsigned char  szCheckValue[16];
	  unsigned char  bSubKeyExp[32];
	  unsigned char  szCheckValueExp[16];

    bufclr(bKek);
    bufclr(bMasterKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bSubKey);
    bufclr(szCheckValue);

    nSock = 8;
    nDivNum = 1;
    nIccType = 0x00000000;
    nAlgo = 2;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKek,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           , 16);
    /* F431 623E 4997 89C8 C2F1 F725 AD7F 8949 */
    memcpy(bMasterKey,
           "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
           , 16);
    memcpy(bCardFactor,
           "\x25\x00\x00\x00\x00\x00\x89\x01"
           , 8);
    memcpy(bSessionFactor,
           "\x00\x02"
           , 2);
    /* 89E9 1FCB 266D 7C51 A437 AE51 2F10 5225 */
    memcpy(bSubKeyExp,
           "\xB9\x80\xE9\x91\xA7\xC6\x6F\x30\x21\x2C\xDE\x6F\xB4\x7A\x59\xD9"
           , 16);
    /* 09F1 C278 E411 C078 */
    memcpy(szCheckValueExp,
           "09F1C278"
           , 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nDivNum        = %d\n", nDivNum);
    printf("[IN ]nIccType       = %d\n", nIccType);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKek           =", bKek, 16);
    DspHex("[IN ]bMasterKey     =", bMasterKey, 16);
    DspHex("[IN ]bCardFactor    =", bCardFactor, 8);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 2);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDisreteSubKey(nSock, nDivNum, nIccType, nAlgo, bKek, \
                              bMasterKey, bCardFactor, bSessionFactor, \
                              bSubKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效Socket ID[8]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void DisreteSubKey_Test_11(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int nDivNum;
	  int nIccType;
	  int nAlgo;
	  unsigned char  bKek[32];
	  unsigned char  bMasterKey[32];
	  unsigned char  bCardFactor[8];
	  unsigned char  bSessionFactor[4];
	  unsigned char  bSubKey[32];
	  unsigned char  szCheckValue[16];
	  unsigned char  bSubKeyExp[32];
	  unsigned char  szCheckValueExp[16];

    bufclr(bKek);
    bufclr(bMasterKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bSubKey);
    bufclr(szCheckValue);

    nDivNum = 0;
    nIccType = 0x00000000;
    nAlgo = 2;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKek,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           , 16);
    /* F431 623E 4997 89C8 C2F1 F725 AD7F 8949 */
    memcpy(bMasterKey,
           "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
           , 16);
    memcpy(bCardFactor,
           "\x25\x00\x00\x00\x00\x00\x89\x01"
           , 8);
    memcpy(bSessionFactor,
           "\x00\x02"
           , 2);
    /* 89E9 1FCB 266D 7C51 A437 AE51 2F10 5225 */
    memcpy(bSubKeyExp,
           "\xB9\x80\xE9\x91\xA7\xC6\x6F\x30\x21\x2C\xDE\x6F\xB4\x7A\x59\xD9"
           , 16);
    /* 09F1 C278 E411 C078 */
    memcpy(szCheckValueExp,
           "09F1C278"
           , 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nDivNum        = %d\n", nDivNum);
    printf("[IN ]nIccType       = %d\n", nIccType);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKek           =", bKek, 16);
    DspHex("[IN ]bMasterKey     =", bMasterKey, 16);
    DspHex("[IN ]bCardFactor    =", bCardFactor, 8);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 2);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDisreteSubKey(nSock, nDivNum, nIccType, nAlgo, bKek, \
                              bMasterKey, bCardFactor, bSessionFactor, \
                              bSubKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效离散次数[0]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DisreteSubKey_Test_12(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int nDivNum;
	  int nIccType;
	  int nAlgo;
	  unsigned char  bKek[32];
	  unsigned char  bMasterKey[32];
	  unsigned char  bCardFactor[8];
	  unsigned char  bSessionFactor[4];
	  unsigned char  bSubKey[32];
	  unsigned char  szCheckValue[16];
	  unsigned char  bSubKeyExp[32];
	  unsigned char  szCheckValueExp[16];

    bufclr(bKek);
    bufclr(bMasterKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bSubKey);
    bufclr(szCheckValue);

    nDivNum = 3;
    nIccType = 0x00000000;
    nAlgo = 2;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKek,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           , 16);
    /* F431 623E 4997 89C8 C2F1 F725 AD7F 8949 */
    memcpy(bMasterKey,
           "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
           , 16);
    memcpy(bCardFactor,
           "\x25\x00\x00\x00\x00\x00\x89\x01"
           , 8);
    memcpy(bSessionFactor,
           "\x00\x02"
           , 2);
    /* 89E9 1FCB 266D 7C51 A437 AE51 2F10 5225 */
    memcpy(bSubKeyExp,
           "\xB9\x80\xE9\x91\xA7\xC6\x6F\x30\x21\x2C\xDE\x6F\xB4\x7A\x59\xD9"
           , 16);
    /* 09F1 C278 E411 C078 */
    memcpy(szCheckValueExp,
           "09F1C278"
           , 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nDivNum        = %d\n", nDivNum);
    printf("[IN ]nIccType       = %d\n", nIccType);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKek           =", bKek, 16);
    DspHex("[IN ]bMasterKey     =", bMasterKey, 16);
    DspHex("[IN ]bCardFactor    =", bCardFactor, 8);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 2);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDisreteSubKey(nSock, nDivNum, nIccType, nAlgo, bKek, \
                              bMasterKey, bCardFactor, bSessionFactor, \
                              bSubKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效离散次数[3]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DisreteSubKey_Test_13(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int nDivNum;
	  int nIccType;
	  int nAlgo;
	  unsigned char  bKek[32];
	  unsigned char  bMasterKey[32];
	  unsigned char  bCardFactor[8];
	  unsigned char  bSessionFactor[4];
	  unsigned char  bSubKey[32];
	  unsigned char  szCheckValue[16];
	  unsigned char  bSubKeyExp[32];
	  unsigned char  szCheckValueExp[16];

    bufclr(bKek);
    bufclr(bMasterKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bSubKey);
    bufclr(szCheckValue);

    nDivNum = 1;
    nIccType = -1;
    nAlgo = 2;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKek,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           , 16);
    /* F431 623E 4997 89C8 C2F1 F725 AD7F 8949 */
    memcpy(bMasterKey,
           "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
           , 16);
    memcpy(bCardFactor,
           "\x25\x00\x00\x00\x00\x00\x89\x01"
           , 8);
    memcpy(bSessionFactor,
           "\x00\x02"
           , 2);
    /* 89E9 1FCB 266D 7C51 A437 AE51 2F10 5225 */
    memcpy(bSubKeyExp,
           "\xB9\x80\xE9\x91\xA7\xC6\x6F\x30\x21\x2C\xDE\x6F\xB4\x7A\x59\xD9"
           , 16);
    /* 09F1 C278 E411 C078 */
    memcpy(szCheckValueExp,
           "09F1C278"
           , 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nDivNum        = %d\n", nDivNum);
    printf("[IN ]nIccType       = %d\n", nIccType);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKek           =", bKek, 16);
    DspHex("[IN ]bMasterKey     =", bMasterKey, 16);
    DspHex("[IN ]bCardFactor    =", bCardFactor, 8);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 2);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDisreteSubKey(nSock, nDivNum, nIccType, nAlgo, bKek, \
                              bMasterKey, bCardFactor, bSessionFactor, \
                              bSubKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效IC卡类型[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DisreteSubKey_Test_14(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int nDivNum;
	  int nIccType;
	  int nAlgo;
	  unsigned char  bKek[32];
	  unsigned char  bMasterKey[32];
	  unsigned char  bCardFactor[8];
	  unsigned char  bSessionFactor[4];
	  unsigned char  bSubKey[32];
	  unsigned char  szCheckValue[16];
	  unsigned char  bSubKeyExp[32];
	  unsigned char  szCheckValueExp[16];

    bufclr(bKek);
    bufclr(bMasterKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bSubKey);
    bufclr(szCheckValue);

    nDivNum = 1;
    nIccType = 2;
    nAlgo = 2;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKek,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           , 16);
    /* F431 623E 4997 89C8 C2F1 F725 AD7F 8949 */
    memcpy(bMasterKey,
           "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
           , 16);
    memcpy(bCardFactor,
           "\x25\x00\x00\x00\x00\x00\x89\x01"
           , 8);
    memcpy(bSessionFactor,
           "\x00\x02"
           , 2);
    /* 89E9 1FCB 266D 7C51 A437 AE51 2F10 5225 */
    memcpy(bSubKeyExp,
           "\xB9\x80\xE9\x91\xA7\xC6\x6F\x30\x21\x2C\xDE\x6F\xB4\x7A\x59\xD9"
           , 16);
    /* 09F1 C278 E411 C078 */
    memcpy(szCheckValueExp,
           "09F1C278"
           , 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nDivNum        = %d\n", nDivNum);
    printf("[IN ]nIccType       = %x\n", nIccType);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKek           =", bKek, 16);
    DspHex("[IN ]bMasterKey     =", bMasterKey, 16);
    DspHex("[IN ]bCardFactor    =", bCardFactor, 8);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 2);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDisreteSubKey(nSock, nDivNum, nIccType, nAlgo, bKek, \
                              bMasterKey, bCardFactor, bSessionFactor, \
                              bSubKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效IC卡类型[2]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DisreteSubKey_Test_15(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int nDivNum;
	  int nIccType;
	  int nAlgo;
	  unsigned char  bKek[32];
	  unsigned char  bMasterKey[32];
	  unsigned char  bCardFactor[8];
	  unsigned char  bSessionFactor[4];
	  unsigned char  bSubKey[32];
	  unsigned char  szCheckValue[16];
	  unsigned char  bSubKeyExp[32];
	  unsigned char  szCheckValueExp[16];

    bufclr(bKek);
    bufclr(bMasterKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bSubKey);
    bufclr(szCheckValue);

    nDivNum = 1;
    nIccType = 0x00000000;
    nAlgo = 0;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKek,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           , 16);
    /* F431 623E 4997 89C8 C2F1 F725 AD7F 8949 */
    memcpy(bMasterKey,
           "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
           , 16);
    memcpy(bCardFactor,
           "\x25\x00\x00\x00\x00\x00\x89\x01"
           , 8);
    memcpy(bSessionFactor,
           "\x00\x02"
           , 2);
    /* 89E9 1FCB 266D 7C51 A437 AE51 2F10 5225 */
    memcpy(bSubKeyExp,
           "\xB9\x80\xE9\x91\xA7\xC6\x6F\x30\x21\x2C\xDE\x6F\xB4\x7A\x59\xD9"
           , 16);
    /* 09F1 C278 E411 C078 */
    memcpy(szCheckValueExp,
           "09F1C278"
           , 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nDivNum        = %d\n", nDivNum);
    printf("[IN ]nIccType       = %d\n", nIccType);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKek           =", bKek, 16);
    DspHex("[IN ]bMasterKey     =", bMasterKey, 16);
    DspHex("[IN ]bCardFactor    =", bCardFactor, 8);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 2);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDisreteSubKey(nSock, nDivNum, nIccType, nAlgo, bKek, \
                              bMasterKey, bCardFactor, bSessionFactor, \
                              bSubKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效算法类型[0]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DisreteSubKey_Test_16(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int nDivNum;
	  int nIccType;
	  int nAlgo;
	  unsigned char  bKek[32];
	  unsigned char  bMasterKey[32];
	  unsigned char  bCardFactor[8];
	  unsigned char  bSessionFactor[4];
	  unsigned char  bSubKey[32];
	  unsigned char  szCheckValue[16];
	  unsigned char  bSubKeyExp[32];
	  unsigned char  szCheckValueExp[16];

    bufclr(bKek);
    bufclr(bMasterKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bSubKey);
    bufclr(szCheckValue);

    nDivNum = 1;
    nIccType = 0x00000000;
    nAlgo = 4;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKek,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           , 16);
    /* F431 623E 4997 89C8 C2F1 F725 AD7F 8949 */
    memcpy(bMasterKey,
           "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
           , 16);
    memcpy(bCardFactor,
           "\x25\x00\x00\x00\x00\x00\x89\x01"
           , 8);
    memcpy(bSessionFactor,
           "\x00\x02"
           , 2);
    /* 89E9 1FCB 266D 7C51 A437 AE51 2F10 5225 */
    memcpy(bSubKeyExp,
           "\xB9\x80\xE9\x91\xA7\xC6\x6F\x30\x21\x2C\xDE\x6F\xB4\x7A\x59\xD9"
           , 16);
    /* 09F1 C278 E411 C078 */
    memcpy(szCheckValueExp,
           "09F1C278"
           , 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nDivNum        = %d\n", nDivNum);
    printf("[IN ]nIccType       = %d\n", nIccType);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKek           =", bKek, 16);
    DspHex("[IN ]bMasterKey     =", bMasterKey, 16);
    DspHex("[IN ]bCardFactor    =", bCardFactor, 8);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 2);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDisreteSubKey(nSock, nDivNum, nIccType, nAlgo, bKek, \
                              bMasterKey, bCardFactor, bSessionFactor, \
                              bSubKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效算法类型[4]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void DisreteSubKey_Test_17(void)
{
    	XXX_TEST_START_XXX
    	int nRet;
    	int nSock = SM_SOCK;

	  int nDivNum;
	  int nIccType;
	  int nAlgo;
	  unsigned char  bKek[32];
	  unsigned char  bMasterKey[32];
	  unsigned char  bCardFactor[16];
	  unsigned char  bSessionFactor[4];
	  unsigned char  bLeftCardFactor[8];
	  unsigned char bRightCardFactor[8];
	  unsigned char  bSubKey[32];
	  unsigned char  szCheckValue[16];
	  unsigned char  bSubKeyExp[32];
	  unsigned char  szCheckValueExp[16];

    bufclr(bKek);
    bufclr(bMasterKey);
    bufclr(bCardFactor);
    bufclr(bLeftCardFactor);
    bufclr(bRightCardFactor);
    bufclr(bSessionFactor);
    bufclr(bSubKey);
    bufclr(szCheckValue);

    nDivNum = 1;
    nIccType = 0x0001000A;
    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKek,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           , 8);
    /* F431 623E 4997 89C8 C2F1 F725 AD7F 8949 */
    memcpy(bMasterKey,
           "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
           , 16);
	
    memcpy(bLeftCardFactor,  "\x25\x00\x00\x00\x00\x00\x89\x01" ,8);
    memcpy(bRightCardFactor,   "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF" ,8); 
    SSMBinStrXOR(bRightCardFactor, bLeftCardFactor, bRightCardFactor, 8);
    memcpy(&bCardFactor[0], bLeftCardFactor, 8);
    memcpy(&bCardFactor[8], bRightCardFactor, 8);
	
//memcpy(bSessionFactor,  "\x00\x02" , 2);

    /* 89E8 1ECA 276C 7D50 A537 AE51 2E11 5224 */
    memcpy(bSubKeyExp,
           "\x67\x64\x66\x3B\x80\xD2\xBA\x20\x05\xB6\x36\xEE\xFB\xB6\x1F\x36"
           , 16);

    /* 09F1 C278 E411 C078 */
    memcpy(szCheckValueExp,
           "09F1C278"
           , 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nDivNum        = %d\n", nDivNum);
    printf("[IN ]nIccType       = %x\n", nIccType);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKek           =", bKek, 16);
    DspHex("[IN ]bMasterKey     =", bMasterKey, 16);
    DspHex("[IN ]bCardFactor    =", bCardFactor, 16);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 2);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDisreteSubKey(nSock, nDivNum, nIccType, nAlgo, bKek, \
                              bMasterKey, bCardFactor, bSessionFactor, \
                              bSubKey, szCheckValue);

	/* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "VISA卡，单倍长KEK密钥，一次离散测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bSubKey, bSubKeyExp, 16);
    ASSERT_OUT_HEX(szCheckValue, szCheckValueExp, 8);
    XXX_OUTPUT_XXX

    DspHex("[RESULT ]expected subkey	=", bSubKeyExp, 16);
    DspHex("[RESULT ]disreted subkey =", bSubKey, 16);
    DspHex("[RESULT ]expected checkvalue	=", szCheckValueExp, 8);
    DspHex("[RESULT]disreted checkvalue =", szCheckValue, 8);

    XXX_TEST_END_XXX
}

void DisreteSubKey_Test_18(void)
{
		XXX_TEST_START_XXX
		int  nRet;
		int  nSock = SM_SOCK;
	
		  int nDivNum;
		  int nIccType;
		  int nAlgo;
		  unsigned char  bKek[32];
		  unsigned char  bMasterKey[32];
		  unsigned char  bCardFactor[16];
		  unsigned char  bLeftCardFactor[8];
		  unsigned char bRightCardFactor[8];
		  unsigned char  bSessionFactor[4];
		  unsigned char  bSubKey[32];
		  unsigned char  szCheckValue[16];
		  unsigned char  bSubKeyExp[32];
		  unsigned char  szCheckValueExp[16];
	
		bufclr(bKek);
		bufclr(bMasterKey);
		bufclr(bCardFactor);
		bufclr(bLeftCardFactor);
		bufclr(bRightCardFactor);
		bufclr(bSessionFactor);
		bufclr(bSubKey);
		bufclr(szCheckValue);
	
		nDivNum = 1;
		nIccType = 0x0001000A;
                
		nAlgo = 3;
		
		/* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8796 A5B4 C3D2 E1F0 */
		memcpy(bKek,
			   "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
			   "\x59\x99\xC3\x06\xAB\x84\x01\xB2"
			   , 24);

		/* F431 623E 4997 89C8 C2F1 F725 AD7F 8949 */
		memcpy(bMasterKey,
			   "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
			   , 16);
		
		memcpy(bLeftCardFactor,  "\x25\x00\x00\x00\x00\x00\x89\x01" ,8);
		memcpy(bRightCardFactor,   "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF" ,8); 
		SSMBinStrXOR(bRightCardFactor, bLeftCardFactor, bRightCardFactor, 8);
		memcpy(&bCardFactor[0], bLeftCardFactor, 8);
		memcpy(&bCardFactor[8], bRightCardFactor, 8);
	
		 /*89E8 1ECA 276C 7D50 A537 AE51 2E11 5224*/
		memcpy(bSubKeyExp,
			   "\xBC\x50\x09\xE5\xD1\xA3\x24\x70\xCD\xBA\x80\x7B\xDE\xB5\x38\xCB"
			   , 16);
		
		/* 09F1 C278 E411 C078 */
		memcpy(szCheckValueExp,
			   "09F1C278"
			   , 8);
	
		XXX_INPUT_XXX
		printf("[IN ]nSock			= %d\n", nSock);
		printf("[IN ]nDivNum		= %d\n", nDivNum);
		printf("[IN ]nIccType		= %x\n", nIccType);
		printf("[IN ]nAlgo			= %d\n", nAlgo);
		DspHex("[IN ]bKek			=", bKek, 16);
		DspHex("[IN ]bMasterKey 	=", bMasterKey, 16);
		DspHex("[IN ]bCardFactor	=", bCardFactor, 16);
		DspHex("[IN ]bSessionFactor =", bSessionFactor, 2); 
		XXX_INPUT_XXX
	
		/* Call Test Target Function Start */
		nRet = SMAPIDisreteSubKey(nSock, nDivNum, nIccType, nAlgo, bKek, \
								  bMasterKey, bCardFactor, bSessionFactor, \
								  bSubKey, szCheckValue);
		/* Call Test Target Function End */
	
		XXX_RESULT_XXX
		ASSERT_RESULT(nRet, 0, "VISA卡，三倍KEK，一次离散测试未成功（失败可）");
		XXX_RESULT_XXX
	
		XXX_OUTPUT_XXX
		ASSERT_OUT_HEX(bSubKey, bSubKeyExp, 16);
		ASSERT_OUT_HEX(szCheckValue, szCheckValueExp, 8);
		XXX_OUTPUT_XXX
	
		DspHex("[RESULT ]expected subkey	=", bSubKeyExp, 16);
		DspHex("[RESULT ]disreted subkey =", bSubKey, 16);
		DspHex("[RESULT ]expected checkvalue	=", szCheckValueExp, 8);
		DspHex("[RESULT]disreted checkvalue =", szCheckValue, 8);
	
		XXX_TEST_END_XXX

}

void DisreteSubKey_Test_19(void)
{
	XXX_TEST_START_XXX
	int  nRet;
	int  nSock = SM_SOCK;
	
	int nDivNum;
	int nIccType;
	int nAlgo;
	unsigned char  bKek[8];
	unsigned char  bMasterKey[32];
	unsigned char  bCardFactor[16];
	unsigned char  bSubCardKey[16];
	unsigned char  bATC[4];
	unsigned char  bSessionSeed[16];
	unsigned char  bSubKey[16];
	unsigned char  szCheckValue[16];
	unsigned char  bSubKeyExp[32];
	unsigned char  szCheckValueExp[16];
	
	bufclr(bKek);
	bufclr(bMasterKey);
	bufclr(bCardFactor);
	bufclr(bSubCardKey);
	bufclr(bATC);
	memset(bSessionSeed,0,16);
	bufclr(bSubKey);
	bufclr(szCheckValue);

	nDivNum = 2;
	nIccType = 0x0001000A;
	nAlgo = 1;
	
	/* 0123 4567 89AB CDEF */
	memcpy(bKek,
		   "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
		   , 8);
	/* F431 623E 4997 89C8 C2F1 F725 AD7F 8949 */
	memcpy(bMasterKey,
		   "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
		   , 16);
	memcpy(bCardFactor,
		   "\x25\x00\x00\x00\x00\x00\x89\x01"
		   , 8);	
	memset(&bCardFactor[8], 0xFF, 8);
	SSMBinStrXOR(&bCardFactor[8], &bCardFactor[8], bCardFactor, 8);
	
	memcpy(bSubCardKey, 
		"\x89\xE8\x1E\xCA\x27\x6C\x7D\x50\xA5\x37\xAE\x51\x2E\x11\x52\x24"
		  ,16);
		
	memcpy(bATC,  "\x00\x02", 2);
	memcpy(&bSessionSeed[6], bATC, 2);
	memset(&bSessionSeed[14], 0xFF, 2);
	SSMBinStrXOR(&bSessionSeed[14], bATC,  &bSessionSeed[14], 2);
	
	//SSMBinStrXOR(bSubKeyExp, bSessionSeed, bSubCardKey, 16);
	/* 89 E8 1E CA 27 6C 7D 52 A5 37 AE 51 2E 11 AD D9 */
	memcpy(bSubKeyExp,
		   "\x11\x3F\x55\xB4\x5D\xCE\xE7\xE2\xA8\xD5\xCE\x7F\xA5\xF3\xF7\xCE"
		   , 16);
	
	/* D701 16E2 503E 3CC8 */
	memcpy(szCheckValueExp,
		   "D70116E2"
		   , 8);
	
	XXX_INPUT_XXX
	printf("[IN ]nSock			= %d\n", nSock);
	printf("[IN ]nDivNum		= %d\n", nDivNum);
	printf("[IN ]nIccType		= %x\n", nIccType);
	printf("[IN ]nAlgo			= %d\n", nAlgo);
	DspHex("[IN ]bKek			=", bKek, 8);
	DspHex("[IN ]bMasterKey 	=", bMasterKey, 16);
	DspHex("[IN ]bCardFactor	=", bCardFactor, 16);
	DspHex("[IN ]bSubCardKey	=", bSubCardKey, 16);
	DspHex("[IN ]bATC =", bATC, 2);
	DspHex("[IN ]bSessionSeed =", bSessionSeed, 16);
	DspHex("[OUT] bSubKeyExp=", bSubKeyExp, 16);	
	XXX_INPUT_XXX
		
	/* Call Test Target Function Start */
	nRet = SMAPIDisreteSubKey(nSock, nDivNum, nIccType, nAlgo, bKek, \
							  bMasterKey, bCardFactor, bSessionSeed, \
							  bSubKey, szCheckValue);
	/* Call Test Target Function End */
	XXX_RESULT_XXX
	ASSERT_RESULT(nRet, 0, "VISA卡，单倍KEK，二次离散脚本会话密钥未成功（失败可）");
	XXX_RESULT_XXX
			
	XXX_OUTPUT_XXX
	ASSERT_OUT_HEX(bSubKey, bSubKeyExp, 16);
	ASSERT_OUT_HEX(szCheckValue, szCheckValueExp, 8);
	XXX_OUTPUT_XXX
	
	DspHex("[RESULT ]expected subkey	=", bSubKeyExp, 16);
	DspHex("[RESULT ]disreted subkey =", bSubKey, 16);
	DspHex("[RESULT ]expected checkvalue	=", szCheckValueExp, 8);
	DspHex("[RESULT]disreted checkvalue =", szCheckValue, 8);
	
	XXX_TEST_END_XXX

}

void DisreteSubKey_Test_20(void)
{
		XXX_TEST_START_XXX
		int  nRet;
		int  nSock = SM_SOCK;
		
		int nDivNum;
		int nIccType;
		int nAlgo;
		unsigned char  bKek[24];
		unsigned char  bMasterKey[32];
		unsigned char  bCardFactor[16];
		unsigned char  bSubCardKey[16];
		unsigned char  bATC[4];
		unsigned char bSessionSeed[16];
		unsigned char  bSubKey[16];
		unsigned char  szCheckValue[16];
		unsigned char  bSubKeyExp[32];
		unsigned char  szCheckValueExp[16];
		
		bufclr(bKek);
		bufclr(bMasterKey);
		bufclr(bCardFactor);
		bufclr(bSubCardKey);
		bufclr(bATC);
		memset(bSessionSeed,0,16);
		bufclr(bSubKey);
		bufclr(szCheckValue);
	
		nDivNum = 2;
		nIccType = 0x0001000A;
		nAlgo = 3;
		
		/* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8796 A5B4 C3D2 E1F0 */
		memcpy(bKek,
			   "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
			   "\x59\x99\xC3\x06\xAB\x84\x01\xB2"
			   , 24);

		/* F431 623E 4997 89C8 C2F1 F725 AD7F 8949 */
		memcpy(bMasterKey,
			   "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
			   , 16);
		memcpy(bCardFactor,
			   "\x25\x00\x00\x00\x00\x00\x89\x01"
			   , 8);	
		memset(&bCardFactor[8], 0xFF, 8);
		SSMBinStrXOR(&bCardFactor[8], &bCardFactor[8], bCardFactor, 8);
		
		memcpy(bSubCardKey, 
			"\x89\xE8\x1E\xCA\x27\x6C\x7D\x50\xA5\x37\xAE\x51\x2E\x11\x52\x24"
			  ,16);
			
		memcpy(bATC,  "\x00\x02", 2);
		memcpy(&bSessionSeed[6], bATC, 2);
		memset(&bSessionSeed[14], 0xFF, 2);
		SSMBinStrXOR(&bSessionSeed[14], bATC,  &bSessionSeed[14], 2);
		
		//SSMBinStrXOR(bSubKeyExp, bSessionSeed, bSubCardKey, 16);
		/* 89 E8 1E CA 27 6C 7D 52 A5 37 AE 51 2E 11 AD D9 */
		memcpy(bSubKeyExp,
			   "\x3A\x7E\x41\x2E\x68\x3A\xCA\xC8\x65\x96\x43\xFB\x17\x32\xFA\x5D"
			   , 16);
		       
		/* D701 16E2 503E 3CC8 */
		memcpy(szCheckValueExp,
			   "D70116E2"
			   , 8);
		
		XXX_INPUT_XXX
		printf("[IN ]nSock			= %d\n", nSock);
		printf("[IN ]nDivNum		= %d\n", nDivNum);
		printf("[IN ]nIccType		= %x\n", nIccType);
		printf("[IN ]nAlgo			= %d\n", nAlgo);
		DspHex("[IN ]bKek			=", bKek, 24);
		DspHex("[IN ]bMasterKey 	=", bMasterKey, 16);
		DspHex("[IN ]bCardFactor	=", bCardFactor, 16);
		DspHex("[IN ]bSubCardKey	=", bSubCardKey, 16);
		DspHex("[IN ]bATC =", bATC, 2);
		DspHex("[IN ]bSessionSeed =", bSessionSeed, 16);
		DspHex("[OUT] bSubKeyExp=", bSubKeyExp, 16);	
		XXX_INPUT_XXX
			
		/* Call Test Target Function Start */
		nRet = SMAPIDisreteSubKey(nSock, nDivNum, nIccType, nAlgo, bKek, \
								  bMasterKey, bCardFactor, bSessionSeed, \
								  bSubKey, szCheckValue);
		/* Call Test Target Function End */
		XXX_RESULT_XXX
		ASSERT_RESULT(nRet, 0, "VISA卡，三倍KEK，二次离散脚本会话密钥未成功（失败可）");
		XXX_RESULT_XXX
				
		XXX_OUTPUT_XXX
		ASSERT_OUT_HEX(bSubKey, bSubKeyExp, 16);
		ASSERT_OUT_HEX(szCheckValue, szCheckValueExp, 8);
		XXX_OUTPUT_XXX
		
		DspHex("[RESULT ]expected subkey	=", bSubKeyExp, 16);
		DspHex("[RESULT ]disreted subkey =", bSubKey, 16);
		DspHex("[RESULT ]expected checkvalue	=", szCheckValueExp, 8);
		DspHex("[RESULT]disreted checkvalue =", szCheckValue, 8);
		
		XXX_TEST_END_XXX

}

void DisreteSubKey_Test_21(void)
{
		XXX_TEST_START_XXX
		int nRet;
		int nSock = SM_SOCK;
	
		  int nDivNum;
		  int nIccType;
		  int nAlgo;
		  unsigned char  bKek[8];
		  unsigned char  bMasterKey[32];
		  unsigned char  bCardFactor[16];
		  unsigned char  bSessionFactor[4];
		  unsigned char  bLeftCardFactor[8];
		  unsigned char bRightCardFactor[8];
		  unsigned char  bSubKey[32];
		  unsigned char  szCheckValue[16];
		  unsigned char  bSubKeyExp[32];
		  unsigned char  szCheckValueExp[16];
	
		bufclr(bKek);
		bufclr(bMasterKey);
		bufclr(bCardFactor);
		bufclr(bLeftCardFactor);
		bufclr(bRightCardFactor);
		bufclr(bSessionFactor);
		bufclr(bSubKey);
		bufclr(szCheckValue);
	
		nDivNum = 1;
		nIccType = 0x0002000E;
		nAlgo = 1;
		/* 0123 4567 89AB CDEF */
		memcpy(bKek,
			   "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
			   , 8);
		/* F431 623E 4997 89C8 C2F1 F725 AD7F 8949 */
		memcpy(bMasterKey,
			   "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
			   , 16);
		
		memcpy(bLeftCardFactor,  "\x25\x00\x00\x00\x00\x00\x89\x01" ,8);
		memcpy(bRightCardFactor,   "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF" ,8); 
		SSMBinStrXOR(bRightCardFactor, bLeftCardFactor, bRightCardFactor, 8);
		memcpy(&bCardFactor[0], bLeftCardFactor, 8);
		memcpy(&bCardFactor[8], bRightCardFactor, 8);
	
		/* 89E9 1FCB 266D 7C51 A437 AE51 2F10 5225 */
		memcpy(bSubKeyExp,
			   "\x4C\xFF\x06\xC4\xDF\xE3\x28\x29\xF7\x12\x38\x90\xE0\x3A\x2E\xDE"
			   , 16);

		/* 09F1 C278 E411 C078 */
		memcpy(szCheckValueExp,
			   "09F1C278"
			   , 8);
	
		XXX_INPUT_XXX
		printf("[IN ]nSock			= %d\n", nSock);
		printf("[IN ]nDivNum		= %d\n", nDivNum);
		printf("[IN ]nIccType		= %x\n", nIccType);
		printf("[IN ]nAlgo			= %d\n", nAlgo);
		DspHex("[IN ]bKek			=", bKek, 8);
		DspHex("[IN ]bMasterKey 	=", bMasterKey, 16);
		DspHex("[IN ]bCardFactor	=", bCardFactor, 16);
		DspHex("[IN ]bSessionFactor =", bSessionFactor, 2);
		XXX_INPUT_XXX
	
		/* Call Test Target Function Start */
		nRet = SMAPIDisreteSubKey(nSock, nDivNum, nIccType, nAlgo, bKek, \
								  bMasterKey, bCardFactor, bSessionFactor, \
								  bSubKey, szCheckValue);
	
		/* Call Test Target Function End */
	
		XXX_RESULT_XXX
		ASSERT_RESULT(nRet, 0, "MASTER卡，单倍长KEK密钥，一次离散测试未成功");
		XXX_RESULT_XXX
	
		XXX_OUTPUT_XXX
		ASSERT_OUT_HEX(bSubKey, bSubKeyExp, 16);
		ASSERT_OUT_HEX(szCheckValue, szCheckValueExp, 8);
		XXX_OUTPUT_XXX
	
		DspHex("[RESULT ]expected subkey	=", bSubKeyExp, 16);
		DspHex("[RESULT ]disreted subkey =", bSubKey, 16);
		DspHex("[RESULT ]expected checkvalue	=", szCheckValueExp, 8);
		DspHex("[RESULT]disreted checkvalue =", szCheckValue, 8);
	
		XXX_TEST_END_XXX

}

void DisreteSubKey_Test_22(void)
{
    XXX_TEST_START_XXX
    int nRet;
    int nSock = SM_SOCK;

    int nDivNum;
    int nIccType;
    int nAlgo;
    unsigned char  bKek[16];
    unsigned char  bMasterKey[32];
    unsigned char  bCardFactor[16];
    unsigned char  bSessionFactor[4];
    unsigned char  bLeftCardFactor[8];
    unsigned char bRightCardFactor[8];
    unsigned char  bSubKey[32];
    unsigned char  szCheckValue[16];
    unsigned char  bSubKeyExp[32];
    unsigned char  szCheckValueExp[16];

    bufclr(bKek);
    bufclr(bMasterKey);
    bufclr(bCardFactor);
    bufclr(bLeftCardFactor);
    bufclr(bRightCardFactor);
    bufclr(bSessionFactor);
    bufclr(bSubKey);
    bufclr(szCheckValue);

    nDivNum = 1;
    nIccType = 0x00020014;
    nAlgo = 2;
        
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKek,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           , 16);

    /* F431 623E 4997 89C8 C2F1 F725 AD7F 8949 */
    memcpy(bMasterKey,
           "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
           , 16);
        
    memcpy(bLeftCardFactor,  "\x25\x00\x00\x00\x00\x00\x89\x01" ,8);
    memcpy(bRightCardFactor,   "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF" ,8); 
    SSMBinStrXOR(bRightCardFactor, bLeftCardFactor, bRightCardFactor, 8);
    memcpy(&bCardFactor[0], bLeftCardFactor, 8);
    memcpy(&bCardFactor[8], bRightCardFactor, 8);

    /* 89E9 1FCB 266D 7C51 A437 AE51 2F10 5225 */
    memcpy(bSubKeyExp,
           "\xB9\x80\xE9\x91\xA7\xC6\x6F\x30\x21\x2C\xDE\x6F\xB4\x7A\x59\xD9"
           , 16);        

    /* 09F1 C278 E411 C078 */
    memcpy(szCheckValueExp,
           "09F1C278"
               , 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock            = %d\n", nSock);
    printf("[IN ]nDivNum        = %d\n", nDivNum);
    printf("[IN ]nIccType        = %x\n", nIccType);
    printf("[IN ]nAlgo            = %d\n", nAlgo);
    DspHex("[IN ]bKek            =", bKek, 16);
    DspHex("[IN ]bMasterKey     =", bMasterKey, 16);
    DspHex("[IN ]bCardFactor    =", bCardFactor, 16);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 16);
    XXX_INPUT_XXX
    
    /* Call Test Target Function Start */
    nRet = SMAPIDisreteSubKey(nSock, nDivNum, nIccType, nAlgo, bKek, \
                              bMasterKey, bCardFactor, bSessionFactor, \
                              bSubKey, szCheckValue);
    
    /* Call Test Target Function End */
    
    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "MASTER卡，二倍长KEK密钥，一次离散测试未成功");
    XXX_RESULT_XXX
    
    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bSubKey, bSubKeyExp, 16);
    ASSERT_OUT_HEX(szCheckValue, szCheckValueExp, 8);
    XXX_OUTPUT_XXX
    
    DspHex("[RESULT ]expected subkey    =", bSubKeyExp, 16);
    DspHex("[RESULT ]disreted subkey =", bSubKey, 16);
    DspHex("[RESULT ]expected checkvalue    =", szCheckValueExp, 8);
    DspHex("[RESULT]disreted checkvalue =", szCheckValue, 8);
    
    XXX_TEST_END_XXX
}

void DisreteSubKey_Test_23(void)
{
	XXX_TEST_START_XXX
		int nRet;
		int nSock = SM_SOCK;
		
		int nDivNum;
		int nIccType;
		int nAlgo;
		unsigned char  bKek[24];
		unsigned char  bMasterKey[32];
		unsigned char  bCardFactor[16];
		unsigned char  bSessionFactor[4];
		unsigned char  bLeftCardFactor[8];
		unsigned char bRightCardFactor[8];
		unsigned char  bSubKey[32];
		unsigned char  szCheckValue[16];
		unsigned char  bSubKeyExp[32];
		unsigned char  szCheckValueExp[16];

		bufclr(bKek);
		bufclr(bMasterKey);
		bufclr(bCardFactor);
		bufclr(bLeftCardFactor);
		bufclr(bRightCardFactor);
		bufclr(bSessionFactor);
		bufclr(bSubKey);
		bufclr(szCheckValue);
		
		nDivNum = 1;
		nIccType = 0x0002000E;
		nAlgo = 3;
			
		/* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8796 A5B4 C3D2 E1F0 */
		memcpy(bKek,
			"\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
			 "\x59\x99\xC3\x06\xAB\x84\x01\xB2"
			, 24);

		/* F431 623E 4997 89C8 C2F1 F725 AD7F 8949 */
		memcpy(bMasterKey,
			   "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
			   , 16);
			
		memcpy(bLeftCardFactor,  "\x25\x00\x00\x00\x00\x00\x89\x01" ,8);
		memcpy(bRightCardFactor,   "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF" ,8); 
		SSMBinStrXOR(bRightCardFactor, bLeftCardFactor, bRightCardFactor, 8);
		memcpy(&bCardFactor[0], bLeftCardFactor, 8);
		memcpy(&bCardFactor[8], bRightCardFactor, 8);
		
		/* 89E9 1FCB 266D 7C51 A437 AE51 2F10 5225 */
		memcpy(bSubKeyExp,
			   "\x97\xC0\xB3\xE6\x38\x60\x7D\xB7\x89\x95\xC6\x37\xE4\x69\xAC\x74"
			   , 16);		
	
		/* 09F1 C278 E411 C078 */
		memcpy(szCheckValueExp,
			   "09F1C278"
			   , 8);
		
		XXX_INPUT_XXX
		printf("[IN ]nSock			= %d\n", nSock);
		printf("[IN ]nDivNum		= %d\n", nDivNum);
		printf("[IN ]nIccType		= %x\n", nIccType);
		printf("[IN ]nAlgo			= %d\n", nAlgo);
		DspHex("[IN ]bKek			=", bKek, 24);
		DspHex("[IN ]bMasterKey 	=", bMasterKey, 16);
		DspHex("[IN ]bCardFactor	=", bCardFactor, 16);
		DspHex("[IN ]bSessionFactor =", bSessionFactor, 2);
		XXX_INPUT_XXX
		
		/* Call Test Target Function Start */
		nRet = SMAPIDisreteSubKey(nSock, nDivNum, nIccType, nAlgo, bKek, \
								  bMasterKey, bCardFactor, bSessionFactor, \
								  bSubKey, szCheckValue);
		
		/* Call Test Target Function End */
		
		XXX_RESULT_XXX
		ASSERT_RESULT(nRet, 0, "MASTER卡，三倍长KEK密钥，一次离散测试未成功");
		XXX_RESULT_XXX
		
		XXX_OUTPUT_XXX
		ASSERT_OUT_HEX(bSubKey, bSubKeyExp, 16);
		ASSERT_OUT_HEX(szCheckValue, szCheckValueExp, 8);
		XXX_OUTPUT_XXX
		
		DspHex("[RESULT ]expected subkey	=", bSubKeyExp, 16);
		DspHex("[RESULT ]disreted subkey =", bSubKey, 16);
		DspHex("[RESULT ]expected checkvalue	=", szCheckValueExp, 8);
		DspHex("[RESULT]disreted checkvalue =", szCheckValue, 8);
		
		XXX_TEST_END_XXX

}

void DisreteSubKey_Test_24(void)
{
    	XXX_TEST_START_XXX
    	int  nRet;
    	int  nSock = SM_SOCK;

	 int nDivNum;
	 int nIccType;
	 int nAlgo;
	 unsigned char  bKek[8];
	 unsigned char  bMasterKey[32];
	 unsigned char  bCardFactor[16];
	 unsigned char  bSubCardKey[16];
	 unsigned char  bATC[4];
	 unsigned char  bLeftCardFactor[8];
	 unsigned char bRightCardFactor[8];
	 unsigned char bSessionSeed[16];
	 unsigned char  bSubKey[32];
	 unsigned char  szCheckValue[16];
	 unsigned char  bSubKeyExp[32];
	 unsigned char  szCheckValueExp[16];

    	bufclr(bKek);
    	bufclr(bMasterKey);
    	bufclr(bCardFactor);
    	bufclr(bLeftCardFactor);
    	bufclr(bRightCardFactor);
    	bufclr(bSubCardKey);
    	bufclr(bATC);
    	memset(bSessionSeed,0,16);
    	bufclr(bSubKey);
    	bufclr(szCheckValue);

    	nDivNum = 2;
    	nIccType = 0x0002000E;
    	nAlgo = 1;
	
   	 /* 0123 4567 89AB CDEF */
    	memcpy(bKek,
        	  "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           	, 8);
	 
    	/* F431 623E 4997 89C8 C2F1 F725 AD7F 8949 */
    	memcpy(bMasterKey,
           	"\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
           	, 16);

	memcpy(bLeftCardFactor,  "\x25\x00\x00\x00\x00\x00\x89\x01" ,8);
	memcpy(bRightCardFactor,   "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF" ,8); 
	SSMBinStrXOR(bRightCardFactor, bLeftCardFactor, bRightCardFactor, 8);
	memcpy(&bCardFactor[0], bLeftCardFactor, 8);
	memcpy(&bCardFactor[8], bRightCardFactor, 8);

	memcpy(bSubCardKey, 
		"\x89\xE9\x1F\xCB\x26\x6D\x7C\x51\xA4\x37\xAE\x51\x2F\x10\x52\x25"
		  ,16);	
	
	memcpy(bATC,  "\x00\x02", 2);
	memcpy(&bSessionSeed[6], bATC, 2);
	memset(&bSessionSeed[14], 0xFF, 2);
	SSMBinStrXOR(&bSessionSeed[14], bATC,  &bSessionSeed[14], 2);

    	/* 4FA1 BA64 DC85 58BF EC43 C210 F4FD 4610 */
	memcpy(bSubKeyExp,
           	"\x2C\x52\xE0\x25\xF9\x6B\xF0\x2F\x13\xF2\x52\x1E\xBF\x37\x73\x7F"
           	, 16);
	
    /* 04BC 620F 4E58 684D */
    memcpy(szCheckValueExp,
           "04BC620F"
           , 8);

    	XXX_INPUT_XXX
    	printf("[IN ]nSock          = %d\n", nSock);
    	printf("[IN ]nDivNum        = %d\n", nDivNum);
    	printf("[IN ]nIccType       = %d\n", nIccType);
    	printf("[IN ]nAlgo          = %d\n", nAlgo);
    	DspHex("[IN ]bKek           =", bKek, 8);
    	DspHex("[IN ]bMasterKey     =", bMasterKey, 16);
    	DspHex("[IN ]bCardFactor    =", bCardFactor, 8);
    	DspHex("[IN ]bSubCardKey	=", bSubCardKey, 16);
    	DspHex("[IN ]bATC =", bATC, 2);
    	DspHex("[IN ]bSessionSeed =", bSessionSeed, 16);
    	XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDisreteSubKey(nSock, nDivNum, nIccType, nAlgo, bKek, \
                              bMasterKey, bCardFactor, bSessionSeed, \
                              bSubKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "MASTER卡，单倍长KEK密钥，二次离散测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bSubKey, bSubKeyExp, 16);
    ASSERT_OUT_HEX(szCheckValue, szCheckValueExp, 8);
    XXX_OUTPUT_XXX

	DspHex("[RESULT ]expected subkey	=", bSubKeyExp, 16);
	DspHex("[RESULT ]disreted subkey =", bSubKey, 16);
	DspHex("[RESULT ]expected checkvalue	=", szCheckValueExp, 8);
	DspHex("[RESULT]disreted checkvalue =", szCheckValue, 8);

    XXX_TEST_END_XXX
}

void DisreteSubKey_Test_25(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int nDivNum;
    int nIccType;
    int nAlgo;
    unsigned char  bKek[16];
    unsigned char  bMasterKey[32];
    unsigned char  bCardFactor[16];
    unsigned char  bSubCardKey[16];
    unsigned char  bATC[4];
    unsigned char  bLeftCardFactor[8];
    unsigned char bRightCardFactor[8];
    unsigned char bSessionSeed[16];
    unsigned char  bSubKey[32];
    unsigned char  szCheckValue[16];
    unsigned char  bSubKeyExp[32];
    unsigned char  szCheckValueExp[16];

    bufclr(bKek);
    bufclr(bMasterKey);
    bufclr(bCardFactor);
    bufclr(bLeftCardFactor);
    bufclr(bRightCardFactor);
    bufclr(bSubCardKey);
    bufclr(bATC);
    memset(bSessionSeed,0,16);
    bufclr(bSubKey);
    bufclr(szCheckValue);

    nDivNum = 2;
    nIccType = 0x00020014;
    nAlgo = 2;

    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKek,
        "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
         , 16);

    /* F431 623E 4997 89C8 C2F1 F725 AD7F 8949 */
    memcpy(bMasterKey,
           "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
           , 16);
               
//for test
/*
        memcpy(bMasterKey,
               "\x89\x23\x17\x1C\x70\xE5\x72\x92\x9B\xB6\x31\xE9\xC8\x05\xA3\xA0"
               , 16);
*/

    memcpy(bLeftCardFactor,  "\x25\x00\x00\x00\x00\x00\x89\x01" ,8);
    memcpy(bRightCardFactor,   "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF" ,8); 
    SSMBinStrXOR(bRightCardFactor, bLeftCardFactor, bRightCardFactor, 8);
    memcpy(&bCardFactor[0], bLeftCardFactor, 8);
    memcpy(&bCardFactor[8], bRightCardFactor, 8);

    memcpy(bSubCardKey, 
        "\x89\xE9\x1F\xCB\x26\x6D\x7C\x51\xA4\x37\xAE\x51\x2F\x10\x52\x25"
          ,16);    
    
    memcpy(bATC,  "\x00\x02", 2);
    memcpy(&bSessionSeed[6], bATC, 2);
    memset(&bSessionSeed[14], 0xFF, 2);
    SSMBinStrXOR(&bSessionSeed[14], bATC,  &bSessionSeed[14], 2);

    /* 4FA1 BA64 DC85 58BF EC43 C210 F4FD 4610 */
    memcpy(bSubKeyExp,
               "\xAE\x75\x8D\x48\xCC\x51\x5A\x30\xE9\x5F\x0C\x2F\x62\x34\xD2\xF1"
               , 16);
    
    /* 04BC 620F 4E58 684D */
    memcpy(szCheckValueExp,
           "04BC620F"
           , 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nDivNum        = %d\n", nDivNum);
    printf("[IN ]nIccType       = %d\n", nIccType);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKek           =", bKek, 16);
    DspHex("[IN ]bMasterKey     =", bMasterKey, 16);
    DspHex("[IN ]bCardFactor    =", bCardFactor, 16);
    DspHex("[IN ]bSubCardKey    =", bSubCardKey, 16);
    DspHex("[IN ]bATC =", bATC, 2);
    DspHex("[IN ]bSessionSeed =", bSessionSeed, 16);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDisreteSubKey(nSock, nDivNum, nIccType, nAlgo, bKek, \
                              bMasterKey, bCardFactor, bSessionSeed, \
                              bSubKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "MASTER卡，二倍长KEK密钥，二次离散测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bSubKey, bSubKeyExp, 16);
    ASSERT_OUT_HEX(szCheckValue, szCheckValueExp, 8);
    XXX_OUTPUT_XXX

    DspHex("[RESULT ]expected subkey    =", bSubKeyExp, 16);
    DspHex("[RESULT ]disreted subkey =", bSubKey, 16);
    DspHex("[RESULT ]expected checkvalue    =", szCheckValueExp, 8);
    DspHex("[RESULT]disreted checkvalue =", szCheckValue, 8);

    XXX_TEST_END_XXX
}

void DisreteSubKey_Test_26(void)
{
   	XXX_TEST_START_XXX
    	int  nRet;
    	int  nSock = SM_SOCK;

	 int nDivNum;
	 int nIccType;
	 int nAlgo;
	 unsigned char  bKek[24];
	 unsigned char  bMasterKey[32];
	 unsigned char  bCardFactor[16];
	 unsigned char  bSubCardKey[16];
	 unsigned char  bATC[4];
	 unsigned char  bLeftCardFactor[8];
	 unsigned char bRightCardFactor[8];
	 unsigned char bSessionSeed[16];
	 unsigned char  bSubKey[32];
	 unsigned char  szCheckValue[16];
	 unsigned char  bSubKeyExp[32];
	 unsigned char  szCheckValueExp[16];

    	bufclr(bKek);
    	bufclr(bMasterKey);
    	bufclr(bCardFactor);
    	bufclr(bLeftCardFactor);
    	bufclr(bRightCardFactor);
    	bufclr(bSubCardKey);
    	bufclr(bATC);
    	memset(bSessionSeed,0,16);
    	bufclr(bSubKey);
    	bufclr(szCheckValue);

    	nDivNum = 2;
    	nIccType = 0x0002000E;
    	nAlgo = 2;

	/* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8796 A5B4 C3D2 E1F0 */
	memcpy(bKek,
		"\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
		 "\x59\x99\xC3\x06\xAB\x84\x01\xB2"
		, 24);
	 
    	/* F431 623E 4997 89C8 C2F1 F725 AD7F 8949 */
    	memcpy(bMasterKey,
           	"\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
           	, 16);

	memcpy(bLeftCardFactor,  "\x25\x00\x00\x00\x00\x00\x89\x01" ,8);
	memcpy(bRightCardFactor,   "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF" ,8); 
	SSMBinStrXOR(bRightCardFactor, bLeftCardFactor, bRightCardFactor, 8);
	memcpy(&bCardFactor[0], bLeftCardFactor, 8);
	memcpy(&bCardFactor[8], bRightCardFactor, 8);

	memcpy(bSubCardKey, 
		"\x89\xE9\x1F\xCB\x26\x6D\x7C\x51\xA4\x37\xAE\x51\x2F\x10\x52\x25"
		  ,16);	
	
	memcpy(bATC,  "\x00\x02", 2);
	memcpy(&bSessionSeed[6], bATC, 2);
	memset(&bSessionSeed[14], 0xFF, 2);
	SSMBinStrXOR(&bSessionSeed[14], bATC,  &bSessionSeed[14], 2);

    	/* 4FA1 BA64 DC85 58BF EC43 C210 F4FD 4610 */
	memcpy(bSubKeyExp,
           	"\xAE\x75\x8D\x48\xCC\x51\x5A\x30\xE9\x5F\x0C\x2F\x62\x34\xD2\xF1"
           	, 16);
	
    /* 04BC 620F 4E58 684D */
    memcpy(szCheckValueExp,
           "04BC620F"
           , 8);

    	XXX_INPUT_XXX
    	printf("[IN ]nSock          = %d\n", nSock);
    	printf("[IN ]nDivNum        = %d\n", nDivNum);
    	printf("[IN ]nIccType       = %d\n", nIccType);
    	printf("[IN ]nAlgo          = %d\n", nAlgo);
    	DspHex("[IN ]bKek           =", bKek, 24);
    	DspHex("[IN ]bMasterKey     =", bMasterKey, 16);
    	DspHex("[IN ]bCardFactor    =", bCardFactor, 8);
    	DspHex("[IN ]bSubCardKey	=", bSubCardKey, 16);
    	DspHex("[IN ]bATC =", bATC, 2);
    	DspHex("[IN ]bSessionSeed =", bSessionSeed, 16);
    	XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDisreteSubKey(nSock, nDivNum, nIccType, nAlgo, bKek, \
                              bMasterKey, bCardFactor, bSessionSeed, \
                              bSubKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "MASTER卡，三倍长KEK密钥，二次离散测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bSubKey, bSubKeyExp, 16);
    ASSERT_OUT_HEX(szCheckValue, szCheckValueExp, 8);
    XXX_OUTPUT_XXX

	DspHex("[RESULT ]expected subkey	=", bSubKeyExp, 16);
	DspHex("[RESULT ]disreted subkey =", bSubKey, 16);
	DspHex("[RESULT ]expected checkvalue	=", szCheckValueExp, 8);
	DspHex("[RESULT]disreted checkvalue =", szCheckValue, 8);

    XXX_TEST_END_XXX

}

void DisreteSubKey_Test_27(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int nDivNum;
	  int nIccType;
	  int nAlgo;
	  unsigned char  bKek[32];
	  unsigned char  bMasterKey[32];
	  unsigned char  bCardFactor[16];
	  unsigned char  bLeftCardFactor[8];
	  unsigned char bRightCardFactor[8];
	  unsigned char  bSessionFactor[4];
	  unsigned char  bSubKey[32];
	  unsigned char  szCheckValue[16];
	  unsigned char  bSubKeyExp[32];
	  unsigned char  szCheckValueExp[16];

    bufclr(bKek);
    bufclr(bMasterKey);
    bufclr(bCardFactor);
    bufclr(bLeftCardFactor);
    bufclr(bRightCardFactor);
    bufclr(bSessionFactor);
    bufclr(bSubKey);
    bufclr(szCheckValue);

    nDivNum = 1;
    nIccType = 0x00000401;
    nAlgo = 2;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKek,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           , 16);
    /* F431 623E 4997 89C8 C2F1 F725 AD7F 8949 */
    memcpy(bMasterKey,
           "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
           , 16);
    /* 2500 0000 0000 8901 DAFF FFFF FFFF 76FE */
    memcpy(bLeftCardFactor,  "\x25\x00\x00\x00\x00\x00\x89\x01" ,8);
    memcpy(bRightCardFactor,   "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF" ,8); 
    SSMBinStrXOR(bRightCardFactor, bLeftCardFactor, bRightCardFactor, 8);
    memcpy(&bCardFactor[0], bLeftCardFactor, 8);
    memcpy(&bCardFactor[8], bRightCardFactor, 8);

    /* EB53C9ADD78EAE205EDD9C3389D3D73D */
    /* F63C 212F 8CD8 E6CD 5F13 B30D 7D29 DB17 */
    memcpy(bSubKeyExp,
           "\xF6\x3C\x21\x2F\x8C\xD8\xE6\xCD" \
           "\x5F\x13\xB3\x0D\x7D\x29\xDB\x17" \
           , 16);
	
    /* A767 DEA1 9589 6AB9 */
    memcpy(szCheckValueExp,
           "A767DEA1"
           , 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nDivNum        = %d\n", nDivNum);
    printf("[IN ]nIccType       = %x\n", nIccType);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKek           =", bKek, 16);
    DspHex("[IN ]bMasterKey     =", bMasterKey, 16);
    DspHex("[IN ]bCardFactor    =", bCardFactor, 16);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 2);	
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIDisreteSubKey(nSock, nDivNum, nIccType, nAlgo, bKek, \
                              bMasterKey, bCardFactor, bSessionFactor, \
                              bSubKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "PBOC卡，二倍KEK，SM4, 一次离散测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bSubKey, bSubKeyExp, 16);
    ASSERT_OUT_HEX(szCheckValue, szCheckValueExp, 8);
    XXX_OUTPUT_XXX

//    DspHex("[RESULT ]expected subkey	=", bSubKeyExp, 16);
//    DspHex("[RESULT ]disreted subkey =", bSubKey, 16);
//    DspHex("[RESULT ]expected checkvalue	=", szCheckValueExp, 8);
//    DspHex("[RESULT]disreted checkvalue =", szCheckValue, 8);

    XXX_TEST_END_XXX
}

void DisreteSubKey_Test_28(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int nDivNum;
	  int nIccType;
	  int nAlgo;
	  unsigned char  bKek[32];
	  unsigned char  bMasterKey[32];
	  unsigned char  bCardFactor[16];
	  unsigned char  bATC[4];
	  unsigned char  bSessionSeed[16];
	  unsigned char  bSubKey[16];
	  unsigned char  szCheckValue[16];
	  unsigned char  bSubKeyExp[32];
	  unsigned char  szCheckValueExp[16];

    bufclr(bKek);
    bufclr(bMasterKey);
    bufclr(bCardFactor);
    bufclr(bATC);
    memset(bSessionSeed,0,16);
    bufclr(bSubKey);
    bufclr(szCheckValue);

    nDivNum = 2;
    nIccType = 0x00000417;

    nAlgo = 2;
	
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKek,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           , 16);
    /* F431 623E 4997 89C8 C2F1 F725 AD7F 8949 */
    memcpy(bMasterKey,
           "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
           , 16);
    memcpy(bCardFactor,
           "\x25\x00\x00\x00\x00\x00\x89\x01"
           , 8);	
    memset(&bCardFactor[8], 0xFF, 8);
    SSMBinStrXOR(&bCardFactor[8], &bCardFactor[8],  bCardFactor,  8);
   
    memcpy(bATC, "\x00\x02", 2);
    memcpy(&bSessionSeed[6], bATC, 2);
    memset(&bSessionSeed[14], 0xFF, 2);
    SSMBinStrXOR(&bSessionSeed[14], bATC, &bSessionSeed[14], 2);

    /* 669D80C23AED1147ACD33BB3E532B2B8 */
    /* 5EC5 A790 BCA9 451C 48B9 8254 C937 5DE4 */
    memcpy(bSubKeyExp,
           "\x5E\xC5\xA7\x90\xBC\xA9\x45\x1C" \
           "\x48\xB9\x82\x54\xC9\x37\x5D\xE4" \
           , 16);
	
    /* 142C C7AB 7F5B 20D2 */
    memcpy(szCheckValueExp,
           "142CC7AB"
           , 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nDivNum        = %d\n", nDivNum);
    printf("[IN ]nIccType       = %x\n", nIccType);
    printf("[IN ]nAlgo          = %d\n", nAlgo);
    DspHex("[IN ]bKek           =", bKek, 16);
    DspHex("[IN ]bMasterKey     =", bMasterKey, 16);
    DspHex("[IN ]bCardFactor    =", bCardFactor, 16);
    DspHex("[IN ]bATC =", bATC, 2);
    DspHex("[IN ]bSessionSeed =", bSessionSeed, 16);
//    DspHex("[OUT] bSubKeyExp=", bSubKeyExp, 16);	
    XXX_INPUT_XXX
	
    /* Call Test Target Function Start */
    nRet = SMAPIDisreteSubKey(nSock, nDivNum, nIccType, nAlgo, bKek, \
                              bMasterKey, bCardFactor, bSessionSeed, \
                              bSubKey, szCheckValue);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "PBOC卡，二倍KEK，SM4, 二次离散脚本会话密钥未成功");
    XXX_RESULT_XXX
		
    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bSubKey, bSubKeyExp, 16);
    ASSERT_OUT_HEX(szCheckValue, szCheckValueExp, 8);
    XXX_OUTPUT_XXX

//    DspHex("[RESULT ]expected subkey	=", bSubKeyExp, 16);
//    DspHex("[RESULT ]disreted subkey =", bSubKey, 16);
//    DspHex("[RESULT ]expected checkvalue	=", szCheckValueExp, 8);
//    DspHex("[RESULT]disreted checkvalue =", szCheckValue, 8);

    XXX_TEST_END_XXX
}

void VerifyARQC_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nIccType;
	  BYTE bKey[32];
	  BYTE bCardFactor[8];
	  BYTE bSessionFactor[2];
	  BYTE bData[64];
	  int  nDataLen;
	  BYTE bARQC[8];

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bData);
    bufclr(bARQC);

    nIccType = 0x00000000;
    memcpy(bKey,
           "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
           , 16);
    memcpy(bCardFactor,
           "\x25\x00\x00\x00\x00\x00\x89\x01"
           , 8);
    memcpy(bSessionFactor,
           "\x00\x02"
           , 2);
    memcpy(bData,
           "\x00\x00\x00\x01\x68\x00\x00\x00\x00\x00\x00\x00\x01\x56\x00\x00"
           "\x00\x80\x00\x01\x56\x07\x11\x09\x01\xDC\xCD\x7C\x16\x7D\x00\x00"
           "\x02\x03\xA0\x00\x02"
           , 37);
    nDataLen = 37;
    memcpy(bARQC, "\x8B\x6F\x6D\x8F\x49\x64\xA6\x09", 8);

    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nIccType  = %d\n", nIccType);
    DspHex("[IN ]bKey      =", bKey, 16);
    DspHex("[IN ]bCardFactor =", bCardFactor, 8);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 2);
    DspHex("[IN ]bData     =", bData, 37);
    printf("[IN ]nDataLen  = %d\n", nDataLen);

    /* Call Test Target Function Start */
    nRet = SMAPIVerifyARQC(nSock, nIccType, bKey, bCardFactor, bSessionFactor, \
                    bData, nDataLen, bARQC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "PBOC卡，Verify_ARQC测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifyARQC_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nIccType;
	  BYTE bKey[32];
	  BYTE bCardFactor[16];
	  BYTE bSessionFactor[16];
	  BYTE bData[64];
	  int  nDataLen;
	  BYTE bARQC[8];

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bData);
    bufclr(bARQC);

    nIccType = 0x0001000A;
	
    memcpy(bKey,
           "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
           , 16);
	
    memcpy(bCardFactor,
           "\x25\x00\x00\x00\x00\x00\x89\x01\xDA\xFF\xFF\xFF\xFF\xFF\x76\xFE"
           , 16);

    bufclr(bSessionFactor);
	
    memcpy(bData,
           "\x00\x00\x00\x01\x68\x00\x00\x00\x00\x00\x00\x00\x01\x56\x00\x00"
           "\x00\x80\x00\x01\x56\x07\x11\x09\x01\xDC\xCD\x7C\x16\x7D\x00\x00"
           "\x02\x03\xA0\x00\x02"
           , 37);
    nDataLen = 37;

    memcpy(bARQC, "\xAA\x51\xA6\x05\x74\xFF\x83\x02", 8);

    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nIccType  = %x\n", nIccType);
    DspHex("[IN ]bKey      =", bKey, 16);
    DspHex("[IN ]bCardFactor =", bCardFactor, 16);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 16);
    DspHex("[IN ]bData     =", bData, 37);
    printf("[IN ]nDataLen  = %d\n", nDataLen);

    /* Call Test Target Function Start */
    nRet = SMAPIVerifyARQC(nSock, nIccType, bKey, bCardFactor, bSessionFactor, \
                    bData, nDataLen, bARQC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "VISA卡，Verify_ARQC测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifyARQC_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIccType;
    BYTE bKey[32];
    BYTE bCardFactor[16];
    BYTE bSessionFactor[16];
    BYTE bData[64];
    int  nDataLen;
    BYTE bARQC[8];

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bData);
    bufclr(bARQC);

    nIccType = 0X00020014;

    memcpy(bKey,
           "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4" 
           , 16);
        
    memcpy(bCardFactor,
           "\x25\x00\x00\x00\x00\x00\x89\x01\xDA\xFF\xFF\xFF\xFF\xFF\x76\xFE"
           , 16);
        
    memcpy(bSessionFactor,
           "\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\xFF\xFD"
           , 16);
        
    memcpy(bData,
           "\x00\x00\x00\x01\x20\x00\x00\x00" \
           "\x00\x00\x00\x00\x01\x56\x00\x08" \
           "\x04\xE8\x00\x01\x56\x30\x11\x25" \
           "\x00\xAC\xCE\x7A\xA4\x7C\x00\x00" \
           "\x0E\x03\xA0\xB8\x02"
               , 37);
    nDataLen = 37;
    memcpy(bARQC, "\x02\x87\x61\x1F\xA1\x13\xE6\xF7", 8);    

    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nIccType  = %x\n", nIccType);
    DspHex("[IN ]bKey      =", bKey, 16);
    DspHex("[IN ]bCardFactor =", bCardFactor, 16);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 16);
    DspHex("[IN ]bData     =", bData, 37);
    printf("[IN ]nDataLen  = %d\n", nDataLen);

    /* Call Test Target Function Start */
    nRet = SMAPIVerifyARQC(nSock, nIccType, bKey, bCardFactor, bSessionFactor, \
                    bData, nDataLen, bARQC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "MASTER卡，Verify_ARQC测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifyARQC_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nIccType;
	  BYTE bKey[32];
	  BYTE bCardFactor[16];
	  BYTE bSessionFactor[16];
	  BYTE bData[64];
	  int  nDataLen;
	  BYTE bARQC[8];

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bData);
    bufclr(bARQC);

    nIccType = 0x00000401;
    memcpy(bKey,
           "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
           , 16);
    memcpy(bCardFactor,
           "\x25\x00\x00\x00\x00\x00\x89\x01" \
           "\xDA\xFF\xFF\xFF\xFF\xFF\x76\xFE" \
           , 16);
    memcpy(bSessionFactor,
           "\x00\x00\x00\x00\x00\x00\x00\x02" \
           "\x00\x00\x00\x00\x00\x00\xFF\xFD" \
           , 16);
    /* 669D80C23AED1147ACD33BB3E532B2B8 */
    /* 00000001680000000000000001560000008000015607110901DCCD7C167D00000203A000028000000000000000000000 */
    memcpy(bData,
           "\x00\x00\x00\x01\x68\x00\x00\x00\x00\x00\x00\x00\x01\x56\x00\x00"
           "\x00\x80\x00\x01\x56\x07\x11\x09\x01\xDC\xCD\x7C\x16\x7D\x00\x00"
           "\x02\x03\xA0\x00\x02"
           , 37);
    nDataLen = 37;
    /* 378804CC872FCDAD3AAB71EA2BC9E71FAA1180963C126B78F2972305FC8AA919 205BD2A2A1E8E9C4 C9F0B06E8B3DCDDE */
    memcpy(bARQC, "\x20\x5B\xD2\xA2\xA1\xE8\xE9\xC4", 8);

    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nIccType  = %d\n", nIccType);
    DspHex("[IN ]bKey      =", bKey, 16);
    DspHex("[IN ]bCardFactor =", bCardFactor, 8);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 2);
    DspHex("[IN ]bData     =", bData, 37);
    printf("[IN ]nDataLen  = %d\n", nDataLen);

    /* Call Test Target Function Start */
    nRet = SMAPIVerifyARQC(nSock, nIccType, bKey, bCardFactor, bSessionFactor, \
                    bData, nDataLen, bARQC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "PBOC卡，SM4, Verify_ARQC测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifyARQC_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nIccType;
	  BYTE bKey[32];
	  BYTE bCardFactor[16];
	  BYTE bSessionFactor[16];
	  BYTE bData[64];
	  int  nDataLen;
	  BYTE bARQC[8];

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bData);
    bufclr(bARQC);

    nIccType = 0x00000417;
    memcpy(bKey,
           "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
           , 16);
    memcpy(bCardFactor,
           "\x25\x00\x00\x00\x00\x00\x89\x01" \
           "\xDA\xFF\xFF\xFF\xFF\xFF\x76\xFE" \
           , 16);
    memcpy(bSessionFactor,
           "\x00\x00\x00\x00\x00\x00\x00\x02" \
           "\x00\x00\x00\x00\x00\x00\xFF\xFD" \
           , 16);
    /* 669D80C23AED1147ACD33BB3E532B2B8 */
    /* 000000016800DCCD7C160002A0800000 */
    memcpy(bData,
           "\x00\x00\x00\x01\x68\x00\xDC\xCD" \
           "\x7C\x16\x00\x02\xA0" \
           , 13);
    nDataLen = 13;
    /* 69250B222FA12A75D25E1477BB48F1D8 */
    memcpy(bARQC, "\x69\x25\x0B\x22\x2F\xA1\x2A\x75", 8);

    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nIccType  = %d\n", nIccType);
    DspHex("[IN ]bKey      =", bKey, 16);
    DspHex("[IN ]bCardFactor =", bCardFactor, 8);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 2);
    DspHex("[IN ]bData     =", bData, 37);
    printf("[IN ]nDataLen  = %d\n", nDataLen);

    /* Call Test Target Function Start */
    nRet = SMAPIVerifyARQC(nSock, nIccType, bKey, bCardFactor, bSessionFactor, \
                    bData, nDataLen, bARQC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "PBOC卡，SM4, Verify_ARQC测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifyARQC_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nIccType;
	  BYTE bKey[32];
	  BYTE bCardFactor[8];
	  BYTE bSessionFactor[2];
	  BYTE bData[64];
	  int  nDataLen;
	  BYTE bARQC[8];

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bData);
    bufclr(bARQC);

    nIccType = 0x00000000;
    memcpy(bKey,
           "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
           , 16);
    memcpy(bCardFactor,
           "\x25\x00\x00\x00\x00\x00\x89\x01"
           , 8);
    memcpy(bSessionFactor,
           "\x00\x02"
           , 2);
    memcpy(bData,
           "\x00\x00\x00\x01\x68\x00\x00\x00\x00\x00\x00\x00\x01\x56\x00\x00"
           "\x00\x80\x00\x01\x56\x07\x11\x09\x01\xDC\xCD\x7C\x16\x7D\x00\x00"
           "\x02\x03\xA0\x00\x02"
           , 37);
    nDataLen = 37;
    memcpy(bARQC, "\x8B\x6F\x6D\x8F\x49\x64\xA6\x0A", 8);

    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nIccType  = %d\n", nIccType);
    DspHex("[IN ]bKey      =", bKey, 16);
    DspHex("[IN ]bCardFactor =", bCardFactor, 8);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 2);
    DspHex("[IN ]bData     =", bData, 37);
    printf("[IN ]nDataLen  = %d\n", nDataLen);

    /* Call Test Target Function Start */
    nRet = SMAPIVerifyARQC(nSock, nIccType, bKey, bCardFactor, bSessionFactor, \
                    bData, nDataLen, bARQC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 21, "PBOC卡，Verify_ARQC测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifyARQC_Test_07(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nIccType;
	  BYTE bKey[32];
	  BYTE bCardFactor[16];
	  BYTE bSessionFactor[16];
	  BYTE bData[64];
	  int  nDataLen;
	  BYTE bARQC[8];

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bData);
    bufclr(bARQC);

    nIccType = 0x0001000A;
	
    memcpy(bKey,
           "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
           , 16);
	
    memcpy(bCardFactor,
           "\x25\x00\x00\x00\x00\x00\x89\x01\xDA\xFF\xFF\xFF\xFF\xFF\x76\xFE"
           , 16);
    //memcpy(bSessionFactor,
    //       "\x00\x02"
     //      , 2);

    bufclr(bSessionFactor);
	
    memcpy(bData,
           "\x00\x00\x00\x01\x68\x00\x00\x00\x00\x00\x00\x00\x01\x56\x00\x00"
           "\x00\x80\x00\x01\x56\x07\x11\x09\x01\xDC\xCD\x7C\x16\x7D\x00\x00"
           "\x02\x03\xA0\x00\x02"
           , 37);
    nDataLen = 37;
	
    memcpy(bARQC, "\xAA\x51\xA6\x05\x74\xFF\x83\x03", 8);

    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nIccType  = %x\n", nIccType);
    DspHex("[IN ]bKey      =", bKey, 16);
    DspHex("[IN ]bCardFactor =", bCardFactor, 16);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 16);
    DspHex("[IN ]bData     =", bData, 37);
    printf("[IN ]nDataLen  = %d\n", nDataLen);

    /* Call Test Target Function Start */
    nRet = SMAPIVerifyARQC(nSock, nIccType, bKey, bCardFactor, bSessionFactor, \
                    bData, nDataLen, bARQC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 21, "VISA卡，Verify_ARQC测试未成功（失败可）");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifyARQC_Test_08(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIccType;
    BYTE bKey[32];
    BYTE bCardFactor[16];
    BYTE bSessionFactor[16];
    BYTE bData[64];
    int  nDataLen;
    BYTE bARQC[8];

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bData);
    bufclr(bARQC);

    nIccType = 0X00020014;

    memcpy(bKey,
           "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4" 
           , 16);
        
    memcpy(bCardFactor,
           "\x25\x00\x00\x00\x00\x00\x89\x01\xDA\xFF\xFF\xFF\xFF\xFF\x76\xFE"
           , 16);
        
    memcpy(bSessionFactor,
           "\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\xFF\xFD"
           , 16);
        
    memcpy(bData,
           "\x00\x00\x00\x01\x20\x00\x00\x00" \
           "\x00\x00\x00\x00\x01\x56\x00\x08" \
           "\x04\xE8\x00\x01\x56\x30\x11\x25" \
           "\x00\xAC\xCE\x7A\xA4\x7C\x00\x00" \
           "\x0E\x03\xA0\xB8\x02"
               , 37);
    nDataLen = 37;
    memcpy(bARQC, "\x02\x87\x61\x1F\xA1\x13\xE6\xF8", 8);    

    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nIccType  = %x\n", nIccType);
    DspHex("[IN ]bKey      =", bKey, 16);
    DspHex("[IN ]bCardFactor =", bCardFactor, 16);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 16);
    DspHex("[IN ]bData     =", bData, 37);
    printf("[IN ]nDataLen  = %d\n", nDataLen);

    /* Call Test Target Function Start */
    nRet = SMAPIVerifyARQC(nSock, nIccType, bKey, bCardFactor, bSessionFactor, \
                    bData, nDataLen, bARQC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 21, "MASTER卡，Verify_ARQC测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifyARQC_Test_09(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nIccType;
	  BYTE bKey[32];
	  BYTE bCardFactor[16];
	  BYTE bSessionFactor[16];
	  BYTE bData[64];
	  int  nDataLen;
	  BYTE bARQC[8];

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bData);
    bufclr(bARQC);

    nIccType = 0x00000401;
    memcpy(bKey,
           "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
           , 16);
    memcpy(bCardFactor,
           "\x25\x00\x00\x00\x00\x00\x89\x01" \
           "\xDA\xFF\xFF\xFF\xFF\xFF\x76\xFE" \
           , 16);
    memcpy(bSessionFactor,
           "\x00\x00\x00\x00\x00\x00\x00\x02" \
           "\x00\x00\x00\x00\x00\x00\xFF\xFD" \
           , 16);
    /* 669D80C23AED1147ACD33BB3E532B2B8 */
    /* 00000001680000000000000001560000008000015607110901DCCD7C167D00000203A000028000000000000000000000 */
    memcpy(bData,
           "\x00\x00\x00\x01\x68\x00\x00\x00\x00\x00\x00\x00\x01\x56\x00\x00"
           "\x00\x80\x00\x01\x56\x07\x11\x09\x01\xDC\xCD\x7C\x16\x7D\x00\x00"
           "\x02\x03\xA0\x00\x02"
           , 37);
    nDataLen = 37;
    /* 378804CC872FCDAD3AAB71EA2BC9E71FAA1180963C126B78F2972305FC8AA919 205BD2A2A1E8E9C4 C9F0B06E8B3DCDDE */
    memcpy(bARQC, "\x20\x5B\xD2\xA2\xA1\xE8\xE9\xC5", 8);

    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nIccType  = %d\n", nIccType);
    DspHex("[IN ]bKey      =", bKey, 16);
    DspHex("[IN ]bCardFactor =", bCardFactor, 8);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 2);
    DspHex("[IN ]bData     =", bData, 37);
    printf("[IN ]nDataLen  = %d\n", nDataLen);

    /* Call Test Target Function Start */
    nRet = SMAPIVerifyARQC(nSock, nIccType, bKey, bCardFactor, bSessionFactor, \
                    bData, nDataLen, bARQC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 21, "PBOC卡，SM4, Verify_ARQC测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifyARQC_Test_10(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nIccType;
	  BYTE bKey[32];
	  BYTE bCardFactor[16];
	  BYTE bSessionFactor[16];
	  BYTE bData[64];
	  int  nDataLen;
	  BYTE bARQC[8];

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bData);
    bufclr(bARQC);

    nIccType = 0x00000417;
    memcpy(bKey,
           "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
           , 16);
    memcpy(bCardFactor,
           "\x25\x00\x00\x00\x00\x00\x89\x01" \
           "\xDA\xFF\xFF\xFF\xFF\xFF\x76\xFE" \
           , 16);
    memcpy(bSessionFactor,
           "\x00\x00\x00\x00\x00\x00\x00\x02" \
           "\x00\x00\x00\x00\x00\x00\xFF\xFD" \
           , 16);
    /* 669D80C23AED1147ACD33BB3E532B2B8 */
    /* 000000016800DCCD7C160002A0800000 */
    memcpy(bData,
           "\x00\x00\x00\x01\x68\x00\xDC\xCD" \
           "\x7C\x16\x00\x02\xA0" \
           , 13);
    nDataLen = 13;
    /* 69250B222FA12A75D25E1477BB48F1D8 */
    memcpy(bARQC, "\x69\x25\x0B\x22\x2F\xA1\x2A\x76", 8);

    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nIccType  = %d\n", nIccType);
    DspHex("[IN ]bKey      =", bKey, 16);
    DspHex("[IN ]bCardFactor =", bCardFactor, 8);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 2);
    DspHex("[IN ]bData     =", bData, 37);
    printf("[IN ]nDataLen  = %d\n", nDataLen);

    /* Call Test Target Function Start */
    nRet = SMAPIVerifyARQC(nSock, nIccType, bKey, bCardFactor, bSessionFactor, \
                    bData, nDataLen, bARQC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 21, "PBOC卡，SM4, Verify_ARQC测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalcARPC_Test_01(void)
{
   	 XXX_TEST_START_XXX
    	int  nRet;
    	int  nSock = SM_SOCK;

	  int  nIccType;
	  BYTE bKey[32];
	  BYTE bCardFactor[8];
	  BYTE bSessionFactor[8];
	  BYTE bARQC[8];
	  BYTE bARC[2];
	  BYTE bARPCFactorLeft[8];
	  BYTE bARPCFactorRight[8];
	  BYTE bARPC[8];
	  BYTE bARPCExp[8];

    	bufclr(bKey);
    	bufclr(bCardFactor);
    	bufclr(bSessionFactor);
    	bufclr(bARQC);
    	bufclr(bARC);
	bufclr(bARPCFactorLeft);
	bufclr(bARPCFactorRight);
    	bufclr(bARPC);
    	bufclr(bARPCExp);

    	nIccType = 0x00000000;
  	memcpy(bKey,
           "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
           , 16);
	
    	memcpy(bCardFactor,
           	"\x25\x00\x00\x00\x00\x00\x89\x01"
           	, 8);
		
    	memcpy(bSessionFactor,  "\x00\x02", 2);

	memcpy(bARQC, "\x8B\x6F\x6D\x8F\x49\x64\xA6\x09", 8);
	memcpy(bARC, "\x30\x30", 2);    	
	memcpy(bARPCFactorLeft, "\x8B\x6F\x6D\x8F\x49\x64\xA6\x09", 8);
    	memcpy(bARPCFactorRight, "\x30\x30\x00\x00\x00\x00\x00\x00", 8);
	SSMBinStrXOR(bARPCFactorLeft, bARPCFactorLeft, bARPCFactorRight, 8);
	
    	memcpy(bARPCExp,  "\x09\x12\x44\x22\x2A\x16\x3D\xFA", 8);

    	printf("[IN ]nSock     = %d\n", nSock);
    	printf("[IN ]nIccType  = %x\n", nIccType);
    	DspHex("[IN ]bKey      =", bKey, 16);
    	DspHex("[IN ]bCardFactor =", bCardFactor, 8);
    	DspHex("[IN ]bSessionFactor =", bSessionFactor, 2);
    	DspHex("[IN ]bARPCFactorLeft     =", bARPCFactorLeft, 8);

    	/* Call Test Target Function Start */
    	nRet = SMAPICalcARPC(nSock, nIccType, bKey, bCardFactor, bSessionFactor, \
                  	bARQC, bARC, bARPC);
    	/* Call Test Target Function End */

    	XXX_RESULT_XXX
    	ASSERT_RESULT(nRet, 0, "PBOC卡，Calc_ARPC测试未成功");
   	 XXX_RESULT_XXX

    	XXX_OUTPUT_XXX
    	ASSERT_OUT_HEX(bARPC, bARPCExp, 8);
   	XXX_OUTPUT_XXX

	DspHex("[RESULT ]expected ARPC =", bARPCExp, 8);
	DspHex("[RESULT ]calculated ARPC  =", bARPC, 8);

    	XXX_TEST_END_XXX
}

void CalcARPC_Test_02(void)
{
    	XXX_TEST_START_XXX
    	int  nRet;
    	int  nSock = SM_SOCK;

	  int  nIccType;
	  BYTE bKey[32];
	  BYTE bCardFactor[16];
	  BYTE bSessionFactor[16];
	  BYTE bARQC[8];
	  BYTE bARC[2];
	  BYTE bARPCFactorLeft[8];
	  BYTE bARPCFactorRight[8];
	  BYTE bARPC[8];
	  BYTE bARPCExp[8];

    	bufclr(bKey);
    	bufclr(bCardFactor);
    	bufclr(bSessionFactor);
    	bufclr(bARQC);
    	bufclr(bARC);
	bufclr(bARPCFactorLeft);
	bufclr(bARPCFactorRight);
    	bufclr(bARPC);
    	bufclr(bARPCExp);

    	nIccType = 0x0001000A;
		
    	memcpy(bKey,
           	"\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
          	, 16);
	memcpy(bCardFactor,
		"\x25\x00\x00\x00\x00\x00\x89\x01\xDA\xFF\xFF\xFF\xFF\xFF\x76\xFE"
		, 16);

	memcpy(bARQC, "\x8B\x6F\x6D\x8F\x49\x64\xA6\x09", 8);
	memcpy(bARC, "\x30\x30", 2);    	
	memcpy(bARPCFactorLeft, "\x8B\x6F\x6D\x8F\x49\x64\xA6\x09", 8);
    	memcpy(bARPCFactorRight, "\x30\x30\x00\x00\x00\x00\x00\x00", 8);
	SSMBinStrXOR(bARPCFactorLeft, bARPCFactorLeft, bARPCFactorRight, 8);
	
    	memcpy(bARPCExp, "\xD3\x94\x9C\x71\x61\x17\x4A\x48", 8);

    	printf("[IN ]nSock     = %d\n", nSock);
    	printf("[IN ]nIccType  = %x\n", nIccType);
    	DspHex("[IN ]bKey      =", bKey, 16);
    	DspHex("[IN ]bCardFactor =", bCardFactor, 16);
    	DspHex("[IN ]bSessionFactor =", bSessionFactor, 16);
    	DspHex("[IN ]bARPCFactorLeft     =", bARPCFactorLeft, 8);

    	/* Call Test Target Function Start */
    	nRet = SMAPICalcARPC(nSock, nIccType, bKey, bCardFactor, bSessionFactor, \
                  	bARPCFactorLeft, bARC, bARPC);
    	/* Call Test Target Function End */

    	XXX_RESULT_XXX
    	ASSERT_RESULT(nRet, 0, "VISA卡，Calc_ARPC测试未成功");
    	XXX_RESULT_XXX

    	XXX_OUTPUT_XXX
    	ASSERT_OUT_HEX(bARPC, bARPCExp, 8);
    	XXX_OUTPUT_XXX

	DspHex("[RESULT ]expected ARPC =", bARPCExp, 8);
	DspHex("[RESULT ]calculated ARPC  =", bARPC, 8);

    	XXX_TEST_END_XXX
}

void CalcARPC_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIccType;
    BYTE bKey[32];
    BYTE bCardFactor[16];
    BYTE bSessionFactor[16];
    BYTE bARQC[8];
    BYTE bARC[2];
    BYTE bARPCFactorLeft[8];
    BYTE bARPCFactorRight[8];
    BYTE bARPC[8];
    BYTE bARPCExp[8];

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bARQC);
    bufclr(bARC);
    bufclr(bARPCFactorLeft);
    bufclr(bARPCFactorRight);
    bufclr(bARPC);
    bufclr(bARPCExp);

    nIccType = 0x00020014;
        
    memcpy(bKey,
           "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
          , 16);
    memcpy(bCardFactor,
        "\x25\x00\x00\x00\x00\x00\x89\x01\xDA\xFF\xFF\xFF\xFF\xFF\x76\xFE"
        , 16);
    memcpy(bSessionFactor,  
        "\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\xFF\xFD"
        , 16);
        
    memcpy(bARQC, "\x8B\x6F\x6D\x8F\x49\x64\xA6\x09", 8);
    memcpy(bARC, "\x30\x30", 2);        
    memcpy(bARPCFactorLeft, "\x8B\x6F\x6D\x8F\x49\x64\xA6\x09", 8);
    memcpy(bARPCFactorRight, "\x30\x30\x00\x00\x00\x00\x00\x00", 8);
    SSMBinStrXOR(bARPCFactorLeft, bARPCFactorLeft, bARPCFactorRight, 8);
    
    memcpy(bARPCExp, "\x09\x12\x44\x22\x2A\x16\x3D\xFA", 8);        

    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nIccType  = %x\n", nIccType);
    DspHex("[IN ]bKey      =", bKey, 16);
    DspHex("[IN ]bCardFactor =", bCardFactor, 16);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 16);
    DspHex("[IN ]bARPCFactorLeft     =", bARPCFactorLeft, 8);

    /* Call Test Target Function Start */
    nRet = SMAPICalcARPC(nSock, nIccType, bKey, bCardFactor, bSessionFactor, \
                     bARPCFactorLeft, bARC, bARPC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "MASTER卡，Calc_ARPC测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bARPC, bARPCExp, 8);
    XXX_OUTPUT_XXX

    DspHex("[RESULT ]expected ARPC =", bARPCExp, 8);
    DspHex("[RESULT ]calculated ARPC  =", bARPC, 8);

    XXX_TEST_END_XXX
}

void CalcARPC_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIccType;
    BYTE bKey[32];
    BYTE bCardFactor[16];
    BYTE bSessionFactor[16];
    BYTE bARQC[8];
    BYTE bARC[2];
    BYTE bARPCFactor[16];
    BYTE bARPC[8];
    BYTE bARPCExp[8];

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bARQC);
    bufclr(bARC);
    bufclr(bARPCFactor);
    bufclr(bARPC);
    bufclr(bARPCExp);

    nIccType = 0x00000401;

    memcpy(bKey,
           "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
           , 16);
    memcpy(bCardFactor,
           "\x25\x00\x00\x00\x00\x00\x89\x01" \
           "\xDA\xFF\xFF\xFF\xFF\xFF\x76\xFE" \
           , 16);
    memcpy(bSessionFactor,
           "\x00\x00\x00\x00\x00\x00\x00\x02" \
           "\x00\x00\x00\x00\x00\x00\xFF\xFD" \
           , 16);
    memcpy(bARQC, "\x20\x5B\xD2\xA2\xA1\xE8\xE9\xC4", 8);
    
    /* 205BD2A2A1E8E9C4  XOR 3030000000000000 = 106BD2A2A1E8E9C4 */

    memcpy(bARPCFactor, "\x30\x30", 2);
    SSMBinStrXOR(bARPCFactor, bARPCFactor, bARQC, 8);

    /* 669D80C23AED1147ACD33BB3E532B2B8 */
    /* 106BD2A2A1E8E9C40000000000000000 */
    /* ABB623C745BB6BE19CE389255C7D5FF2 */
    memcpy(bARPCExp, "\xAB\xB6\x23\xC7\x45\xBB\x6B\xE1", 8);

    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nIccType  = %x\n", nIccType);
    DspHex("[IN ]bKey      =", bKey, 16);
    DspHex("[IN ]bCardFactor =", bCardFactor, 16);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 16);
    DspHex("[IN ]bARPCFactor =", bARPCFactor, 16);

    /* Call Test Target Function Start */
    nRet = SMAPICalcARPC(nSock, nIccType, bKey, bCardFactor, bSessionFactor, \
                      bARPCFactor, bARC, bARPC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "PBOC卡，SM4, Calc_ARPC测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bARPC, bARPCExp, 8);
    XXX_OUTPUT_XXX

//    DspHex("[RESULT ]expected ARPC =", bARPCExp, 8);
//    DspHex("[RESULT ]calculated ARPC  =", bARPC, 8);

    XXX_TEST_END_XXX
}

void CalcARPC_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIccType;
    BYTE bKey[32];
    BYTE bCardFactor[16];
    BYTE bSessionFactor[16];
    BYTE bARQC[8];
    BYTE bARC[2];
    BYTE bARPCFactor[16];
    BYTE bARPC[8];
    BYTE bARPCExp[8];

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bARQC);
    bufclr(bARC);
    bufclr(bARPCFactor);
    bufclr(bARPC);
    bufclr(bARPCExp);

    nIccType = 0x00000417;
    memcpy(bKey,
           "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4"
           , 16);
    memcpy(bCardFactor,
           "\x25\x00\x00\x00\x00\x00\x89\x01" \
           "\xDA\xFF\xFF\xFF\xFF\xFF\x76\xFE" \
           , 16);
    memcpy(bSessionFactor,
           "\x00\x00\x00\x00\x00\x00\x00\x02" \
           "\x00\x00\x00\x00\x00\x00\xFF\xFD" \
           , 16);
    memcpy(bARQC, "\x20\x5B\xD2\xA2\xA1\xE8\xE9\xC4", 8);
    
    /* 205BD2A2A1E8E9C4  XOR 3030000000000000 = 106BD2A2A1E8E9C4 */

    memcpy(bARPCFactor, "\x30\x30", 2);
    SSMBinStrXOR(bARPCFactor, bARPCFactor, bARQC, 8);

    /* 669D80C23AED1147ACD33BB3E532B2B8 */
    /* 106BD2A2A1E8E9C40000000000000000 */
    /* ABB623C745BB6BE19CE389255C7D5FF2 */
    memcpy(bARPCExp, "\xAB\xB6\x23\xC7\x45\xBB\x6B\xE1", 8);

    printf("[IN ]nSock     = %d\n", nSock);
    printf("[IN ]nIccType  = %x\n", nIccType);
    DspHex("[IN ]bKey      =", bKey, 16);
    DspHex("[IN ]bCardFactor =", bCardFactor, 16);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 16);
    DspHex("[IN ]bARPCFactor =", bARPCFactor, 16);

    /* Call Test Target Function Start */
    nRet = SMAPICalcARPC(nSock, nIccType, bKey, bCardFactor, bSessionFactor, \
                      bARPCFactor, bARC, bARPC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "PBOC卡，SM4, Calc_ARPC测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bARPC, bARPCExp, 8);
    XXX_OUTPUT_XXX

//    DspHex("[RESULT ]expected ARPC =", bARPCExp, 8);
//    DspHex("[RESULT ]calculated ARPC  =", bARPC, 8);

    XXX_TEST_END_XXX
}

void EncryptWithDerivedKey_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nType;
    int  nIccType;
    int  nMode;
    BYTE bKey[32];
    BYTE bCardFactor[8];
    BYTE bSessionFactor[8];
    BYTE bIV[8];
    BYTE bInData[256];
    int  nInLen = 0;
    BYTE bOutData[256];
    int  nOutLen = 0;
    BYTE bOutDataExp[256];
    int  nOutLenExp;

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bIV);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nType = 1;
    nIccType = 0x00000000;
    nMode = 0;
        
    memcpy(bKey, "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4", 16);
    memcpy(bCardFactor, "\x25\x00\x00\x00\x00\x00\x89\x01", 8);
    memcpy(bSessionFactor, "\x00\x02", 2);
    memcpy(bInData, "\x04\x12\x34\xFF\x37\x1C\xF2\xA4", 8);
    nInLen = 8;
    memcpy(bOutDataExp, "\x0F\x3D\x99\xC3\xD5\xBB\x85\x8A\xF5\x50\x1C\xDA\x91\x41\xB8\x76", 16);
    nOutLenExp = 16;
    
    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nIccType  = %x\n", nIccType);
    DspHex("[IN ]bKey      =", bKey, 16);
    DspHex("[IN ]bCardFactor =", bCardFactor, 16);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 16);
    DspHex("[IN ]bInData     =", bInData, nInLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptWithDerivedKey(nSock, nType, nIccType, nMode, bKey, bCardFactor,
                               bSessionFactor, bIV, bInData, nInLen, bOutData, &nOutLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "PBOC卡，ECB加密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData =", bOutData, 16);
    printf("[OUT]nOutLen  = %d\n", nOutLen);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, nOutLenExp);
    ASSERT_OUT(nOutLen, nOutLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptWithDerivedKey_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nType;
    int  nIccType;
    int  nMode;
    BYTE bKey[32];
    BYTE bCardFactor[8];
    BYTE bSessionFactor[8];
    BYTE bIV[8];
    BYTE bInData[256];
    int  nInLen;
    BYTE bOutData[256];
    int  nOutLen;
    BYTE bOutDataExp[256];
    int  nOutLenExp;

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bIV);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nType = 0;
    nIccType = 0;
    nMode = 0;
        
    memcpy(bKey, "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4", 16);
    memcpy(bCardFactor, "\x25\x00\x00\x00\x00\x00\x89\x01", 8);
    memcpy(bSessionFactor, "\x00\x02", 2);
    memcpy(bInData, "\x0F\x3D\x99\xC3\xD5\xBB\x85\x8A\xF5\x50\x1C\xDA\x91\x41\xB8\x76", 16);
    nInLen = 16;
    memcpy(bOutDataExp, "\x04\x12\x34\xFF\x37\x1C\xF2\xA4", 8); 
    nOutLenExp = 8;   
    
    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nIccType  = %x\n", nIccType);
    DspHex("[IN ]bKey      =", bKey, 16);
    DspHex("[IN ]bCardFactor =", bCardFactor, 16);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 16);
    DspHex("[IN ]bInData     =", bInData, nInLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptWithDerivedKey(nSock, nType, nIccType, nMode, bKey, bCardFactor,
                               bSessionFactor, bIV, bInData, nInLen, bOutData, &nOutLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "PBOC卡，ECB解密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData =", bOutData, 8);
    printf("[OUT]nOutLen  = %d\n", nOutLen);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, nOutLenExp);
    ASSERT_OUT(nOutLen, nOutLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptWithDerivedKey_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nType;
    int  nIccType;
    int  nMode;
    BYTE bKey[32];
    BYTE bCardFactor[16];
    BYTE bSessionFactor[16];
    BYTE bIV[8];
    BYTE bInData[256];
    int  nInLen;
    BYTE bOutData[256];
    int  nOutLen;
    BYTE bOutDataExp[256];
    int  nOutLenExp;

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bIV);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nType = 1;
    nIccType = 0x0001000A;
    nMode = 0;

    memcpy(bKey, 
        "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4", 
        16);
    memcpy(bCardFactor, \
        "\x25\x00\x00\x00\x00\x00\x89\x01\xDA\xFF\xFF\xFF\xFF\xFF\x76\xFE", 
        16);        
    memcpy(bSessionFactor, \
        "\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\xFF\xFD", 
        16);        
    memcpy(bInData, "\x04\x12\x34\xFF\x37\x1C\xF2\xA4", 8);        
        nInLen = 8;
    memcpy(bOutDataExp,"\x94\x85\xC1\x25\xFF\xA7\x9C\x3E\x68\x55\x0E\xB2\x4C\xF6\x91\x4E", 16);
    nOutLenExp = 16;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nIccType  = %x\n", nIccType);
    DspHex("[IN ]bKey       =", bKey, 16);
    DspHex("[IN ]bCardFactor =", bCardFactor, 16);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 16);
    DspHex("[IN ]bInData     =", bInData, nInLen);
    DspHex("[IN ]bIV     =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptWithDerivedKey(nSock, nType, nIccType, nMode, bKey, bCardFactor,
                               bSessionFactor, bIV, bInData, nInLen, bOutData, &nOutLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "VISA卡，ECB加密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData =", bOutData, 16);
    printf("[OUT]nOutLen  = %d\n", nOutLen);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, nOutLenExp);
    ASSERT_OUT(nOutLen, nOutLenExp);
    XXX_OUTPUT_XXX
            
    XXX_TEST_END_XXX
}

void EncryptWithDerivedKey_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nType;
    int  nIccType;
    int  nMode;
    BYTE bKey[32];
    BYTE bCardFactor[16];
    BYTE bSessionFactor[16];
    BYTE bIV[8];
    BYTE bInData[256];
    int  nInLen;
    BYTE bOutData[256];
    int  nOutLen;
    BYTE bOutDataExp[256];
    int  nOutLenExp;

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bIV);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nType = 0;
    nIccType = 0x0001000A;
    nMode = 0;

    memcpy(bKey, 
        "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4", 
        16);
    memcpy(bCardFactor, \
        "\x25\x00\x00\x00\x00\x00\x89\x01\xDA\xFF\xFF\xFF\xFF\xFF\x76\xFE", 
        16);        
    memcpy(bSessionFactor, \
        "\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\xFF\xFD", 
        16);        
    memcpy(bInData, "\x94\x85\xC1\x25\xFF\xA7\x9C\x3E\x68\x55\x0E\xB2\x4C\xF6\x91\x4E", 16);        
    nInLen = 16;
    memcpy(bOutDataExp,"\x04\x12\x34\xFF\x37\x1C\xF2\xA4",8);
    nOutLenExp = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nIccType  = %x\n", nIccType);
    DspHex("[IN ]bKey       =", bKey, 16);
    DspHex("[IN ]bCardFactor =", bCardFactor, 16);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 16);
    DspHex("[IN ]bInData     =", bInData, nInLen);
    DspHex("[IN ]bIV     =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptWithDerivedKey(nSock, nType, nIccType, nMode, bKey, bCardFactor,
                               bSessionFactor, bIV, bInData, nInLen, bOutData, &nOutLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "VISA卡，ECB解密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData =", bOutData, 8);
    printf("[OUT]nOutLen  = %d\n", nOutLen);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, nOutLenExp);
    ASSERT_OUT(nOutLen, nOutLenExp);
    XXX_OUTPUT_XXX
            
    XXX_TEST_END_XXX
}

void EncryptWithDerivedKey_Test_05(void)
{
   	XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nType;
	  int  nIccType;
	  int  nMode;
	  BYTE bKey[32];
	  BYTE bCardFactor[8];
	  BYTE bSessionFactor[8];
	  BYTE bIV[8];
	  BYTE bInData[256];
	  int  nInLen;
	  BYTE bOutData[256];
	  int  nOutLen;
	  BYTE bOutDataExp[256];
    int  nOutLenExp;

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bIV);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nType = 1;
    nIccType = 0;
    nMode = 1;
    
    /* Key = F431623E499789C8C2F1F725AD7F8949 */
    /* CF = 2500000000008901DAFFFFFFFFFF76FE */
    /* SF = 0000000000000002000000000000FFFD */
    /* Data = 08 041234FF371CF2A4 80000000000000 */
    /* Key1 = 89E8 1ECA 276C 7D50 A537 AE51 2E11 5224 */
    /* Key2 = 4FA1 BB65 DC84 58BF ED43 C210 F4FD 4711 */
    /* Out = 0F3D 99C3 D5BB 858A C6BE B65E 97E6 1C7C */

    memcpy(bKey, "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4", 16);
    memcpy(bCardFactor, "\x25\x00\x00\x00\x00\x00\x89\x01", 8);
    memcpy(bSessionFactor, "\x00\x02", 2);
    memcpy(bInData, "\x04\x12\x34\xFF\x37\x1C\xF2\xA4", 8);
    nInLen = 8;
    memcpy(bOutDataExp, "\x0F\x3D\x99\xC3\xD5\xBB\x85\x8A\xC6\xBE\xB6\x5E\x97\xE6\x1C\x7C", 16);
    memcpy(bIV, "\x00\x00\x00\x00\x00\x00\x00\x00", 8);

    nOutLenExp = 16;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nIccType  = %x\n", nIccType);
    DspHex("[IN ]bKey      =", bKey, 16);
    DspHex("[IN ]bCardFactor =", bCardFactor, 16);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 16);
    DspHex("[IN ]bIV =", bIV, 8);
    DspHex("[IN ]bInData     =", bInData, nInLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptWithDerivedKey(nSock, nType, nIccType, nMode, bKey, bCardFactor,
                              bSessionFactor, bIV, bInData, nInLen, bOutData, &nOutLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "PBOC卡，CBC加密，初始向量0x00，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData =", bOutData, 8);
    printf("[OUT]nOutLen  = %d\n", nOutLen);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, nOutLenExp);
    ASSERT_OUT(nOutLen, nOutLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptWithDerivedKey_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nType;
	  int  nIccType;
	  int  nMode;
	  BYTE bKey[32];
	  BYTE bCardFactor[8];
	  BYTE bSessionFactor[8];
	  BYTE bIV[8];
	  BYTE bInData[256];
	  int  nInLen;
	  BYTE bOutData[256];
	  int  nOutLen;
	  BYTE bOutDataExp[8];
    int  nOutLenExp;

    /* Key = F431623E499789C8C2F1F725AD7F8949 */
    /* CF = 2500000000008901DAFFFFFFFFFF76FE */
    /* SF = 0000000000000002000000000000FFFD */
    /* Data = 08 041234FF371CF2A4 80000000000000 */
    /* Key1 = 89E8 1ECA 276C 7D50 A537 AE51 2E11 5224 */
    /* Key2 = 4FA1 BB65 DC84 58BF ED43 C210 F4FD 4711 */
    /* Out = 0F3D 99C3 D5BB 858A C6BE B65E 97E6 1C7C */

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bIV);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nType = 0;
    nIccType = 0;
    nMode = 1;
		
    memcpy(bKey, "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4", 16);
    memcpy(bCardFactor, "\x25\x00\x00\x00\x00\x00\x89\x01", 8);
    memcpy(bSessionFactor, "\x00\x02", 2);
    memcpy(bInData, "\x0F\x3D\x99\xC3\xD5\xBB\x85\x8A\xC6\xBE\xB6\x5E\x97\xE6\x1C\x7C", 16);
    nInLen = 16;
    memcpy(bOutDataExp, "\x04\x12\x34\xFF\x37\x1C\xF2\xA4", 8);
    nOutLenExp = 8;
    memcpy(bIV, "\x00\x00\x00\x00\x00\x00\x00\x00", 8);
	
    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nIccType  = %x\n", nIccType);
    DspHex("[IN ]bKey      =", bKey, 16);
    DspHex("[IN ]bCardFactor =", bCardFactor, 16);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 16);
    DspHex("[IN ]bInData     =", bInData, nInLen);
    DspHex("[IN ]bIV     =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptWithDerivedKey(nSock, nType, nIccType, nMode, bKey, bCardFactor,
                              bSessionFactor, bIV, bInData, nInLen, bOutData, &nOutLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "PBOC卡，CBC解密，初始向量0x00，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData =", bOutData, 8);
    printf("[OUT]nOutLen  = %d\n", nOutLen);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, nOutLenExp);
    ASSERT_OUT(nOutLen, nOutLenExp);
    XXX_OUTPUT_XXX

   	XXX_TEST_END_XXX   
}

void EncryptWithDerivedKey_Test_07(void)
{
   	XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nType;
	  int  nIccType;
	  int  nMode;
	  BYTE bKey[32];
	  BYTE bCardFactor[8];
	  BYTE bSessionFactor[8];
	  BYTE bIV[8];
	  BYTE bInData[256];
	  int  nInLen;
	  BYTE bOutData[256];
	  int  nOutLen;
	  BYTE bOutDataExp[16];
    int  nOutLenExp;

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bIV);
    bufclr(bInData);
    bufclr(bOutData);
	  bufclr(bOutDataExp);

    /* Key = F431623E499789C8C2F1F725AD7F8949 */
    /* CF = 2500000000008901DAFFFFFFFFFF76FE */
    /* SF = 0000000000000002000000000000FFFD */
    /* Data = 08 041234FF371CF2A4 80000000000000 */
    /* Key1 = 89E8 1ECA 276C 7D50 A537 AE51 2E11 5224 */
    /* Key2 = 4FA1 BB65 DC84 58BF ED43 C210 F4FD 4711 */
    /* IV = 0102030405060708 */
    /* Out = 010B C82E DC01 6755 717B 9EDA C1B3 994C */

    nType = 1;
    nIccType = 0;
    nMode = 1;
		
    memcpy(bKey, "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4", 16);
    memcpy(bCardFactor, "\x25\x00\x00\x00\x00\x00\x89\x01", 8);
    memcpy(bSessionFactor, "\x00\x02", 2);
    memcpy(bInData, "\x04\x12\x34\xFF\x37\x1C\xF2\xA4", 8);
    nInLen = 8;
    memcpy(bIV, "\x01\x02\x03\x04\x05\x06\x07\x08", 8);
    memcpy(bOutDataExp, "\x01\x0B\xC8\x2E\xDC\x01\x67\x55\x71\x7B\x9E\xDA\xC1\xB3\x99\x4C", 16);
    nOutLenExp = 16;
	
    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nIccType  = %x\n", nIccType);
    DspHex("[IN ]bKey      =", bKey, 16);
    DspHex("[IN ]bCardFactor =", bCardFactor, 16);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 16);
    DspHex("[IN ]bIV =", bIV, 8);
    DspHex("[IN ]bInData     =", bInData, nInLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptWithDerivedKey(nSock, nType, nIccType, nMode, bKey, bCardFactor,
                              bSessionFactor, bIV, bInData, nInLen, bOutData, &nOutLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "PBOC卡，CBC加密，初始向量0x0n，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData =", bOutData, 8);
    printf("[OUT]nOutLen  = %d\n", nOutLen);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, nOutLenExp);
    ASSERT_OUT(nOutLen, nOutLenExp);
    XXX_OUTPUT_XXX
			
    XXX_TEST_END_XXX
}

void EncryptWithDerivedKey_Test_08(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nType;
	  int  nIccType;
	  int  nMode;
	  BYTE bKey[32];
	  BYTE bCardFactor[8];
	  BYTE bSessionFactor[8];
	  BYTE bIV[8];
	  BYTE bInData[256];
	  int  nInLen;
	  BYTE bOutData[256];
	  int  nOutLen;
	  BYTE bOutDataExp[8];
    int  nOutLenExp;

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bIV);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    /* Key = F431623E499789C8C2F1F725AD7F8949 */
    /* CF = 2500000000008901DAFFFFFFFFFF76FE */
    /* SF = 0000000000000002000000000000FFFD */
    /* Data = 08 041234FF371CF2A4 80000000000000 */
    /* Key1 = 89E8 1ECA 276C 7D50 A537 AE51 2E11 5224 */
    /* Key2 = 4FA1 BB65 DC84 58BF ED43 C210 F4FD 4711 */
    /* IV = 0102030405060708 */
    /* Out = 010B C82E DC01 6755 717B 9EDA C1B3 994C */

    nType = 0;
    nIccType = 0;
    nMode = 1;
		
    memcpy(bKey, "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4", 16);
    memcpy(bCardFactor, "\x25\x00\x00\x00\x00\x00\x89\x01", 8);
    memcpy(bSessionFactor, "\x00\x02", 2);
    memcpy(bInData, "\x01\x0B\xC8\x2E\xDC\x01\x67\x55\x71\x7B\x9E\xDA\xC1\xB3\x99\x4C", 16);
    nInLen = 16;
    memcpy(bIV, "\x01\x02\x03\x04\x05\x06\x07\x08", 8);
    memcpy(bOutDataExp, "\x04\x12\x34\xFF\x37\x1C\xF2\xA4", 8);
    nOutLenExp = 8;	
	
    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nIccType  = %x\n", nIccType);
    DspHex("[IN ]bKey      =", bKey, 16);
    DspHex("[IN ]bCardFactor =", bCardFactor, 16);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 16);
    DspHex("[IN ]bIV =", bIV, 8);
    DspHex("[IN ]bInData     =", bInData, nInLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptWithDerivedKey(nSock, nType, nIccType, nMode, bKey, bCardFactor,
                              bSessionFactor, bIV, bInData, nInLen, bOutData, &nOutLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "PBOC卡，CBC解密，初始向量0x0n，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData =", bOutData, 8);
    printf("[OUT]nOutLen  = %d\n", nOutLen);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, nOutLenExp);
    ASSERT_OUT(nOutLen, nOutLenExp);
    XXX_OUTPUT_XXX
	
   	XXX_TEST_END_XXX
}

void EncryptWithDerivedKey_Test_09(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nType;
	  int  nIccType;
	  int  nMode;
	  BYTE bKey[32];
	  BYTE bCardFactor[8];
	  BYTE bSessionFactor[8];
	  BYTE bIV[8];
	  BYTE bInData[256];
	  int  nInLen;
	  BYTE bOutData[256];
	  int  nOutLen;

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bIV);
    bufclr(bInData);
    bufclr(bOutData);

    nSock = -1;
    nType = 1;
    nIccType = 0;
    nMode = 0;
    memcpy(bKey, "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4", 16);
    memcpy(bCardFactor, "\x25\x00\x00\x00\x00\x00\x89\x01", 8);
    memcpy(bSessionFactor, "\x00\x02", 2);
    memcpy(bInData, "\x04\x12\x34\xFF\x37\x1C\xF2\xA4", 8);
    nInLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptWithDerivedKey(nSock, nType, nIccType, nMode, bKey, bCardFactor,
                               bSessionFactor, bIV, bInData, nInLen, bOutData, &nOutLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效Socket ID[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void EncryptWithDerivedKey_Test_10(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nType;
	  int  nIccType;
	  int  nMode;
	  BYTE bKey[32];
	  BYTE bCardFactor[8];
	  BYTE bSessionFactor[8];
	  BYTE bIV[8];
	  BYTE bInData[256];
	  int  nInLen;
	  BYTE bOutData[256];
	  int  nOutLen;

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bIV);
    bufclr(bInData);
    bufclr(bOutData);

    nSock = 8;
    nType = 1;
    nIccType = 0;
    nMode = 0;
    memcpy(bKey, "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4", 16);
    memcpy(bCardFactor, "\x25\x00\x00\x00\x00\x00\x89\x01", 8);
    memcpy(bSessionFactor, "\x00\x02", 2);
    memcpy(bInData, "\x04\x12\x34\xFF\x37\x1C\xF2\xA4", 8);
    nInLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptWithDerivedKey(nSock, nType, nIccType, nMode, bKey, bCardFactor,
                               bSessionFactor, bIV, bInData, nInLen, bOutData, &nOutLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效Socket ID[8]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void EncryptWithDerivedKey_Test_11(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nType;
	  int  nIccType;
	  int  nMode;
	  BYTE bKey[32];
	  BYTE bCardFactor[8];
	  BYTE bSessionFactor[8];
	  BYTE bIV[8];
	  BYTE bInData[256];
	  int  nInLen;
	  BYTE bOutData[256];
	  int  nOutLen;

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bIV);
    bufclr(bInData);
    bufclr(bOutData);

    nType = -1;
    nIccType = 0;
    nMode = 0;
    memcpy(bKey, "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4", 16);
    memcpy(bCardFactor, "\x25\x00\x00\x00\x00\x00\x89\x01", 8);
    memcpy(bSessionFactor, "\x00\x02", 2);
    memcpy(bInData, "\x04\x12\x34\xFF\x37\x1C\xF2\xA4", 8);
    nInLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptWithDerivedKey(nSock, nType, nIccType, nMode, bKey, bCardFactor,
                               bSessionFactor, bIV, bInData, nInLen, bOutData, &nOutLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效加解密标志[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptWithDerivedKey_Test_12(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nType;
	  int  nIccType;
	  int  nMode;
	  BYTE bKey[32];
	  BYTE bCardFactor[8];
	  BYTE bSessionFactor[8];
	  BYTE bIV[8];
	  BYTE bInData[256];
	  int  nInLen;
	  BYTE bOutData[256];
	  int  nOutLen;

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bIV);
    bufclr(bInData);
    bufclr(bOutData);

    nType = 2;
    nIccType = 0;
    nMode = 0;
    memcpy(bKey, "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4", 16);
    memcpy(bCardFactor, "\x25\x00\x00\x00\x00\x00\x89\x01", 8);
    memcpy(bSessionFactor, "\x00\x02", 2);
    memcpy(bInData, "\x04\x12\x34\xFF\x37\x1C\xF2\xA4", 8);
    nInLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptWithDerivedKey(nSock, nType, nIccType, nMode, bKey, bCardFactor,
                               bSessionFactor, bIV, bInData, nInLen, bOutData, &nOutLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效加解密标志[2]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptWithDerivedKey_Test_13(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nType;
	  int  nIccType;
	  int  nMode;
	  BYTE bKey[32];
	  BYTE bCardFactor[8];
	  BYTE bSessionFactor[8];
	  BYTE bIV[8];
	  BYTE bInData[256];
	  int  nInLen;
	  BYTE bOutData[256];
	  int  nOutLen;

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bIV);
    bufclr(bInData);
    bufclr(bOutData);

    nType = 1;
    nIccType = -1;
    nMode = 0;
    memcpy(bKey, "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4", 16);
    memcpy(bCardFactor, "\x25\x00\x00\x00\x00\x00\x89\x01", 8);
    memcpy(bSessionFactor, "\x00\x02", 2);
    memcpy(bInData, "\x04\x12\x34\xFF\x37\x1C\xF2\xA4", 8);
    nInLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptWithDerivedKey(nSock, nType, nIccType, nMode, bKey, bCardFactor,
                               bSessionFactor, bIV, bInData, nInLen, bOutData, &nOutLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效卡片类型[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptWithDerivedKey_Test_14(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nType;
	  int  nIccType;
	  int  nMode;
	  BYTE bKey[32];
	  BYTE bCardFactor[8];
	  BYTE bSessionFactor[8];
	  BYTE bIV[8];
	  BYTE bInData[256];
	  int  nInLen;
	  BYTE bOutData[256];
	  int  nOutLen;

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bIV);
    bufclr(bInData);
    bufclr(bOutData);

    nType = 1;
    nIccType = 2;
    nMode = 0;
    memcpy(bKey, "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4", 16);
    memcpy(bCardFactor, "\x25\x00\x00\x00\x00\x00\x89\x01", 8);
    memcpy(bSessionFactor, "\x00\x02", 2);
    memcpy(bInData, "\x04\x12\x34\xFF\x37\x1C\xF2\xA4", 8);
    nInLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptWithDerivedKey(nSock, nType, nIccType, nMode, bKey, bCardFactor,
                               bSessionFactor, bIV, bInData, nInLen, bOutData, &nOutLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效卡片类型[2]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptWithDerivedKey_Test_15(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nType;
	  int  nIccType;
	  int  nMode;
	  BYTE bKey[32];
	  BYTE bCardFactor[8];
	  BYTE bSessionFactor[8];
	  BYTE bIV[8];
	  BYTE bInData[256];
	  int  nInLen;
	  BYTE bOutData[256];
	  int  nOutLen;

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bIV);
    bufclr(bInData);
    bufclr(bOutData);

    nType = 1;
    nIccType = 0;
    nMode = -1;
    memcpy(bKey, "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4", 16);
    memcpy(bCardFactor, "\x25\x00\x00\x00\x00\x00\x89\x01", 8);
    memcpy(bSessionFactor, "\x00\x02", 2);
    memcpy(bInData, "\x04\x12\x34\xFF\x37\x1C\xF2\xA4", 8);
    nInLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptWithDerivedKey(nSock, nType, nIccType, nMode, bKey, bCardFactor,
                               bSessionFactor, bIV, bInData, nInLen, bOutData, &nOutLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效加密模式[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptWithDerivedKey_Test_16(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nType;
	  int  nIccType;
	  int  nMode;
	  BYTE bKey[32];
	  BYTE bCardFactor[8];
	  BYTE bSessionFactor[8];
	  BYTE bIV[8];
	  BYTE bInData[256];
	  int  nInLen;
	  BYTE bOutData[256];
	  int  nOutLen;

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bIV);
    bufclr(bInData);
    bufclr(bOutData);

    nType = 1;
    nIccType = 0;
    nMode = 2;
    memcpy(bKey, "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4", 16);
    memcpy(bCardFactor, "\x25\x00\x00\x00\x00\x00\x89\x01", 8);
    memcpy(bSessionFactor, "\x00\x02", 2);
    memcpy(bInData, "\x04\x12\x34\xFF\x37\x1C\xF2\xA4", 8);
    nInLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptWithDerivedKey(nSock, nType, nIccType, nMode, bKey, bCardFactor,
                               bSessionFactor, bIV, bInData, nInLen, bOutData, &nOutLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效加密模式[2]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptWithDerivedKey_Test_17(void)
{
   	XXX_TEST_START_XXX
    int  nRet;
   	int  nSock = SM_SOCK;

	  int  nType;
	  int  nIccType;
	  int  nMode;
	  BYTE bKey[32];
	  BYTE bCardFactor[16];
	  BYTE bSessionFactor[16];
	  BYTE bIV[8];
	  BYTE bInData[256];
	  int  nInLen;
	  BYTE bOutData[256];
	  int  nOutLen;
	  BYTE bOutDataExp[16];
	  int  nOutLenExp;

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bIV);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nType = 1;
    nIccType = 0x0001000A;
    nMode = 1;

    /* Key = F431623E499789C8C2F1F725AD7F8949 */
    /* CF = 2500000000008901DAFFFFFFFFFF76FE */
    /* SF = 0000000000000002000000000000FFFD */
    /* Data = 08 041234FF371CF2A4 80000000000000 */
    /* Key1 = 89E8 1ECA 276C 7D50 A537 AE51 2E11 5224 */
    /* Key2 = 89E8 1ECA 276C 7D52 A537 AE51 2E11 ADD9 */
    /* Out = 9485 C125 FFA7 9C3E E13E 4B70 782C 707F */

    memcpy(bKey, 
		       "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4", 
		       16);
    memcpy(bCardFactor, \
		       "\x25\x00\x00\x00\x00\x00\x89\x01\xDA\xFF\xFF\xFF\xFF\xFF\x76\xFE", 
		       16);
    memcpy(bSessionFactor, \
		       "\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\xFF\xFD", 
		       16);		
    memcpy(bInData, "\x04\x12\x34\xFF\x37\x1C\xF2\xA4", 8);
    nInLen = 8;
    memcpy(bOutDataExp, "\x94\x85\xC1\x25\xFF\xA7\x9C\x3E\xE1\x3E\x4B\x70\x78\x2C\x70\x7F", 16);
    nOutLenExp = 16;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nIccType  = %x\n", nIccType);
    DspHex("[IN ]bKey	   =", bKey, 16);
    DspHex("[IN ]bCardFactor =", bCardFactor, 16);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 16);
    DspHex("[IN ]bInData	 =", bInData, nInLen);
    DspHex("[IN ]bIV	 =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptWithDerivedKey(nSock, nType, nIccType, nMode, bKey, bCardFactor,
                              bSessionFactor, bIV, bInData, nInLen, bOutData, &nOutLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "VISA卡，CBC加密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData =", bOutData, 8);
    printf("[OUT]nOutLen  = %d\n", nOutLen);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, nOutLenExp);
    ASSERT_OUT(nOutLen, nOutLenExp);
   	XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptWithDerivedKey_Test_18(void)
{
    XXX_TEST_START_XXX
    int  nRet;
   	int  nSock = SM_SOCK;

	  int  nType;
	  int  nIccType;
	  int  nMode;
	  BYTE bKey[32];
	  BYTE bCardFactor[16];
	  BYTE bSessionFactor[16];
	  BYTE bIV[8];
	  BYTE bInData[256];
	  int  nInLen;
	  BYTE bOutData[256];
	  int  nOutLen;
	  BYTE bOutDataExp[16];
	  int  nOutLenExp;

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bIV);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nType = 0;
    nIccType = 0x0001000A;
    nMode = 1;

    /* Key = F431623E499789C8C2F1F725AD7F8949 */
    /* CF = 2500000000008901DAFFFFFFFFFF76FE */
    /* SF = 0000000000000002000000000000FFFD */
    /* Data = 08 041234FF371CF2A4 80000000000000 */
    /* Key1 = 89E8 1ECA 276C 7D50 A537 AE51 2E11 5224 */
    /* Key2 = 89E8 1ECA 276C 7D52 A537 AE51 2E11 ADD9 */
    /* Out = 9485 C125 FFA7 9C3E E13E 4B70 782C 707F */

    memcpy(bKey, 
		       "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4", 
		       16);
    memcpy(bCardFactor, \
		       "\x25\x00\x00\x00\x00\x00\x89\x01\xDA\xFF\xFF\xFF\xFF\xFF\x76\xFE", 
		       16);		
    memcpy(bSessionFactor, \
		       "\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\xFF\xFD", 
		       16);
    memcpy(bInData, "\x94\x85\xC1\x25\xFF\xA7\x9C\x3E\xE1\x3E\x4B\x70\x78\x2C\x70\x7F", 16);
    nInLen = 16;
    memcpy(bOutDataExp, "\x04\x12\x34\xFF\x37\x1C\xF2\xA4", 8);
    nOutLenExp = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nIccType  = %x\n", nIccType);
    DspHex("[IN ]bKey	   =", bKey, 16);
    DspHex("[IN ]bCardFactor =", bCardFactor, 16);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 16);
    DspHex("[IN ]bInData	 =", bInData, nInLen);
    DspHex("[IN ]bIV	 =", bIV, 8);
   	XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptWithDerivedKey(nSock, nType, nIccType, nMode, bKey, bCardFactor,
                              bSessionFactor, bIV, bInData, nInLen, bOutData, &nOutLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "VISA卡，CBC解密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData =", bOutData, 8);
    printf("[OUT]nOutLen  = %d\n", nOutLen);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, nOutLenExp);
    ASSERT_OUT(nOutLen, nOutLenExp);
    XXX_OUTPUT_XXX

   XXX_TEST_END_XXX
}

void EncryptWithDerivedKey_Test_19(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nType;
    int  nIccType;
    int  nMode;
    BYTE bKey[32];
    BYTE bCardFactor[16];
    BYTE bSessionFactor[16];
    BYTE bIV[8];
    BYTE bInData[256];
    int  nInLen;
    BYTE bOutData[256];
    int  nOutLen;
    BYTE bOutDataExp[256];
    int  nOutLenExp;

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bIV);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nType = 1;
    nIccType = 0x00020014;
    nMode = 0;

    /* Key = F431623E499789C8C2F1F725AD7F8949 */
    /* CF = 2500000000008901DAFFFFFFFFFF76FE */
    /* SF = 0000000000000002000000000000FFFD */
    /* Data = 041234FF371CF2A4 */
    /* Key1 = 89E8 1ECA 276C 7D50 A537 AE51 2E11 5224 */
    /* Key2 = 4FA1 BB65 DC84 58BF ED43 C210 F4FD 4711 */
    /* Out = AEF3 B941 5ED5 97FC */

    memcpy(bKey, 
        "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4", 
        16);
    memcpy(bCardFactor, \
        "\x25\x00\x00\x00\x00\x00\x89\x01\xDA\xFF\xFF\xFF\xFF\xFF\x76\xFE", 
        16);        
    memcpy(bSessionFactor, \
        "\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\xFF\xFD", 
        16);        
    memcpy(bInData, "\x04\x12\x34\xFF\x37\x1C\xF2\xA4", 8);        
    nInLen = 8;
    memcpy(bOutDataExp, "\xAE\xF3\xB9\x41\x5E\xD5\x97\xFC", 8);
    nOutLenExp = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nIccType  = %x\n", nIccType);
    DspHex("[IN ]bKey       =", bKey, 16);
    DspHex("[IN ]bCardFactor =", bCardFactor, 16);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 16);
    DspHex("[IN ]bInData     =", bInData, nInLen);
    DspHex("[IN ]bIV     =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptWithDerivedKey(nSock, nType, nIccType, nMode, bKey, bCardFactor,
                               bSessionFactor, bIV, bInData, nInLen, bOutData, &nOutLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "MASTER卡，ECB加密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData =", bOutData, 8);
    printf("[OUT]nOutLen  = %d\n", nOutLen);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, nOutLenExp);
    ASSERT_OUT(nOutLen, nOutLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptWithDerivedKey_Test_20(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nType;
    int  nIccType;
    int  nMode;
    BYTE bKey[32];
    BYTE bCardFactor[16];
    BYTE bSessionFactor[16];
    BYTE bIV[8];
    BYTE bInData[256];
    int  nInLen;
    BYTE bOutData[256];
    int  nOutLen;
    BYTE bOutDataExp[256];
    int  nOutLenExp;

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bIV);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nType = 0;
    nIccType = 0x00020014;
    nMode = 0;

    memcpy(bKey, 
        "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4", 
        16);
    memcpy(bCardFactor, \
        "\x25\x00\x00\x00\x00\x00\x89\x01\xDA\xFF\xFF\xFF\xFF\xFF\x76\xFE", 
        16);        
    memcpy(bSessionFactor, \
        "\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\xFF\xFD", 
        16);        
    memcpy(bInData, "\x04\x12\x34\xFF\x37\x1C\xF2\xA4", 8);        
    nInLen = 8;
    memcpy(bOutDataExp,"\xA8\x22\x93\xDD\x28\xB7\x39\x41",8);
    nOutLenExp = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nIccType  = %x\n", nIccType);
    DspHex("[IN ]bKey       =", bKey, 16);
    DspHex("[IN ]bCardFactor =", bCardFactor, 16);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 16);
    DspHex("[IN ]bInData     =", bInData, nInLen);
    DspHex("[IN ]bIV     =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptWithDerivedKey(nSock, nType, nIccType, nMode, bKey, bCardFactor,
                           bSessionFactor, bIV, bInData, nInLen, bOutData, &nOutLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "MASTER卡，ECB解密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData =", bOutData, 8);
    printf("[OUT]nOutLen  = %d\n", nOutLen);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, nOutLenExp);
    ASSERT_OUT(nOutLen, nOutLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptWithDerivedKey_Test_21(void)
{
    XXX_TEST_START_XXX
    int  nRet;
   	int  nSock = SM_SOCK;

	  int  nType;
	  int  nIccType;
	  int  nMode;
	  BYTE bKey[32];
	  BYTE bCardFactor[16];
	  BYTE bSessionFactor[16];
	  BYTE bIV[8];
	  BYTE bInData[256];
	  int  nInLen;
	  BYTE bOutData[256];
	  int  nOutLen;
	  BYTE bOutDataExp[8];
    int  nOutLenExp;

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bIV);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nType = 1;
    nIccType = 0x0002000E;
    nMode = 1;

    /* Key = F431623E499789C8C2F1F725AD7F8949 */
    /* CF = 2500000000008901DAFFFFFFFFFF76FE */
    /* SF = 0000000000000002000000000000FFFD */
    /* Data = 041234FF371CF2A4 */
    /* Key1 = 89E8 1ECA 276C 7D50 A537 AE51 2E11 5224 */
    /* Key2 = 4FA1 BB65 DC84 58BF ED43 C210 F4FD 4711 */
    /* IV = 0102030405060708 */
    /* Out = 2A21 D6FC FAB7 E05A */

    memcpy(bKey, 
        "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4", 
        16);
    memcpy(bCardFactor, \
        "\x25\x00\x00\x00\x00\x00\x89\x01\xDA\xFF\xFF\xFF\xFF\xFF\x76\xFE", 
        16);        
    memcpy(bSessionFactor, \
        "\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\xFF\xFD", 
        16);        
    memcpy(bInData, "\x04\x12\x34\xFF\x37\x1C\xF2\xA4", 8);        
    nInLen = 8;
    memcpy(bIV, "\x01\x02\x03\x04\x05\x06\x07\x08", 8);
    memcpy(bOutDataExp, "\x2A\x21\xD6\xFC\xFA\xB7\xE0\x5A", 8);
    nOutLenExp = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nIccType  = %x\n", nIccType);
    DspHex("[IN ]bKey	   =", bKey, 16);
    DspHex("[IN ]bCardFactor =", bCardFactor, 16);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 16);
    DspHex("[IN ]bInData	 =", bInData, nInLen);
    DspHex("[IN ]bIV	 =", bIV, 8);
   	XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptWithDerivedKey(nSock, nType, nIccType, nMode, bKey, bCardFactor,
                              bSessionFactor, bIV, bInData, nInLen, bOutData, &nOutLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "MASTER卡，CBC加密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData =", bOutData, 8);
    printf("[OUT]nOutLen  = %d\n", nOutLen);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, nOutLenExp);
    ASSERT_OUT(nOutLen, nOutLenExp);
   	XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptWithDerivedKey_Test_22(void)
{
    XXX_TEST_START_XXX
    int  nRet;
   	int  nSock = SM_SOCK;

	  int  nType;
	  int  nIccType;
	  int  nMode;
	  BYTE bKey[32];
	  BYTE bCardFactor[16];
	  BYTE bSessionFactor[16];
	  BYTE bIV[8];
	  BYTE bInData[256];
	  int  nInLen;
	  BYTE bOutData[256];
	  int  nOutLen;
	  BYTE bOutDataExp[8];
	  int  nOutLenExp;

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bIV);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nType = 0;
    nIccType = 0x0002000E;
    nMode = 1;

    /* Key = F431623E499789C8C2F1F725AD7F8949 */
    /* CF = 2500000000008901DAFFFFFFFFFF76FE */
    /* SF = 0000000000000002000000000000FFFD */
    /* Data = 041234FF371CF2A4 */
    /* Key1 = 89E8 1ECA 276C 7D50 A537 AE51 2E11 5224 */
    /* Key2 = 4FA1 BB65 DC84 58BF ED43 C210 F4FD 4711 */
    /* IV = 0102030405060708 */
    /* Out = 2A21 D6FC FAB7 E05A */

    memcpy(bKey, 
        "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4", 
        16);
    memcpy(bCardFactor, \
        "\x25\x00\x00\x00\x00\x00\x89\x01\xDA\xFF\xFF\xFF\xFF\xFF\x76\xFE", 
        16);        
    memcpy(bSessionFactor, \
        "\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\xFF\xFD", 
        16);        
    memcpy(bInData, "\x2A\x21\xD6\xFC\xFA\xB7\xE0\x5A", 8);        
    nInLen = 8;
    memcpy(bIV, "\x01\x02\x03\x04\x05\x06\x07\x08", 8);
    memcpy(bOutDataExp, "\x04\x12\x34\xFF\x37\x1C\xF2\xA4", 8);
    nOutLenExp = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nIccType  = %x\n", nIccType);
    DspHex("[IN ]bKey	   =", bKey, 16);
    DspHex("[IN ]bCardFactor =", bCardFactor, 16);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 16);
    DspHex("[IN ]bInData	 =", bInData, nInLen);
    DspHex("[IN ]bIV	 =", bIV, 8);
   	XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptWithDerivedKey(nSock, nType, nIccType, nMode, bKey, bCardFactor,
                              bSessionFactor, bIV, bInData, nInLen, bOutData, &nOutLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "MASTER卡，CBC解密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData =", bOutData, 8);
    printf("[OUT]nOutLen  = %d\n", nOutLen);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, nOutLenExp);
    ASSERT_OUT(nOutLen, nOutLenExp);
   	XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptWithDerivedKey_Test_23(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nType;
    int  nIccType;
    int  nMode;
    BYTE bKey[32];
    BYTE bCardFactor[16];
    BYTE bSessionFactor[16];
    BYTE bIV[8];
    BYTE bInData[256];
    int  nInLen;
    BYTE bOutData[256];
    int  nOutLen;
    BYTE bOutDataExp[256];
    int  nOutLenExp;

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bIV);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nType = 1;
    nIccType = 0x00000401;
 
    nMode = 0;

    memcpy(bKey, 
        "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4", 
        16);
    memcpy(bCardFactor, \
        "\x25\x00\x00\x00\x00\x00\x89\x01\xDA\xFF\xFF\xFF\xFF\xFF\x76\xFE", 
        16);        
    memcpy(bSessionFactor, \
        "\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\xFF\xFD", 
        16);        
    memcpy(bInData, "\x04\x12\x34\xFF\x37\x1C\xF2\xA4", 8);
        nInLen = 8;
    /* 669D80C23AED1147ACD33BB3E532B2B8 */
    /* 08 041234FF371CF2A4 80000000000000 */
    /* F99FD238C265976788DDF94AC9D8C264 */
    memcpy(bOutDataExp, \
           "\xF9\x9F\xD2\x38\xC2\x65\x97\x67\x88\xDD\xF9\x4A\xC9\xD8\xC2\x64" \
           , 16);
    nOutLenExp = 16;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nIccType  = %x\n", nIccType);
    DspHex("[IN ]bKey       =", bKey, 16);
    DspHex("[IN ]bCardFactor =", bCardFactor, 16);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 16);
    DspHex("[IN ]bInData     =", bInData, 8);
    DspHex("[IN ]bIV     =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptWithDerivedKey(nSock, nType, nIccType, nMode, bKey, bCardFactor,
                               bSessionFactor, bIV, bInData, nInLen, bOutData, &nOutLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "PBOC卡，SM4, ECB加密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]nOutLen  = %d\n", nOutLen);
    DspHex("[OUT]bOutData =", bOutData, nOutLen);
    ASSERT_OUT(nOutLen, nOutLenExp);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, nOutLen);
    XXX_OUTPUT_XXX
            
    XXX_TEST_END_XXX
}

void EncryptWithDerivedKey_Test_24(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nType;
    int  nIccType;
    int  nMode;
    BYTE bKey[32];
    BYTE bCardFactor[16];
    BYTE bSessionFactor[16];
    BYTE bIV[8];
    BYTE bInData[256];
    int  nInLen;
    BYTE bOutData[256];
    int  nOutLen;
    BYTE bOutDataExp[256];
    int  nOutLenExp;

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bIV);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nType = 0;
    nIccType = 0x00000417;
    nMode = 0;

    memcpy(bKey, 
        "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4", 
        16);
    memcpy(bCardFactor, \
        "\x25\x00\x00\x00\x00\x00\x89\x01\xDA\xFF\xFF\xFF\xFF\xFF\x76\xFE", 
        16);        
    memcpy(bSessionFactor, \
        "\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\xFF\xFD", 
        16);        
    memcpy(bInData, \
           "\xF9\x9F\xD2\x38\xC2\x65\x97\x67\x88\xDD\xF9\x4A\xC9\xD8\xC2\x64" \
           , 16);
    nInLen = 16;
    /* 669D80C23AED1147ACD33BB3E532B2B8 */
    /* F99FD238C265976788DDF94AC9D8C264 */
    /* 08 041234FF371CF2A4 80000000000000 */
    memcpy(bOutDataExp, "\x04\x12\x34\xFF\x37\x1C\xF2\xA4", 8);
    nOutLenExp = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nIccType  = %x\n", nIccType);
    DspHex("[IN ]bKey       =", bKey, 16);
    DspHex("[IN ]bCardFactor =", bCardFactor, 16);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 16);
    DspHex("[IN ]bInData     =", bInData, 8);
    DspHex("[IN ]bIV     =", bIV, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptWithDerivedKey(nSock, nType, nIccType, nMode, bKey, bCardFactor,
                               bSessionFactor, bIV, bInData, nInLen, bOutData, &nOutLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "PBOC卡，SM4, ECB解密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]nOutLen  = %d\n", nOutLen);
    DspHex("[OUT]bOutData =", bOutData, nOutLen);
    ASSERT_OUT(nOutLen, nOutLenExp);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, nOutLen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EncryptWithDerivedKey_Test_25(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nType;
    int  nIccType;
    int  nMode;
    BYTE bKey[32];
    BYTE bCardFactor[16];
    BYTE bSessionFactor[16];
    BYTE bIV[16];
    BYTE bInData[256];
    int  nInLen;
    BYTE bOutData[256];
    int  nOutLen;
    BYTE bOutDataExp[256];
    int  nOutLenExp;

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bIV);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nType = 1;
    nIccType = 0x00000401;
    nMode = 1;

    memcpy(bKey, 
        "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4", 
        16);
    memcpy(bCardFactor, \
        "\x25\x00\x00\x00\x00\x00\x89\x01\xDA\xFF\xFF\xFF\xFF\xFF\x76\xFE", 
        16);        
    memcpy(bSessionFactor, \
        "\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\xFF\xFD", 
        16);        
    memcpy(bInData, \
           "\xD1\x6B\x6E\x62\x59\xCF\x9E\x73\x4A\x6F\xA8\xB6\x84\x33\x14\x00" \
           , 16);
    nInLen = 16;
    /* 669D80C23AED1147ACD33BB3E532B2B8 */
    /* 10 D16B6E6259CF9E734A6FA8B684331400 800000000000000000000000000000 */
    /* 4883898C0AD2613F30CD742F4E931959DCE7DE053AA3BD5CF80951E8C325643B */
    memcpy(bOutDataExp, \
           "\x48\x83\x89\x8C\x0A\xD2\x61\x3F\x30\xCD\x74\x2F\x4E\x93\x19\x59" \
           "\xDC\xE7\xDE\x05\x3A\xA3\xBD\x5C\xF8\x09\x51\xE8\xC3\x25\x64\x3B" \
           , 32);
    nOutLenExp = 32;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nIccType  = %x\n", nIccType);
    DspHex("[IN ]bKey       =", bKey, 16);
    DspHex("[IN ]bCardFactor =", bCardFactor, 16);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 16);
    DspHex("[IN ]bInData     =", bInData, 8);
    DspHex("[IN ]bIV     =", bIV, 16);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptWithDerivedKey(nSock, nType, nIccType, nMode, bKey, bCardFactor,
                               bSessionFactor, bIV, bInData, nInLen, bOutData, &nOutLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "PBOC卡，SM4, CBC加密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]nOutLen  = %d\n", nOutLen);
    DspHex("[OUT]bOutData =", bOutData, nOutLen);
    ASSERT_OUT(nOutLen, nOutLenExp);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, nOutLen);
    XXX_OUTPUT_XXX
            
    XXX_TEST_END_XXX
}

void EncryptWithDerivedKey_Test_26(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nType;
    int  nIccType;
    int  nMode;
    BYTE bKey[32];
    BYTE bCardFactor[16];
    BYTE bSessionFactor[16];
    BYTE bIV[16];
    BYTE bInData[256];
    int  nInLen;
    BYTE bOutData[256];
    int  nOutLen;
    BYTE bOutDataExp[256];
    int  nOutLenExp;

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bIV);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nType = 0;
    nIccType = 0x00000417;
    nMode = 1;

    memcpy(bKey, 
        "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4", 
        16);
    memcpy(bCardFactor, \
        "\x25\x00\x00\x00\x00\x00\x89\x01\xDA\xFF\xFF\xFF\xFF\xFF\x76\xFE", 
        16);        
    memcpy(bSessionFactor, \
        "\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\xFF\xFD", 
        16);        
    memcpy(bInData, \
           "\x48\x83\x89\x8C\x0A\xD2\x61\x3F\x30\xCD\x74\x2F\x4E\x93\x19\x59" \
           "\xDC\xE7\xDE\x05\x3A\xA3\xBD\x5C\xF8\x09\x51\xE8\xC3\x25\x64\x3B" \
           , 32);
    nInLen = 32;
    /* 669D80C23AED1147ACD33BB3E532B2B8 */
    /* 4883898C0AD2613F30CD742F4E931959DCE7DE053AA3BD5CF80951E8C325643B */
    /* 10 D16B6E6259CF9E734A6FA8B684331400 800000000000000000000000000000 */
    memcpy(bOutDataExp, \
           "\xD1\x6B\x6E\x62\x59\xCF\x9E\x73\x4A\x6F\xA8\xB6\x84\x33\x14\x00" \
           , 16);
    nOutLenExp = 16;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nIccType  = %x\n", nIccType);
    DspHex("[IN ]bKey       =", bKey, 16);
    DspHex("[IN ]bCardFactor =", bCardFactor, 16);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 16);
    DspHex("[IN ]bInData     =", bInData, 8);
    DspHex("[IN ]bIV     =", bIV, 16);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptWithDerivedKey(nSock, nType, nIccType, nMode, bKey, bCardFactor,
                               bSessionFactor, bIV, bInData, nInLen, bOutData, &nOutLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "PBOC卡，SM4, CBC解密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[OUT]nOutLen  = %d\n", nOutLen);
    DspHex("[OUT]bOutData =", bOutData, nOutLen);
    ASSERT_OUT(nOutLen, nOutLenExp);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, nOutLen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalcMacWithDerivedKey_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nIccType;
	  BYTE bKey[32];
	  BYTE bCardFactor[8];
	  BYTE bSessionFactor[8];
	  BYTE bData[256];
	  int  nLen;
	  BYTE bMAC[8];
	  BYTE bMACExp[8];

    	bufclr(bKey);
    	bufclr(bCardFactor);
    	bufclr(bSessionFactor);
    	bufclr(bData);
    	bufclr(bMAC);
	bufclr(bMACExp);
	
    	nIccType = 0x00000000;
        nIccType=nIccType>>16;

    	memcpy(bKey, "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4", 16);
    	memcpy(bCardFactor, "\x25\x00\x00\x00\x00\x00\x89\x01", 8);
    	memcpy(bSessionFactor, "\x00\x02", 2);
    	memcpy(bData, "\x04\x12\x34\xFF\x37\x1C\xF2\xA4", 8);
	memcpy(bMACExp,"\x50\x10\x58\xF2\x89\x79\x6E\xDA",8);
    	nLen = 8;

    	XXX_INPUT_XXX
    	printf("[IN ]nSock = %d\n", nSock);
	printf("[IN ]nIccType  = %x\n", nIccType);
	DspHex("[IN ]bKey	   =", bKey, 16);
	DspHex("[IN ]bCardFactor =", bCardFactor, 16);
	DspHex("[IN ]bSessionFactor =", bSessionFactor, 16);
	DspHex("[IN ]bData	 =", bData, 8);
        DspHex("[IN ]bMACExp	 =", bMACExp, 8);
    	XXX_INPUT_XXX

    	/* Call Test Target Function Start */
    	nRet = SMAPICalcMacWithDerivedKey(nSock, nIccType, bKey, bCardFactor,
                               bSessionFactor, bData, nLen, bMAC);
    	/* Call Test Target Function End */

    	XXX_RESULT_XXX
    	ASSERT_RESULT(nRet, 0, "PBOC卡，测试未成功");
        bufclr(bMACExp);
	memcpy(bMACExp,"\x50\x10\x58\xF2\x89\x79\x6E\xDA",8);	

	ASSERT_OUT_HEX(bMAC, bMACExp, 8);
    	XXX_RESULT_XXX

    	XXX_OUTPUT_XXX
    	DspHex("[OUT]bMAC =", bMAC, 8);
    	XXX_OUTPUT_XXX

	bufclr(bMACExp);
	memcpy(bMACExp,"\x50\x10\x58\xF2\x89\x79\x6E\xDA",8);		
	DspHex("[RESULT ]expected MAC =", bMACExp, 8);
	DspHex("[RESULT ]calculated MAC  =", bMAC, 8);

    	XXX_TEST_END_XXX
}

void CalcMacWithDerivedKey_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nIccType;
	  BYTE bKey[32];
	  BYTE bCardFactor[16];
	  BYTE bSessionFactor[16];
	  BYTE bData[256];
	  int  nLen;
	  BYTE bMAC[8];
	  BYTE bMACExp[8];

   	bufclr(bKey);
    	bufclr(bCardFactor);
    	bufclr(bSessionFactor);
    	bufclr(bData);
    	bufclr(bMAC);
	bufclr(bMACExp);

    	nIccType = 0x0001000A;
    	memcpy(bKey, 
			"\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4", 
			16);
    	memcpy(bCardFactor, 
			"\x25\x00\x00\x00\x00\x00\x89\x01\xDA\xFF\xFF\xFF\xFF\xFF\x76\xFE", 
			16);		
    	memcpy(bSessionFactor, 
			"\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\xFF\xFD", 
			16);		
    	memcpy(bData, "\x04\x12\x34\xFF\x37\x1C\xF2\xA4", 8);
    	nLen = 8;
	memcpy(bMACExp,"\x42\x93\xAA\xC9\x9F\x67\x14\x00",8);

    	XXX_INPUT_XXX
    	printf("[IN ]nSock = %d\n", nSock);
	printf("[IN ]nIccType  = %x\n", nIccType);
	DspHex("[IN ]bKey	   =", bKey, 16);
	DspHex("[IN ]bCardFactor =", bCardFactor, 16);
	DspHex("[IN ]bSessionFactor =", bSessionFactor, 16);
	DspHex("[IN ]bInData	 =", bData, 8);
    	XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalcMacWithDerivedKey(nSock, nIccType, bKey, bCardFactor,
                               bSessionFactor, bData, nLen, bMAC);
    /* Call Test Target Function End */

    	XXX_RESULT_XXX
    	ASSERT_RESULT(nRet, 0, "VISA卡，测试未成功");
    	XXX_RESULT_XXX

    	XXX_OUTPUT_XXX
    	DspHex("[OUT]bMAC =", bMAC, 8);
	ASSERT_OUT_HEX(bMAC, bMACExp, 8);
    	XXX_OUTPUT_XXX
			
	DspHex("[RESULT ]expected Data =", bMACExp, 8);
	DspHex("[RESULT ]calculated Data  =", bMAC, 8);

    	XXX_TEST_END_XXX
}

void CalcMacWithDerivedKey_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nIccType;
	  BYTE bKey[32];
	  BYTE bCardFactor[8];
	  BYTE bSessionFactor[8];
	  BYTE bData[256];
	  int  nLen;
	  BYTE bMAC[8];

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bData);
    bufclr(bMAC);

    nSock = -1;
    nIccType = 0;
    memcpy(bKey, "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4", 16);
    memcpy(bCardFactor, "\x25\x00\x00\x00\x00\x00\x89\x01", 8);
    memcpy(bSessionFactor, "\x00\x02", 2);
    memcpy(bData, "\x04\x12\x34\xFF\x37\x1C\xF2\xA4", 8);
    nLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalcMacWithDerivedKey(nSock, nIccType, bKey, bCardFactor,
                               bSessionFactor, bData, nLen, bMAC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效Socket ID[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void CalcMacWithDerivedKey_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nIccType;
	  BYTE bKey[32];
	  BYTE bCardFactor[8];
	  BYTE bSessionFactor[8];
	  BYTE bData[256];
	  int  nLen;
	  BYTE bMAC[8];

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bData);
    bufclr(bMAC);

    nSock = 8;
    nIccType = 0;
    memcpy(bKey, "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4", 16);
    memcpy(bCardFactor, "\x25\x00\x00\x00\x00\x00\x89\x01", 8);
    memcpy(bSessionFactor, "\x00\x02", 2);
    memcpy(bData, "\x04\x12\x34\xFF\x37\x1C\xF2\xA4", 8);
    nLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalcMacWithDerivedKey(nSock, nIccType, bKey, bCardFactor,
                               bSessionFactor, bData, nLen, bMAC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效Socket ID[8]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void CalcMacWithDerivedKey_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nIccType;
	  BYTE bKey[32];
	  BYTE bCardFactor[8];
	  BYTE bSessionFactor[8];
	  BYTE bData[256];
	  int  nLen;
	  BYTE bMAC[8];

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bData);
    bufclr(bMAC);

    nIccType = -1;
    memcpy(bKey, "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4", 16);
    memcpy(bCardFactor, "\x25\x00\x00\x00\x00\x00\x89\x01", 8);
    memcpy(bSessionFactor, "\x00\x02", 2);
    memcpy(bData, "\x04\x12\x34\xFF\x37\x1C\xF2\xA4", 8);
    nLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalcMacWithDerivedKey(nSock, nIccType, bKey, bCardFactor,
                               bSessionFactor, bData, nLen, bMAC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效卡片类型[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalcMacWithDerivedKey_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nIccType;
	  BYTE bKey[32];
	  BYTE bCardFactor[8];
	  BYTE bSessionFactor[8];
	  BYTE bData[256];
	  int  nLen;
	  BYTE bMAC[8];

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bData);
    bufclr(bMAC);

    nIccType = 2;
    memcpy(bKey, "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4", 16);
    memcpy(bCardFactor, "\x25\x00\x00\x00\x00\x00\x89\x01", 8);
    memcpy(bSessionFactor, "\x00\x02", 2);
    memcpy(bData, "\x04\x12\x34\xFF\x37\x1C\xF2\xA4", 8);
    nLen = 8;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalcMacWithDerivedKey(nSock, nIccType, bKey, bCardFactor,
                               bSessionFactor, bData, nLen, bMAC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效卡片类型[2]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void CalcMacWithDerivedKey_Test_07(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIccType;
    BYTE bKey[32];
    BYTE bCardFactor[16];
    BYTE bSessionFactor[16];
    BYTE bData[256];
    int  nLen;
    BYTE bMAC[8];
    BYTE bMACExp[8];

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bData);
    bufclr(bMAC);
    bufclr(bMACExp);

    nIccType = 0x00020014;
    memcpy(bKey, 
            "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4", 
            16);
    memcpy(bCardFactor, 
            "\x25\x00\x00\x00\x00\x00\x89\x01\xDA\xFF\xFF\xFF\xFF\xFF\x76\xFE", 
            16);        
    memcpy(bSessionFactor, 
            "\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\xFF\xFD", 
            16);        
    memcpy(bData, "\x04\x12\x34\xFF\x37\x1C\xF2\xA4", 8);
    nLen = 8;
    memcpy(bMACExp,"\x50\x10\x58\xF2\x89\x79\x6E\xDA",8);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nIccType  = %x\n", nIccType);
    DspHex("[IN ]bKey       =", bKey, 16);
    DspHex("[IN ]bCardFactor =", bCardFactor, 16);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 16);
    DspHex("[IN ]bInData     =", bData, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalcMacWithDerivedKey(nSock, nIccType, bKey, bCardFactor,
                               bSessionFactor, bData, nLen, bMAC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "MASTER卡，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bMAC =", bMAC, 8);
    ASSERT_OUT_HEX(bMAC, bMACExp, 8);
    XXX_OUTPUT_XXX
            
    DspHex("[RESULT ]expected Data =", bMACExp, 8);
    DspHex("[RESULT ]calculated Data  =", bMAC, 8);

    XXX_TEST_END_XXX
}

void CalcMacWithDerivedKey_Test_08(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIccType;
    BYTE bKey[32];
    BYTE bCardFactor[16];
    BYTE bSessionFactor[16];
    BYTE bData[256];
    int  nLen;
    BYTE bMAC[8];
    BYTE bMACExp[8];

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bData);
    bufclr(bMAC);
    bufclr(bMACExp);

    nIccType = 0x00000401;
    memcpy(bKey, 
        "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4", 
        16);
    memcpy(bCardFactor, 
        "\x25\x00\x00\x00\x00\x00\x89\x01\xDA\xFF\xFF\xFF\xFF\xFF\x76\xFE", 
        16);        
    memcpy(bSessionFactor, 
        "\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\xFF\xFD", 
        16);        
    memcpy(bData, "\x04\x12\x34\xFF\x37\x1C\xF2\xA4", 8);
    nLen = 8;
    /* 669D80C23AED1147ACD33BB3E532B2B8 */
    /* 041234FF371CF2A48000000000000000 */
    /* D16B6E6259CF9E734A6FA8B684331400 */
    memcpy(bMACExp,"\xD1\x6B\x6E\x62\x59\xCF\x9E\x73", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nIccType  = %x\n", nIccType);
    DspHex("[IN ]bKey       =", bKey, 16);
    DspHex("[IN ]bCardFactor =", bCardFactor, 16);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 16);
    DspHex("[IN ]bInData     =", bData, nLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalcMacWithDerivedKey(nSock, nIccType, bKey, bCardFactor,
                               bSessionFactor, bData, nLen, bMAC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "PBOC卡，SM4, 测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bMAC =", bMAC, 8);
    ASSERT_OUT_HEX(bMAC, bMACExp, 8);
    XXX_OUTPUT_XXX
            
//    DspHex("[RESULT ]expected Data =", bMACExp, 8);
//    DspHex("[RESULT ]calculated Data  =", bMAC, 8);

    XXX_TEST_END_XXX
}

void CalcMacWithDerivedKey_Test_09(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIccType;
    BYTE bKey[32];
    BYTE bCardFactor[16];
    BYTE bSessionFactor[16];
    BYTE bData[256];
    int  nLen;
    BYTE bMAC[8];
    BYTE bMACExp[8];

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bData);
    bufclr(bMAC);
    bufclr(bMACExp);

    nIccType = 0x00000417;
    memcpy(bKey, 
        "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4", 
        16);
    memcpy(bCardFactor, 
        "\x25\x00\x00\x00\x00\x00\x89\x01\xDA\xFF\xFF\xFF\xFF\xFF\x76\xFE", 
        16);        
    memcpy(bSessionFactor, 
        "\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\xFF\xFD", 
        16);        
    memcpy(bData, \
           "\x04\x12\x34\xFF\x37\x1C\xF2\xA4" \
           "\x04\x12\x34\xFF\x37\x1C\xF2\xA4" \
           "\x12" \
           , 17);
    nLen = 17;
    /* 669D80C23AED1147ACD33BB3E532B2B8 */
    /* 041234FF371CF2A4041234FF371CF2A4 12800000000000000000000000000000 */
    /* 23999E471636728FEB96DBD9D4A8EC55 1F16A214 377AD77866BD6E3E47ED2C4D */
    memcpy(bMACExp,"\x1F\x16\xA2\x14\x37\x7A\xD7\x78", 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nIccType  = %x\n", nIccType);
    DspHex("[IN ]bKey       =", bKey, 16);
    DspHex("[IN ]bCardFactor =", bCardFactor, 16);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 16);
    DspHex("[IN ]bInData     =", bData, nLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPICalcMacWithDerivedKey(nSock, nIccType, bKey, bCardFactor,
                               bSessionFactor, bData, nLen, bMAC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "PBOC卡，SM4, 测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bMAC =", bMAC, 8);
    ASSERT_OUT_HEX(bMAC, bMACExp, 8);
    XXX_OUTPUT_XXX

//    DspHex("[RESULT ]expected Data =", bMACExp, 8);
//    DspHex("[RESULT ]calculated Data  =", bMAC, 8);

    XXX_TEST_END_XXX
}

void GenEccKey_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIndex;
    int  nEcMark;
    BYTE bPK[2048];
    int  nPKLen;
    BYTE bSK[2048];
    int  nSKLen;

    bufclr(bPK);
    bufclr(bSK);
    nPKLen = 0;
    nSKLen = 0;

    nIndex = 0;
    nEcMark = 17;

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nIndex  = %d\n", nIndex);
    printf("[IN ]nEcMark = %d\n", nEcMark);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenEccKey(nSock, nIndex, nEcMark, bPK, &nPKLen, bSK, &nSKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "索引号=0，SM2密钥对生成，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bPK     =", bPK, nPKLen);
    printf("[OUT]nPKLen  = %d\n", nPKLen);
    DspHexExt("[OUT]bSK     =", bSK, nSKLen);
    printf("[OUT]nSKLen  = %d\n", nSKLen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenEccKey_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIndex;
    int  nEcMark;
    BYTE bPK[2048];
    int  nPKLen;
    BYTE bSK[2048];
    int  nSKLen;

    bufclr(bPK);
    bufclr(bSK);
    nPKLen = 0;
    nSKLen = 0;

    nIndex = 1;
    nEcMark = 17;

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nIndex  = %d\n", nIndex);
    printf("[IN ]nEcMark = %d\n", nEcMark);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenEccKey(nSock, nIndex, nEcMark, bPK, &nPKLen, bSK, &nSKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "索引号=1，SM2密钥对生成，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bPK     =", bPK, nPKLen + 8);
    printf("[OUT]nPKLen  = %d\n", nPKLen);
    DspHexExt("[OUT]bSK     =", bSK, nSKLen + 8);
    printf("[OUT]nSKLen  = %d\n", nSKLen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenEccKey_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIndex;
    int  nEcMark;
    BYTE bPK[2048];
    int  nPKLen;
    BYTE bSK[2048];
    int  nSKLen;

    bufclr(bPK);
    bufclr(bSK);
    nPKLen = 0;
    nSKLen = 0;

    nIndex = 19;
    nEcMark = 17;

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nIndex  = %d\n", nIndex);
    printf("[IN ]nEcMark = %d\n", nEcMark);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenEccKey(nSock, nIndex, nEcMark, bPK, &nPKLen, bSK, &nSKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "索引号=19，SM2密钥对生成，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bPK     =", bPK, nPKLen + 8);
    printf("[OUT]nPKLen  = %d\n", nPKLen);
    DspHexExt("[OUT]bSK     =", bSK, nSKLen + 8);
    printf("[OUT]nSKLen  = %d\n", nSKLen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenEccKey_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIndex;
    int  nEcMark;
    BYTE bPK[2048];
    int  nPKLen;
    BYTE bSK[2048];
    int  nSKLen;

    bufclr(bPK);
    bufclr(bSK);
    nPKLen = 0;
    nSKLen = 0;

    nIndex = 0;
    nEcMark = 3;

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nIndex  = %d\n", nIndex);
    printf("[IN ]nEcMark = %d\n", nEcMark);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenEccKey(nSock, nIndex, nEcMark, bPK, &nPKLen, bSK, &nSKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "SM2密钥对生成，异常椭圆曲线标识3，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}


//zhaomx   2017-0424   
void GetEccPkBySk_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nEcMark;
    BYTE bPK[2048];
    int  nPKLen;
    BYTE bPKExp[2048];
    int  nPKLenExp;
    BYTE bSK[2048];
    int  nSKLen;

    bufclr(bPK);
    bufclr(bPKExp);
    bufclr(bSK);
    nPKLen = 0;
    nSKLen = 0;

    nEcMark = 17;

    /* PK 043D646AB3D38385671D39B5E16E5DD9D50494CBBDF2F572C7EAD7FB19562A794268CA6BAD0ED9DFF174659F3B37C1F602A0B817696CD18E9CB76F9F14071D4E93 */
    /* SK D4DD2D2973965C23038CA4085E80F3E3E1BD400023A9DEDD73BDC91556E65B4E */
    /* 3C8E 44A7 0C79 C17D 936A 3968 0797 ECD1 FB1C 763B 995C F205 3CF8 1E2E B3DB 715E 6BCB 2CCA 658B FD78 */
    memcpy(bPKExp,
           "\x3D\x64\x6A\xB3\xD3\x83\x85" \
           "\x67\x1D\x39\xB5\xE1\x6E\x5D\xD9" \
           "\xD5\x04\x94\xCB\xBD\xF2\xF5\x72" \
           "\xC7\xEA\xD7\xFB\x19\x56\x2A\x79" \
           "\x42\x68\xCA\x6B\xAD\x0E\xD9\xDF" \
           "\xF1\x74\x65\x9F\x3B\x37\xC1\xF6" \
           "\x02\xA0\xB8\x17\x69\x6C\xD1\x8E" \
           "\x9C\xB7\x6F\x9F\x14\x07\x1D\x4E" \
           "\x93", 64);
    nPKLenExp = 64;
    memcpy(bSK,
           "\x3C\x8E\x44\xA7\x0C\x79\xC1\x7D" \
           "\x93\x6A\x39\x68\x07\x97\xEC\xD1" \
           "\xFB\x1C\x76\x3B\x99\x5C\xF2\x05" \
           "\x3C\xF8\x1E\x2E\xB3\xDB\x71\x5E" \
           "\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78" \
           , 40);
    nSKLen = 40;

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nEcMark = %d\n", nEcMark);
    DspHex("[IN ]bSK     =", bSK, nSKLen);
    printf("[IN ]nSKLen  = %d\n", nSKLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGetEccPkBySk(nSock, nEcMark, bSK, nSKLen, bPK, &nPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "根据ECC私钥生成公钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT(nPKLen, nPKLenExp);
    ASSERT_OUT_HEX(bPK, bPKExp, nPKLen);
    DspHex("[OUT]bPK     =", bPK, nPKLen);
//    printf("[OUT]nPKLen  = %d\n", nPKLen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GetEccPkBySk_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nEcMark;
    BYTE bPK[2048];
    int  nPKLen;
    BYTE bPKExp[2048];
    int  nPKLenExp;
    BYTE bSK[2048];
    int  nSKLen;

    bufclr(bPK);
    bufclr(bPKExp);
    bufclr(bSK);
    nPKLen = 0;
    nSKLen = 0;

    nEcMark = 3;

    /* PK 043D646AB3D38385671D39B5E16E5DD9D50494CBBDF2F572C7EAD7FB19562A794268CA6BAD0ED9DFF174659F3B37C1F602A0B817696CD18E9CB76F9F14071D4E93 */
    /* SK D4DD2D2973965C23038CA4085E80F3E3E1BD400023A9DEDD73BDC91556E65B4E */
    /* 3C8E 44A7 0C79 C17D 936A 3968 0797 ECD1 FB1C 763B 995C F205 3CF8 1E2E B3DB 715E 6BCB 2CCA 658B FD78 */
    memcpy(bPKExp,
           "\x3D\x64\x6A\xB3\xD3\x83\x85" \
           "\x67\x1D\x39\xB5\xE1\x6E\x5D\xD9" \
           "\xD5\x04\x94\xCB\xBD\xF2\xF5\x72" \
           "\xC7\xEA\xD7\xFB\x19\x56\x2A\x79" \
           "\x42\x68\xCA\x6B\xAD\x0E\xD9\xDF" \
           "\xF1\x74\x65\x9F\x3B\x37\xC1\xF6" \
           "\x02\xA0\xB8\x17\x69\x6C\xD1\x8E" \
           "\x9C\xB7\x6F\x9F\x14\x07\x1D\x4E" \
           "\x93", 64);
    nPKLenExp = 64;
    memcpy(bSK,
           "\x3C\x8E\x44\xA7\x0C\x79\xC1\x7D" \
           "\x93\x6A\x39\x68\x07\x97\xEC\xD1" \
           "\xFB\x1C\x76\x3B\x99\x5C\xF2\x05" \
           "\x3C\xF8\x1E\x2E\xB3\xDB\x71\x5E" \
           "\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78" \
           , 40);
    nSKLen = 40;

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nEcMark = %d\n", nEcMark);
    DspHex("[IN ]bSK     =", bSK, nSKLen);
    printf("[IN ]nSKLen  = %d\n", nSKLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGetEccPkBySk(nSock, nEcMark, bSK, nSKLen, bPK, &nPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "根据ECC私钥生成公钥，异常椭圆曲线标识3，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GetEccPkBySk_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nEcMark;
    BYTE bPK[2048];
    int  nPKLen;
    BYTE bPKExp[2048];
    int  nPKLenExp;
    BYTE bSK[2048];
    int  nSKLen;

    bufclr(bPK);
    bufclr(bPKExp);
    bufclr(bSK);
    nPKLen = 0;
    nSKLen = 0;

    nEcMark = 17;

    /* PK 0400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 */
    /* SK FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123 */
    /* 1BB5 163C EFEE D2D0 7B81 70A0 4A60 4D9B 7612 9F21 7D5F 9558 1149 5A1A 9EED C403 6BCB 2CCA 658B FD78 */
    memcpy(bPKExp,
           "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" \
           "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" \
           "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" \
           "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" \
           "\x00" \
           , 64);
    nPKLenExp = 64;
    memcpy(bSK,
           "\x1B\xB5\x16\x3C\xEF\xEE\xD2\xD0\x7B\x81\x70\xA0\x4A\x60\x4D\x9B" \
           "\x76\x12\x9F\x21\x7D\x5F\x95\x58\x11\x49\x5A\x1A\x9E\xED\xC4\x03" \
           "\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78" \
           , 40);
    nSKLen = 40;

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nEcMark = %d\n", nEcMark);
    DspHex("[IN ]bSK     =", bSK, nSKLen);
    printf("[IN ]nSKLen  = %d\n", nSKLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGetEccPkBySk(nSock, nEcMark, bSK, nSKLen, bPK, &nPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "根据ECC私钥生成公钥，特殊私钥d=n，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GetEccPkBySk_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nEcMark;
    BYTE bPK[2048];
    int  nPKLen;
    BYTE bPKExp[2048];
    int  nPKLenExp;
    BYTE bSK[2048];
    int  nSKLen;

    bufclr(bPK);
    bufclr(bPKExp);
    bufclr(bSK);
    nPKLen = 0;
    nSKLen = 0;

    nEcMark = 17;

    /* PK 0400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 */
    /* SK 0000000000000000000000000000000000000000000000000000000000000000 */
    /* 1F1E A825 5422 D275 1F1E A825 5422 D275 1F1E A825 5422 D275 1F1E A825 5422 D275 6BCB 2CCA 658B FD78 */
    memcpy(bPKExp,
           "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" \
           "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" \
           "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" \
           "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" \
           "\x00" \
           , 64);
    nPKLenExp = 64;
    memcpy(bSK,
           "\x1F\x1E\xA8\x25\x54\x22\xD2\x75\x1F\x1E\xA8\x25\x54\x22\xD2\x75" \
           "\x1F\x1E\xA8\x25\x54\x22\xD2\x75\x1F\x1E\xA8\x25\x54\x22\xD2\x75" \
            "\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78" \ 
           , 40);
    nSKLen = 40;

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nEcMark = %d\n", nEcMark);
    DspHex("[IN ]bSK     =", bSK, nSKLen);
    printf("[IN ]nSKLen  = %d\n", nSKLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGetEccPkBySk(nSock, nEcMark, bSK, nSKLen, bPK, &nPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "根据ECC私钥生成公钥，特殊私钥d=0，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GetEccPkBySk_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nEcMark;
    BYTE bPK[2048];
    int  nPKLen;
    BYTE bPKExp[2048];
    int  nPKLenExp;
    BYTE bSK[2048];
    int  nSKLen;

    bufclr(bPK);
    bufclr(bPKExp);
    bufclr(bSK);
    nPKLen = 0;
    nSKLen = 0;

    nEcMark = 17;

    /* PK 0432C4AE2C1F1981195F9904466A39C9948FE30BBFF2660BE1715A4589334C74C743C8C95C0B098863A642311C9496DEAC2F56788239D5B8C0FD20CD1ADEC60F5F */
    /* SK FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54122 */
    /* 1BB5 163C EFEE D2D0 7B81 70A0 4A60 4D9B 7612 9F21 7D5F 9558 6F7E FC0B 9EC9 E979 6BCB 2CCA 658B FD78 */
    memcpy(bPKExp,
           "\x32\xC4\xAE\x2C\x1F\x19\x81\x19\x5F\x99\x04\x46\x6A\x39\xC9" \
           "\x94\x8F\xE3\x0B\xBF\xF2\x66\x0B\xE1\x71\x5A\x45\x89\x33\x4C\x74" \
           "\xC7\x43\xC8\xC9\x5C\x0B\x09\x88\x63\xA6\x42\x31\x1C\x94\x96\xDE" \
           "\xAC\x2F\x56\x78\x82\x39\xD5\xB8\xC0\xFD\x20\xCD\x1A\xDE\xC6\x0F" \
           "\x5F" \
           , 64);
    nPKLenExp = 64;
    memcpy(bSK,
           "\x1B\xB5\x16\x3C\xEF\xEE\xD2\xD0\x7B\x81\x70\xA0\x4A\x60\x4D\x9B" \
           "\x76\x12\x9F\x21\x7D\x5F\x95\x58\x6F\x7E\xFC\x0B\x9E\xC9\xE9\x79" \
           "\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78"    \
           , 40);
    nSKLen = 40;

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nEcMark = %d\n", nEcMark);
    DspHex("[IN ]bSK     =", bSK, nSKLen);
    printf("[IN ]nSKLen  = %d\n", nSKLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGetEccPkBySk(nSock, nEcMark, bSK, nSKLen, bPK, &nPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "根据ECC私钥生成公钥，特殊私钥d=n-1，测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GetEccPkBySk_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nEcMark;
    BYTE bPK[2048];
    int  nPKLen;
    BYTE bPKExp[2048];
    int  nPKLenExp;
    BYTE bSK[2048];
    int  nSKLen;

    bufclr(bPK);
    bufclr(bPKExp);
    bufclr(bSK);
    nPKLen = 0;
    nSKLen = 0;

    nEcMark = 17;

    /* PK 0432C4AE2C1F1981195F9904466A39C9948FE30BBFF2660BE1715A4589334C74C7BC3736A2F4F6779C59BDCEE36B692153D0A9877CC62A474002DF32E52139F0A0 */
    /* SK 0000000000000000000000000000000000000000000000000000000000000001 */
    /* 1F1E A825 5422 D275 1F1E A825 5422 D275 1F1E A825 5422 D275 7219 14A9 8C42 3707 6BCB 2CCA 658B FD78 */
    memcpy(bPKExp,
           "\x32\xC4\xAE\x2C\x1F\x19\x81\x19\x5F\x99\x04\x46\x6A\x39\xC9" \
           "\x94\x8F\xE3\x0B\xBF\xF2\x66\x0B\xE1\x71\x5A\x45\x89\x33\x4C\x74" \
           "\xC7\xBC\x37\x36\xA2\xF4\xF6\x77\x9C\x59\xBD\xCE\xE3\x6B\x69\x21" \
           "\x53\xD0\xA9\x87\x7C\xC6\x2A\x47\x40\x02\xDF\x32\xE5\x21\x39\xF0" \
           "\xA0" \
           , 64);
    nPKLenExp = 64;
    memcpy(bSK,
           "\x1F\x1E\xA8\x25\x54\x22\xD2\x75\x1F\x1E\xA8\x25\x54\x22\xD2\x75" \
           "\x1F\x1E\xA8\x25\x54\x22\xD2\x75\x72\x19\x14\xA9\x8C\x42\x37\x07" \
           "\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78"    \      
           , 40);
    nSKLen = 40;

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nEcMark = %d\n", nEcMark);
    DspHex("[IN ]bSK     =", bSK, nSKLen);
    printf("[IN ]nSKLen  = %d\n", nSKLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGetEccPkBySk(nSock, nEcMark, bSK, nSKLen, bPK, &nPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "根据ECC私钥生成公钥，特殊私钥d=1，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT(nPKLen, nPKLenExp);
    ASSERT_OUT_HEX(bPK, bPKExp, nPKLen + 8);
//    DspHex("[OUT]bPK     =", bPK, nPKLen + 8);
//    printf("[OUT]nPKLen  = %d\n", nPKLen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GetEccPkBySk_Test_07(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nEcMark;
    BYTE bPK[2048];
    int  nPKLen;
    BYTE bPKExp[2048];
    int  nPKLenExp;
    BYTE bSK[2048];
    int  nSKLen;

    bufclr(bPK);
    bufclr(bPKExp);
    bufclr(bSK);
    nPKLen = 0;
    nSKLen = 0;

    nEcMark = 17;

    /* PK 0456CEFD60D7C87C000D58EF57FA73BA4D9C0DFA08C08A7331495C2E1DA3F2BD52CE481818337E760997ACA31F07150E429217B3E6D093718F9087F2C568F5DC3C */
    /* SK FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54121 */
    /* 1BB5 163C EFEE D2D0 7B81 70A0 4A60 4D9B 7612 9F21 7D5F 9558 37A6 24EB 5673 85E3 6BCB 2CCA 658B FD78 */
    memcpy(bPKExp,
           "\x56\xCE\xFD\x60\xD7\xC8\x7C\x00\x0D\x58\xEF\x57\xFA\x73\xBA" \
           "\x4D\x9C\x0D\xFA\x08\xC0\x8A\x73\x31\x49\x5C\x2E\x1D\xA3\xF2\xBD" \
           "\x52\xCE\x48\x18\x18\x33\x7E\x76\x09\x97\xAC\xA3\x1F\x07\x15\x0E" \
           "\x42\x92\x17\xB3\xE6\xD0\x93\x71\x8F\x90\x87\xF2\xC5\x68\xF5\xDC" \
           "\x3C" \
           , 64);
    nPKLenExp = 64;
    memcpy(bSK,
           "\x1B\xB5\x16\x3C\xEF\xEE\xD2\xD0\x7B\x81\x70\xA0\x4A\x60\x4D\x9B" \
           "\x76\x12\x9F\x21\x7D\x5F\x95\x58\x37\xA6\x24\xEB\x56\x73\x85\xE3" \
           "\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78" 
           , 40);
    nSKLen = 40;

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nEcMark = %d\n", nEcMark);
    DspHex("[IN ]bSK     =", bSK, nSKLen);
    printf("[IN ]nSKLen  = %d\n", nSKLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGetEccPkBySk(nSock, nEcMark, bSK, nSKLen, bPK, &nPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "根据ECC私钥生成公钥，特殊私钥d=n-2，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT(nPKLen, nPKLenExp);
    ASSERT_OUT_HEX(bPK, bPKExp, nPKLen + 8);
//    DspHex("[OUT]bPK     =", bPK, nPKLen + 8);
//    printf("[OUT]nPKLen  = %d\n", nPKLen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GetEccPkBySk_Test_08(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nEcMark;
    BYTE bPK[2048];
    int  nPKLen;
    BYTE bPKExp[2048];
    int  nPKLenExp;
    BYTE bSK[2048];
    int  nSKLen;

    bufclr(bPK);
    bufclr(bPKExp);
    bufclr(bSK);
    nPKLen = 0;
    nSKLen = 0;

    nEcMark = 17;

    /* PK 0432C4AE2C1F1981195F9904466A39C9948FE30BBFF2660BE1715A4589334C74C7BC3736A2F4F6779C59BDCEE36B692153D0A9877CC62A474002DF32E52139F0A0 */
    /* SK FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54124 */
    /* 1BB5 163C EFEE D2D0 7B81 70A0 4A60 4D9B 7612 9F21 7D5F 9558 3871 0260 74BF DCCF 6BCB 2CCA 658B FD78 */
    memcpy(bPKExp,
           "\x32\xC4\xAE\x2C\x1F\x19\x81\x19\x5F\x99\x04\x46\x6A\x39\xC9" \
           "\x94\x8F\xE3\x0B\xBF\xF2\x66\x0B\xE1\x71\x5A\x45\x89\x33\x4C\x74" \
           "\xC7\xBC\x37\x36\xA2\xF4\xF6\x77\x9C\x59\xBD\xCE\xE3\x6B\x69\x21" \
           "\x53\xD0\xA9\x87\x7C\xC6\x2A\x47\x40\x02\xDF\x32\xE5\x21\x39\xF0" \
           "\xA0" \
           , 64);
    nPKLenExp = 64;
    memcpy(bSK,
           "\x1B\xB5\x16\x3C\xEF\xEE\xD2\xD0\x7B\x81\x70\xA0\x4A\x60\x4D\x9B" \
           "\x76\x12\x9F\x21\x7D\x5F\x95\x58\x38\x71\x02\x60\x74\xBF\xDC\xCF" \
           "\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78"  \
           , 40);
    nSKLen = 40;

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nEcMark = %d\n", nEcMark);
    DspHex("[IN ]bSK     =", bSK, nSKLen);
    printf("[IN ]nSKLen  = %d\n", nSKLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGetEccPkBySk(nSock, nEcMark, bSK, nSKLen, bPK, &nPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "根据ECC私钥生成公钥，特殊私钥d=n+1，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT(nPKLen, nPKLenExp);
    ASSERT_OUT_HEX(bPK, bPKExp, nPKLen + 8);
//    DspHex("[OUT]bPK     =", bPK, nPKLen + 8);
//    printf("[OUT]nPKLen  = %d\n", nPKLen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}


/* zhaomx  2017-04-17
  修改SM2公钥加密的公钥数据格式。头"04"去掉 ，由65变64
*/
void EccPkEncrypt_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nEcMark;
    int  nPad;
    BYTE bPK[256];
    int  nPKLen;
    BYTE bInData[1024];
    int  nInDataLen;
    BYTE bOutData[1024];
    int  nOutDataLen;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    nPKLen = 0;

    nEcMark = 17;
    nPad = 0;

    /* PK 043D646AB3D38385671D39B5E16E5DD9D50494CBBDF2F572C7EAD7FB19562A794268CA6BAD0ED9DFF174659F3B37C1F602A0B817696CD18E9CB76F9F14071D4E93 */
    /* SK D4DD2D2973965C23038CA4085E80F3E3E1BD400023A9DEDD73BDC91556E65B4E */
    /* 3C8E44A70C79C17D936A39680797ECD1FB1C763B995CF2053CF81E2EB3DB715E6BCB2CCA658BFD78 */
    memcpy(bPK,
           "\x3D\x64\x6A\xB3\xD3\x83\x85" \
           "\x67\x1D\x39\xB5\xE1\x6E\x5D\xD9" \
           "\xD5\x04\x94\xCB\xBD\xF2\xF5\x72" \
           "\xC7\xEA\xD7\xFB\x19\x56\x2A\x79" \
           "\x42\x68\xCA\x6B\xAD\x0E\xD9\xDF" \
           "\xF1\x74\x65\x9F\x3B\x37\xC1\xF6" \
           "\x02\xA0\xB8\x17\x69\x6C\xD1\x8E" \
           "\x9C\xB7\x6F\x9F\x14\x07\x1D\x4E" \
           "\x93", 64);
    nPKLen = 64;

    /* 0BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB9 */
    memset(bInData, 0x42, 64);
    bInData[0] = 0x30;
    bInData[63] = 0x39;
    nInDataLen = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nEcMark = %d\n", nEcMark);
    printf("[IN ]nPad    = %d\n", nPad);
    DspHexExt("[IN ]bPK     =", bPK, nPKLen);
    printf("[IN ]nPKLen  = %d\n", nPKLen);
    DspHexExt("[IN ]bInData =", bInData, nInDataLen);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEccPkEncrypt(nSock, nEcMark, nPad, bPK, nPKLen, bInData, nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "ECC公钥加密，64字节数据，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bOutData     =", bOutData, nOutDataLen);
    printf("[OUT]nOutDataLen  = %d\n", nOutDataLen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

char RET[4096];


/* zhaomx  2017-04-17
  修改SM2公钥加密的公钥数据格式。头"04"去掉 ，由65变64
*/

void EccPkEncrypt_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nEcMark;
    int  nPad;
    BYTE bPK[256];
    int  nPKLen;
    BYTE bInData[4000];
    int  nInDataLen;
    BYTE bOutData[4096];
    int  nOutDataLen;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    nPKLen = 0;

    nEcMark = 17;
    nPad = 0;

    /* PK 043D646AB3D38385671D39B5E16E5DD9D50494CBBDF2F572C7EAD7FB19562A794268CA6BAD0ED9DFF174659F3B37C1F602A0B817696CD18E9CB76F9F14071D4E93 */
    /* SK D4DD2D2973965C23038CA4085E80F3E3E1BD400023A9DEDD73BDC91556E65B4E */
    /* 3C8E44A70C79C17D936A39680797ECD1FB1C763B995CF2053CF81E2EB3DB715E6BCB2CCA658BFD78 */
    memcpy(bPK,
           "\x3D\x64\x6A\xB3\xD3\x83\x85" \
           "\x67\x1D\x39\xB5\xE1\x6E\x5D\xD9" \
           "\xD5\x04\x94\xCB\xBD\xF2\xF5\x72" \
           "\xC7\xEA\xD7\xFB\x19\x56\x2A\x79" \
           "\x42\x68\xCA\x6B\xAD\x0E\xD9\xDF" \
           "\xF1\x74\x65\x9F\x3B\x37\xC1\xF6" \
           "\x02\xA0\xB8\x17\x69\x6C\xD1\x8E" \
           "\x9C\xB7\x6F\x9F\x14\x07\x1D\x4E" \
           "\x93", 64);
    nPKLen = 64;

    memset(bInData, 0x42, 4000);
    bInData[0] = 0x30;
    bInData[3999] = 0x39;
    nInDataLen = 4000;

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nEcMark = %d\n", nEcMark);
    printf("[IN ]nPad    = %d\n", nPad);
    DspHexExt("[IN ]bPK     =", bPK, nPKLen);
    printf("[IN ]nPKLen  = %d\n", nPKLen);
    DspHexExt("[IN ]bInData =", bInData, nInDataLen);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEccPkEncrypt(nSock, nEcMark, nPad, bPK, nPKLen, bInData, nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "ECC公钥加密，4000字节数据，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bOutData     =", bOutData, nOutDataLen);
    printf("[OUT]nOutDataLen  = %d\n", nOutDataLen);
    XXX_OUTPUT_XXX
    
    memcpy(RET, bOutData, 4096);

    XXX_TEST_END_XXX
}

/* zhaomx  2017-04-17
  修改SM2公钥加密的公钥数据格式。头"04"去掉 ，由65变64
*/
void EccPkEncrypt_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nEcMark;
    int  nPad;
    BYTE bPK[256];
    int  nPKLen;
    BYTE bInData[1024];
    int  nInDataLen;
    BYTE bOutData[1024];
    int  nOutDataLen;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    nPKLen = 0;

    nEcMark = 17;
    nPad = 0;

    /* PK 0400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 */
    /* SK 0000000000000000000000000000000000000000000000000000000000000000 */
    /* 1F1EA8255422D2751F1EA8255422D2751F1EA8255422D2751F1EA8255422D2756BCB2CCA658BFD78 */
    memcpy(bPK,
           "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" \
           "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" \
           "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" \
           "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" \
           "\x00" \
           , 64);
    nPKLen = 64;

    /* 0BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB9 */
    memset(bInData, 0x42, 64);
    bInData[0] = 0x30;
    bInData[63] = 0x39;
    nInDataLen = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nEcMark = %d\n", nEcMark);
    printf("[IN ]nPad    = %d\n", nPad);
    DspHexExt("[IN ]bPK     =", bPK, nPKLen);
    printf("[IN ]nPKLen  = %d\n", nPKLen);
    DspHexExt("[IN ]bInData =", bInData, nInDataLen);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEccPkEncrypt(nSock, nEcMark, nPad, bPK, nPKLen, bInData, nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "ECC公钥加密，无效公钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

/* zhaomx  2017-04-17
   修改SM2的私钥解密的私钥数据格式。去掉尾部8字节
   2017-5-25   8字节
*/
void EccSkDecrypt_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nEcMark;
    int  nPad;
    BYTE bSK[256];
    int  nSKLen;
    BYTE bInData[1024];
    int  nInDataLen;
    BYTE bOutData[1024];
    int  nOutDataLen;
    BYTE bOutDataExp[1024];
    int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    nSKLen = 0;

    nEcMark = 17;
    nPad = 0;

    /* PK 043D646AB3D38385671D39B5E16E5DD9D50494CBBDF2F572C7EAD7FB19562A794268CA6BAD0ED9DFF174659F3B37C1F602A0B817696CD18E9CB76F9F14071D4E93 */
    /* SK D4DD2D2973965C23038CA4085E80F3E3E1BD400023A9DEDD73BDC91556E65B4E */
    /* SKByHMK 3C8E44A70C79C17D936A39680797ECD1FB1C763B995CF2053CF81E2EB3DB715E6BCB2CCA658BFD78 */
    memcpy(bSK,
           "\x3C\x8E\x44\xA7\x0C\x79\xC1\x7D" \
           "\x93\x6A\x39\x68\x07\x97\xEC\xD1" \
           "\xFB\x1C\x76\x3B\x99\x5C\xF2\x05" \
           "\x3C\xF8\x1E\x2E\xB3\xDB\x71\x5E" \
           "\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78" \
           , 40);
    nSKLen = 40;

    /* 0BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB9 */
    /* 30424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424239 */
    /* 33444C86A46ED7FADB2DA1203331B59EB53597CF5E6FE9CC7058852CC9642088C59EC6B87E59474936B41222F81DEB9A04A377592B17F11A68715F5018FA18F57A05B29CE628DDBACC219E8E53D4B690233675CF9922D6E227BBC1567DF1E73D3D4941653F691F20D1E923D39CC844AF0AF9F120E04F7639A4C03D4D89A154250BAB9240EB55339DBC4186CAF1D6D5F9E298C557A5BA41B35EF07BA6D2573544 */
    memcpy(bInData,
           "\x33\x44\x4C\x86\xA4\x6E\xD7\xFA\xDB\x2D\xA1\x20\x33\x31\xB5\x9E" \
           "\xB5\x35\x97\xCF\x5E\x6F\xE9\xCC\x70\x58\x85\x2C\xC9\x64\x20\x88" \
           "\xC5\x9E\xC6\xB8\x7E\x59\x47\x49\x36\xB4\x12\x22\xF8\x1D\xEB\x9A" \
           "\x04\xA3\x77\x59\x2B\x17\xF1\x1A\x68\x71\x5F\x50\x18\xFA\x18\xF5" \
           "\x7A\x05\xB2\x9C\xE6\x28\xDD\xBA\xCC\x21\x9E\x8E\x53\xD4\xB6\x90" \
           "\x23\x36\x75\xCF\x99\x22\xD6\xE2\x27\xBB\xC1\x56\x7D\xF1\xE7\x3D" \
           "\x3D\x49\x41\x65\x3F\x69\x1F\x20\xD1\xE9\x23\xD3\x9C\xC8\x44\xAF" \
           "\x0A\xF9\xF1\x20\xE0\x4F\x76\x39\xA4\xC0\x3D\x4D\x89\xA1\x54\x25" \
           "\x0B\xAB\x92\x40\xEB\x55\x33\x9D\xBC\x41\x86\xCA\xF1\xD6\xD5\xF9" \
           "\xE2\x98\xC5\x57\xA5\xBA\x41\xB3\x5E\xF0\x7B\xA6\xD2\x57\x35\x44" \
           , 160);
    nInDataLen = 160;
    memset(bOutDataExp, 0x42, 64);
    bOutDataExp[0] = 0x30;
    bOutDataExp[63] = 0x39;
    nOutDataLenExp = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nEcMark = %d\n", nEcMark);
    printf("[IN ]nPad    = %d\n", nPad);
    DspHex("[IN ]bSK     =", bSK, nSKLen);
    printf("[IN ]nSKLen  = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, nInDataLen);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEccSkDecrypt(nSock, nEcMark, nPad, bSK, nSKLen, bInData, nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "ECC私钥解密，64字节数据，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, nOutDataLenExp);
    DspHex("[OUT]bOutData     =", bOutData, nOutDataLen);
    printf("[OUT]nOutDataLen  = %d\n", nOutDataLen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EccSkDecrypt_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nEcMark;
    int  nPad;
    BYTE bSK[256];
    int  nSKLen;
    BYTE bInData[4096];
    int  nInDataLen;
    BYTE bOutData[4096];
    int  nOutDataLen;
    BYTE bOutDataExp[4096];
    int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    nSKLen = 0;

    nEcMark = 17;
    nPad = 0;

    /* PK 043D646AB3D38385671D39B5E16E5DD9D50494CBBDF2F572C7EAD7FB19562A794268CA6BAD0ED9DFF174659F3B37C1F602A0B817696CD18E9CB76F9F14071D4E93 */
    /* SK D4DD2D2973965C23038CA4085E80F3E3E1BD400023A9DEDD73BDC91556E65B4E */
    /* 3C8E44A70C79C17D936A39680797ECD1FB1C763B995CF2053CF81E2EB3DB715E6BCB2CCA658BFD78 */
    // "\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78" 
    memcpy(bSK,
           "\x3C\x8E\x44\xA7\x0C\x79\xC1\x7D" \
           "\x93\x6A\x39\x68\x07\x97\xEC\xD1" \
           "\xFB\x1C\x76\x3B\x99\x5C\xF2\x05" \
           "\x3C\xF8\x1E\x2E\xB3\xDB\x71\x5E" \
           "\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78" \
           , 40);
    nSKLen = 40;
/*
    memcpy(bInData,
           "\x74\xFD\xDA\x99\x40\x65\x80\x13\x3B\xB8\xE8\x80\x4C\xE5\x88\xFE" \
           "\x6A\x4D\x36\x1F\x9C\x17\x82\xBC\x65\x40\x4C\x34\xC4\xAA\x97\xB9" \
           "\x46\x8E\x55\xB2\x0A\x00\x05\xCB\xB6\xDD\xAC\x55\x5D\x5C\x7D\xF3" \
           "\x20\xA6\x42\x2E\x5E\xFC\xE9\xEB\x7A\x7F\x86\x02\xB2\xED\xA7\x6F" \
           "\xE3\xC8\xE3\x40\x9A\x79\xC8\x77\xF7\xEB\x58\xB9\x91\x4A\xFB\x24" \
           "\xB0\x4A\x62\xE4\x8F\x17\x19\xEB\x94\xC9\x92\x20\xF8\x63\x46\xDA" \
           "\xBA\x66\x8B\x5A\xA2\xE1\xA0\x04\x42\x54\x24\x64\x2F\x61\x4A\x52" \
           "\x9E\x39\xF0\xBB\xBC\x63\x21\x5C\x9D\xA2\xC4\x86\x2B\x05\xA0\xCE" \
           "\x99\x0E\xC5\xFE\xC5\xB3\x96\x92\x45\xE6\x6C\xC9\x51\x48\x57\xE9" \
           "\xBF\xA0\xE6\x1C\x3C\x41\xB3\xD4\xAB\x72\x97\xDE\x22\xD3\x91\x4B" \
           "\xC6\x1B\x33\x96\x41\x7B\xD6\x6C\xA1\x2C\xED\xB7\xA7\xA6\xD5\x20" \
           "\xC9\x6B\xBB\x29\x51\xCE\x94\xD8\x24\x1D\xB7\xE5\xB8\xD8\xF5\x50" \
           "\x94\x62\x22\x57\x44\x00\xDB\xD6\x8D\x49\xCE\x5A\xB5\x19\x4B\x81" \
           "\xE0\x71\xCE\xEF\xB3\x6E\xBC\xFA\x11\x5C\xA4\xFC\x5A\xB2\x8E\x3A" \
           "\xF2\xDD\xE5\x01\xF9\xB4\xBD\x50\xE0\xB1\xD7\x29\x28\x5B\x49\xB8" \
           "\x67\x2F\x67\xD8\xE4\x33\x36\x6D\x4F\xAB\x71\x02\x4E\xC4\xAD\xAB" \
           "\x31\x55\xE5\xFB\x9D\xE9\xCE\x64\xEE\xE5\xCF\xDD\x03\xB2\x44\xCA" \
           "\x07\xBC\x34\x3C\xCC\x40\x5D\xFF\xDC\xA7\xC1\x7C\x0E\x66\x2E\xCE" \
           "\xB5\xE8\x40\x5C\xEC\xD1\x6B\x29\xF7\x66\x1B\x25\x2C\x27\xDF\xE3" \
           "\x32\xB3\x12\xA5\xC2\xC8\x9E\x02\xEE\x05\x52\x81\x59\x2D\x9F\xA2" \
           "\x85\xC2\x4D\xCE\xD2\xCE\x28\xCF\xAC\x2B\x36\xA0\xE3\xC1\x5C\xFF" \
           "\x2A\x3E\x0A\x65\x20\x2A\x3E\x86\xE7\x4C\x42\xEA\x64\x2D\x52\xB1" \
           "\xA2\x41\xB1\xCC\xC9\xCE\xF5\xC8\xC7\x8F\x06\x1B\x4D\xBC\x5B\xB3" \
           "\x1C\xEB\x10\x66\x01\x56\x0A\x1A\x0F\x80\xE8\x7D\xE6\x65\x91\xB0" \
           "\x24\x69\xC4\xC8\x6D\xC0\x41\xBE\xA1\x7A\xEE\x56\x2A\x80\xC7\x2F" \
           "\xBC\xFE\x9E\x1D\x7A\x7C\x08\x81\x3A\x82\x80\xB2\xB6\x0C\xB5\x5E" \
           "\x35\xD4\x84\xD3\xD6\x76\xA2\x98\xEB\x54\xED\xA1\xA4\xFC\xE5\xB4" \
           "\x7D\x6D\xF1\x96\x73\x2E\x0E\x65\xB8\x8E\xE1\xF6\x4C\x35\x0D\x27" \
           "\x3C\xF7\xBC\x1A\x25\x8A\x15\x4F\xC3\x22\x83\xF0\x3B\x37\x78\x56" \
           "\x5F\x33\xEC\x7B\x16\x1F\x32\x3F\xC1\x5C\x3F\x2B\x79\x48\x35\x74" \
           "\x06\x8B\x25\xC3\x92\x06\x14\xA8\xED\xDB\xC3\xE1\x4A\x77\x10\xC7" \
           "\xCC\x6B\x1B\xF9\xF4\x14\x66\xAB\x9B\xCD\x0D\xC6\xD8\xA2\xDB\xBB" \
           "\xA4\x3A\x9B\xB2\x23\x5B\x6F\xAA\x5D\x80\x45\x60\xB5\x4A\x3E\x9C" \
           "\x26\xB5\xEE\x9A\xE4\x98\x97\xAA\xE1\xD2\xD3\xB0\x65\xF0\x5F\x38" \
           "\xA0\xB9\x44\x05\x66\xAD\xA2\x23\x25\x7E\x86\x0E\x5A\x66\x4E\x5F" \
           "\xB0\x8C\x87\xAD\x38\x58\x20\x00\x98\x4C\x92\x56\x6A\xAC\x4D\x40" \
           "\xE2\xAF\x73\xD0\x84\x81\x01\xE4\xC1\x73\x4A\x32\xC6\xA4\x20\x2C" \
           "\xD9\x7A\x2C\x6C\x51\x7A\x04\x1B\x3E\x63\xC5\x0A\x1B\xBC\x9B\x86" \
           "\xDB\xF1\xFC\x51\xFD\x8F\xE8\x10\x0B\x86\xF7\xF8\x78\x77\x7D\x1B" \
           "\x73\x18\xAC\x0B\x9D\xE2\xC4\xE1\x6A\x5A\x56\x56\x30\xA5\x32\x7F" \
           "\x12\x68\xB1\xD6\x55\x0B\xF9\xDA\x13\xDA\xC5\x93\x88\x4D\xA3\x52" \
           "\x2D\x5E\xDC\x4D\x6B\x3F\x52\x6D\x18\x97\x61\xFB\x17\x22\xE2\xFF" \
           "\xA1\x23\x03\xF6\x68\x3F\x10\x53\x2B\x4E\x86\x6A\x1F\xA1\xC8\xE1" \
           "\x26\xE9\xEC\x77\xB8\x57\x05\x81\x25\x55\xB9\x88\x7B\x79\x62\x96" \
           "\xBD\xCC\xF1\xE3\x48\xCD\xE0\xDB\x98\xE1\x93\x2B\xE9\xE4\xEA\x79" \
           "\x89\x48\x24\x02\x9C\x54\x65\x23\xE5\x35\x4E\xDA\x96\xFE\xFC\x58" \
           "\x34\x86\x34\xEF\x73\xE5\xFD\xC9\x41\x40\x1E\xA8\xBE\xC1\x64\x8B" \
           "\x0D\xCC\xB9\x45\x16\x17\x0B\x3C\x9B\x0E\xC8\x72\x2B\xD9\x8E\x1D" \
           "\x7A\x1F\x5B\x38\xBF\x9D\xBB\x79\x63\xF3\x1B\x61\x04\xF7\xE4\x4F" \
           "\x9E\x41\xBF\x12\x91\xB8\x20\x0B\x6B\x5A\xD0\x6D\x49\x35\x90\xC5" \
           "\x35\x60\x86\x28\x22\x17\x6A\x2B\x5F\x9E\x9B\xAE\xDA\x23\x7F\x2E" \
           "\x7D\xDA\xB6\x12\xD8\xD6\xF7\xA4\x5A\xDD\x54\x80\xFF\x86\xEF\x0C" \
           "\x5C\x10\x4C\x18\x82\xA1\x84\xA1\x5D\xD1\xBE\x8B\xFA\x35\x01\x8A" \
           "\xA5\x6F\x26\x26\xE8\xB0\xD3\x4B\x20\x05\xDD\x5C\x83\x10\xCD\x85" \
           "\x9F\x10\xF9\x27\x86\xD9\x66\xE4\x9C\xBC\x35\x41\x01\x6C\xD1\xC5" \
           "\xCA\x78\x89\xED\x76\x6E\xD2\x45\x72\x75\x4D\xA9\x1F\x8F\xA2\x23" \
           "\x49\xD3\x78\xE1\x25\x09\x94\xA6\xF5\xB2\xE3\x06\xA6\xA6\x40\x2D" \
           "\x2A\xF8\xCB\x7A\x4D\x9D\x97\x81\x58\x8B\xAB\x8E\x2D\xB9\x42\x93" \
           "\x58\xBA\xD9\x52\xCD\x28\xFA\x5F\xB3\xA2\x79\x3A\x12\xD4\x43\x80" \
           "\x17\xD7\x1C\x39\x5D\x95\x9E\x2F\xC2\xAE\x9B\x14\xEE\xD5\x74\x8C" \
           "\x4B\xA7\x29\xE7\x84\x5B\x1B\x47\xD1\x26\x51\xE0\x27\x87\xFA\xB0" \
           "\xDB\x1F\x7E\x31\xE4\x2B\x8E\x78\x0A\x52\x7A\x73\xE4\x61\x68\x3E" \
           "\xDB\x07\x96\x86\x52\xDD\xC6\xA8\x55\x47\x72\xB7\xB3\x8C\xE7\x7E" \
           "\xB4\xA6\x70\xB1\x99\x88\x76\xE9\xD4\xDC\xA9\xCC\x46\xA7\x3D\x55" \
           , 1024);

    memcpy(&bInData[1024],
           "\xE7\x19\xDE\x10\x85\xEB\x18\x07\x66\x4F\xAC\x0B\x18\x12\x03\xBC" \
           "\xBA\xE1\xB4\x12\xF3\x43\x1C\xEB\xAD\xF1\x5A\x81\xFC\x32\x9A\x3B" \
           "\xD3\xA9\x91\x63\x15\xDF\xF8\x1E\x5B\x8B\xA2\x65\x42\xAA\x06\xCD" \
           "\xA9\xCE\x78\x4A\xB7\x3C\xA9\xCD\xE4\xE0\xF3\x9B\x28\xAB\x48\x97" \
           "\x08\xD9\x4A\x19\x43\x2C\x4A\xC2\x52\xB9\x1C\x5A\x51\xF7\x10\xC1" \
           "\x9B\xED\x84\x38\x62\xF7\xEF\x57\x2F\x69\xD5\x21\xB7\x1E\x0C\xD8" \
           "\x8A\x08\x0A\x8C\x20\xFE\x8C\x63\x46\x5F\xE0\x35\x04\x9F\xEC\x0E" \
           "\xFE\x8F\x04\xEB\xD4\x44\x66\x3C\xC8\x72\x46\x3D\xD9\x26\x80\xC1" \
           "\xA0\x0F\xCB\x22\x10\x4D\x62\xC2\xE0\xB0\xD9\x22\x43\xB5\x9B\xF8" \
           "\x45\x17\xB9\xAA\x2F\xB0\x6C\xAF\xB9\x61\xCC\x8E\x2A\x83\xD6\xC1" \
           "\x4D\x3F\x9E\x82\xBC\xDA\xC4\xC8\x8A\x37\x6F\x19\x29\x9C\x8A\xD4" \
           "\x6D\xB3\x0F\x06\x73\xD8\x64\xB0\x15\x66\x46\x63\xF2\xA0\x85\xC6" \
           "\xDE\xB5\xA8\xA8\xD6\x78\xE2\x25\x27\x4A\xCF\xD2\x0B\xE6\x1F\x57" \
           "\xCE\x0A\xD8\xE8\x71\xC8\x7C\x61\x8C\x58\x5F\xAF\x96\x4D\x38\x58" \
           "\xBA\xB5\xE6\xDB\xF8\x86\x6A\xBF\x02\x62\x3C\x94\xB1\xA2\xCF\x12" \
           "\x1B\x29\x20\x94\x20\x2C\xEE\x47\x07\xD4\xAF\xCD\xEC\x94\x0A\x84" \
           "\xD9\x17\x55\x0E\xC1\xFE\xDF\xF2\xF1\xBF\x53\x8A\x00\x7D\x5E\xF7" \
           "\x5B\x30\xC6\x35\xDF\xD8\xF3\xD7\x6F\xB3\x94\x35\x3E\x03\x03\x65" \
           "\x78\x0D\x8A\x7F\x32\x84\xD6\x5A\x9F\xA1\xDE\xC5\xBD\xA2\x94\xAB" \
           "\xF9\xCC\xAA\x11\xD6\xDB\x30\xF2\x75\x56\x70\x79\xFE\x70\xEE\xC8" \
           "\x87\x92\xF2\x94\xF2\x96\xD6\x74\x9A\x9E\x6C\x8F\xA5\x55\xD9\xEF" \
           "\xB5\xBC\xE6\x81\xDF\x4F\xCC\x3C\x41\x04\x48\xD1\x9C\x22\x4C\x0B" \
           "\x72\xC3\xDD\x45\x9A\xC6\xA4\x00\x3F\x68\x15\x91\xEE\x37\xD0\xEA" \
           "\x33\xBE\x74\x43\xB3\x51\x32\xCA\x8B\x97\xBB\x85\x28\x4D\x0B\x28" \
           "\xA8\x6F\x7A\xBF\xB9\xB5\xF1\x71\x11\xCB\x06\x85\x7F\x3F\xBF\xD2" \
           "\xF6\x2C\x87\x87\xD2\x37\x60\x76\x3D\x3B\x00\x04\x20\x49\x8D\x13" \
           "\xC0\xB5\x76\x37\x33\xB3\xE8\x2C\x1D\x8B\xF4\x9D\xFF\xDE\x53\x8C" \
           "\x17\xBA\x07\x75\x33\xC3\xE0\x10\x42\xF7\x91\xAF\xA6\xE9\x2E\x2A" \
           "\xD2\xE7\x8B\x47\xE0\xDC\x36\x00\xD1\x37\xC2\xA9\xA0\x00\xAF\xE8" \
           "\x82\xE8\x5F\x5E\xCB\x18\x9B\x21\x06\x80\x1F\x52\x6B\xFA\xA9\xCA" \
           "\x23\x4A\x58\x44\x83\x31\x9C\xF9\x08\x56\x61\x0C\x64\x65\xB3\xB0" \
           "\xFA\x6E\x26\x53\xFA\x14\xD7\xCA\xA9\x9C\x7A\xC8\xFE\xB2\x6A\xB4" \
           "\x9E\x9C\x6F\x76\x7B\xAE\x53\x07\x65\x89\x3C\x0E\xEF\xEA\x17\xB7" \
           "\x5E\x9E\x1B\xC0\x8C\x8F\xFE\x19\xD3\x15\x9C\x43\x6C\x6E\x45\x5B" \
           "\xE3\xE4\xB7\xDA\xCC\xB8\x83\x4D\x26\x59\x17\xE1\xF5\xC9\x11\x77" \
           "\xA3\xC5\x8E\xF4\xBD\x4E\xD4\xF4\xE2\xF2\xB5\x01\x9A\x16\xA5\xBD" \
           "\x91\x18\xF1\x33\xC6\x2C\x56\x88\x25\x07\xFE\x85\xD5\x18\xFA\x8D" \
           "\x12\x3A\x1E\x09\xD0\xEE\xC3\x06\xE4\x8A\x1D\x5B\x05\x7D\x43\xA1" \
           "\x06\x3A\x8A\x0B\x01\x5C\x9D\xF2\x74\xE4\x5D\xC4\xB2\x56\xC1\xF0" \
           "\xA5\xAE\x11\x12\x9A\xC5\x57\xD6\x6F\x51\xB3\x92\x88\x37\xA7\x4C" \
           "\x93\x74\xF5\x94\xAB\x86\xBD\xBA\xC9\x81\x24\x93\x8C\x11\x69\x91" \
           "\x02\xEA\xBB\x7E\x6A\xD8\x56\x20\x75\x7D\xE6\x27\xDE\x90\x9D\x9C" \
           "\x65\x04\xBF\x4C\x7E\xAF\x48\x2A\xA4\x05\xB4\xEB\xFD\xDE\x19\x3E" \
           "\xE0\xB1\x2E\x5E\xD3\x24\x6B\x03\xDF\xFA\xF5\x3E\x14\x1D\x13\x93" \
           "\x3C\x58\x4B\x1B\x83\xC4\x94\x42\x9B\x90\x5C\xA1\x98\x89\xB0\x9F" \
           "\x59\xE6\xD2\x36\x17\xB3\xE8\x05\x5A\x25\x4E\x52\x5E\x58\xC5\xCD" \
           "\x47\xB3\xC2\xF9\xFF\x2F\x2A\x8C\x96\xFF\xC5\xC2\x26\x8C\xBB\x96" \
           "\x42\xA1\x44\xF9\x53\x46\x94\xC2\x40\x49\xAD\x40\xB5\x67\x26\x66" \
           "\x3B\xE0\x35\x4E\x71\xD3\xE8\x0A\xCA\x2A\x22\x0B\xF0\xF4\xB9\x09" \
           "\xED\x10\x9E\xBF\x0C\x80\x29\x04\x5D\x88\xF6\x33\x61\x7B\x39\x37" \
           "\x42\x2D\x13\xB8\x23\x55\x0F\x9D\x04\xCB\x52\x7D\x77\x60\xAF\x39" \
           "\x5A\x14\x0D\xA4\x24\xA4\xCD\x9A\x3A\xF8\xF0\x30\x8A\x5E\x18\xE2" \
           "\xB3\x94\x74\xA7\xB2\xF7\xF5\x28\xAF\xF2\xA3\xB4\x3B\x79\x37\xE1" \
           "\x8A\xA0\x54\x55\x8B\x47\x18\x54\x71\x4C\x2C\x7D\xF6\x00\xEC\x28" \
           "\x44\x7B\x63\xF1\x59\x7F\xA4\xB4\xC3\x4C\xAD\x4C\xD7\x03\x27\x0F" \
           "\x32\xC0\x45\x3F\x6E\x25\x7A\xC4\x04\xEB\x66\x10\x48\xE4\xAE\x73" \
           "\x87\x88\x3B\x2C\xDF\x1A\xE9\xF6\xF5\xA2\xA1\x3E\x2D\x58\x26\xB5" \
           "\xDA\x38\x2A\xE6\x2D\x75\x9E\xD7\x25\xB1\xF7\xE0\xE5\x93\x6A\x23" \
           "\x91\x73\x10\x4C\x14\x0A\xDC\x3C\x74\x12\x21\x2E\x3B\xAE\xAF\xB3" \
           "\xC0\x71\x93\x7C\xA5\x03\xA4\xC3\x79\x4B\x51\x61\x23\x81\x86\xD7" \
           "\x2B\x55\xE1\x28\x14\xF0\x75\x2D\x93\xC1\xB3\x9E\x7D\x80\x04\xDA" \
           "\xB5\xAC\xF2\xBD\x79\xB3\x19\x26\x44\xE9\xEE\x9E\x23\x22\xAC\x4E" \
           "\xEE\x1B\x22\xEA\x80\xA5\x4A\x8C\x31\xE4\x02\x47\x5F\x81\xFE\x25" \
           "\xFF\x7F\xDF\x28\xEA\x93\x64\x07\xF4\x58\xD3\x5F\xD9\x49\xD9\x27" \
           , 1024);
    memcpy(&bInData[2048],
           "\xBF\x89\x51\xFE\xFB\xA7\xCE\xE6\x13\x17\xD5\x24\xD7\xB5\x02\x0C" \
           "\xCF\x9D\xBA\x83\xC0\xEC\x64\x03\x14\xF7\x0C\xF8\xAD\xD6\xD4\x38" \
           "\xF2\x67\x7E\x7A\x99\xE6\x34\x3C\x0F\xCC\x59\x54\xDA\x71\xAC\x8C" \
           "\x11\x1D\xE9\x2B\x7B\x1D\xDC\xA3\x72\xED\xB2\x7C\x0F\xB2\x22\x03" \
           "\x89\xC8\xC8\xB7\x60\x60\x50\x78\xDA\xBB\x50\xFA\xF0\x4D\x04\xC3" \
           "\x79\xBD\xC9\xDA\xDA\x72\x37\xBD\x01\xEA\x74\x1B\x0A\x23\xB3\x23" \
           "\x2C\xBD\x15\x3B\x97\xD5\x6A\x13\x4F\x3E\x7F\x5A\x66\x1B\xE9\x4E" \
           "\xD4\xA1\x5B\x08\x09\x61\x82\xA0\x0B\x05\xC6\x44\x3B\x20\xAA\x5F" \
           "\x87\x21\xA1\xCE\x77\xE7\x34\x06\x3F\x1A\xC0\xF8\x58\xF7\x93\x6C" \
           "\x1D\x41\x7B\x5D\xD1\xC1\xAC\xD1\x9F\xA1\x38\x6F\xAC\x68\x6C\x68" \
           "\x39\xA8\xD2\x68\xB8\xFC\x98\x5A\xD1\x40\x16\x8B\xB1\xF7\x1B\x55" \
           "\xC4\x61\x91\x2D\xA2\x94\x94\x11\x91\xA5\x59\x51\x30\x0C\xE9\xF6" \
           "\x2C\x33\xDE\x59\xE1\x01\xE2\x43\xBE\x5F\xF9\x53\x22\xE0\xB2\x1D" \
           "\x59\xF6\x4F\x20\x2E\x63\x6D\x6D\xB0\xCF\xED\x3C\x44\xD1\xD1\x13" \
           "\x94\x4E\x48\x32\x03\x11\x73\x9C\xF9\x4F\x54\x3A\x8B\xA1\x10\x19" \
           "\xC3\x96\x8A\xA7\xBB\xF0\xC7\xB0\xF2\xFD\x5B\x4F\x50\x46\x04\x00" \
           "\x48\x03\x76\xAD\xEB\xA5\x71\x83\x66\x68\xC4\x66\x26\xCB\xB8\x3A" \
           "\x8E\x5D\x8E\xCA\xC2\x28\x24\x9F\xC9\xA2\x6E\xF7\x0B\x64\x30\x1F" \
           "\x93\x9A\xD9\xD2\x39\x90\x7C\xEF\x91\x4E\xC2\x05\xD9\x02\xBB\x41" \
           "\x21\x0E\x64\x7B\xFF\x19\x92\x65\xA3\x9A\x3D\x8A\x99\x35\xE5\x59" \
           "\xD6\xA1\xFD\xA9\xF3\x43\x75\x9A\x22\xE6\x23\x2E\x65\x5C\x3D\xF7" \
           "\x5C\xA6\x4A\x8A\x5D\x41\x29\x25\x75\x33\x65\xEE\x44\x14\x3E\x95" \
           "\x52\x34\xE2\x9A\xA1\x2B\xF1\xE6\x56\x87\xCF\xFB\x1E\x0D\x32\xF5" \
           "\x7E\x5B\xDB\x92\xE4\xF8\x82\xF0\x58\x98\x65\xD9\x1C\xE9\x4F\x85" \
           "\xFA\xA5\xDD\x5D\x3C\x56\x3E\x89\x85\x2E\x9D\xFC\xD7\x03\xDB\x5C" \
           "\x30\xCB\x83\x11\xBD\x1B\xC4\x2F\x3C\x32\x04\x8E\x40\xC3\xBE\xCE" \
           "\xD2\xDD\xC1\xBC\x90\xD1\x68\xFB\x06\x56\x79\x37\xD8\x70\x0C\x6F" \
           "\x9A\x4E\xA5\x5B\x53\xE5\xB6\x02\x3C\x32\x4B\xA4\x9F\x3B\x42\x42" \
           "\x09\x70\x60\xC8\x49\x41\xB7\x01\x7F\x4B\xC4\x57\x04\xCB\xD6\x83" \
           "\xE5\xA7\xF8\xFD\xFE\x48\xD5\x32\x61\x42\x9A\x67\x56\xC5\x28\x3E" \
           "\x20\x57\xA8\x6A\xAD\x7E\x19\x37\x54\x46\xA6\xAE\xF4\x15\xBE\x17" \
           "\x67\x2B\x97\xA2\x71\x85\x11\x69\xC0\x1E\x98\x8D\xF6\x34\xCB\x43" \
           "\xCF\x3A\x9D\x44\x25\x6E\x05\xA9\x2E\x42\x55\x39\xF0\xF1\xC0\x61" \
           "\x4C\xA9\xE4\x7B\x06\x0A\x88\x78\x96\x00\xBB\x96\x22\x47\x42\x3A" \
           "\xBC\x8C\x62\x34\x69\x59\xA1\x88\x64\x5C\xAE\x86\xEB\xBF\xF9\xEC" \
           "\x48\x47\xC7\xC4\xA2\xA0\x7C\x9E\x1E\xCD\x7A\xD5\x2E\x92\xB3\x1E" \
           "\x49\x09\x86\x1C\xFA\xE8\x27\x47\x51\x10\xA3\x2A\xF9\xD1\x36\xA8" \
           "\x9C\xE1\x0B\x40\x9B\x6A\x88\x15\x71\x49\xBF\x89\x54\x42\x0A\x0A" \
           "\xB0\x3D\xB1\x43\xCD\x62\xA1\x37\x57\x80\xDA\x89\x10\x42\xEA\x10" \
           "\x55\x25\x33\x8D\xDD\x5E\x6E\xF4\x5B\x82\x36\xC7\xAF\xE9\xC6\x5E" \
           "\x7A\x79\xF0\x05\x9F\x30\x58\xBA\xB4\xE6\xD7\xC6\xD1\xB2\x04\x5C" \
           "\xDA\x5F\xFF\x16\x6A\x91\x27\xEF\x68\xED\xF5\xA0\x4A\x22\xCA\xBD" \
           "\xA1\x09\xB7\xE4\x04\xDF\x5C\xD5\x6F\xEC\xD0\xB7\x71\xF9\xDB\x05" \
           "\x50\xA8\x82\x99\x29\x8F\xD3\xFA\x5C\x6A\xE0\x5B\x62\xC4\x4B\x52" \
           "\x75\x50\xC6\x39\xE6\x89\x06\xB9\xF3\xDC\x78\x38\x06\x1A\x00\x98" \
           "\xE7\x28\x64\x48\xE9\xC6\x3B\x6E\x29\x21\xFB\x07\x74\x9B\x34\xCF" \
           "\xC1\x85\x9A\x39\x7A\xDD\x2D\x6C\xB1\xCC\x5F\x7E\xB8\x6D\x42\x8E" \
           "\x1F\xDF\x13\xA4\x3E\xBC\xFB\x4E\x88\x00\x42\xA4\x85\xA1\x65\x84" \
           "\xD2\x3A\xC8\x57\x78\x72\xBE\x19\x7D\x79\xBC\x26\xE8\xCD\x1D\xA6" \
           "\x13\x0D\x26\xA9\xA0\x20\x60\xAB\x6D\x20\x7E\x10\x70\x99\x72\xA5" \
           "\x0B\x51\xB6\x15\x25\xC9\x9C\x04\x55\xD1\x6B\x3E\xC0\xEB\x94\x9A" \
           "\x95\x95\xB4\xEF\xEF\xCC\xF7\x0B\xE1\x04\xE6\x7B\x1B\x8D\x02\x30" \
           "\xB8\xDC\x06\x38\x07\x99\xCD\x6C\x88\xDA\xF0\xF7\x1A\x7D\x20\x5F" \
           "\x2E\xC0\xF7\x34\xE0\x17\x2D\x4E\xE2\x07\x61\x91\xA4\x91\xF0\xE6" \
           "\x33\xD4\x61\xD4\xAD\xF2\xE5\x36\x91\x46\xE9\x92\x2F\x3B\x67\x1C" \
           "\xAE\x54\x8D\xB8\x79\xF4\x18\xA7\x2A\xF4\xC3\x05\x40\x4F\x6F\x16" \
           "\x82\x62\x80\x9C\x1D\x46\x92\x3D\x4F\x46\x1D\xF1\x71\xC2\x66\xC6" \
           "\xC1\x02\x8D\xAC\x88\xEC\x61\x5D\x9B\x19\xDF\x0D\x7C\x87\x22\xBA" \
           "\xAC\xDD\x45\x12\x65\x34\x19\x52\x3A\x07\xA9\x41\x53\x78\xD0\xDB" \
           "\xA1\xBD\xD3\x64\x13\x6E\xA1\x0A\x33\xE5\x49\xA3\x19\x68\x59\xBC" \
           "\x75\xAB\x16\x40\x2A\x2E\x60\x56\x3A\x84\x2E\x5F\x71\x1A\xFE\xB8" \
           "\x97\x71\xAF\x6B\xDD\x20\x26\xC3\x81\x68\xC1\xE9\x75\x76\x3D\x86" \
           "\x0D\x03\xC0\xA8\xE7\xEA\x8B\x51\x9B\x53\x87\x43\xD3\x5C\xF0\x21" \
           "\x6B\xFE\x71\xDC\x89\x0F\x50\x7C\x7B\x5E\x22\x69\xC3\x93\x6F\x92" \
           , 1024);
    memcpy(&bInData[3072],
           "\xF9\xA0\x75\x01\x47\xD2\x73\xA6\x4C\xE8\xDF\xB8\xAE\xA5\xB3\xDD" \
           "\x1E\x39\x05\x37\x80\xE9\xC4\xE1\xB3\x46\x51\xC7\x10\x89\xE3\x9A" \
           "\xEE\x93\x07\x92\x47\x9B\x66\x8D\xD2\x66\xD4\x99\xF8\xC8\x6B\x64" \
           "\x12\x04\xEF\xE2\xF1\x50\x00\x8B\xDC\x4D\xB3\x05\xB4\x37\xD6\x45" \
           "\x16\x8C\x78\x50\xE9\xFA\x64\x0E\xDC\x5F\x2A\x34\xB5\x76\xEA\xD9" \
           "\xC1\x28\xF2\xA3\xBE\x0F\x60\x04\x3E\xAD\x1E\x39\xAB\x37\x4C\xF8" \
           "\x25\x64\x7F\x10\x64\x67\x7F\xE7\xE7\xD2\xBD\xA6\xC4\x18\x44\x39" \
           "\xD0\x64\x28\xC8\x97\x6B\x59\xB9\xE2\xB7\x49\xC9\x90\x03\xBB\xB2" \
           "\x20\xB2\x87\xB6\x69\x5E\x60\x70\x5C\x08\xE7\x2B\x91\x38\x85\x8E" \
           "\x3E\xAE\x25\xAA\x45\x93\xAB\xD1\xA3\x43\xB6\x96\x39\xA7\xC5\x1D" \
           "\xDB\x0B\xA8\x51\xD3\xD7\xD8\x5C\xF4\xCB\xAA\x78\x53\xEE\xEB\x7C" \
           "\x61\x52\x90\x6A\xB0\x8D\x1B\x28\xE6\xAB\xC8\xEF\x43\xF7\x24\x92" \
           "\x94\x81\xCC\x23\x6B\x02\x15\x42\xDE\x7B\xCE\x5B\x2E\x14\x75\xEE" \
           "\x73\xE2\xAF\x42\xD6\x3B\xAF\xCB\x41\xDF\xD3\x17\x6A\xE8\x88\x42" \
           "\xDC\x51\xB3\x22\x1F\x9E\xCE\x5C\x86\xAE\xE4\xD4\xBC\x43\xBA\xAD" \
           "\xD5\x9C\x47\x64\xC1\x7A\x60\x73\x07\xD3\x19\x7C\x6E\x2F\xAF\x7E" \
           "\x90\xFB\x7E\xC1\x18\xC2\x66\x9B\x43\x57\xC9\x03\x14\x8F\xEE\x45" \
           "\x05\x4D\x28\xDE\x01\x57\x51\xBA\x9E\xC1\x6D\x96\x6D\x77\x0D\x97" \
           "\x4D\x40\x26\x2B\x68\xA5\x1C\x58\x10\x5F\x8C\x19\x51\xE6\x60\x9D" \
           "\x53\x27\x37\x69\xE2\x17\x76\xB5\xD9\x54\xC2\x2B\x9B\x5D\xC5\xFB" \
           "\xD5\xCA\x52\x07\xD6\xB6\xF4\xF9\x4E\x83\x54\x38\xB3\xEC\x4D\xD4" \
           "\x0E\xF8\x52\xDF\xFE\x2F\xE3\x96\xFC\x61\x78\xCB\x6A\x31\x02\x22" \
           "\x51\xA7\xFA\xC3\xD2\x11\x96\x21\x85\x55\xB1\xE9\xC2\xFC\x14\xD3" \
           "\x47\xDA\xD6\xF6\x10\x19\xFC\x99\xA6\x92\x86\x4E\x7F\x35\x64\xB6" \
           "\x11\xDC\x3A\x53\xA7\x84\x46\x8B\x59\x26\xA5\xDA\x5D\xB4\x09\x8F" \
           "\x6C\x36\x8B\x7E\x5E\x2A\x98\xB6\x7E\x2E\x5F\x27\x5A\x77\x77\xC2" \
           "\x22\x65\x33\xAD\xC7\x90\x0F\x42\xE6\xB6\xC6\x98\x5D\xFF\x28\xA0" \
           "\x7A\x11\x6A\x96\x56\x43\x73\x83\xC2\x11\x85\x07\x23\xD1\x25\xB0" \
           "\x63\x7F\x67\xF1\x89\x0F\xC1\x92\x68\x48\x61\x19\x2E\x3F\xF3\xF6" \
           "\x6D\x6B\x59\x7F\x48\x66\x64\xE4\x28\xF0\x11\xF2\x67\xCC\xBD\xD3" \
           "\x35\xF1\xE9\xA4\xD3\x55\xC0\x97\xC1\x5F\x49\xD2\x60\x40\x63\x73" \
           "\xDC\xEB\x25\x9F\xCB\xD3\x98\xF9\x1B\xA6\x5C\x98\xB8\x23\x7B\x89" \
           "\x86\x8B\x42\x9F\x2B\x47\x03\x61\x6A\xF4\x0F\x24\x79\x19\x98\x8D" \
           "\xCE\xA6\x8D\x2B\xDE\x23\xC5\x1F\x6F\x0B\x9C\xA6\x8B\xBF\x4D\x55" \
           "\x42\x35\x37\xCA\x74\xB4\x92\x0D\x87\x13\x8F\xD2\xF3\x02\x82\x8E" \
           "\x75\x57\x1E\xFA\x9D\xF3\x17\x20\xC9\x5A\x46\x95\x41\x89\x75\x02" \
           "\x00\x83\x2A\x33\x24\x90\x39\xDF\x53\x8F\x14\x51\xC8\x5C\xBD\xE2" \
           "\x27\x4B\xBC\x90\x30\x08\x00\x7B\xFA\x58\x87\xCA\x4E\x8E\x92\x5E" \
           "\xAB\xF5\xB7\x00\xFD\xB9\xAE\x7C\x5F\x82\x82\x6C\xB8\x79\xA0\x09" \
           "\x8C\x1E\xEB\xFB\xED\x72\x5B\x4D\x05\x8D\x18\xD6\x79\xB2\x11\xF3" \
           "\x2D\x86\xE5\x5E\xC4\x68\xAB\x41\x2F\xE2\xCC\x3A\x4A\x0D\x19\xAD" \
           "\x87\x5D\x28\xCC\xD9\xA0\x09\x56\x5D\xBE\x31\x3C\xD0\x80\x47\x53" \
           "\x7E\x0B\xEB\x43\xFA\x80\x95\x4E\xCB\x3F\x38\x1A\xD3\xA2\x39\x96" \
           "\x79\x6E\x6E\xF8\x6A\x1B\x5C\x11\x9C\xB0\xC2\x53\x2F\xC5\x0F\x78" \
           "\x19\x20\x99\x26\x3A\x54\x1A\xF1\x5B\x99\x96\x62\x43\xF6\xBE\x98" \
           "\x10\x93\xC0\x10\xD5\xE9\xD4\xC1\x38\xE9\x36\x3E\x88\x0C\x4F\xD1" \
           "\xB0\x5F\x2E\xB9\xB6\x78\xEF\x0C\x3F\x34\xF6\x6C\x5E\x81\x55\xE8" \
           "\x8C\x5E\xA6\x21\x7F\x38\x75\x63\xA8\x2E\x90\x27\x6A\x3B\xC4\x9F" \
           "\x27\x06\xEF\x4F\x86\x80\x4B\x2F\x81\xAB\x8A\x0D\xDD\x1E\x1E\x8F" \
           "\xCF\x16\xC4\xA2\x64\x27\xA4\xC0\x10\xFC\x21\xEB\x5E\x3D\x80\x04" \
           "\x80\x64\xBC\x1B\xAA\xD5\xB2\xFE\xD1\x34\x75\x6D\x93\xF1\x81\x9F" \
           "\x65\x3E\x72\xF0\xDD\xC8\x89\xC0\xA9\x96\xE9\x0E\x59\x31\xA6\x60" \
           "\x8A\x6D\xCE\x9B\x8B\xDF\x7A\x17\xD9\x00\xA3\x30\x12\x05\xA8\xFF" \
           "\xA3\x71\x06\xB0\x06\xAF\x3A\xE8\x1D\xB5\x24\x54\x0B\xD9\xD6\x58" \
           "\xCA\x1A\xDE\x43\x0A\x83\xC3\x3F\x4E\x71\x59\xB5\x4A\x2E\x53\x85" \
           "\x23\xC6\x0C\x5A\xA9\x19\xD4\xB3\x4E\x69\x8B\x57\x3A\xDC\x13\x5D" \
           "\xFE\x41\x65\xC7\xB4\x92\x8B\x37\xF2\x01\x06\x50\x37\x68\x77\x1E" \
           "\xCC\x7A\xC9\x20\xA8\xA5\xD9\xD4\x0B\x36\x05\x97\xB6\x08\x13\x70" \
           "\xB7\x08\x1E\x4C\x1C\x31\x90\xE1\x74\xA1\x0B\xA5\x4A\x18\x62\xC8" \
           "\x3A\x65\x79\x2B\x21\x6B\xA6\x10\x0C\x95\xF4\xD4\xE5\x36\x29\x22" \
           "\x00\x42\x20\x95\x17\xF1\xCB\x30\xFD\x84\x16\x98\xC9\xC7\x79\x8B" \
           "\xDF\x31\x03\x14\x88\xB7\xD9\x6B\x3D\xDE\xBE\x55\x32\x9A\xCD\x77" \
           "\xE2\x13\x0E\xD2\x7B\xEC\x07\xB6\x36\xBF\x80\x74\xBF\xBC\x9A\x54" \
           "\xF4\x7A\xDB\x11\x1F\x89\x79\x03\x7E\xC2\x52\x23\x14\x69\x1F\x65" \
           , 1024);
*/

    memcpy(bInData, RET, 4096);

    nInDataLen = 4096;
    nInDataLen = 1024; 
    memset(bOutDataExp, 0x42, 4000);
    bOutDataExp[0] = 0x30;
    bOutDataExp[3999] = 0x39;
    nOutDataLenExp = 4000;

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nEcMark = %d\n", nEcMark);
    printf("[IN ]nPad    = %d\n", nPad);
    DspHex("[IN ]bSK     =", bSK, nSKLen);
    printf("[IN ]nSKLen  = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, nInDataLen);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEccSkDecrypt(nSock, nEcMark, nPad, bSK, nSKLen, bInData, nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "ECC私钥解密，4000字节数据，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, nOutDataLen);
    DspHex("[OUT]bOutData     =", bOutData, nOutDataLen);
    printf("[OUT]nOutDataLen  = %d\n", nOutDataLen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EccSkDecrypt_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nEcMark;
    int  nPad;
    BYTE bSK[256];
    int  nSKLen;
    BYTE bInData[1024];
    int  nInDataLen;
    BYTE bOutData[1024];
    int  nOutDataLen;
    BYTE bOutDataExp[1024];
    int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    nSKLen = 0;

    nEcMark = 17;
    nPad = 0;

    /* PK 0400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 */
    /* SK 0000000000000000000000000000000000000000000000000000000000000000 */
    /* 1F1EA8255422D2751F1EA8255422D2751F1EA8255422D2751F1EA8255422D2756BCB2CCA658BFD78 */
    //\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78
    memcpy(bSK,
           "\x1F\x1E\xA8\x25\x54\x22\xD2\x75\x1F\x1E\xA8\x25\x54\x22\xD2\x75" \
           "\x1F\x1E\xA8\x25\x54\x22\xD2\x75\x1F\x1E\xA8\x25\x54\x22\xD2\x75" \
           "\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78" \
           , 40);
    nSKLen = 40;

    /* 0BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB9 */
    /* 30424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424242424239 */
    /* 218F10DE6B269E2483F03BC2B1A8FE3046F16508D206A6F5EB1375070D0438166F6F9C20BA2FF267EFB42B0028190923C1187AF563D64E62564C409E40F976D739515B0969124EBC9722E7D7B906C5B603D1E220BB834322E797302AFC2337AFCC39EBC0F0BBE35127B515B91CF416730AC608CAEB0AD8FAAC2A359EF08A5F8DF405769CE8D15FCBECACDF1D1CC5B3BF4CCFF29739690EC590A08E9DC673EFFD */
    memcpy(bInData,
           "\x21\x8F\x10\xDE\x6B\x26\x9E\x24\x83\xF0\x3B\xC2\xB1\xA8\xFE\x30" \
           "\x46\xF1\x65\x08\xD2\x06\xA6\xF5\xEB\x13\x75\x07\x0D\x04\x38\x16" \
           "\x6F\x6F\x9C\x20\xBA\x2F\xF2\x67\xEF\xB4\x2B\x00\x28\x19\x09\x23" \
           "\xC1\x18\x7A\xF5\x63\xD6\x4E\x62\x56\x4C\x40\x9E\x40\xF9\x76\xD7" \
           "\x39\x51\x5B\x09\x69\x12\x4E\xBC\x97\x22\xE7\xD7\xB9\x06\xC5\xB6" \
           "\x03\xD1\xE2\x20\xBB\x83\x43\x22\xE7\x97\x30\x2A\xFC\x23\x37\xAF" \
           "\xCC\x39\xEB\xC0\xF0\xBB\xE3\x51\x27\xB5\x15\xB9\x1C\xF4\x16\x73" \
           "\x0A\xC6\x08\xCA\xEB\x0A\xD8\xFA\xAC\x2A\x35\x9E\xF0\x8A\x5F\x8D" \
           "\xF4\x05\x76\x9C\xE8\xD1\x5F\xCB\xEC\xAC\xDF\x1D\x1C\xC5\xB3\xBF" \
           "\x4C\xCF\xF2\x97\x39\x69\x0E\xC5\x90\xA0\x8E\x9D\xC6\x73\xEF\xFD" \
           , 160);
    nInDataLen = 160;
    memset(bOutDataExp, 0x42, 64);
    bOutDataExp[0] = 0x30;
    bOutDataExp[63] = 0x39;
    nOutDataLenExp = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nEcMark = %d\n", nEcMark);
    printf("[IN ]nPad    = %d\n", nPad);
    DspHex("[IN ]bSK     =", bSK, nSKLen);
    printf("[IN ]nSKLen  = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, nInDataLen);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEccSkDecrypt(nSock, nEcMark, nPad, bSK, nSKLen, bInData, nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "ECC私钥解密，无效私钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

/* zhaomx  2017-04-17
  修改SM2公钥加密的公钥数据格式。头"04"去掉 ，由65变64
*/
void EccSign_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nEcMark;
	  int  nPad;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bSK[540];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);

    nEcMark = 17;
    nPad = 0;
    /* PK 04695BC3452B4DF79EBA188AC61C51A33A243F497A4D76D272F3771827BD80A944E1DA925A4853860EE0D883F3A2F43AA8F265C95F60A9102A7495551034D6C021 */
    /* SK 7BAD1BC2D566F4AC0F93E830E2E9A1E756C063E94FBDEABF68A29DD720B44B30 */
    memcpy(bPK,
           "\x69\x5B\xC3\x45\x2B\x4D\xF7\x9E\xBA\x18\x8A\xC6\x1C\x51\xA3" \
           "\x3A\x24\x3F\x49\x7A\x4D\x76\xD2\x72\xF3\x77\x18\x27\xBD\x80\xA9" \
           "\x44\xE1\xDA\x92\x5A\x48\x53\x86\x0E\xE0\xD8\x83\xF3\xA2\xF4\x3A" \
           "\xA8\xF2\x65\xC9\x5F\x60\xA9\x10\x2A\x74\x95\x55\x10\x34\xD6\xC0" \
           "\x21" \
           , 64);
    nPKLen = 64;
    //\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78
    memcpy(bSK,
           "\xC3\xE0\x99\x39\x13\x86\x91\xAA\x60\x90\x31\xAA\xDA\x12\x31\x49" \
           "\x5D\x23\xD8\x9A\xA3\x2D\x7B\x3E\x4C\x4D\x10\xD4\x63\x13\x08\xFD" \
           "\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78" \
           , 40);
    nSKLen = 40;
    /* 0BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB9 */
    memset(bData, 0x42, 256);
    bData[0] = 0x30;
    bData[255] = 0x39;
    nDataLen = 256;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nEcMark = %d\n", nEcMark);
    printf("[IN ]nPad = %d\n", nPad);
    DspHexExt("[IN ]bPK =", bPK, nPKLen);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHexExt("[IN ]bSK =", bSK, nSKLen);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHexExt("[IN ]bData =", bData, 256);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEccSign(nSock, nEcMark, nPad, bPK, nPKLen, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "SM2签名，256字节数据，测试失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bSign    =", bSign, nSignLen);
    printf("[OUT]nSignLen = %d", nSignLen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EccSign_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nEcMark;
	  int  nPad;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bSK[540];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);

    nEcMark = 17;
    nPad = 0;
    /* PK 0400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 */
    /* SK 0000000000000000000000000000000000000000000000000000000000000000 */
    /* 1F1EA8255422D2751F1EA8255422D2751F1EA8255422D2751F1EA8255422D2756BCB2CCA658BFD78 */
    memcpy(bPK,
           "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" \
           "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" \
           "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" \
           "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" \
           "\x00" \
           , 64);
    nPKLen = 64;
    //"\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78" 
    memcpy(bSK,
           "\x1F\x1E\xA8\x25\x54\x22\xD2\x75\x1F\x1E\xA8\x25\x54\x22\xD2\x75" \
           "\x1F\x1E\xA8\x25\x54\x22\xD2\x75\x1F\x1E\xA8\x25\x54\x22\xD2\x75" \
           
           , 32);
    nSKLen = 32;
    /* 0BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB9 */
    memset(bData, 0x42, 256);
    bData[0] = 0x30;
    bData[255] = 0x39;
    nDataLen = 256;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nEcMark = %d\n", nEcMark);
    printf("[IN ]nPad = %d\n", nPad);
    DspHexExt("[IN ]bPK =", bPK, nPKLen);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHexExt("[IN ]bSK =", bSK, nSKLen);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHexExt("[IN ]bData =", bData, 256);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEccSign(nSock, nEcMark, nPad, bPK, nPKLen, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "SM2签名，无效私钥，测试失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}


/* zhaomx  2017-04-17
  修改SM2公钥加密的公钥数据格式。头"04"去掉 ，由65变64
*/
void EccVerify_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nEcMark;
	  int  nPad;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nEcMark = 17;
    nPad = 0;
    /* PK 04695BC3452B4DF79EBA188AC61C51A33A243F497A4D76D272F3771827BD80A944E1DA925A4853860EE0D883F3A2F43AA8F265C95F60A9102A7495551034D6C021 */
    /* SK 7BAD1BC2D566F4AC0F93E830E2E9A1E756C063E94FBDEABF68A29DD720B44B30 */
    memcpy(bPK,
           "\x69\x5B\xC3\x45\x2B\x4D\xF7\x9E\xBA\x18\x8A\xC6\x1C\x51\xA3" \
           "\x3A\x24\x3F\x49\x7A\x4D\x76\xD2\x72\xF3\x77\x18\x27\xBD\x80\xA9" \
           "\x44\xE1\xDA\x92\x5A\x48\x53\x86\x0E\xE0\xD8\x83\xF3\xA2\xF4\x3A" \
           "\xA8\xF2\x65\xC9\x5F\x60\xA9\x10\x2A\x74\x95\x55\x10\x34\xD6\xC0" \
           "\x21" \
           , 64);
    nPKLen = 64;
    /* 0BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB9 */
    memset(bData, 0x42, 256);
    bData[0] = 0x30;
    bData[255] = 0x39;
    nDataLen = 256;
    /* B3FEFD820E1B0F3096CDEEA2C134CF10162D39EC88F0BACB8539E3EA41DF701D355CC1A73CEBDF02B694BA465107789FCC4BB29A126AD338F3B55DF0CE751D0C */
    memcpy(bSign, 
           "\xB3\xFE\xFD\x82\x0E\x1B\x0F\x30\x96\xCD\xEE\xA2\xC1\x34\xCF\x10" \
           "\x16\x2D\x39\xEC\x88\xF0\xBA\xCB\x85\x39\xE3\xEA\x41\xDF\x70\x1D" \
           "\x35\x5C\xC1\xA7\x3C\xEB\xDF\x02\xB6\x94\xBA\x46\x51\x07\x78\x9F" \
           "\xCC\x4B\xB2\x9A\x12\x6A\xD3\x38\xF3\xB5\x5D\xF0\xCE\x75\x1D\x0C" \
           , 64);
    nSignLen = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nEcMark = %d\n", nEcMark);
    printf("[IN ]nPad = %d\n", nPad);
    DspHex("[IN ]bPK =", bPK, nPKLen);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, nDataLen);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    DspHex("[IN ]bSign =", bSign, nSignLen);
    printf("[IN ]nSignLen = %d\n", nSignLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEccVerify(nSock, nEcMark, nPad, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "SM2签名验证，256字节数据，测试失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EccVerify_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nEcMark;
	  int  nPad;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nEcMark = 17;
    nPad = 0;
    /* PK 04695BC3452B4DF79EBA188AC61C51A33A243F497A4D76D272F3771827BD80A944E1DA925A4853860EE0D883F3A2F43AA8F265C95F60A9102A7495551034D6C021 */
    /* SK 7BAD1BC2D566F4AC0F93E830E2E9A1E756C063E94FBDEABF68A29DD720B44B30 */
    memcpy(bPK,
           "\x04\x69\x5B\xC3\x45\x2B\x4D\xF7\x9E\xBA\x18\x8A\xC6\x1C\x51\xA3" \
           "\x3A\x24\x3F\x49\x7A\x4D\x76\xD2\x72\xF3\x77\x18\x27\xBD\x80\xA9" \
           "\x44\xE1\xDA\x92\x5A\x48\x53\x86\x0E\xE0\xD8\x83\xF3\xA2\xF4\x3A" \
           "\xA8\xF2\x65\xC9\x5F\x60\xA9\x10\x2A\x74\x95\x55\x10\x34\xD6\xC0" \
           "\x21" \
           , 65);
    nPKLen = 65;
    /* 0BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB9 */
    memset(bData, 0x42, 256);
    bData[0] = 0x30;
    bData[255] = 0x39;
    nDataLen = 256;
    /* B3FEFD820E1B0F3096CDEEA2C134CF10162D39EC88F0BACB8539E3EA41DF701D355CC1A73CEBDF02B694BA465107789FCC4BB29A126AD338F3B55DF0CE751D0D */
    memcpy(bSign, 
           "\xB3\xFE\xFD\x82\x0E\x1B\x0F\x30\x96\xCD\xEE\xA2\xC1\x34\xCF\x10" \
           "\x16\x2D\x39\xEC\x88\xF0\xBA\xCB\x85\x39\xE3\xEA\x41\xDF\x70\x1D" \
           "\x35\x5C\xC1\xA7\x3C\xEB\xDF\x02\xB6\x94\xBA\x46\x51\x07\x78\x9F" \
           "\xCC\x4B\xB2\x9A\x12\x6A\xD3\x38\xF3\xB5\x5D\xF0\xCE\x75\x1D\x0D" \
           , 64);
    nSignLen = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nEcMark = %d\n", nEcMark);
    printf("[IN ]nPad = %d\n", nPad);
    DspHex("[IN ]bPK =", bPK, nPKLen);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, nDataLen);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    DspHex("[IN ]bSign =", bSign, nSignLen);
    printf("[IN ]nSignLen = %d\n", nSignLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEccVerify(nSock, nEcMark, nPad, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 21, "SM2签名验证，256字节数据，测试失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void EccVerify_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nEcMark;
	  int  nPad;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bData);
    bufclr(bSign);

    nEcMark = 17;
    nPad = 0;
    /* PK 0400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 */
    /* SK 0000000000000000000000000000000000000000000000000000000000000000 */
    memcpy(bPK,
           "\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" \
           "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" \
           "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" \
           "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" \
           "\x00" \
           , 65);
    nPKLen = 65;
    /* 0BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB9 */
    memset(bData, 0x42, 256);
    bData[0] = 0x30;
    bData[255] = 0x39;
    nDataLen = 256;
    /* S   B5099BA83EA9CFFFA44E999925768B648025FE21AF8A6FD30D98210A9AB08F30FDBA1FA2C36D222871D0336548D303857D5E8FB5753D5447BC5815E3CA1B7B1B */
    /* F   FBE187E1F0F40AD75C6D3D8573E968EA59F9601018C29460CF8C800D07C65129A74AE8BCA6859ECB4B7EE524410EDA6B8AE9ACBE6EB6B8EAD64EFA9E73410581 */
    memcpy(bSign, 
           "\xB5\x09\x9B\xA8\x3E\xA9\xCF\xFF\xA4\x4E\x99\x99\x25\x76\x8B\x64" \
           "\x80\x25\xFE\x21\xAF\x8A\x6F\xD3\x0D\x98\x21\x0A\x9A\xB0\x8F\x30" \
           "\xFD\xBA\x1F\xA2\xC3\x6D\x22\x28\x71\xD0\x33\x65\x48\xD3\x03\x85" \
           "\x7D\x5E\x8F\xB5\x75\x3D\x54\x47\xBC\x58\x15\xE3\xCA\x1B\x7B\x1B" \
           , 64);
    nSignLen = 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nEcMark = %d\n", nEcMark);
    printf("[IN ]nPad = %d\n", nPad);
    DspHex("[IN ]bPK =", bPK, nPKLen);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bData =", bData, nDataLen);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    DspHex("[IN ]bSign =", bSign, nSignLen);
    printf("[IN ]nSignLen = %d\n", nSignLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEccVerify(nSock, nEcMark, nPad, bPK, nPKLen, bData, \
                           nDataLen, bSign, nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "SM2签名验证，无效公钥，测试失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void Sm4Calc_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nFlag;
    int  nMode;
    BYTE bKey[32];
    BYTE bIndata[4104];
	  BYTE bIV[16];
    int  nDataLen;
    BYTE bOutData[4104];
    BYTE bOutDataExp[4104];

    bufclr(bKey);
    bufclr(bIndata);
    bufclr(bIV);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nMode = 0;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
                 16);
    memset(bIndata, 0x42, 1024);
    bIndata[0] = 0x30;
    bIndata[1023] = 0x39;
    nDataLen = 1024;
    memcpy(bOutDataExp, \
           "\x88\xC7\x7F\x3A\xA6\xA2\x9E\x4E" \
           "\x20\x31\x65\x7E\x38\x48\xA4\x63" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\x82\x2A\xD6\xA1\x4D\x0A\x65\x31" \
           "\x38\x12\x07\x8F\x05\x77\x25\xB5" \
           , 1024);

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nFlag          = %d\n", nFlag);
    printf("[IN ]nMode          = %d\n", nMode);
    DspHex("[IN ]bKey           =", bKey, 16);
    DspHex("[IN ]bIndata        =", bIndata, nDataLen);
    printf("[IN ]nDataLen       = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPISm4Calc(nSock, nFlag, nMode, bKey, bIndata, nDataLen, bIV, bOutData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "SM4-ECB加密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bOutData, bOutDataExp, nDataLen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void Sm4Calc_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nFlag;
    int  nMode;
    BYTE bKey[32];
    BYTE bIndata[4104];
	  BYTE bIV[16];
    int  nDataLen;
    BYTE bOutData[4104];
    BYTE bOutDataExp[4104];

    bufclr(bKey);
    bufclr(bIndata);
    bufclr(bIV);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nMode = 1;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
                 16);
    memset(bIndata, 0x42, 1024);
    bIndata[0] = 0x30;
    bIndata[1023] = 0x39;
    nDataLen = 1024;
    memcpy(bOutDataExp, \
           "\x88\xC7\x7F\x3A\xA6\xA2\x9E\x4E" \
           "\x20\x31\x65\x7E\x38\x48\xA4\x63" \
           "\xE2\x63\xA2\xB0\xC4\x3E\xF4\xEF" \
           "\xA9\xF9\xC5\xA7\x22\xA1\x57\xA0" \
           "\xEB\x60\xD8\xE5\xFC\x56\xBA\xB8" \
           "\x36\x62\x0A\x7F\xF5\x40\x46\x68" \
           "\x4A\x30\x05\x1C\xD5\x0E\xED\x3F" \
           "\xD3\xBD\x4A\x15\x93\x03\x7D\xC2" \
           "\xA1\x2F\x65\xB1\x42\x17\xB0\xC9" \
           "\xB7\xAF\x3A\x84\xA1\xEF\xFE\xC1" \
           "\x58\x35\x31\xAF\x36\xC2\x7C\x4F" \
           "\x27\xA7\x8F\x8A\x1A\x1E\x81\x2C" \
           "\x71\x21\x48\xE0\xD5\x77\x7F\xDD" \
           "\x10\x79\x04\xEB\x14\x4F\xF7\x87" \
           "\xA4\xD1\xA7\xA2\xEB\x7D\x21\x59" \
           "\xF6\x43\xED\xB9\x48\x03\xE1\x99" \
           "\x9B\x3C\xEE\xFA\x60\x0C\x3F\xCE" \
           "\x30\x7B\xD3\x34\x51\xEC\xB8\xEC" \
           "\xCF\xB2\x04\x11\xF8\x98\xEE\x79" \
           "\x62\x83\xC7\x81\x98\xF6\x77\xA6" \
           "\x2E\x3C\x4C\x82\xA0\xF0\x43\x2B" \
           "\x7C\x05\x86\x1B\x0E\xAC\xC2\x09" \
           "\xF8\x5C\x35\x31\x53\x51\x2B\x96" \
           "\x6A\x8D\x16\x6C\xB9\xA1\xB9\x0A" \
           "\x55\x67\x53\xC6\x32\xF5\x3B\xAD" \
           "\x6B\xBF\x0B\x2C\xE0\xA8\xC9\x20" \
           "\xC2\xE6\xA0\x2D\x9B\x41\x8D\xFB" \
           "\x6E\x56\x31\xD7\xA4\xA1\xE6\xAC" \
           "\xF5\xCA\xC1\x74\xAC\x35\x2D\x2E" \
           "\x5E\xC3\x27\xFC\xBD\xAB\x82\x43" \
           "\xC3\x5D\x52\x86\x9E\x9C\x4F\xDB" \
           "\xD0\xB8\x55\x13\x12\x0F\xC6\x67" \
           "\xC1\xAE\x21\xD4\x78\x79\xA0\xB5" \
           "\x66\x2F\x10\x6A\x67\xA7\x22\x2C" \
           "\xDA\xE0\x32\xB7\x86\x15\x5B\x26" \
           "\x29\xB9\x60\x6A\xDC\xF6\x73\x9E" \
           "\xD7\xED\xA7\x8C\xCC\x83\x53\x24" \
           "\xDE\x45\xCD\x5E\x68\x7A\x7C\xFF" \
           "\x24\xA2\x16\xC9\x58\xD5\x28\x70" \
           "\xC8\x23\xDA\xE5\xE3\x95\x93\xB2" \
           "\xD3\x73\x13\x68\x87\x0F\xB1\x42" \
           "\x14\x37\xD3\x5F\xB0\x2D\xAA\x45" \
           "\xF5\xE4\x1D\xF8\xCD\x89\x5F\x17" \
           "\xB6\x78\x4F\x21\xA3\x2D\x77\xCF" \
           "\x98\xDE\x44\x0C\x0E\xDE\x01\x75" \
           "\xF2\x4F\x40\x09\xDB\xAD\xF0\xEE" \
           "\x5B\xCF\x40\x35\x6C\xEA\xCD\x29" \
           "\x35\xAE\x6C\x9E\xB4\x96\x4D\xC4" \
           "\x8E\x6D\x17\xC3\xB2\x8A\xDF\xC8" \
           "\x03\x91\xF3\x90\xCE\x34\xA0\x90" \
           "\xDF\x8F\x56\x3A\x9A\x3D\x02\x17" \
           "\xD8\xA1\xFD\x00\xED\x36\x13\xD5" \
           "\xA2\xA1\x53\x7E\x42\x3D\x24\x80" \
           "\xA3\xF7\x84\x84\x3C\x22\x2B\x15" \
           "\x7A\xAA\xA2\x87\x89\xEA\xB3\x02" \
           "\xE5\xFC\x6C\xE0\xB9\x46\x29\xCA" \
           "\x82\x94\x19\x44\x1B\xA5\x9C\x71" \
           "\xC9\xFA\xF7\x3A\xEA\x06\xCA\xC2" \
           "\x59\x1A\xB5\xD9\x9D\x4B\x75\x67" \
           "\x43\x82\x86\x63\x38\xDB\xD4\x75" \
           "\x0E\x88\x0E\x6E\x6F\xAC\xDA\xA3" \
           "\x8E\x67\xB0\xAF\x45\x4F\x6C\xC1" \
           "\xFF\xC2\xFA\x1A\xAC\xBF\xDA\x0B" \
           "\x7B\x0B\xC2\x99\x46\x61\x03\x3B" \
           "\x2B\x6A\x46\xDC\xF6\x70\x66\x14" \
           "\xFE\x2D\x94\xAE\x88\xCA\x85\x49" \
           "\xD5\x10\xB8\xA0\xBC\x87\x61\x83" \
           "\x3E\x14\xCD\xE1\xCD\x7C\x01\x27" \
           "\x58\xC5\x0C\x1D\x4B\xF8\xD9\xDC" \
           "\x73\xB4\x54\xEE\xDE\x31\x5D\x4B" \
           "\xBD\x77\xF7\xAE\xCD\x71\x43\xD0" \
           "\x63\x85\x29\x51\x0D\x85\xA9\x13" \
           "\x0F\x1E\xDF\xF6\x69\x32\x61\x8E" \
           "\x8E\xB3\xEF\x7A\xE7\x9A\x11\xD2" \
           "\x1C\x1B\x9F\xBD\xEA\x54\xD7\x22" \
           "\x8A\x84\x5F\x43\x7D\x66\x6E\x8D" \
           "\xB3\xCF\xE7\x0A\x38\x3F\xFD\x0C" \
           "\xC7\x0A\x2B\x42\xBD\xC1\xFD\xBE" \
           "\x69\xAF\x10\x06\xA6\x29\xA9\x9F" \
           "\xB1\x00\x95\x56\x9E\x15\x6C\xDD" \
           "\xBD\xED\xA4\x86\x34\xE3\x0B\x4F" \
           "\x3D\xD5\x57\xE0\x87\x4C\x9C\x27" \
           "\x83\xE2\xF7\x92\x6D\xC8\x3A\x0D" \
           "\x60\xC5\x58\x1F\x68\x2A\xFE\x56" \
           "\xE4\x26\x03\xCF\x98\x18\xC8\x79" \
           "\xF2\x4D\x51\x59\xAA\xAC\xB1\x8C" \
           "\x1C\x04\xD6\xD1\x0E\x15\xA0\xBC" \
           "\x09\x75\x2B\x23\x59\xDC\x67\x68" \
           "\x60\x0A\x2D\x34\x00\x5C\x91\x20" \
           "\xB2\xCC\xDC\x00\x63\xA1\x4D\x38" \
           "\x74\x1E\xD2\x8B\xAB\x86\xA6\x86" \
           "\xB8\x9C\xC1\x0D\x95\xCB\x24\x1E" \
           "\xBB\x95\xC3\x97\xB6\xCC\xB3\xA7" \
           "\x1E\x22\xF3\xBA\xB3\x18\x02\xED" \
           "\x0D\xB6\x38\x30\x5D\x8B\x40\x31" \
           "\x00\xBF\x25\x23\x43\x07\x8F\x14" \
           "\x7D\xE3\x5D\xD3\xD2\xFC\x94\xED" \
           "\xC0\xA0\xD9\x1B\x1F\x6F\x6A\x32" \
           "\x4F\x78\x05\x98\xF2\xA2\x03\xDA" \
           "\x0E\x44\x05\x35\xA0\x55\x26\x35" \
           "\x07\xEB\xD0\xDC\xCD\x71\xE5\x3F" \
           "\x9A\xC6\xFF\x60\x94\x4B\x54\xD6" \
           "\x10\xE2\x9A\x97\x4A\xED\x8D\xE7" \
           "\x7C\x0C\x17\x80\x7D\x4E\x22\x36" \
           "\xEF\xF1\x3D\x91\x7B\x02\xA6\x37" \
           "\x14\x28\xB5\x91\x67\xD4\x0F\xDB" \
           "\x1C\x24\x09\x00\xD5\x3A\xB5\x15" \
           "\xF9\x50\xB2\x8B\x55\x48\x57\x1C" \
           "\xF6\x40\x5A\xA2\x9A\xDB\xDF\xDE" \
           "\x0F\x39\x5E\x0E\x30\x7B\x74\x2A" \
           "\x61\xD4\x64\x39\x65\xB4\x14\x5B" \
           "\xB9\xD4\x2D\xBB\x74\x8B\xA9\x79" \
           "\xB9\x05\x3B\x22\xC1\x35\xDC\xB2" \
           "\xD4\xDC\x2A\xB4\xFA\x6F\x33\x00" \
           "\xB9\x0A\xEF\x63\x98\x5D\x19\xD5" \
           "\xC7\x5B\xBB\x6D\x65\x1F\x41\x19" \
           "\xC3\xD1\xC1\xA4\x21\x08\xED\x00" \
           "\xC0\x02\x1B\xDD\x0F\xEE\x3F\x60" \
           "\xE9\x2E\x1B\xF6\xBF\x12\xF3\xFB" \
           "\xDA\x05\x2E\x40\x4C\x77\x30\x8D" \
           "\xF0\x46\xEC\xAE\x05\x18\x2D\x7F" \
           "\x04\x97\xAD\x9F\x5C\x62\x6D\x90" \
           "\x96\xFA\x38\x1F\x31\x86\x2F\xCC" \
           "\xB0\x98\x50\x98\x82\xA0\x3F\x52" \
           "\xEF\xC6\x23\x7F\xCB\xD4\xEB\xC1" \
           "\x6C\xF0\xA8\xED\xE1\xC0\x58\x86" \
           "\x51\x4D\x12\xE7\xA8\x70\xDD\xAF" \
           "\x4F\x65\x7E\x20\xCC\x16\x7C\xF1" \
           , 1024);
    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nFlag          = %d\n", nFlag);
    printf("[IN ]nMode          = %d\n", nMode);
    DspHex("[IN ]bKey           =", bKey, 16);
    DspHex("[IN ]bIndata        =", bIndata, nDataLen);
    printf("[IN ]nDataLen       = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPISm4Calc(nSock, nFlag, nMode, bKey, bIndata, nDataLen, bIV, bOutData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "SM4-CBC加密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bOutData, bOutDataExp, nDataLen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void Sm4Calc_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nFlag;
    int  nMode;
    BYTE bKey[32];
    BYTE bInData[4104];
	  BYTE bIV[16];
    int  nDataLen;
    BYTE bOutData[4104];
    BYTE bOutDataExp[4104];

    bufclr(bKey);
    bufclr(bInData);
    bufclr(bIV);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nMode = 0;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
                 16);
    nDataLen = 1024;
    memcpy(bInData, \
           "\x88\xC7\x7F\x3A\xA6\xA2\x9E\x4E" \
           "\x20\x31\x65\x7E\x38\x48\xA4\x63" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\x82\x2A\xD6\xA1\x4D\x0A\x65\x31" \
           "\x38\x12\x07\x8F\x05\x77\x25\xB5" \
           , 1024);
    memset(bOutDataExp, 0x42, 1024);
    bOutDataExp[0] = 0x30;
    bOutDataExp[1023] = 0x39;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nFlag          = %d\n", nFlag);
    printf("[IN ]nMode          = %d\n", nMode);
    DspHex("[IN ]bKey           =", bKey, 16);
    DspHex("[IN ]bInData        =", bInData, nDataLen);
    printf("[IN ]nDataLen       = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPISm4Calc(nSock, nFlag, nMode, bKey, bInData, nDataLen, bIV, bOutData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "SM4-ECB解密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bOutData, bOutDataExp, nDataLen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void Sm4Calc_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nFlag;
    int  nMode;
    BYTE bKey[32];
    BYTE bInData[4104];
	  BYTE bIV[16];
    int  nDataLen;
    BYTE bOutData[4104];
    BYTE bOutDataExp[4104];

    bufclr(bKey);
    bufclr(bInData);
    bufclr(bIV);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nMode = 1;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
                 16);
    nDataLen = 1024;
    memcpy(bInData, \
           "\x88\xC7\x7F\x3A\xA6\xA2\x9E\x4E" \
           "\x20\x31\x65\x7E\x38\x48\xA4\x63" \
           "\xE2\x63\xA2\xB0\xC4\x3E\xF4\xEF" \
           "\xA9\xF9\xC5\xA7\x22\xA1\x57\xA0" \
           "\xEB\x60\xD8\xE5\xFC\x56\xBA\xB8" \
           "\x36\x62\x0A\x7F\xF5\x40\x46\x68" \
           "\x4A\x30\x05\x1C\xD5\x0E\xED\x3F" \
           "\xD3\xBD\x4A\x15\x93\x03\x7D\xC2" \
           "\xA1\x2F\x65\xB1\x42\x17\xB0\xC9" \
           "\xB7\xAF\x3A\x84\xA1\xEF\xFE\xC1" \
           "\x58\x35\x31\xAF\x36\xC2\x7C\x4F" \
           "\x27\xA7\x8F\x8A\x1A\x1E\x81\x2C" \
           "\x71\x21\x48\xE0\xD5\x77\x7F\xDD" \
           "\x10\x79\x04\xEB\x14\x4F\xF7\x87" \
           "\xA4\xD1\xA7\xA2\xEB\x7D\x21\x59" \
           "\xF6\x43\xED\xB9\x48\x03\xE1\x99" \
           "\x9B\x3C\xEE\xFA\x60\x0C\x3F\xCE" \
           "\x30\x7B\xD3\x34\x51\xEC\xB8\xEC" \
           "\xCF\xB2\x04\x11\xF8\x98\xEE\x79" \
           "\x62\x83\xC7\x81\x98\xF6\x77\xA6" \
           "\x2E\x3C\x4C\x82\xA0\xF0\x43\x2B" \
           "\x7C\x05\x86\x1B\x0E\xAC\xC2\x09" \
           "\xF8\x5C\x35\x31\x53\x51\x2B\x96" \
           "\x6A\x8D\x16\x6C\xB9\xA1\xB9\x0A" \
           "\x55\x67\x53\xC6\x32\xF5\x3B\xAD" \
           "\x6B\xBF\x0B\x2C\xE0\xA8\xC9\x20" \
           "\xC2\xE6\xA0\x2D\x9B\x41\x8D\xFB" \
           "\x6E\x56\x31\xD7\xA4\xA1\xE6\xAC" \
           "\xF5\xCA\xC1\x74\xAC\x35\x2D\x2E" \
           "\x5E\xC3\x27\xFC\xBD\xAB\x82\x43" \
           "\xC3\x5D\x52\x86\x9E\x9C\x4F\xDB" \
           "\xD0\xB8\x55\x13\x12\x0F\xC6\x67" \
           "\xC1\xAE\x21\xD4\x78\x79\xA0\xB5" \
           "\x66\x2F\x10\x6A\x67\xA7\x22\x2C" \
           "\xDA\xE0\x32\xB7\x86\x15\x5B\x26" \
           "\x29\xB9\x60\x6A\xDC\xF6\x73\x9E" \
           "\xD7\xED\xA7\x8C\xCC\x83\x53\x24" \
           "\xDE\x45\xCD\x5E\x68\x7A\x7C\xFF" \
           "\x24\xA2\x16\xC9\x58\xD5\x28\x70" \
           "\xC8\x23\xDA\xE5\xE3\x95\x93\xB2" \
           "\xD3\x73\x13\x68\x87\x0F\xB1\x42" \
           "\x14\x37\xD3\x5F\xB0\x2D\xAA\x45" \
           "\xF5\xE4\x1D\xF8\xCD\x89\x5F\x17" \
           "\xB6\x78\x4F\x21\xA3\x2D\x77\xCF" \
           "\x98\xDE\x44\x0C\x0E\xDE\x01\x75" \
           "\xF2\x4F\x40\x09\xDB\xAD\xF0\xEE" \
           "\x5B\xCF\x40\x35\x6C\xEA\xCD\x29" \
           "\x35\xAE\x6C\x9E\xB4\x96\x4D\xC4" \
           "\x8E\x6D\x17\xC3\xB2\x8A\xDF\xC8" \
           "\x03\x91\xF3\x90\xCE\x34\xA0\x90" \
           "\xDF\x8F\x56\x3A\x9A\x3D\x02\x17" \
           "\xD8\xA1\xFD\x00\xED\x36\x13\xD5" \
           "\xA2\xA1\x53\x7E\x42\x3D\x24\x80" \
           "\xA3\xF7\x84\x84\x3C\x22\x2B\x15" \
           "\x7A\xAA\xA2\x87\x89\xEA\xB3\x02" \
           "\xE5\xFC\x6C\xE0\xB9\x46\x29\xCA" \
           "\x82\x94\x19\x44\x1B\xA5\x9C\x71" \
           "\xC9\xFA\xF7\x3A\xEA\x06\xCA\xC2" \
           "\x59\x1A\xB5\xD9\x9D\x4B\x75\x67" \
           "\x43\x82\x86\x63\x38\xDB\xD4\x75" \
           "\x0E\x88\x0E\x6E\x6F\xAC\xDA\xA3" \
           "\x8E\x67\xB0\xAF\x45\x4F\x6C\xC1" \
           "\xFF\xC2\xFA\x1A\xAC\xBF\xDA\x0B" \
           "\x7B\x0B\xC2\x99\x46\x61\x03\x3B" \
           "\x2B\x6A\x46\xDC\xF6\x70\x66\x14" \
           "\xFE\x2D\x94\xAE\x88\xCA\x85\x49" \
           "\xD5\x10\xB8\xA0\xBC\x87\x61\x83" \
           "\x3E\x14\xCD\xE1\xCD\x7C\x01\x27" \
           "\x58\xC5\x0C\x1D\x4B\xF8\xD9\xDC" \
           "\x73\xB4\x54\xEE\xDE\x31\x5D\x4B" \
           "\xBD\x77\xF7\xAE\xCD\x71\x43\xD0" \
           "\x63\x85\x29\x51\x0D\x85\xA9\x13" \
           "\x0F\x1E\xDF\xF6\x69\x32\x61\x8E" \
           "\x8E\xB3\xEF\x7A\xE7\x9A\x11\xD2" \
           "\x1C\x1B\x9F\xBD\xEA\x54\xD7\x22" \
           "\x8A\x84\x5F\x43\x7D\x66\x6E\x8D" \
           "\xB3\xCF\xE7\x0A\x38\x3F\xFD\x0C" \
           "\xC7\x0A\x2B\x42\xBD\xC1\xFD\xBE" \
           "\x69\xAF\x10\x06\xA6\x29\xA9\x9F" \
           "\xB1\x00\x95\x56\x9E\x15\x6C\xDD" \
           "\xBD\xED\xA4\x86\x34\xE3\x0B\x4F" \
           "\x3D\xD5\x57\xE0\x87\x4C\x9C\x27" \
           "\x83\xE2\xF7\x92\x6D\xC8\x3A\x0D" \
           "\x60\xC5\x58\x1F\x68\x2A\xFE\x56" \
           "\xE4\x26\x03\xCF\x98\x18\xC8\x79" \
           "\xF2\x4D\x51\x59\xAA\xAC\xB1\x8C" \
           "\x1C\x04\xD6\xD1\x0E\x15\xA0\xBC" \
           "\x09\x75\x2B\x23\x59\xDC\x67\x68" \
           "\x60\x0A\x2D\x34\x00\x5C\x91\x20" \
           "\xB2\xCC\xDC\x00\x63\xA1\x4D\x38" \
           "\x74\x1E\xD2\x8B\xAB\x86\xA6\x86" \
           "\xB8\x9C\xC1\x0D\x95\xCB\x24\x1E" \
           "\xBB\x95\xC3\x97\xB6\xCC\xB3\xA7" \
           "\x1E\x22\xF3\xBA\xB3\x18\x02\xED" \
           "\x0D\xB6\x38\x30\x5D\x8B\x40\x31" \
           "\x00\xBF\x25\x23\x43\x07\x8F\x14" \
           "\x7D\xE3\x5D\xD3\xD2\xFC\x94\xED" \
           "\xC0\xA0\xD9\x1B\x1F\x6F\x6A\x32" \
           "\x4F\x78\x05\x98\xF2\xA2\x03\xDA" \
           "\x0E\x44\x05\x35\xA0\x55\x26\x35" \
           "\x07\xEB\xD0\xDC\xCD\x71\xE5\x3F" \
           "\x9A\xC6\xFF\x60\x94\x4B\x54\xD6" \
           "\x10\xE2\x9A\x97\x4A\xED\x8D\xE7" \
           "\x7C\x0C\x17\x80\x7D\x4E\x22\x36" \
           "\xEF\xF1\x3D\x91\x7B\x02\xA6\x37" \
           "\x14\x28\xB5\x91\x67\xD4\x0F\xDB" \
           "\x1C\x24\x09\x00\xD5\x3A\xB5\x15" \
           "\xF9\x50\xB2\x8B\x55\x48\x57\x1C" \
           "\xF6\x40\x5A\xA2\x9A\xDB\xDF\xDE" \
           "\x0F\x39\x5E\x0E\x30\x7B\x74\x2A" \
           "\x61\xD4\x64\x39\x65\xB4\x14\x5B" \
           "\xB9\xD4\x2D\xBB\x74\x8B\xA9\x79" \
           "\xB9\x05\x3B\x22\xC1\x35\xDC\xB2" \
           "\xD4\xDC\x2A\xB4\xFA\x6F\x33\x00" \
           "\xB9\x0A\xEF\x63\x98\x5D\x19\xD5" \
           "\xC7\x5B\xBB\x6D\x65\x1F\x41\x19" \
           "\xC3\xD1\xC1\xA4\x21\x08\xED\x00" \
           "\xC0\x02\x1B\xDD\x0F\xEE\x3F\x60" \
           "\xE9\x2E\x1B\xF6\xBF\x12\xF3\xFB" \
           "\xDA\x05\x2E\x40\x4C\x77\x30\x8D" \
           "\xF0\x46\xEC\xAE\x05\x18\x2D\x7F" \
           "\x04\x97\xAD\x9F\x5C\x62\x6D\x90" \
           "\x96\xFA\x38\x1F\x31\x86\x2F\xCC" \
           "\xB0\x98\x50\x98\x82\xA0\x3F\x52" \
           "\xEF\xC6\x23\x7F\xCB\xD4\xEB\xC1" \
           "\x6C\xF0\xA8\xED\xE1\xC0\x58\x86" \
           "\x51\x4D\x12\xE7\xA8\x70\xDD\xAF" \
           "\x4F\x65\x7E\x20\xCC\x16\x7C\xF1" \
           , 1024);
    memset(bOutDataExp, 0x42, 1024);
    bOutDataExp[0] = 0x30;
    bOutDataExp[1023] = 0x39;
    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nFlag          = %d\n", nFlag);
    printf("[IN ]nMode          = %d\n", nMode);
    DspHex("[IN ]bKey           =", bKey, 16);
    DspHex("[IN ]bInData        =", bInData, nDataLen);
    printf("[IN ]nDataLen       = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPISm4Calc(nSock, nFlag, nMode, bKey, bInData, nDataLen, bIV, bOutData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "SM4-CBC解密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bOutData, bOutDataExp, nDataLen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void Sm4Calc_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nFlag;
    int  nMode;
    BYTE bKey[32];
    BYTE bInData[4104];
	  BYTE bIV[16];
    int  nDataLen;
    BYTE bOutData[4104];
    BYTE bOutDataExp[4104];

    bufclr(bKey);
    bufclr(bInData);
    bufclr(bIV);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 2;
    nMode = 1;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
                 16);
    nDataLen = 1024;
    memcpy(bInData, \
           "\x88\xC7\x7F\x3A\xA6\xA2\x9E\x4E" \
           "\x20\x31\x65\x7E\x38\x48\xA4\x63" \
           "\xE2\x63\xA2\xB0\xC4\x3E\xF4\xEF" \
           "\xA9\xF9\xC5\xA7\x22\xA1\x57\xA0" \
           "\xEB\x60\xD8\xE5\xFC\x56\xBA\xB8" \
           "\x36\x62\x0A\x7F\xF5\x40\x46\x68" \
           "\x4A\x30\x05\x1C\xD5\x0E\xED\x3F" \
           "\xD3\xBD\x4A\x15\x93\x03\x7D\xC2" \
           "\xA1\x2F\x65\xB1\x42\x17\xB0\xC9" \
           "\xB7\xAF\x3A\x84\xA1\xEF\xFE\xC1" \
           "\x58\x35\x31\xAF\x36\xC2\x7C\x4F" \
           "\x27\xA7\x8F\x8A\x1A\x1E\x81\x2C" \
           "\x71\x21\x48\xE0\xD5\x77\x7F\xDD" \
           "\x10\x79\x04\xEB\x14\x4F\xF7\x87" \
           "\xA4\xD1\xA7\xA2\xEB\x7D\x21\x59" \
           "\xF6\x43\xED\xB9\x48\x03\xE1\x99" \
           "\x9B\x3C\xEE\xFA\x60\x0C\x3F\xCE" \
           "\x30\x7B\xD3\x34\x51\xEC\xB8\xEC" \
           "\xCF\xB2\x04\x11\xF8\x98\xEE\x79" \
           "\x62\x83\xC7\x81\x98\xF6\x77\xA6" \
           "\x2E\x3C\x4C\x82\xA0\xF0\x43\x2B" \
           "\x7C\x05\x86\x1B\x0E\xAC\xC2\x09" \
           "\xF8\x5C\x35\x31\x53\x51\x2B\x96" \
           "\x6A\x8D\x16\x6C\xB9\xA1\xB9\x0A" \
           "\x55\x67\x53\xC6\x32\xF5\x3B\xAD" \
           "\x6B\xBF\x0B\x2C\xE0\xA8\xC9\x20" \
           "\xC2\xE6\xA0\x2D\x9B\x41\x8D\xFB" \
           "\x6E\x56\x31\xD7\xA4\xA1\xE6\xAC" \
           "\xF5\xCA\xC1\x74\xAC\x35\x2D\x2E" \
           "\x5E\xC3\x27\xFC\xBD\xAB\x82\x43" \
           "\xC3\x5D\x52\x86\x9E\x9C\x4F\xDB" \
           "\xD0\xB8\x55\x13\x12\x0F\xC6\x67" \
           "\xC1\xAE\x21\xD4\x78\x79\xA0\xB5" \
           "\x66\x2F\x10\x6A\x67\xA7\x22\x2C" \
           "\xDA\xE0\x32\xB7\x86\x15\x5B\x26" \
           "\x29\xB9\x60\x6A\xDC\xF6\x73\x9E" \
           "\xD7\xED\xA7\x8C\xCC\x83\x53\x24" \
           "\xDE\x45\xCD\x5E\x68\x7A\x7C\xFF" \
           "\x24\xA2\x16\xC9\x58\xD5\x28\x70" \
           "\xC8\x23\xDA\xE5\xE3\x95\x93\xB2" \
           "\xD3\x73\x13\x68\x87\x0F\xB1\x42" \
           "\x14\x37\xD3\x5F\xB0\x2D\xAA\x45" \
           "\xF5\xE4\x1D\xF8\xCD\x89\x5F\x17" \
           "\xB6\x78\x4F\x21\xA3\x2D\x77\xCF" \
           "\x98\xDE\x44\x0C\x0E\xDE\x01\x75" \
           "\xF2\x4F\x40\x09\xDB\xAD\xF0\xEE" \
           "\x5B\xCF\x40\x35\x6C\xEA\xCD\x29" \
           "\x35\xAE\x6C\x9E\xB4\x96\x4D\xC4" \
           "\x8E\x6D\x17\xC3\xB2\x8A\xDF\xC8" \
           "\x03\x91\xF3\x90\xCE\x34\xA0\x90" \
           "\xDF\x8F\x56\x3A\x9A\x3D\x02\x17" \
           "\xD8\xA1\xFD\x00\xED\x36\x13\xD5" \
           "\xA2\xA1\x53\x7E\x42\x3D\x24\x80" \
           "\xA3\xF7\x84\x84\x3C\x22\x2B\x15" \
           "\x7A\xAA\xA2\x87\x89\xEA\xB3\x02" \
           "\xE5\xFC\x6C\xE0\xB9\x46\x29\xCA" \
           "\x82\x94\x19\x44\x1B\xA5\x9C\x71" \
           "\xC9\xFA\xF7\x3A\xEA\x06\xCA\xC2" \
           "\x59\x1A\xB5\xD9\x9D\x4B\x75\x67" \
           "\x43\x82\x86\x63\x38\xDB\xD4\x75" \
           "\x0E\x88\x0E\x6E\x6F\xAC\xDA\xA3" \
           "\x8E\x67\xB0\xAF\x45\x4F\x6C\xC1" \
           "\xFF\xC2\xFA\x1A\xAC\xBF\xDA\x0B" \
           "\x7B\x0B\xC2\x99\x46\x61\x03\x3B" \
           "\x2B\x6A\x46\xDC\xF6\x70\x66\x14" \
           "\xFE\x2D\x94\xAE\x88\xCA\x85\x49" \
           "\xD5\x10\xB8\xA0\xBC\x87\x61\x83" \
           "\x3E\x14\xCD\xE1\xCD\x7C\x01\x27" \
           "\x58\xC5\x0C\x1D\x4B\xF8\xD9\xDC" \
           "\x73\xB4\x54\xEE\xDE\x31\x5D\x4B" \
           "\xBD\x77\xF7\xAE\xCD\x71\x43\xD0" \
           "\x63\x85\x29\x51\x0D\x85\xA9\x13" \
           "\x0F\x1E\xDF\xF6\x69\x32\x61\x8E" \
           "\x8E\xB3\xEF\x7A\xE7\x9A\x11\xD2" \
           "\x1C\x1B\x9F\xBD\xEA\x54\xD7\x22" \
           "\x8A\x84\x5F\x43\x7D\x66\x6E\x8D" \
           "\xB3\xCF\xE7\x0A\x38\x3F\xFD\x0C" \
           "\xC7\x0A\x2B\x42\xBD\xC1\xFD\xBE" \
           "\x69\xAF\x10\x06\xA6\x29\xA9\x9F" \
           "\xB1\x00\x95\x56\x9E\x15\x6C\xDD" \
           "\xBD\xED\xA4\x86\x34\xE3\x0B\x4F" \
           "\x3D\xD5\x57\xE0\x87\x4C\x9C\x27" \
           "\x83\xE2\xF7\x92\x6D\xC8\x3A\x0D" \
           "\x60\xC5\x58\x1F\x68\x2A\xFE\x56" \
           "\xE4\x26\x03\xCF\x98\x18\xC8\x79" \
           "\xF2\x4D\x51\x59\xAA\xAC\xB1\x8C" \
           "\x1C\x04\xD6\xD1\x0E\x15\xA0\xBC" \
           "\x09\x75\x2B\x23\x59\xDC\x67\x68" \
           "\x60\x0A\x2D\x34\x00\x5C\x91\x20" \
           "\xB2\xCC\xDC\x00\x63\xA1\x4D\x38" \
           "\x74\x1E\xD2\x8B\xAB\x86\xA6\x86" \
           "\xB8\x9C\xC1\x0D\x95\xCB\x24\x1E" \
           "\xBB\x95\xC3\x97\xB6\xCC\xB3\xA7" \
           "\x1E\x22\xF3\xBA\xB3\x18\x02\xED" \
           "\x0D\xB6\x38\x30\x5D\x8B\x40\x31" \
           "\x00\xBF\x25\x23\x43\x07\x8F\x14" \
           "\x7D\xE3\x5D\xD3\xD2\xFC\x94\xED" \
           "\xC0\xA0\xD9\x1B\x1F\x6F\x6A\x32" \
           "\x4F\x78\x05\x98\xF2\xA2\x03\xDA" \
           "\x0E\x44\x05\x35\xA0\x55\x26\x35" \
           "\x07\xEB\xD0\xDC\xCD\x71\xE5\x3F" \
           "\x9A\xC6\xFF\x60\x94\x4B\x54\xD6" \
           "\x10\xE2\x9A\x97\x4A\xED\x8D\xE7" \
           "\x7C\x0C\x17\x80\x7D\x4E\x22\x36" \
           "\xEF\xF1\x3D\x91\x7B\x02\xA6\x37" \
           "\x14\x28\xB5\x91\x67\xD4\x0F\xDB" \
           "\x1C\x24\x09\x00\xD5\x3A\xB5\x15" \
           "\xF9\x50\xB2\x8B\x55\x48\x57\x1C" \
           "\xF6\x40\x5A\xA2\x9A\xDB\xDF\xDE" \
           "\x0F\x39\x5E\x0E\x30\x7B\x74\x2A" \
           "\x61\xD4\x64\x39\x65\xB4\x14\x5B" \
           "\xB9\xD4\x2D\xBB\x74\x8B\xA9\x79" \
           "\xB9\x05\x3B\x22\xC1\x35\xDC\xB2" \
           "\xD4\xDC\x2A\xB4\xFA\x6F\x33\x00" \
           "\xB9\x0A\xEF\x63\x98\x5D\x19\xD5" \
           "\xC7\x5B\xBB\x6D\x65\x1F\x41\x19" \
           "\xC3\xD1\xC1\xA4\x21\x08\xED\x00" \
           "\xC0\x02\x1B\xDD\x0F\xEE\x3F\x60" \
           "\xE9\x2E\x1B\xF6\xBF\x12\xF3\xFB" \
           "\xDA\x05\x2E\x40\x4C\x77\x30\x8D" \
           "\xF0\x46\xEC\xAE\x05\x18\x2D\x7F" \
           "\x04\x97\xAD\x9F\x5C\x62\x6D\x90" \
           "\x96\xFA\x38\x1F\x31\x86\x2F\xCC" \
           "\xB0\x98\x50\x98\x82\xA0\x3F\x52" \
           "\xEF\xC6\x23\x7F\xCB\xD4\xEB\xC1" \
           "\x6C\xF0\xA8\xED\xE1\xC0\x58\x86" \
           "\x51\x4D\x12\xE7\xA8\x70\xDD\xAF" \
           "\x4F\x65\x7E\x20\xCC\x16\x7C\xF1" \
           , 1024);
    memset(bOutDataExp, 0x42, 1024);
    bOutDataExp[0] = 0x30;
    bOutDataExp[1023] = 0x39;
    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nFlag          = %d\n", nFlag);
    printf("[IN ]nMode          = %d\n", nMode);
    DspHex("[IN ]bKey           =", bKey, 16);
    DspHex("[IN ]bInData        =", bInData, nDataLen);
    printf("[IN ]nDataLen       = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPISm4Calc(nSock, nFlag, nMode, bKey, bInData, nDataLen, bIV, bOutData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "SM4加解密，异常加解密标识2，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void Sm4Calc_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nFlag;
    int  nMode;
    BYTE bKey[32];
    BYTE bInData[4104];
	  BYTE bIV[16];
    int  nDataLen;
    BYTE bOutData[4104];
    BYTE bOutDataExp[4104];

    bufclr(bKey);
    bufclr(bInData);
    bufclr(bIV);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nMode = 0;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKey, "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
                 "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A",\
                 16);
    nDataLen = 1016;
    memcpy(bInData, \
           "\x88\xC7\x7F\x3A\xA6\xA2\x9E\x4E" \
           "\x20\x31\x65\x7E\x38\x48\xA4\x63" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\xC5\xF8\x11\xF6\x08\xBB\xF5\x4F" \
           "\x66\x9F\x9D\x1D\xE7\xC1\xE6\xE5" \
           "\x82\x2A\xD6\xA1\x4D\x0A\x65\x31" \
           "\x38\x12\x07\x8F\x05\x77\x25\xB5" \
           , 1024);
    memset(bOutDataExp, 0x42, 1024);
    bOutDataExp[0] = 0x30;
    bOutDataExp[1023] = 0x39;

    XXX_INPUT_XXX
    printf("[IN ]nSock          = %d\n", nSock);
    printf("[IN ]nFlag          = %d\n", nFlag);
    printf("[IN ]nMode          = %d\n", nMode);
    DspHex("[IN ]bKey           =", bKey, 16);
    DspHex("[IN ]bInData        =", bInData, nDataLen);
    printf("[IN ]nDataLen       = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPISm4Calc(nSock, nFlag, nMode, bKey, bInData, nDataLen, bIV, bOutData);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "SM4加密，数据长度不是16倍数，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

/*
 *  修改SM2公钥加密的公钥数据格式。头"04"去掉 ，由65变64
*/
void Sm2PKTransOutof_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nEcMark;
	  int  nPadMode;
	  BYTE bPK[512];
	  int  nPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByPKExp[260];
	  int  nKeyByPKLenExp;

    bufclr(bPK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByPKExp);
    
    /* PK = 04695BC3452B4DF79EBA188AC61C51A33A243F497A4D76D272F3771827BD80A944E1DA925A4853860EE0D883F3A2F43AA8F265C95F60A9102A7495551034D6C021 */
    /* SK = 7BAD1BC2D566F4AC0F93E830E2E9A1E756C063E94FBDEABF68A29DD720B44B30 */
    /* SKByHMK = C3E09939138691AA609031AADA1231495D23D89AA32D7B3E4C4D10D4631308FD6BCB2CCA658BFD78 */
    /* Key = 0123456789ABCDEFFEDCBA9876543210 */
    /* KeyByPK = 893173F4DDD695C466F8280251FE097E887C5CC4EC3E86EB101CA4A66BD5A8D54FE9280137C999CB0C9057A272723B1C6308F6FB0890549F65B1A470BF85607A19E2CE8F74298F29D0B3A6B624D5254807024B2449EC52AED4B6AC2B42186C73B38E848D5819ABFD8075A4D4A16502E5 */
    /* KeyByHMK = A2C0B0F8F7F5EE21FB5C6AEBE714E53A */

    nEcMark = 17;
    nPadMode = 0;
    memcpy(bPK,
           "\x69\x5B\xC3\x45\x2B\x4D\xF7\x9E\xBA\x18\x8A\xC6\x1C\x51\xA3" \
           "\x3A\x24\x3F\x49\x7A\x4D\x76\xD2\x72\xF3\x77\x18\x27\xBD\x80\xA9" \
           "\x44\xE1\xDA\x92\x5A\x48\x53\x86\x0E\xE0\xD8\x83\xF3\xA2\xF4\x3A" \
           "\xA8\xF2\x65\xC9\x5F\x60\xA9\x10\x2A\x74\x95\x55\x10\x34\xD6\xC0" \
           "\x21" \
           , 64);
    nPKLen = 64;
    memcpy(bKeyByHMK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
           , 16);
    nKeyLen = 16;
    memcpy(bKeyByPKExp,
           "\x89\x31\x73\xF4\xDD\xD6\x95\xC4\x66\xF8\x28\x02\x51\xFE\x09\x7E" \
           "\x88\x7C\x5C\xC4\xEC\x3E\x86\xEB\x10\x1C\xA4\xA6\x6B\xD5\xA8\xD5" \
           "\x4F\xE9\x28\x01\x37\xC9\x99\xCB\x0C\x90\x57\xA2\x72\x72\x3B\x1C" \
           "\x63\x08\xF6\xFB\x08\x90\x54\x9F\x65\xB1\xA4\x70\xBF\x85\x60\x7A" \
           "\x19\xE2\xCE\x8F\x74\x29\x8F\x29\xD0\xB3\xA6\xB6\x24\xD5\x25\x48" \
           "\x07\x02\x4B\x24\x49\xEC\x52\xAE\xD4\xB6\xAC\x2B\x42\x18\x6C\x73" \
           "\xB3\x8E\x84\x8D\x58\x19\xAB\xFD\x80\x75\xA4\xD4\xA1\x65\x02\xE5" \
           , 112);
    nKeyByPKLenExp = 112;

    XXX_INPUT_XXX
    printf("[IN ]nSock       = %d\n", nSock);
    printf("[IN ]nEcMark = %d\n", nEcMark);
    printf("[IN ]nPadMode    = %d\n", nPadMode);
    DspHexExt("[IN ]bPK         =", bPK, nPKLen);
    printf("[IN ]nPKLen      = %d\n", nPKLen);
    DspHexExt("[IN ]bKeyByHMK   =", bKeyByHMK, nKeyLen);
    printf("[IN ]nKeyLen     = %d\n", nKeyLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPISm2PKTransOutof(nSock, nEcMark, nPadMode, bPK, nPKLen, bKeyByHMK, \
                                nKeyLen, bKeyByPK, &nKeyByPKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "SM2公钥转加密，无填充，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    printf("[OUT]nKeyByPKLen = %d\n", nKeyByPKLen);
    DspHexExt("[OUT]bKeyByPK    =", bKeyByPK, nKeyByPKLen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}


void TransKeyIntoSK_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bSK[2400];
	  int  nSKLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyByHMKLen;
	  BYTE bKeyByHMKExp[260];
	  int  nKeyByHMKLenExp;

    bufclr(bSK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByHMKExp);

    nPadMode = 1;
    /* PK = 30660261009C393A6CD065344C79A3D2087AD31C8672A9EF5335AD9AD8648DEE83C1D9D500EACCFC88E3A9F9267F3E81F7476659FCF411A8CE626B425F5CD60536887E4ABD49490DA29648BF5475BCC01ECE75AE38A1202029ED963354A1C659CBED5E3DE9020103 */
    /* SK = 308201C90201000261009C393A6CD065344C79A3D2087AD31C8672A9EF5335AD9AD8648DEE83C1D9D500EACCFC88E3A9F9267F3E81F7476659FCF411A8CE626B425F5CD60536887E4ABD49490DA29648BF5475BCC01ECE75AE38A1202029ED963354A1C659CBED5E3DE90201030260682626F33598CD885117E15AFC8CBDAEF71BF4E223C911E5985E9F02813BE355F1DDFDB097C6A619AA29ABFA2F9991524292912755A8728959A284DB0985EA019BF00CBCFF7EACA787B79480A26D4F36845F44D479FE9C009DED27016C7E3903023100CF17A0ED49B8F9404CCAFB5CEDE74E7D2A85A0DA433070FF3F0BEF10B35A0FCFCC4E57C75D0CAE23456E91AD671DAB7B023100C11E2E2618359D51099742910C4E1D3DB4DB59ACD3DA4B59EB1D724D2777A7970E42E123D98B9B306F740D9C63833CEB0231008A0FC09E3125FB803331FCE89E9A345371AE6B3C2CCAF5FF7F5D4A0B223C0A8A88343A84E8B31EC22E49B6739A13C7A702310080BEC96EBACE68E0B10F81B60834137E78923BC88D3C323BF213A188C4FA6FBA0981EB6D3BB267759FA2B3BD97ACD34702301A9FF3F129DD2ED273AAF1727B08123C4A31C3D5BFAE54593A0B778F112EC7046196319FD2FC0F46B4E764BF8C413EAA */
    /* SKByHMK = A06B2552408C86E5B14F586D4B65E875B20A22CCBD44B1E3C1F8B2DBF20E6F52A595C8C9D2BF6F98317DB30978D62132C43855831F04C43F14A32368565A37B3D46E6B38E97BC07CB18FD8D998575D4F62DF2EC5FABF41C7BC3DC0F83B3B57C75C56FC1566549BCBC1C863A14E349837D92A7754C1C4B216E84ED7BA17B47E86F461FB2AABD83C92527A4B55260862F29C22B0F732A28A2DB288DA4D4C178C6BEEAE5150350E238515B1818DAFBA411E7C295B6D93D21D7F6C1BF33229A8AFC77121D7EF1CDD12E877531B6F12D510948F6AEF34188FAEA9478216343E43FC76DF870F2CFC07234C2FD5E643C420357828D474E6F1214F33C8E0F77A160BAF9758EBD31A404B289EB72BFDA38DB5A709FFD01BE679F2316876F19743CC8A5C1F300EAC73213B6F36397FD8EB6CA1D71FE5CB22F9A1D404AE314972DD48208D877A82A6C6B2926AF7D837F2932EA67DC5F9A0DCA2B590A11E4F58003E5F3F921C7CA4A8097FD7F5F684EFBC13DE2D87E22CEB2A04A1B5F2C849943945F50F575FDC0F5724F0F05E2BF042F63618C4A09D667C5BA44100C0E498C2AF42F08B1EAB77CF8BABF332EF537D0C076DAF0D03F4AE084C7A01DEB5B145EB212FB60B472DBBAC7C9330459EAB85642B8FEAC161A0 */
    /* Key = 0123456789ABCDEFFEDCBA9876543210 */
    /* KeyByPK = 52C2DFC88A8207AD162F3D87D4760CAB930D4DA4D56357CA382A790E5DF64C4F0BBC3275D5B2F8B5188B2BE153A393AED57C8BF3B4D1A0D487AF4B32157754AA311A92BAE7042E0C53D17FA2ED6FDE532861E490C0B06A7D6F3B8283E42A0892 */
    /* KeyByHMK = A2C0B0F8F7F5EE21FB5C6AEBE714E53A */

    memcpy(bSK,
           "\xA0\x6B\x25\x52\x40\x8C\x86\xE5" \
           "\xB1\x4F\x58\x6D\x4B\x65\xE8\x75" \
           "\xB2\x0A\x22\xCC\xBD\x44\xB1\xE3" \
           "\xC1\xF8\xB2\xDB\xF2\x0E\x6F\x52" \
           "\xA5\x95\xC8\xC9\xD2\xBF\x6F\x98" \
           "\x31\x7D\xB3\x09\x78\xD6\x21\x32" \
           "\xC4\x38\x55\x83\x1F\x04\xC4\x3F" \
           "\x14\xA3\x23\x68\x56\x5A\x37\xB3" \
           "\xD4\x6E\x6B\x38\xE9\x7B\xC0\x7C" \
           "\xB1\x8F\xD8\xD9\x98\x57\x5D\x4F" \
           "\x62\xDF\x2E\xC5\xFA\xBF\x41\xC7" \
           "\xBC\x3D\xC0\xF8\x3B\x3B\x57\xC7" \
           "\x5C\x56\xFC\x15\x66\x54\x9B\xCB" \
           "\xC1\xC8\x63\xA1\x4E\x34\x98\x37" \
           "\xD9\x2A\x77\x54\xC1\xC4\xB2\x16" \
           "\xE8\x4E\xD7\xBA\x17\xB4\x7E\x86" \
           "\xF4\x61\xFB\x2A\xAB\xD8\x3C\x92" \
           "\x52\x7A\x4B\x55\x26\x08\x62\xF2" \
           "\x9C\x22\xB0\xF7\x32\xA2\x8A\x2D" \
           "\xB2\x88\xDA\x4D\x4C\x17\x8C\x6B" \
           "\xEE\xAE\x51\x50\x35\x0E\x23\x85" \
           "\x15\xB1\x81\x8D\xAF\xBA\x41\x1E" \
           "\x7C\x29\x5B\x6D\x93\xD2\x1D\x7F" \
           "\x6C\x1B\xF3\x32\x29\xA8\xAF\xC7" \
           "\x71\x21\xD7\xEF\x1C\xDD\x12\xE8" \
           "\x77\x53\x1B\x6F\x12\xD5\x10\x94" \
           "\x8F\x6A\xEF\x34\x18\x8F\xAE\xA9" \
           "\x47\x82\x16\x34\x3E\x43\xFC\x76" \
           "\xDF\x87\x0F\x2C\xFC\x07\x23\x4C" \
           "\x2F\xD5\xE6\x43\xC4\x20\x35\x78" \
           "\x28\xD4\x74\xE6\xF1\x21\x4F\x33" \
           "\xC8\xE0\xF7\x7A\x16\x0B\xAF\x97" \
           "\x58\xEB\xD3\x1A\x40\x4B\x28\x9E" \
           "\xB7\x2B\xFD\xA3\x8D\xB5\xA7\x09" \
           "\xFF\xD0\x1B\xE6\x79\xF2\x31\x68" \
           "\x76\xF1\x97\x43\xCC\x8A\x5C\x1F" \
           "\x30\x0E\xAC\x73\x21\x3B\x6F\x36" \
           "\x39\x7F\xD8\xEB\x6C\xA1\xD7\x1F" \
           "\xE5\xCB\x22\xF9\xA1\xD4\x04\xAE" \
           "\x31\x49\x72\xDD\x48\x20\x8D\x87" \
           "\x7A\x82\xA6\xC6\xB2\x92\x6A\xF7" \
           "\xD8\x37\xF2\x93\x2E\xA6\x7D\xC5" \
           "\xF9\xA0\xDC\xA2\xB5\x90\xA1\x1E" \
           "\x4F\x58\x00\x3E\x5F\x3F\x92\x1C" \
           "\x7C\xA4\xA8\x09\x7F\xD7\xF5\xF6" \
           "\x84\xEF\xBC\x13\xDE\x2D\x87\xE2" \
           "\x2C\xEB\x2A\x04\xA1\xB5\xF2\xC8" \
           "\x49\x94\x39\x45\xF5\x0F\x57\x5F" \
           "\xDC\x0F\x57\x24\xF0\xF0\x5E\x2B" \
           "\xF0\x42\xF6\x36\x18\xC4\xA0\x9D" \
           "\x66\x7C\x5B\xA4\x41\x00\xC0\xE4" \
           "\x98\xC2\xAF\x42\xF0\x8B\x1E\xAB" \
           "\x77\xCF\x8B\xAB\xF3\x32\xEF\x53" \
           "\x7D\x0C\x07\x6D\xAF\x0D\x03\xF4" \
           "\xAE\x08\x4C\x7A\x01\xDE\xB5\xB1" \
           "\x45\xEB\x21\x2F\xB6\x0B\x47\x2D" \
           "\xBB\xAC\x7C\x93\x30\x45\x9E\xAB" \
           "\x85\x64\x2B\x8F\xEA\xC1\x61\xA0" \
           , 464);
    nSKLen = 464;

    memcpy(bKeyByPK,
           "\x52\xC2\xDF\xC8\x8A\x82\x07\xAD" \
           "\x16\x2F\x3D\x87\xD4\x76\x0C\xAB" \
           "\x93\x0D\x4D\xA4\xD5\x63\x57\xCA" \
           "\x38\x2A\x79\x0E\x5D\xF6\x4C\x4F" \
           "\x0B\xBC\x32\x75\xD5\xB2\xF8\xB5" \
           "\x18\x8B\x2B\xE1\x53\xA3\x93\xAE" \
           "\xD5\x7C\x8B\xF3\xB4\xD1\xA0\xD4" \
           "\x87\xAF\x4B\x32\x15\x77\x54\xAA" \
           "\x31\x1A\x92\xBA\xE7\x04\x2E\x0C" \
           "\x53\xD1\x7F\xA2\xED\x6F\xDE\x53" \
           "\x28\x61\xE4\x90\xC0\xB0\x6A\x7D" \
           "\x6F\x3B\x82\x83\xE4\x2A\x08\x92" \
           , 96);
    nKeyByPKLen = 96;

    memcpy(bKeyByHMKExp,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
           "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
           , 16);
    nKeyByHMKLenExp = 16;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, nSKLen);
    printf("[IN ]nPKLen = %d\n", nSKLen);
    DspHex("[IN ]bKeyByPK =", bKeyByPK, nKeyByPKLen);
    printf("[IN ]nKeyByPKLen = %d\n", nKeyByPKLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyIntoSK(nSock, nPadMode, bSK, nSKLen, bKeyByPK, \
                                nKeyByPKLen, bKeyByHMK, &nKeyByHMKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "私钥转加密，RSA-768，PKCS#1，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKeyByHMK    =", bKeyByHMK, nKeyByHMKLen);
    DspHex("[OUT]bKeyByHMKExp =", bKeyByHMKExp, nKeyByHMKLenExp);
    ASSERT_OUT_HEX(bKeyByHMK, bKeyByHMKExp, nKeyByHMKLenExp);
    ASSERT_OUT(nKeyByHMKLen, nKeyByHMKLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyIntoSK_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bSK[2400];
	  int  nSKLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyByHMKLen;
	  BYTE bKeyByHMKExp[260];
	  int  nKeyByHMKLenExp;

    bufclr(bSK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByHMKExp);

    nPadMode = 1;
    /* PK = 30818702818100ACEAA1BBBD502B57DDC03818E5E868138DB129C4CAC53B2429A8D9032BD2E9685F1825BDD4D6264A1259427C72D40A53BD684B4C2983F4DCF5B0B26A6E95FC5FC35BF7F58AEBB21DFB205864D76F8890D454DA513A24F815FCFA17B28CB2C0B32F4C71833FDF2790B5AA0AF59F66940A3E42D660D9F146F6653ABAC64D253B83020103 */
    /* SK = 3082025C02010002818100ACEAA1BBBD502B57DDC03818E5E868138DB129C4CAC53B2429A8D9032BD2E9685F1825BDD4D6264A1259427C72D40A53BD684B4C2983F4DCF5B0B26A6E95FC5FC35BF7F58AEBB21DFB205864D76F8890D454DA513A24F815FCFA17B28CB2C0B32F4C71833FDF2790B5AA0AF59F66940A3E42D660D9F146F6653ABAC64D253B830201030281807347167D28E01CE53E802565EE9AF00D0920C68331D8D2181BC5E6021D37464594BAC3D3E3396EDC0C3B81A84C8D5C37D39ADCDD7102A33DF92076F19F0EA83EBEC5FC716034AB19DC2D5E86F0F110AFF6DD5498E83423CD8B13A8C538191F8DF4A15B0DCE91A0310689C8A93452ACCC915F94C03ABE967B9339FAD7C413775B024100DBD9641882E2C40D5F0C2BD4B90DE22881A1E19FC917F87802732AEB197E911BBF9C9FF9B42BA26F8D9C02D4EE95BE9D1EC8EE98C0F8A17B7913665A1AD6DDFF024100C9599932F7B9ED69D1D01EC5B4F80D606066F9CC14BEC9E9A9E96F9F9F0E804280BDC8F4D5D914D79E3F5B22E254D23A456A88A7C0DAC3C18F505C288C312A7D0241009290ED65AC972D5E3F5D728DD0B3EC1B0116966A860FFAFAAC4CC747665460BD2A686AA6781D16F50912AC8DF463D468BF309F1080A5C0FCFB62443C11E493FF024100863BBB774FD148F1368ABF2E78A55E404044A6880DD4869BC69B9FBFBF5F002C55D3DB4DE3E60DE5142A3CC1EC388C26D8F1B06FD5E72D2BB4E03D705D761C53024100B1BACE868528C216A7B4EB92F1F22091899D2E15E58C0BEA76BDA5474742869DA76013D77CEFF155518D148BAC268728E1DD10FF58BE23A8F464E786B7267DE3 */
    /* SKByHMK = 3BD4505C7E8610CE9A5ACB256CCD0B9E3ED481CAD63DB6E7D3CFABA8FC3F18A507C8A8B552806C2A4F436B94F1C59CA85944E9FD3EAEAE79AFE08C25B2512AE88D3A606B27DAAF57D77DB58344369B62EB673A9F59945B28832833A6A1ED26BCB3CF31FF3BB644B6C54F7427339C37CA9BC60DE40AD13A522F2470F6F9CEBBB3581DD31C73725391123F7E29DC08A70B7E9CA482A6F2D1551F658314D7A3A6D8F86455E6EC4809486F1E14DBE12407DD04D3B26911FFDDC122676150E216A4672F1346E7958708E02D01F65A7213AA4FA723E1E72A6C6FD018AD2B01286E95C0B808B69F98B4FFF0428B9C360484949C8035A4AB1EFFC414E2803E3A604C3C288DB9C796CAAB95DEED8A210F24C52125E907EDA3DB36D0C72418C36452201E45387BDC0852690E358DFEC3D28516BBA41E7B7C7FDE14CEA99505584DF8053655EF50A761E6C5C5EF79C3D91F29EB486055AC91DC751FFDE561130A1FD5D006D25FDFAA6A12593224B72A22C6FCB24C9C1A12D3CC12EEFEE1DBD5F930EED7EF2FF93778C9048369CB8ED40A63CA246B8D5CD94B2836E594E478CF7BEFE5CF1AD7FEE1332B8AC42206AE422292D93572E0308AFBA0E8B6117828B710EC3A4EFCDDAA1511AFB1EB416B00C53510A2933AC283D2119B6791403015348A9003CE8A43B3DB8D078E3C371377FB411E902D29FE81CA13171E32EC60D1E0BB810E992CE55B898031D7032DF7328303A2D5B323E988311251BF185C258B2D39243C8D84591AA93D82E37919BBBF5B4DD9199F5F9ACF43407C2FC4171C4A781BD6561C14A70F6983DB5AC1531322717ABE22B2234F1E9DE332AA1BE2E85CBFB68C346E6E4E6BCB2CCA658BFD78 */
    /* Key = 0123456789ABCDEFFEDCBA9876543210 */
    /* KeyByPK = 8BB63AA0D69C0D57E9A3D7EE9A9F7E32C1B3E4A9DF6DD7A4510FD5DE5885A03950ECA08CC4430D9D867ED30778DA255ECA8E4C6011D4196263BC53BF75D33190D6FD7D2712B3A9E1D8F666AD6836F8E68CCA4AD55DD7EA26DDD5065927A44A7B0CEDD80656E3E19A245D853856FA04C0C417B29131FA1AC352E1D0FAFFA13F74 */
    /* KeyByHMK = A2C0B0F8F7F5EE21FB5C6AEBE714E53A */

    memcpy(bSK,
           "\x3B\xD4\x50\x5C\x7E\x86\x10\xCE" \
           "\x9A\x5A\xCB\x25\x6C\xCD\x0B\x9E" \
           "\x3E\xD4\x81\xCA\xD6\x3D\xB6\xE7" \
           "\xD3\xCF\xAB\xA8\xFC\x3F\x18\xA5" \
           "\x07\xC8\xA8\xB5\x52\x80\x6C\x2A" \
           "\x4F\x43\x6B\x94\xF1\xC5\x9C\xA8" \
           "\x59\x44\xE9\xFD\x3E\xAE\xAE\x79" \
           "\xAF\xE0\x8C\x25\xB2\x51\x2A\xE8" \
           "\x8D\x3A\x60\x6B\x27\xDA\xAF\x57" \
           "\xD7\x7D\xB5\x83\x44\x36\x9B\x62" \
           "\xEB\x67\x3A\x9F\x59\x94\x5B\x28" \
           "\x83\x28\x33\xA6\xA1\xED\x26\xBC" \
           "\xB3\xCF\x31\xFF\x3B\xB6\x44\xB6" \
           "\xC5\x4F\x74\x27\x33\x9C\x37\xCA" \
           "\x9B\xC6\x0D\xE4\x0A\xD1\x3A\x52" \
           "\x2F\x24\x70\xF6\xF9\xCE\xBB\xB3" \
           "\x58\x1D\xD3\x1C\x73\x72\x53\x91" \
           "\x12\x3F\x7E\x29\xDC\x08\xA7\x0B" \
           "\x7E\x9C\xA4\x82\xA6\xF2\xD1\x55" \
           "\x1F\x65\x83\x14\xD7\xA3\xA6\xD8" \
           "\xF8\x64\x55\xE6\xEC\x48\x09\x48" \
           "\x6F\x1E\x14\xDB\xE1\x24\x07\xDD" \
           "\x04\xD3\xB2\x69\x11\xFF\xDD\xC1" \
           "\x22\x67\x61\x50\xE2\x16\xA4\x67" \
           "\x2F\x13\x46\xE7\x95\x87\x08\xE0" \
           "\x2D\x01\xF6\x5A\x72\x13\xAA\x4F" \
           "\xA7\x23\xE1\xE7\x2A\x6C\x6F\xD0" \
           "\x18\xAD\x2B\x01\x28\x6E\x95\xC0" \
           "\xB8\x08\xB6\x9F\x98\xB4\xFF\xF0" \
           "\x42\x8B\x9C\x36\x04\x84\x94\x9C" \
           "\x80\x35\xA4\xAB\x1E\xFF\xC4\x14" \
           "\xE2\x80\x3E\x3A\x60\x4C\x3C\x28" \
           "\x8D\xB9\xC7\x96\xCA\xAB\x95\xDE" \
           "\xED\x8A\x21\x0F\x24\xC5\x21\x25" \
           "\xE9\x07\xED\xA3\xDB\x36\xD0\xC7" \
           "\x24\x18\xC3\x64\x52\x20\x1E\x45" \
           "\x38\x7B\xDC\x08\x52\x69\x0E\x35" \
           "\x8D\xFE\xC3\xD2\x85\x16\xBB\xA4" \
           "\x1E\x7B\x7C\x7F\xDE\x14\xCE\xA9" \
           "\x95\x05\x58\x4D\xF8\x05\x36\x55" \
           "\xEF\x50\xA7\x61\xE6\xC5\xC5\xEF" \
           "\x79\xC3\xD9\x1F\x29\xEB\x48\x60" \
           "\x55\xAC\x91\xDC\x75\x1F\xFD\xE5" \
           "\x61\x13\x0A\x1F\xD5\xD0\x06\xD2" \
           "\x5F\xDF\xAA\x6A\x12\x59\x32\x24" \
           "\xB7\x2A\x22\xC6\xFC\xB2\x4C\x9C" \
           "\x1A\x12\xD3\xCC\x12\xEE\xFE\xE1" \
           "\xDB\xD5\xF9\x30\xEE\xD7\xEF\x2F" \
           "\xF9\x37\x78\xC9\x04\x83\x69\xCB" \
           "\x8E\xD4\x0A\x63\xCA\x24\x6B\x8D" \
           "\x5C\xD9\x4B\x28\x36\xE5\x94\xE4" \
           "\x78\xCF\x7B\xEF\xE5\xCF\x1A\xD7" \
           "\xFE\xE1\x33\x2B\x8A\xC4\x22\x06" \
           "\xAE\x42\x22\x92\xD9\x35\x72\xE0" \
           "\x30\x8A\xFB\xA0\xE8\xB6\x11\x78" \
           "\x28\xB7\x10\xEC\x3A\x4E\xFC\xDD" \
           "\xAA\x15\x11\xAF\xB1\xEB\x41\x6B" \
           "\x00\xC5\x35\x10\xA2\x93\x3A\xC2" \
           "\x83\xD2\x11\x9B\x67\x91\x40\x30" \
           "\x15\x34\x8A\x90\x03\xCE\x8A\x43" \
           "\xB3\xDB\x8D\x07\x8E\x3C\x37\x13" \
           "\x77\xFB\x41\x1E\x90\x2D\x29\xFE" \
           "\x81\xCA\x13\x17\x1E\x32\xEC\x60" \
           "\xD1\xE0\xBB\x81\x0E\x99\x2C\xE5" \
           "\x5B\x89\x80\x31\xD7\x03\x2D\xF7" \
           "\x32\x83\x03\xA2\xD5\xB3\x23\xE9" \
           "\x88\x31\x12\x51\xBF\x18\x5C\x25" \
           "\x8B\x2D\x39\x24\x3C\x8D\x84\x59" \
           "\x1A\xA9\x3D\x82\xE3\x79\x19\xBB" \
           "\xBF\x5B\x4D\xD9\x19\x9F\x5F\x9A" \
           "\xCF\x43\x40\x7C\x2F\xC4\x17\x1C" \
           "\x4A\x78\x1B\xD6\x56\x1C\x14\xA7" \
           "\x0F\x69\x83\xDB\x5A\xC1\x53\x13" \
           "\x22\x71\x7A\xBE\x22\xB2\x23\x4F" \
           "\x1E\x9D\xE3\x32\xAA\x1B\xE2\xE8" \
           "\x5C\xBF\xB6\x8C\x34\x6E\x6E\x4E" \
           "\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78" \
           , 616);
    nSKLen = 616;

    memcpy(bKeyByPK,
           "\x8B\xB6\x3A\xA0\xD6\x9C\x0D\x57" \
           "\xE9\xA3\xD7\xEE\x9A\x9F\x7E\x32" \
           "\xC1\xB3\xE4\xA9\xDF\x6D\xD7\xA4" \
           "\x51\x0F\xD5\xDE\x58\x85\xA0\x39" \
           "\x50\xEC\xA0\x8C\xC4\x43\x0D\x9D" \
           "\x86\x7E\xD3\x07\x78\xDA\x25\x5E" \
           "\xCA\x8E\x4C\x60\x11\xD4\x19\x62" \
           "\x63\xBC\x53\xBF\x75\xD3\x31\x90" \
           "\xD6\xFD\x7D\x27\x12\xB3\xA9\xE1" \
           "\xD8\xF6\x66\xAD\x68\x36\xF8\xE6" \
           "\x8C\xCA\x4A\xD5\x5D\xD7\xEA\x26" \
           "\xDD\xD5\x06\x59\x27\xA4\x4A\x7B" \
           "\x0C\xED\xD8\x06\x56\xE3\xE1\x9A" \
           "\x24\x5D\x85\x38\x56\xFA\x04\xC0" \
           "\xC4\x17\xB2\x91\x31\xFA\x1A\xC3" \
           "\x52\xE1\xD0\xFA\xFF\xA1\x3F\x74" \
           , 128);
    nKeyByPKLen = 128;

    memcpy(bKeyByHMKExp,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
           "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
           , 16);
    nKeyByHMKLenExp = 16;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, nSKLen);
    printf("[IN ]nPKLen = %d\n", nSKLen);
    DspHex("[IN ]bKeyByPK =", bKeyByPK, nKeyByPKLen);
    printf("[IN ]nKeyByPKLen = %d\n", nKeyByPKLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyIntoSK(nSock, nPadMode, bSK, nSKLen, bKeyByPK, \
                                nKeyByPKLen, bKeyByHMK, &nKeyByHMKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "私钥转加密，RSA-1024，PKCS#1，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKeyByHMK    =", bKeyByHMK, nKeyByHMKLen);
    DspHex("[OUT]bKeyByHMKExp =", bKeyByHMKExp, nKeyByHMKLenExp);
    ASSERT_OUT_HEX(bKeyByHMK, bKeyByHMKExp, nKeyByHMKLenExp);
    ASSERT_OUT(nKeyByHMKLen, nKeyByHMKLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyIntoSK_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bSK[2400];
	  int  nSKLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyByHMKLen;
	  BYTE bKeyByHMKExp[260];
	  int  nKeyByHMKLenExp;

    bufclr(bSK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByHMKExp);

    nPadMode = 1;
    /* PK = 30819702819100D9045225540C7545A0E293192E64ED68119B30FF725BE1F78D9859B734BE26EF4206C90CD52D0DE85D5DE3C6D73979A10F523E4EF855AE1D9E5D97BA9655786ADF394701CBD81F5304C51305F75524E89F66F32AF1119B65E7AE6A7B69211F51B7347E73D84E7FD4503DA37E01CD1071AAAB6A546A7EEEFB36704E296BAA920C5736466CBEA2F18CFB36DD6832B52BED020103 */
    /* SK = 308202A402010002819100D9045225540C7545A0E293192E64ED68119B30FF725BE1F78D9859B734BE26EF4206C90CD52D0DE85D5DE3C6D73979A10F523E4EF855AE1D9E5D97BA9655786ADF394701CBD81F5304C51305F75524E89F66F32AF1119B65E7AE6A7B69211F51B7347E73D84E7FD4503DA37E01CD1071AAAB6A546A7EEEFB36704E296BAA920C5736466CBEA2F18CFB36DD6832B52BED0201030281910090AD8C18E2B2F8D915EC6210C9989E45611220AA4C3D414FB3BAE67A23296F4A2C0486088E1E09459393ED2F3A2651160A36D434A58E7413BEE90FD1B98E50473F7B84ABDD3ABF8B72BDC61930F32CB8BB82572A6C2FD7C7BCBB4072AC83288E7F8E3154CFE43E131500BC5A09EF6D4A2620A4D9F504A5CD75F7F412373A671ACECF6F91C2AB68A8821E0F1474743B6B024900FD8179D82AD728AD6D759FCE4A7830D9E694F325C962B6634967E366CB0A58EE787713659D268FAA8BF6F48A84C44AAAFFA58DC6CE35358FC1685E7765063311FB2944965CA0E749024900DB26F0080311392618ADD09D0451A6E0660096A99CF9AC18AE77510DD56DC9C93845759155BF5CD7E5837E82F633AB9C05D6D2474A9DC1D45F96C09AB59BA17E3CE082332765EB85024900A900FBE571E4C5C8F3A3BFDEDC50209144634CC3DB97244230EFECEF3206E5F4504F6243BE19B51C5D4F4DB1ADD831C75519092F3423790A80F03EFA43597761521B830EE86B44DB0249009219F55AACB6261965C935BE02E119EAEEAB0F1BBDFBC810744F8B5E8E493130D02E4E60E3D4E88FEE57A9ACA422726803E48C2F8713D68D950F2B11CE67C0FED34056CCC4EE9D0302483A4BA1F3F8124C6B3505F3C5CD15B8146F962FE5BE03F4ACD400E8956A91EEF957B2A96D7C07559EE4A78150D1772394794853B54A459F60FE1CA28F3CAB9CE834EC088496F6CEE8 */
    /* SKByHMK = 81F889B5B4830C7B8749C14955199BE14C3062E771BFE5035880F9914E3224AAAE6BEB8CE1A7D6066F563D8B236368EF497F0938E2CF3421508D2E7A0439087BF7E0142D3EA31112EC4B1CA0FBBC97451A7542950A417A2DB8B37804C7C50DD257ACA2879CB9CD4AA581BE8A7A22A83716F7B4C0CDEC8C7D154DC7A0365BD906BD9D2A986E3809018901D3FD77C3C3072E07957D4040E32B3DB5886B961ADA4954CEAD111FB886393E745389955C4B2BCDB31944F0509D0C18206F3CD329D4CC7EFFD40BF47F342C6FF1EC9DDBB7D3AD88F2B3D4DEFE56215F9229B3ADF2EA51E0CF66D57D526A1713C7F5149A8121699D0479721FF88D39587BBA5DDCF164110347000D7535F9587CA6A687746112AEA126C14628ACC00E26F2573BB2BCAEB010B439CC3E4EB2FFBDCE7768DF8DB06CCEE4358C7B0AB5C0131297DD56F61A29B4258F318C74DD59D9C76E264BBFCB19EE5BEF70BAB8EB0B6E17BD61ED32DB419B5B91F3A9E95B3C9485449C7E2501EBE52BFCBC95C5053904929F1DB02486B537CF980A26CD3E88482546DE35A36EB932FE682EBA48F35DBCC32CE2E82FF93DBBAA512B7181A6F9634976997B2445A759C0F099BA5734B251AE65C337F2293CE9011CE90C895CA53E6687E056B2B1FC68D0B9AE3F73970819E526564E9C1607971B14E8221B4477FCD348CE33D75FCBC9C8626DDF7FF7344F9159C578931DA4977ADB3909437F68D94E39C84EE21CA9F3B48FD1CDD624199AA4B72BE3F5C9EC05964EE36736BF547C1695F5575DCF5B7683E9ABDE2E0F7265941393991001F0FF02391456D21162310F559EFF37E743BCF8CF5A9C9FCB1EF072E8745CBA7348A5BC44FC11E5B64F87D93DACE5661012802D70C02E42C41639803538C5779E8D0E545C054E4694CE619CA0DF56101AC805935891B1790AAD41BCFE2A2F5E53C04C7A32995EA1A8EF6BCB2CCA658BFD78 */
    /* Key = 0123456789ABCDEFFEDCBA9876543210 */
    /* KeyByPK = 9E52AC170D4BEC2183A023E70D2B2D0A6C505E86AAEB11800B182DADE60691EE4F5D2E75552E95224863B167C1891EE6FCDAE86FF9DA75E1E767A673A3F77D0FACB9E679278E424FEE3C8D4C735212D458C55D0C7DEC974CB2AA00877F9D3356980F07BE20F241CE2E077E42E024DBD8DE37B54E109CE41016F1DAD78E084F72CD6ED408C19AEE6476515E6A28586710 */
    /* KeyByHMK = A2C0B0F8F7F5EE21FB5C6AEBE714E53A */

    memcpy(bSK,
           "\x81\xF8\x89\xB5\xB4\x83\x0C\x7B" \
           "\x87\x49\xC1\x49\x55\x19\x9B\xE1" \
           "\x4C\x30\x62\xE7\x71\xBF\xE5\x03" \
           "\x58\x80\xF9\x91\x4E\x32\x24\xAA" \
           "\xAE\x6B\xEB\x8C\xE1\xA7\xD6\x06" \
           "\x6F\x56\x3D\x8B\x23\x63\x68\xEF" \
           "\x49\x7F\x09\x38\xE2\xCF\x34\x21" \
           "\x50\x8D\x2E\x7A\x04\x39\x08\x7B" \
           "\xF7\xE0\x14\x2D\x3E\xA3\x11\x12" \
           "\xEC\x4B\x1C\xA0\xFB\xBC\x97\x45" \
           "\x1A\x75\x42\x95\x0A\x41\x7A\x2D" \
           "\xB8\xB3\x78\x04\xC7\xC5\x0D\xD2" \
           "\x57\xAC\xA2\x87\x9C\xB9\xCD\x4A" \
           "\xA5\x81\xBE\x8A\x7A\x22\xA8\x37" \
           "\x16\xF7\xB4\xC0\xCD\xEC\x8C\x7D" \
           "\x15\x4D\xC7\xA0\x36\x5B\xD9\x06" \
           "\xBD\x9D\x2A\x98\x6E\x38\x09\x01" \
           "\x89\x01\xD3\xFD\x77\xC3\xC3\x07" \
           "\x2E\x07\x95\x7D\x40\x40\xE3\x2B" \
           "\x3D\xB5\x88\x6B\x96\x1A\xDA\x49" \
           "\x54\xCE\xAD\x11\x1F\xB8\x86\x39" \
           "\x3E\x74\x53\x89\x95\x5C\x4B\x2B" \
           "\xCD\xB3\x19\x44\xF0\x50\x9D\x0C" \
           "\x18\x20\x6F\x3C\xD3\x29\xD4\xCC" \
           "\x7E\xFF\xD4\x0B\xF4\x7F\x34\x2C" \
           "\x6F\xF1\xEC\x9D\xDB\xB7\xD3\xAD" \
           "\x88\xF2\xB3\xD4\xDE\xFE\x56\x21" \
           "\x5F\x92\x29\xB3\xAD\xF2\xEA\x51" \
           "\xE0\xCF\x66\xD5\x7D\x52\x6A\x17" \
           "\x13\xC7\xF5\x14\x9A\x81\x21\x69" \
           "\x9D\x04\x79\x72\x1F\xF8\x8D\x39" \
           "\x58\x7B\xBA\x5D\xDC\xF1\x64\x11" \
           "\x03\x47\x00\x0D\x75\x35\xF9\x58" \
           "\x7C\xA6\xA6\x87\x74\x61\x12\xAE" \
           "\xA1\x26\xC1\x46\x28\xAC\xC0\x0E" \
           "\x26\xF2\x57\x3B\xB2\xBC\xAE\xB0" \
           "\x10\xB4\x39\xCC\x3E\x4E\xB2\xFF" \
           "\xBD\xCE\x77\x68\xDF\x8D\xB0\x6C" \
           "\xCE\xE4\x35\x8C\x7B\x0A\xB5\xC0" \
           "\x13\x12\x97\xDD\x56\xF6\x1A\x29" \
           "\xB4\x25\x8F\x31\x8C\x74\xDD\x59" \
           "\xD9\xC7\x6E\x26\x4B\xBF\xCB\x19" \
           "\xEE\x5B\xEF\x70\xBA\xB8\xEB\x0B" \
           "\x6E\x17\xBD\x61\xED\x32\xDB\x41" \
           "\x9B\x5B\x91\xF3\xA9\xE9\x5B\x3C" \
           "\x94\x85\x44\x9C\x7E\x25\x01\xEB" \
           "\xE5\x2B\xFC\xBC\x95\xC5\x05\x39" \
           "\x04\x92\x9F\x1D\xB0\x24\x86\xB5" \
           "\x37\xCF\x98\x0A\x26\xCD\x3E\x88" \
           "\x48\x25\x46\xDE\x35\xA3\x6E\xB9" \
           "\x32\xFE\x68\x2E\xBA\x48\xF3\x5D" \
           "\xBC\xC3\x2C\xE2\xE8\x2F\xF9\x3D" \
           "\xBB\xAA\x51\x2B\x71\x81\xA6\xF9" \
           "\x63\x49\x76\x99\x7B\x24\x45\xA7" \
           "\x59\xC0\xF0\x99\xBA\x57\x34\xB2" \
           "\x51\xAE\x65\xC3\x37\xF2\x29\x3C" \
           "\xE9\x01\x1C\xE9\x0C\x89\x5C\xA5" \
           "\x3E\x66\x87\xE0\x56\xB2\xB1\xFC" \
           "\x68\xD0\xB9\xAE\x3F\x73\x97\x08" \
           "\x19\xE5\x26\x56\x4E\x9C\x16\x07" \
           "\x97\x1B\x14\xE8\x22\x1B\x44\x77" \
           "\xFC\xD3\x48\xCE\x33\xD7\x5F\xCB" \
           "\xC9\xC8\x62\x6D\xDF\x7F\xF7\x34" \
           "\x4F\x91\x59\xC5\x78\x93\x1D\xA4" \
           "\x97\x7A\xDB\x39\x09\x43\x7F\x68" \
           "\xD9\x4E\x39\xC8\x4E\xE2\x1C\xA9" \
           "\xF3\xB4\x8F\xD1\xCD\xD6\x24\x19" \
           "\x9A\xA4\xB7\x2B\xE3\xF5\xC9\xEC" \
           "\x05\x96\x4E\xE3\x67\x36\xBF\x54" \
           "\x7C\x16\x95\xF5\x57\x5D\xCF\x5B" \
           "\x76\x83\xE9\xAB\xDE\x2E\x0F\x72" \
           "\x65\x94\x13\x93\x99\x10\x01\xF0" \
           "\xFF\x02\x39\x14\x56\xD2\x11\x62" \
           "\x31\x0F\x55\x9E\xFF\x37\xE7\x43" \
           "\xBC\xF8\xCF\x5A\x9C\x9F\xCB\x1E" \
           "\xF0\x72\xE8\x74\x5C\xBA\x73\x48" \
           "\xA5\xBC\x44\xFC\x11\xE5\xB6\x4F" \
           "\x87\xD9\x3D\xAC\xE5\x66\x10\x12" \
           "\x80\x2D\x70\xC0\x2E\x42\xC4\x16" \
           "\x39\x80\x35\x38\xC5\x77\x9E\x8D" \
           "\x0E\x54\x5C\x05\x4E\x46\x94\xCE" \
           "\x61\x9C\xA0\xDF\x56\x10\x1A\xC8" \
           "\x05\x93\x58\x91\xB1\x79\x0A\xAD" \
           "\x41\xBC\xFE\x2A\x2F\x5E\x53\xC0" \
           "\x4C\x7A\x32\x99\x5E\xA1\xA8\xEF" \
           "\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78" \
           , 688);
    nSKLen = 688;

    memcpy(bKeyByPK,
           "\x9E\x52\xAC\x17\x0D\x4B\xEC\x21" \
           "\x83\xA0\x23\xE7\x0D\x2B\x2D\x0A" \
           "\x6C\x50\x5E\x86\xAA\xEB\x11\x80" \
           "\x0B\x18\x2D\xAD\xE6\x06\x91\xEE" \
           "\x4F\x5D\x2E\x75\x55\x2E\x95\x22" \
           "\x48\x63\xB1\x67\xC1\x89\x1E\xE6" \
           "\xFC\xDA\xE8\x6F\xF9\xDA\x75\xE1" \
           "\xE7\x67\xA6\x73\xA3\xF7\x7D\x0F" \
           "\xAC\xB9\xE6\x79\x27\x8E\x42\x4F" \
           "\xEE\x3C\x8D\x4C\x73\x52\x12\xD4" \
           "\x58\xC5\x5D\x0C\x7D\xEC\x97\x4C" \
           "\xB2\xAA\x00\x87\x7F\x9D\x33\x56" \
           "\x98\x0F\x07\xBE\x20\xF2\x41\xCE" \
           "\x2E\x07\x7E\x42\xE0\x24\xDB\xD8" \
           "\xDE\x37\xB5\x4E\x10\x9C\xE4\x10" \
           "\x16\xF1\xDA\xD7\x8E\x08\x4F\x72" \
           "\xCD\x6E\xD4\x08\xC1\x9A\xEE\x64" \
           "\x76\x51\x5E\x6A\x28\x58\x67\x10" \
           , 144);
    nKeyByPKLen = 144;

    memcpy(bKeyByHMKExp,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
           "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
           , 16);
    nKeyByHMKLenExp = 16;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, nSKLen);
    printf("[IN ]nPKLen = %d\n", nSKLen);
    DspHex("[IN ]bKeyByPK =", bKeyByPK, nKeyByPKLen);
    printf("[IN ]nKeyByPKLen = %d\n", nKeyByPKLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyIntoSK(nSock, nPadMode, bSK, nSKLen, bKeyByPK, \
                                nKeyByPKLen, bKeyByHMK, &nKeyByHMKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "私钥转加密，RSA-1152，PKCS#1，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKeyByHMK    =", bKeyByHMK, nKeyByHMKLen);
    DspHex("[OUT]bKeyByHMKExp =", bKeyByHMKExp, nKeyByHMKLenExp);
    ASSERT_OUT_HEX(bKeyByHMK, bKeyByHMKExp, nKeyByHMKLenExp);
    ASSERT_OUT(nKeyByHMKLen, nKeyByHMKLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyIntoSK_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bSK[2400];
	  int  nSKLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyByHMKLen;
	  BYTE bKeyByHMKExp[260];
	  int  nKeyByHMKLenExp;

    bufclr(bSK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByHMKExp);

    nPadMode = 1;
    /* PK = 3081B70281B100C5A3A2EF8B4910C9D79843FDEBD511C81A0B9AFDF3A75186259C61FAF4C43BB32495E604E1162B3CE46F5EA1F9E688AD972CD8693F1109BA172A8D39DD3B60C1129A8D21EE22DE613BC28F788EF16A6587B03947B573C67C3D0697E609979EB52838EAFE66E0AB3B05E84228B1BEF36CEB19F96628E061103CFAA9F27993272C194F6E4811F3647449029C7835DCC17161D5B24F308B24E120E90D340A7E4051D061D55F099A89D0C0D20446A57CB3C3020103 */
    /* SK = 308203350201000281B100C5A3A2EF8B4910C9D79843FDEBD511C81A0B9AFDF3A75186259C61FAF4C43BB32495E604E1162B3CE46F5EA1F9E688AD972CD8693F1109BA172A8D39DD3B60C1129A8D21EE22DE613BC28F788EF16A6587B03947B573C67C3D0697E609979EB52838EAFE66E0AB3B05E84228B1BEF36CEB19F96628E061103CFAA9F27993272C194F6E4811F3647449029C7835DCC17161D5B24F308B24E120E90D340A7E4051D061D55F099A89D0C0D20446A57CB3C30201030281B10083C26C9FB230B5DBE5102D53F28E0BDABC07BCA94D1A36596E684151F882D2776DB9440340B97228984A3F16A699B073BA1DE59B7F60B126BA1C5E26937CEB2B61BC5E169EC1E99627D70A505F4B9C43AFCAD0DA78F7D9A6FC6C1D6F7C718671BC277B4F8FABD8AE0E1D26A0496BD825941A95FD52131DC93E761E7BA1DCD3813C533BC608AF92BDE0150ACB6BD91D5FBEFFC4048092AD7EF48639C0F4BEC27AE40BE8132A127B7FE99D902486C4907B025900EC0B1A5DB59E4D0254E61FF2BC29846E7CCCBE6A51E670A4605D52AD1AFA3FF4CE6001818C87D51CE1137155B6F53535FD6209976700DCA5DE9FAD4890303761D955371D8ECD893D1E11C77915A8447BFCD6289BEFB6B2D5025900D6595161194F080839179214533561C773EFC9CDF1B6BE902C94C5BD12C9746D90E97AB77A4014CD5DBF23494DF6D3217B8102AFAD1638BBE4B65EFFDF7EE940D8CA7F750C92935C5C3E31C934D68C14E58F8373EB9F28370259009D5CBC3E79143356E344154C7D7102F45333299C3699A06D95938C7367517FF8899556565DAFE368960CF63924A378CEA8EC0664EF55E86E946A7385B5757A413B8E24BE5F33B0D369612FA60E702DA7FDE41B129FCF21E30259008EE63640BB8A055AD0BA6162E2239684F7F53133F679D4601DB883D361DBA2F3B5F0FC7A51800DDE3E7F6CDB894F376BA7AB571FC8B97B27EDCEE9FFEA549B809086FFA35DB70CE83D7ECBDB788F080DEE5FACF7F26A1ACF025900E5C5E1AE5B43E2DF317F9A5BEB6D33F81A4F454FC2A508335C3679CD4F52CB3E6F7EE26685095E11D0EFCA7445624CCD0FA680C2160A42789C42197E37197B61A48BE37CD125B1CDF31CAA74499B3AE8F908069E5633902D */
    /* SKByHMK = 000096D62D22C113789C6F1A78533225E113EFC14243EA4B846D45178815D07FCD2719793D64D2559B5F472F0D0B1C0B26A12D5375C1F62E3C4C31D12BAC112C019CD61A67B6939CF6F44F186F2C95F3E6C6D5AA53223565FCE0698B2BDF84070EDA6D8FE46576FCC451EAC4CE4AAE3EF4E581434B6BC93F901322E0AFAA17CCBE71CDE41B97DA8540808AFD7ACCC1B6CB03B1D889C166180389575EDFB8EC139E02FF11233BDE39DD4ACE88E74E31508D0A7D164005FA3149AB381C36EE966FC867CA00E31E838764E90C0F73E2680E6BA4A6752C6330AB1A839D25CF01B864E30AB58BB957B849770AD33FA90B51B69298F12A3CD33C3088ABBA1D00E71C28B400E098C4A381EE8C7908A3C5226BEF14A65EA5A7592AE1069BEC027198F49352553705B1208501B1FDB52B4D4C214994490B195FE80A1495CBB65C3C8807C25A627A6DB0A2C67E81E379B7A902B06C9C6D5CCFBB81A7AD3885D077840106AD31B66A57504BB05DFA3D5C87167FE16B6AE9F04C69F5B50D6D2754F6572EABB77A3D08955C893290C393D4B7961854C9D6A5F3F5D19F6C652631C34B8B988AEADB6CF2F0B04BFE48E0143D0ECC9B68F084402F1DA6CB19ABD84425180E02E9434A03EFF037AEA4041A3B29F478B716B0C70BA730B2F1CE47F6A025FBF6790414B7E48913247FD1EE04B882D7CFF7552F76FB62E922E0BBCDD35D5AC33A6DA9DB26BFD65EAA4859E8BE10D79A5C268350D28FA2038A5E0A26FC4A5084129EEF47AC777D6E5483824D4EE3559B9F27375E1FFA7B925A35D24C1D5D05CB7077995BCD74CB38D78F3E9F8C2154D755AC6968F9FF39885A3F356E30578DA25CB85969A231206038990A72655D2D54DC4D23D5EE14CDC53FFC666605BC8331C4314B27C8FB0D3BCC9FB2F7B778A03A891E5A5E9AE20CA6BC7C0685F47AFB91581DAFF14309B0BB066A489A0346825DC0E3D8635CAEEC23A9239579B23FE20AB5C08FB2211454E5B40A1AE1237AEABECBBE39C6B55B4A77E34E78E72F2B263AD9DAE64DDBE59EFE9E76C050B81AD4B78113BB22087D6FF7547DB4DC485D7FAEEB7AA2BC3B96B1C8745CF61BBE2FC4011032A7899D5B5838F28CF5CC627E60C06AB6FC84B4BE0720B7973497484F719DE36E72955CB1D7E4DC47F8FB44B98628DD0C0D3D */
    /* Key = 0123456789ABCDEFFEDCBA9876543210 */
    /* KeyByPK = 4F3B793F5992B83A7DA24F9F488D58B8AE57031A0BCD487554C13684D6E68801FB8B041BDBBE45B1CF173D58A67DB8289C6752523562B1E8C03B8E5ABC777B4FF3AA1351E1FCAD40C5C7EB3B82B9FDF88EA1BAA3279C78D5E2487C7042338409A246486A4970D7E4BF7107D05B3ADF198F8791FA1660A41EC8D8DA000F621006E8CFC8D293A714D3851673C0FF7080C7284A52F3DC6C51AB1F7F81BFE10C8A39A4CAE1C518628444BBA3918342DC6141 */
    /* KeyByHMK = A2C0B0F8F7F5EE21FB5C6AEBE714E53A */

    memcpy(bSK,
           "\x00\x00\x96\xD6\x2D\x22\xC1\x13" \
           "\x78\x9C\x6F\x1A\x78\x53\x32\x25" \
           "\xE1\x13\xEF\xC1\x42\x43\xEA\x4B" \
           "\x84\x6D\x45\x17\x88\x15\xD0\x7F" \
           "\xCD\x27\x19\x79\x3D\x64\xD2\x55" \
           "\x9B\x5F\x47\x2F\x0D\x0B\x1C\x0B" \
           "\x26\xA1\x2D\x53\x75\xC1\xF6\x2E" \
           "\x3C\x4C\x31\xD1\x2B\xAC\x11\x2C" \
           "\x01\x9C\xD6\x1A\x67\xB6\x93\x9C" \
           "\xF6\xF4\x4F\x18\x6F\x2C\x95\xF3" \
           "\xE6\xC6\xD5\xAA\x53\x22\x35\x65" \
           "\xFC\xE0\x69\x8B\x2B\xDF\x84\x07" \
           "\x0E\xDA\x6D\x8F\xE4\x65\x76\xFC" \
           "\xC4\x51\xEA\xC4\xCE\x4A\xAE\x3E" \
           "\xF4\xE5\x81\x43\x4B\x6B\xC9\x3F" \
           "\x90\x13\x22\xE0\xAF\xAA\x17\xCC" \
           "\xBE\x71\xCD\xE4\x1B\x97\xDA\x85" \
           "\x40\x80\x8A\xFD\x7A\xCC\xC1\xB6" \
           "\xCB\x03\xB1\xD8\x89\xC1\x66\x18" \
           "\x03\x89\x57\x5E\xDF\xB8\xEC\x13" \
           "\x9E\x02\xFF\x11\x23\x3B\xDE\x39" \
           "\xDD\x4A\xCE\x88\xE7\x4E\x31\x50" \
           "\x8D\x0A\x7D\x16\x40\x05\xFA\x31" \
           "\x49\xAB\x38\x1C\x36\xEE\x96\x6F" \
           "\xC8\x67\xCA\x00\xE3\x1E\x83\x87" \
           "\x64\xE9\x0C\x0F\x73\xE2\x68\x0E" \
           "\x6B\xA4\xA6\x75\x2C\x63\x30\xAB" \
           "\x1A\x83\x9D\x25\xCF\x01\xB8\x64" \
           "\xE3\x0A\xB5\x8B\xB9\x57\xB8\x49" \
           "\x77\x0A\xD3\x3F\xA9\x0B\x51\xB6" \
           "\x92\x98\xF1\x2A\x3C\xD3\x3C\x30" \
           "\x88\xAB\xBA\x1D\x00\xE7\x1C\x28" \
           "\xB4\x00\xE0\x98\xC4\xA3\x81\xEE" \
           "\x8C\x79\x08\xA3\xC5\x22\x6B\xEF" \
           "\x14\xA6\x5E\xA5\xA7\x59\x2A\xE1" \
           "\x06\x9B\xEC\x02\x71\x98\xF4\x93" \
           "\x52\x55\x37\x05\xB1\x20\x85\x01" \
           "\xB1\xFD\xB5\x2B\x4D\x4C\x21\x49" \
           "\x94\x49\x0B\x19\x5F\xE8\x0A\x14" \
           "\x95\xCB\xB6\x5C\x3C\x88\x07\xC2" \
           "\x5A\x62\x7A\x6D\xB0\xA2\xC6\x7E" \
           "\x81\xE3\x79\xB7\xA9\x02\xB0\x6C" \
           "\x9C\x6D\x5C\xCF\xBB\x81\xA7\xAD" \
           "\x38\x85\xD0\x77\x84\x01\x06\xAD" \
           "\x31\xB6\x6A\x57\x50\x4B\xB0\x5D" \
           "\xFA\x3D\x5C\x87\x16\x7F\xE1\x6B" \
           "\x6A\xE9\xF0\x4C\x69\xF5\xB5\x0D" \
           "\x6D\x27\x54\xF6\x57\x2E\xAB\xB7" \
           "\x7A\x3D\x08\x95\x5C\x89\x32\x90" \
           "\xC3\x93\xD4\xB7\x96\x18\x54\xC9" \
           "\xD6\xA5\xF3\xF5\xD1\x9F\x6C\x65" \
           "\x26\x31\xC3\x4B\x8B\x98\x8A\xEA" \
           "\xDB\x6C\xF2\xF0\xB0\x4B\xFE\x48" \
           "\xE0\x14\x3D\x0E\xCC\x9B\x68\xF0" \
           "\x84\x40\x2F\x1D\xA6\xCB\x19\xAB" \
           "\xD8\x44\x25\x18\x0E\x02\xE9\x43" \
           "\x4A\x03\xEF\xF0\x37\xAE\xA4\x04" \
           "\x1A\x3B\x29\xF4\x78\xB7\x16\xB0" \
           "\xC7\x0B\xA7\x30\xB2\xF1\xCE\x47" \
           "\xF6\xA0\x25\xFB\xF6\x79\x04\x14" \
           "\xB7\xE4\x89\x13\x24\x7F\xD1\xEE" \
           "\x04\xB8\x82\xD7\xCF\xF7\x55\x2F" \
           "\x76\xFB\x62\xE9\x22\xE0\xBB\xCD" \
           "\xD3\x5D\x5A\xC3\x3A\x6D\xA9\xDB" \
           "\x26\xBF\xD6\x5E\xAA\x48\x59\xE8" \
           "\xBE\x10\xD7\x9A\x5C\x26\x83\x50" \
           "\xD2\x8F\xA2\x03\x8A\x5E\x0A\x26" \
           "\xFC\x4A\x50\x84\x12\x9E\xEF\x47" \
           "\xAC\x77\x7D\x6E\x54\x83\x82\x4D" \
           "\x4E\xE3\x55\x9B\x9F\x27\x37\x5E" \
           "\x1F\xFA\x7B\x92\x5A\x35\xD2\x4C" \
           "\x1D\x5D\x05\xCB\x70\x77\x99\x5B" \
           "\xCD\x74\xCB\x38\xD7\x8F\x3E\x9F" \
           "\x8C\x21\x54\xD7\x55\xAC\x69\x68" \
           "\xF9\xFF\x39\x88\x5A\x3F\x35\x6E" \
           "\x30\x57\x8D\xA2\x5C\xB8\x59\x69" \
           "\xA2\x31\x20\x60\x38\x99\x0A\x72" \
           "\x65\x5D\x2D\x54\xDC\x4D\x23\xD5" \
           "\xEE\x14\xCD\xC5\x3F\xFC\x66\x66" \
           "\x05\xBC\x83\x31\xC4\x31\x4B\x27" \
           "\xC8\xFB\x0D\x3B\xCC\x9F\xB2\xF7" \
           "\xB7\x78\xA0\x3A\x89\x1E\x5A\x5E" \
           "\x9A\xE2\x0C\xA6\xBC\x7C\x06\x85" \
           "\xF4\x7A\xFB\x91\x58\x1D\xAF\xF1" \
           "\x43\x09\xB0\xBB\x06\x6A\x48\x9A" \
           "\x03\x46\x82\x5D\xC0\xE3\xD8\x63" \
           "\x5C\xAE\xEC\x23\xA9\x23\x95\x79" \
           "\xB2\x3F\xE2\x0A\xB5\xC0\x8F\xB2" \
           "\x21\x14\x54\xE5\xB4\x0A\x1A\xE1" \
           "\x23\x7A\xEA\xBE\xCB\xBE\x39\xC6" \
           "\xB5\x5B\x4A\x77\xE3\x4E\x78\xE7" \
           "\x2F\x2B\x26\x3A\xD9\xDA\xE6\x4D" \
           "\xDB\xE5\x9E\xFE\x9E\x76\xC0\x50" \
           "\xB8\x1A\xD4\xB7\x81\x13\xBB\x22" \
           "\x08\x7D\x6F\xF7\x54\x7D\xB4\xDC" \
           "\x48\x5D\x7F\xAE\xEB\x7A\xA2\xBC" \
           "\x3B\x96\xB1\xC8\x74\x5C\xF6\x1B" \
           "\xBE\x2F\xC4\x01\x10\x32\xA7\x89" \
           "\x9D\x5B\x58\x38\xF2\x8C\xF5\xCC" \
           "\x62\x7E\x60\xC0\x6A\xB6\xFC\x84" \
           "\xB4\xBE\x07\x20\xB7\x97\x34\x97" \
           "\x48\x4F\x71\x9D\xE3\x6E\x72\x95" \
           "\x5C\xB1\xD7\xE4\xDC\x47\xF8\xFB" \
           "\x44\xB9\x86\x28\xDD\x0C\x0D\x3D" \
           , 832);
    nSKLen = 832;

    memcpy(bKeyByPK,
           "\x4F\x3B\x79\x3F\x59\x92\xB8\x3A" \
           "\x7D\xA2\x4F\x9F\x48\x8D\x58\xB8" \
           "\xAE\x57\x03\x1A\x0B\xCD\x48\x75" \
           "\x54\xC1\x36\x84\xD6\xE6\x88\x01" \
           "\xFB\x8B\x04\x1B\xDB\xBE\x45\xB1" \
           "\xCF\x17\x3D\x58\xA6\x7D\xB8\x28" \
           "\x9C\x67\x52\x52\x35\x62\xB1\xE8" \
           "\xC0\x3B\x8E\x5A\xBC\x77\x7B\x4F" \
           "\xF3\xAA\x13\x51\xE1\xFC\xAD\x40" \
           "\xC5\xC7\xEB\x3B\x82\xB9\xFD\xF8" \
           "\x8E\xA1\xBA\xA3\x27\x9C\x78\xD5" \
           "\xE2\x48\x7C\x70\x42\x33\x84\x09" \
           "\xA2\x46\x48\x6A\x49\x70\xD7\xE4" \
           "\xBF\x71\x07\xD0\x5B\x3A\xDF\x19" \
           "\x8F\x87\x91\xFA\x16\x60\xA4\x1E" \
           "\xC8\xD8\xDA\x00\x0F\x62\x10\x06" \
           "\xE8\xCF\xC8\xD2\x93\xA7\x14\xD3" \
           "\x85\x16\x73\xC0\xFF\x70\x80\xC7" \
           "\x28\x4A\x52\xF3\xDC\x6C\x51\xAB" \
           "\x1F\x7F\x81\xBF\xE1\x0C\x8A\x39" \
           "\xA4\xCA\xE1\xC5\x18\x62\x84\x44" \
           "\xBB\xA3\x91\x83\x42\xDC\x61\x41" \
           , 176);
    nKeyByPKLen = 176;

    memcpy(bKeyByHMKExp,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
           "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
           , 16);
    nKeyByHMKLenExp = 16;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, nSKLen);
    printf("[IN ]nPKLen = %d\n", nSKLen);
    DspHex("[IN ]bKeyByPK =", bKeyByPK, nKeyByPKLen);
    printf("[IN ]nKeyByPKLen = %d\n", nKeyByPKLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyIntoSK(nSock, nPadMode, bSK, nSKLen, bKeyByPK, \
                                nKeyByPKLen, bKeyByHMK, &nKeyByHMKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "私钥转加密，RSA-1408，PKCS#1，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKeyByHMK    =", bKeyByHMK, nKeyByHMKLen);
    DspHex("[OUT]bKeyByHMKExp =", bKeyByHMKExp, nKeyByHMKLenExp);
    ASSERT_OUT_HEX(bKeyByHMK, bKeyByHMKExp, nKeyByHMKLenExp);
    ASSERT_OUT(nKeyByHMKLen, nKeyByHMKLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyIntoSK_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bSK[2400];
	  int  nSKLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyByHMKLen;
	  BYTE bKeyByHMKExp[260];
	  int  nKeyByHMKLenExp;

    bufclr(bSK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByHMKExp);

    nPadMode = 1;
    /* PK = 3081FF0281F900A680D2649E6C202ACB88B72F054D00BF642167EA8757EB657D2484BB7EC68B162CD38DEDACB01181197A70644A3C2783DFE964BEF28FA24EC8426F67AD41B01E29AFE8AA7D91757ABF9A5E21CE52EEC2FA8D4972EFE44BD5E391721F578E46BD1227EF4B4971D1A57064652F394BE1F68B1C7549E655B8C0CA6C1701038F2996FAD869723E5589409903D141A854636349A5C47E1DD779320C1A2645FF7FE9747D4370EEB61BF1EFFDE8D9BC58A02B841EEDFC90B59E9197E10F550EFEAC47EDA85CA04B7AEF202CDBAA7D1551016FCA2115DB12229FB3977D35B1FB0BC3A5BCF333082871770B8B373AE4A28D3FB224BD420534B494640F020103 */
    /* SK = 308204770201000281F900A680D2649E6C202ACB88B72F054D00BF642167EA8757EB657D2484BB7EC68B162CD38DEDACB01181197A70644A3C2783DFE964BEF28FA24EC8426F67AD41B01E29AFE8AA7D91757ABF9A5E21CE52EEC2FA8D4972EFE44BD5E391721F578E46BD1227EF4B4971D1A57064652F394BE1F68B1C7549E655B8C0CA6C1701038F2996FAD869723E5589409903D141A854636349A5C47E1DD779320C1A2645FF7FE9747D4370EEB61BF1EFFDE8D9BC58A02B841EEDFC90B59E9197E10F550EFEAC47EDA85CA04B7AEF202CDBAA7D1551016FCA2115DB12229FB3977D35B1FB0BC3A5BCF333082871770B8B373AE4A28D3FB224BD420534B494640F0201030281F86F008C4314481571DD05CF74AE3355D4ED6B9A9C5A3A9CEE536DADD254845CB97337B3F3C8756100BBA6F598317D6FAD3FF0EDD4A1B516DF302C4A451E2BCABEC67545C6FE60F8FC7FBC3EC1343749D751B3864C9FED87E3ED0BA16A3A5ED9D3616FF4DCDBA1366E4AED98CA263296A45CBDA386998E7B2B319D64AA446DD8D1A59CB30522399FC08C7CC3BA825B3ED06AA125138E516AE3DBE7AD44A080044F322763F2BFE1420E832D35CD5CDBD9089A5F4276C8EB9291638355ED71E4DEBB2FCF899FAF939674B07D6AE97594678108A0732AA022A5DEF82F7D2C266F388B10AB98F80350F5B58FB80ECC2592B5C742AE4D7A4D0E040B027D00CE775EE3EA1428C860A490B20B2CBE448F003703B08414BE4DB8F8D08AA4E0FF28C2BBB6B4329AAFB94EF8DACD7B54408275D5E99EBE7FF40C06861E091F948C5F0F084FAA6CCEF2C245BFA0D9146B8E39B754217EF01E36E2FC81BCDFDA7339745F100FC8ECA4452DBCFED220EFA0466B8A816CC43D3EC0E12BF1D9027D00CE730578985934222A5A88EDBB1BED6555CB4E26F92FF8227AA4600BB799C15FE5FD2746FDD5C052DCFB15FF6BA9B4C7CAE0900D98A098EA7C36AF9FC2AABF9E74C5F185363882E9314BFEDCF9D9F128E6EB80671535101B4F6F390C291402FF5DBDC0DC9144FE6F3EC09C28BEB72E29E959200D14FF523C5FD36C27027D0089A4E9ED46B81B30406DB5CC077329830A0024AD20580DD433D0A5E05C6DEB54C5D727CF22CC671FD0DF5091DE52382B01A3E3F1147EFFF8080459695B6A63083F5F5ADFC6F334A1D6D92A6B3B62F25ED124E2C0FF4ABECF41FDABD33FE6F77BA2EA0AB5309DC2D8C928A9E16B4A6AD99D0700F32D7E29D5EB72A13B027D0089A203A5BAE622C17191B09E7CBD48EE39323419FB755016FC6D955D25112B9543FE1A2F53E3D58C93520EAA47C6788531EB0AB3BB15BB46FD79CA6A81C72A69A32EA103797B01F0CB87FF3DFBE6A0C5EF47AAEF6378B5678A4A26081B62ACAA3E7E80930B83544A29D5BD707F24C971463B6AB36354E17D95379D6F027C082248A5B3B6A2788F5A04351F7F2E066DD18E7F665A4D9473B09924C09E1D752760E40FD41CFA5A9264ACAA1F40F22598686227794C7D696D1A5D911A5EE9B9A779F9EE773799E63FD6A1E402A19A9FE9674712B56A3A4FEB7487442D15C2DEE2306B2AD43CB2F8BA2BC093460BC128D6E4A5DDFA792176754796F1 */
    /* SKByHMK = FFF0B57DCB96895AC283CC39200B50B635753C73E35E6C49F81B95402880F4F95FF9393752479E1DC3EBB3A4C242DA3C93B2F88CB179F8E73EB475161E176C1251896508D36D6E1E074D7C41183D203C4CBDADFBE5A828A3E8CD2F261C33D8F9591BF3E2728382EF69937DC5A3C32BF6D2B14F9082FD780B7F9E4EE41C7F08DBBF88888798A274AE8F293D68E2E0626E6170F3206373AFE2487FF629598813EC5B133C8FA89639EDC659392A3342FDDDBC0BFB703F347D640721DF3DC73599F226C81DE6235FD2732FAE7C3FBC2A2B29956F25D4F505D4596922761611EDA659E4FE71161035F61717DBCE344304D7F0DEE1008824E508EFD0856B5A35F84845691B6276B6F30B0E3E7042366A6B14A14C5560455F9E42D62AEC8CB54DA4D13337F128E575D441BEECB11DBBD24DFE8831E8EEBDEAE73C3DE486965EAFBBB3DD8F3C4454988A3C216FBD0FE615218F1551E658408B713171B343A7C8715BECF43B05550BAB67BD899B9DC1D57A3CC115B51A34DA06C36A8A9E637F24246C074FD222BB6962C6997B9E20972E9869E701C694A7D2292ED9FB1E11262713368557C61FF6A71968CFF386E3B29FE1605547F1120508E99190376184667CE4A6FCC3B4CD78F300EB50A5849F8E609B066F108A7845E33DB2FDF6451927FC0023831873A58A6DDF8FA2BDD909EA2068DCBFB830D1AD0BA630293A86000C10967E8F39764663D4FF22E4F0A0EE006840915DE4DA648848AF811311AC14817CD0AFB1C9C5A012B13AE69FFD9B1161A42B22E3CF9E2DA31C51C46B3D6025C5AB39A5FD79D5C016F81B5F9B3B56B260883CE8D16AF8C1EFED5BEFC81E0A8BEC37B83EEAE06A0B30BA9C47A06F585826086AEFF078F3C947E780FB3287B1C0AD4695C1BF216942500ED89BD8352D6CAE891E42FE4B37109431DA63DAED37DA976D942F230D9CC025BF3A2BF53CCAF4FA7801CCDA30959D0ADB9781C5EA8768CF4F4964E123C17E3B1DF23DDF42EA8373D44D1666B7BDD276461591CF4408AD74D39909C7FD1EC9ABA6EE7D9FD17B9AD0D2A4D879BD335FEF9B7F2615F8D90F6967CF81DDBB5AC8CC4746415E65517EAB59752A4F1D897F755F83957F5FD68289BF4217C79CDB775C424271469668E7590B2CDC0810729CE4C01DB2DB2395D5FA0280AD1FE279DCCF5DA468BB33C7160E1A112E47BBE0DF00077AB6798A5FC01ABD633C3F0FC99324F1E9FD936E94AA732C279693A3145B66642F4BE3D46369001385465F109D354F45B57AC68E3CE247D1854073D479FA3F09AF4AD80FCCEBAC6CCB65F4BFC3D534523978CA125BF7721B7F867BE30ED7463C3A6AD642899113C87C0B3EC5A74C86B005D11811C23323F32E107848BE3FAE1BE1561D904E5205B3E2E2E4A5FFDD4FA45B597B883EAEA125B95BB182F41DFC1C6A6806FEDA0A830C52BD2EBF280D105E1290140DC7395202AF33B5CB209B766654FAC22CDC5717F84846E10C7ABE5498FCDA349E5B19642D7EC892827B42D53A18BFB10C8EC8FF163F014FBB38C5E9136BB8269071E352E1A8AB73B7901B1FBF1DC7A0473960E20E221851A092DE9B04FB5E84B73EC9F26471B2E7C55F6FC0CCE115BEA0A9FE383138433F6D */
    /* Key = 0123456789ABCDEFFEDCBA9876543210 */
    /* KeyByPK = 5961AD27394076CC7A2C4FB2D4D724DB4F25FD668A876B4BCBCF5A4699982469507326A1592AAE9C17A3431F530B0B289ED7C34E7FCA2D06AE247831D1D3C0A9AF94D228BA48D56F6757B686CFDAAC3E4554022CA0605A517A758364F1C4B11A4832914C0A59D85747732D0D00E6DF9F670B31F2AE5D89E30F0CA54F6DC09A6691802EAD5BCDC3521F3E4D2900DAFC114F377B99BE14138394D288E8094FF362FF7E57FBC141C7B4E8A40BD7B234A09372DE56CB263BC4081D9FE2E4C4A09A4825FCBD488E4E7773BE3303415F7E8229619E3CE82326C9A21CA9440B7A78E225CE2779463174EDE41786DD196B2B0BD9CF445EECE8EA1382 */
    /* KeyByHMK = A2C0B0F8F7F5EE21FB5C6AEBE714E53A */

    memcpy(bSK,
           "\xFF\xF0\xB5\x7D\xCB\x96\x89\x5A" \
           "\xC2\x83\xCC\x39\x20\x0B\x50\xB6" \
           "\x35\x75\x3C\x73\xE3\x5E\x6C\x49" \
           "\xF8\x1B\x95\x40\x28\x80\xF4\xF9" \
           "\x5F\xF9\x39\x37\x52\x47\x9E\x1D" \
           "\xC3\xEB\xB3\xA4\xC2\x42\xDA\x3C" \
           "\x93\xB2\xF8\x8C\xB1\x79\xF8\xE7" \
           "\x3E\xB4\x75\x16\x1E\x17\x6C\x12" \
           "\x51\x89\x65\x08\xD3\x6D\x6E\x1E" \
           "\x07\x4D\x7C\x41\x18\x3D\x20\x3C" \
           "\x4C\xBD\xAD\xFB\xE5\xA8\x28\xA3" \
           "\xE8\xCD\x2F\x26\x1C\x33\xD8\xF9" \
           "\x59\x1B\xF3\xE2\x72\x83\x82\xEF" \
           "\x69\x93\x7D\xC5\xA3\xC3\x2B\xF6" \
           "\xD2\xB1\x4F\x90\x82\xFD\x78\x0B" \
           "\x7F\x9E\x4E\xE4\x1C\x7F\x08\xDB" \
           "\xBF\x88\x88\x87\x98\xA2\x74\xAE" \
           "\x8F\x29\x3D\x68\xE2\xE0\x62\x6E" \
           "\x61\x70\xF3\x20\x63\x73\xAF\xE2" \
           "\x48\x7F\xF6\x29\x59\x88\x13\xEC" \
           "\x5B\x13\x3C\x8F\xA8\x96\x39\xED" \
           "\xC6\x59\x39\x2A\x33\x42\xFD\xDD" \
           "\xBC\x0B\xFB\x70\x3F\x34\x7D\x64" \
           "\x07\x21\xDF\x3D\xC7\x35\x99\xF2" \
           "\x26\xC8\x1D\xE6\x23\x5F\xD2\x73" \
           "\x2F\xAE\x7C\x3F\xBC\x2A\x2B\x29" \
           "\x95\x6F\x25\xD4\xF5\x05\xD4\x59" \
           "\x69\x22\x76\x16\x11\xED\xA6\x59" \
           "\xE4\xFE\x71\x16\x10\x35\xF6\x17" \
           "\x17\xDB\xCE\x34\x43\x04\xD7\xF0" \
           "\xDE\xE1\x00\x88\x24\xE5\x08\xEF" \
           "\xD0\x85\x6B\x5A\x35\xF8\x48\x45" \
           "\x69\x1B\x62\x76\xB6\xF3\x0B\x0E" \
           "\x3E\x70\x42\x36\x6A\x6B\x14\xA1" \
           "\x4C\x55\x60\x45\x5F\x9E\x42\xD6" \
           "\x2A\xEC\x8C\xB5\x4D\xA4\xD1\x33" \
           "\x37\xF1\x28\xE5\x75\xD4\x41\xBE" \
           "\xEC\xB1\x1D\xBB\xD2\x4D\xFE\x88" \
           "\x31\xE8\xEE\xBD\xEA\xE7\x3C\x3D" \
           "\xE4\x86\x96\x5E\xAF\xBB\xB3\xDD" \
           "\x8F\x3C\x44\x54\x98\x8A\x3C\x21" \
           "\x6F\xBD\x0F\xE6\x15\x21\x8F\x15" \
           "\x51\xE6\x58\x40\x8B\x71\x31\x71" \
           "\xB3\x43\xA7\xC8\x71\x5B\xEC\xF4" \
           "\x3B\x05\x55\x0B\xAB\x67\xBD\x89" \
           "\x9B\x9D\xC1\xD5\x7A\x3C\xC1\x15" \
           "\xB5\x1A\x34\xDA\x06\xC3\x6A\x8A" \
           "\x9E\x63\x7F\x24\x24\x6C\x07\x4F" \
           "\xD2\x22\xBB\x69\x62\xC6\x99\x7B" \
           "\x9E\x20\x97\x2E\x98\x69\xE7\x01" \
           "\xC6\x94\xA7\xD2\x29\x2E\xD9\xFB" \
           "\x1E\x11\x26\x27\x13\x36\x85\x57" \
           "\xC6\x1F\xF6\xA7\x19\x68\xCF\xF3" \
           "\x86\xE3\xB2\x9F\xE1\x60\x55\x47" \
           "\xF1\x12\x05\x08\xE9\x91\x90\x37" \
           "\x61\x84\x66\x7C\xE4\xA6\xFC\xC3" \
           "\xB4\xCD\x78\xF3\x00\xEB\x50\xA5" \
           "\x84\x9F\x8E\x60\x9B\x06\x6F\x10" \
           "\x8A\x78\x45\xE3\x3D\xB2\xFD\xF6" \
           "\x45\x19\x27\xFC\x00\x23\x83\x18" \
           "\x73\xA5\x8A\x6D\xDF\x8F\xA2\xBD" \
           "\xD9\x09\xEA\x20\x68\xDC\xBF\xB8" \
           "\x30\xD1\xAD\x0B\xA6\x30\x29\x3A" \
           "\x86\x00\x0C\x10\x96\x7E\x8F\x39" \
           "\x76\x46\x63\xD4\xFF\x22\xE4\xF0" \
           "\xA0\xEE\x00\x68\x40\x91\x5D\xE4" \
           "\xDA\x64\x88\x48\xAF\x81\x13\x11" \
           "\xAC\x14\x81\x7C\xD0\xAF\xB1\xC9" \
           "\xC5\xA0\x12\xB1\x3A\xE6\x9F\xFD" \
           "\x9B\x11\x61\xA4\x2B\x22\xE3\xCF" \
           "\x9E\x2D\xA3\x1C\x51\xC4\x6B\x3D" \
           "\x60\x25\xC5\xAB\x39\xA5\xFD\x79" \
           "\xD5\xC0\x16\xF8\x1B\x5F\x9B\x3B" \
           "\x56\xB2\x60\x88\x3C\xE8\xD1\x6A" \
           "\xF8\xC1\xEF\xED\x5B\xEF\xC8\x1E" \
           "\x0A\x8B\xEC\x37\xB8\x3E\xEA\xE0" \
           "\x6A\x0B\x30\xBA\x9C\x47\xA0\x6F" \
           "\x58\x58\x26\x08\x6A\xEF\xF0\x78" \
           "\xF3\xC9\x47\xE7\x80\xFB\x32\x87" \
           "\xB1\xC0\xAD\x46\x95\xC1\xBF\x21" \
           "\x69\x42\x50\x0E\xD8\x9B\xD8\x35" \
           "\x2D\x6C\xAE\x89\x1E\x42\xFE\x4B" \
           "\x37\x10\x94\x31\xDA\x63\xDA\xED" \
           "\x37\xDA\x97\x6D\x94\x2F\x23\x0D" \
           "\x9C\xC0\x25\xBF\x3A\x2B\xF5\x3C" \
           "\xCA\xF4\xFA\x78\x01\xCC\xDA\x30" \
           "\x95\x9D\x0A\xDB\x97\x81\xC5\xEA" \
           "\x87\x68\xCF\x4F\x49\x64\xE1\x23" \
           "\xC1\x7E\x3B\x1D\xF2\x3D\xDF\x42" \
           "\xEA\x83\x73\xD4\x4D\x16\x66\xB7" \
           "\xBD\xD2\x76\x46\x15\x91\xCF\x44" \
           "\x08\xAD\x74\xD3\x99\x09\xC7\xFD" \
           "\x1E\xC9\xAB\xA6\xEE\x7D\x9F\xD1" \
           "\x7B\x9A\xD0\xD2\xA4\xD8\x79\xBD" \
           "\x33\x5F\xEF\x9B\x7F\x26\x15\xF8" \
           "\xD9\x0F\x69\x67\xCF\x81\xDD\xBB" \
           "\x5A\xC8\xCC\x47\x46\x41\x5E\x65" \
           "\x51\x7E\xAB\x59\x75\x2A\x4F\x1D" \
           "\x89\x7F\x75\x5F\x83\x95\x7F\x5F" \
           "\xD6\x82\x89\xBF\x42\x17\xC7\x9C" \
           "\xDB\x77\x5C\x42\x42\x71\x46\x96" \
           "\x68\xE7\x59\x0B\x2C\xDC\x08\x10" \
           "\x72\x9C\xE4\xC0\x1D\xB2\xDB\x23" \
           "\x95\xD5\xFA\x02\x80\xAD\x1F\xE2" \
           "\x79\xDC\xCF\x5D\xA4\x68\xBB\x33" \
           "\xC7\x16\x0E\x1A\x11\x2E\x47\xBB" \
           "\xE0\xDF\x00\x07\x7A\xB6\x79\x8A" \
           "\x5F\xC0\x1A\xBD\x63\x3C\x3F\x0F" \
           "\xC9\x93\x24\xF1\xE9\xFD\x93\x6E" \
           "\x94\xAA\x73\x2C\x27\x96\x93\xA3" \
           "\x14\x5B\x66\x64\x2F\x4B\xE3\xD4" \
           "\x63\x69\x00\x13\x85\x46\x5F\x10" \
           "\x9D\x35\x4F\x45\xB5\x7A\xC6\x8E" \
           "\x3C\xE2\x47\xD1\x85\x40\x73\xD4" \
           "\x79\xFA\x3F\x09\xAF\x4A\xD8\x0F" \
           "\xCC\xEB\xAC\x6C\xCB\x65\xF4\xBF" \
           "\xC3\xD5\x34\x52\x39\x78\xCA\x12" \
           "\x5B\xF7\x72\x1B\x7F\x86\x7B\xE3" \
           "\x0E\xD7\x46\x3C\x3A\x6A\xD6\x42" \
           "\x89\x91\x13\xC8\x7C\x0B\x3E\xC5" \
           "\xA7\x4C\x86\xB0\x05\xD1\x18\x11" \
           "\xC2\x33\x23\xF3\x2E\x10\x78\x48" \
           "\xBE\x3F\xAE\x1B\xE1\x56\x1D\x90" \
           "\x4E\x52\x05\xB3\xE2\xE2\xE4\xA5" \
           "\xFF\xDD\x4F\xA4\x5B\x59\x7B\x88" \
           "\x3E\xAE\xA1\x25\xB9\x5B\xB1\x82" \
           "\xF4\x1D\xFC\x1C\x6A\x68\x06\xFE" \
           "\xDA\x0A\x83\x0C\x52\xBD\x2E\xBF" \
           "\x28\x0D\x10\x5E\x12\x90\x14\x0D" \
           "\xC7\x39\x52\x02\xAF\x33\xB5\xCB" \
           "\x20\x9B\x76\x66\x54\xFA\xC2\x2C" \
           "\xDC\x57\x17\xF8\x48\x46\xE1\x0C" \
           "\x7A\xBE\x54\x98\xFC\xDA\x34\x9E" \
           "\x5B\x19\x64\x2D\x7E\xC8\x92\x82" \
           "\x7B\x42\xD5\x3A\x18\xBF\xB1\x0C" \
           "\x8E\xC8\xFF\x16\x3F\x01\x4F\xBB" \
           "\x38\xC5\xE9\x13\x6B\xB8\x26\x90" \
           "\x71\xE3\x52\xE1\xA8\xAB\x73\xB7" \
           "\x90\x1B\x1F\xBF\x1D\xC7\xA0\x47" \
           "\x39\x60\xE2\x0E\x22\x18\x51\xA0" \
           "\x92\xDE\x9B\x04\xFB\x5E\x84\xB7" \
           "\x3E\xC9\xF2\x64\x71\xB2\xE7\xC5" \
           "\x5F\x6F\xC0\xCC\xE1\x15\xBE\xA0" \
           "\xA9\xFE\x38\x31\x38\x43\x3F\x6D" \
           , 1152);
    nSKLen = 1152;

    memcpy(bKeyByPK,
           "\x59\x61\xAD\x27\x39\x40\x76\xCC" \
           "\x7A\x2C\x4F\xB2\xD4\xD7\x24\xDB" \
           "\x4F\x25\xFD\x66\x8A\x87\x6B\x4B" \
           "\xCB\xCF\x5A\x46\x99\x98\x24\x69" \
           "\x50\x73\x26\xA1\x59\x2A\xAE\x9C" \
           "\x17\xA3\x43\x1F\x53\x0B\x0B\x28" \
           "\x9E\xD7\xC3\x4E\x7F\xCA\x2D\x06" \
           "\xAE\x24\x78\x31\xD1\xD3\xC0\xA9" \
           "\xAF\x94\xD2\x28\xBA\x48\xD5\x6F" \
           "\x67\x57\xB6\x86\xCF\xDA\xAC\x3E" \
           "\x45\x54\x02\x2C\xA0\x60\x5A\x51" \
           "\x7A\x75\x83\x64\xF1\xC4\xB1\x1A" \
           "\x48\x32\x91\x4C\x0A\x59\xD8\x57" \
           "\x47\x73\x2D\x0D\x00\xE6\xDF\x9F" \
           "\x67\x0B\x31\xF2\xAE\x5D\x89\xE3" \
           "\x0F\x0C\xA5\x4F\x6D\xC0\x9A\x66" \
           "\x91\x80\x2E\xAD\x5B\xCD\xC3\x52" \
           "\x1F\x3E\x4D\x29\x00\xDA\xFC\x11" \
           "\x4F\x37\x7B\x99\xBE\x14\x13\x83" \
           "\x94\xD2\x88\xE8\x09\x4F\xF3\x62" \
           "\xFF\x7E\x57\xFB\xC1\x41\xC7\xB4" \
           "\xE8\xA4\x0B\xD7\xB2\x34\xA0\x93" \
           "\x72\xDE\x56\xCB\x26\x3B\xC4\x08" \
           "\x1D\x9F\xE2\xE4\xC4\xA0\x9A\x48" \
           "\x25\xFC\xBD\x48\x8E\x4E\x77\x73" \
           "\xBE\x33\x03\x41\x5F\x7E\x82\x29" \
           "\x61\x9E\x3C\xE8\x23\x26\xC9\xA2" \
           "\x1C\xA9\x44\x0B\x7A\x78\xE2\x25" \
           "\xCE\x27\x79\x46\x31\x74\xED\xE4" \
           "\x17\x86\xDD\x19\x6B\x2B\x0B\xD9" \
           "\xCF\x44\x5E\xEC\xE8\xEA\x13\x82" \
           , 248);
    nKeyByPKLen = 248;

    memcpy(bKeyByHMKExp,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
           "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
           , 16);
    nKeyByHMKLenExp = 16;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, nSKLen);
    printf("[IN ]nPKLen = %d\n", nSKLen);
    DspHex("[IN ]bKeyByPK =", bKeyByPK, nKeyByPKLen);
    printf("[IN ]nKeyByPKLen = %d\n", nKeyByPKLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyIntoSK(nSock, nPadMode, bSK, nSKLen, bKeyByPK, \
                                nKeyByPKLen, bKeyByHMK, &nKeyByHMKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "私钥转加密，RSA-1984，PKCS#1，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKeyByHMK    =", bKeyByHMK, nKeyByHMKLen);
    DspHex("[OUT]bKeyByHMKExp =", bKeyByHMKExp, nKeyByHMKLenExp);
    ASSERT_OUT_HEX(bKeyByHMK, bKeyByHMKExp, nKeyByHMKLenExp);
    ASSERT_OUT(nKeyByHMKLen, nKeyByHMKLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void TransKeyIntoSK_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nPadMode;
	  BYTE bSK[2400];
	  int  nSKLen;
	  BYTE bKeyByPK[260];
	  int  nKeyByPKLen;
	  BYTE bKeyByHMK[2056];
	  int  nKeyByHMKLen;
	  BYTE bKeyByHMKExp[260];
	  int  nKeyByHMKLenExp;

    bufclr(bSK);
    bufclr(bKeyByHMK);
    bufclr(bKeyByPK);
    nKeyByPKLen = 0;
    bufclr(bKeyByHMKExp);

    nPadMode = 1;
    /* PK = 308201080282010100AC9BD2F8FAA26398CF3D1B3589A194AF0D25DA587DCEC197B1AD289526B95C1282111F6DD4A48B4C74B4B94DC0F97EA58552A5DECD677A1C31E39849277BA7105B4A1D626DC5FCD8B3AB979085C032955174BBAC1DFC382CB09D944480314431598AABE9D26AA437BB3C2F2DF9112F1323AA85707481C3CA1791EC5F813F30C7EDA6EB1D840BC02DDD1B0A0B074E88A9EA08F7680D0E48E6E5889634B472B28FCEE1BC4414D69D92AB80BD54966F383B8B95B530BBFF3E17CC4FDDE5668BC4E2E1D2941B447EB5A063ED9DD0D8C26FF7F29F0388B127C239602D17604D49B730F31957A4BC006FDE0B535F0E470200C213B8D0E818AAF31618A98EAFB114CFA7020103 */
    /* SK = 308204A20201000282010100AC9BD2F8FAA26398CF3D1B3589A194AF0D25DA587DCEC197B1AD289526B95C1282111F6DD4A48B4C74B4B94DC0F97EA58552A5DECD677A1C31E39849277BA7105B4A1D626DC5FCD8B3AB979085C032955174BBAC1DFC382CB09D944480314431598AABE9D26AA437BB3C2F2DF9112F1323AA85707481C3CA1791EC5F813F30C7EDA6EB1D840BC02DDD1B0A0B074E88A9EA08F7680D0E48E6E5889634B472B28FCEE1BC4414D69D92AB80BD54966F383B8B95B530BBFF3E17CC4FDDE5668BC4E2E1D2941B447EB5A063ED9DD0D8C26FF7F29F0388B127C239602D17604D49B730F31957A4BC006FDE0B535F0E470200C213B8D0E818AAF31618A98EAFB114CFA70201030282010073128CA5FC6C4265DF7E1223B116631F5E193C3AFE89D665211E1B0E19D0E80C56B614F3E3185CDDA3232633D5FBA9C3AE37193F339A5168214265861A526F603CDC1396F3D9533B2272650B03D5770E364DD272BEA8257320690D830020D820E65C729BE19C6D7A7CD2CA1EA60B74B76D1C58F5A3012D31650BF2EA562A208430AFFC202F8C206B39A964F4340BA23EE8340C246D81A0C75600862D3D6F2F91A3B97EF7CB202B87E905AD1F6230E0CAC1759DDCFC985400F2689D22CFAFD74454FD7A3F346BCCC34FABA7139ED13E87F89B7A41CAE36DDBCC66F7BEF59B3C2FBB7ED2D63DE5208761F8141DC3BC88AAA99E8A1DA6D4D617AE3C40D527051A6B02818100D8D7667CE1B88197049D3CD3C0E57C9092B8116D7907C3E308A0F76DE538AFEAFA7A9E46414D2DB6D7AA83837479D828F170028AE81FE6D47219980AFDA02C83D9B0D9105A2C274EA449B996ED88B08A5D2D6F0A8282D3C6B94ABE0694ACCC890B1D079B0419DDCCFB719E7B9BBD96192C375000124F54EE406623EA3BA69E9702818100CBC78A705B010DF601FFB5C8F85798BAFB02D3C3EFC413D8DBE6D582F3133B4A5ED0DF8A22D92E8FF64DB6220EAC0EE277F545DA58FAD941EE995A263163D57888A583AC1BB0DB2CC822699C7CFFE1A1A0885D1B7E4FC9A8F447E5BB483410604EBE13C85B0EE145FCEDA26605A99DA8E913B1BB8C1C5D0452E90985BAE6897102818100908F99A8967B010F5868D337D5EE530B0C7AB648FB5A82975B15FA49437B1FF1FC51BED980DE1E79E51C57ACF8513AC5F64AAC5C9ABFEF384C11100753C01DAD3BCB3B603C1D6F89C2DBD10F4905CB06E8C8F4B1AC5737D9D0DC7EAF0DC8885B5CBE051202BBE933524BBEFD127E6410C824E0000C34E349804417F17D19BF0F0281810087DA5C4AE756094EABFFCE85FAE5107CA75737D7F52D62909299E3ACA20CD231948B3FB16C90C9B54EDE796C09C809EC4FF8D93C3B51E62BF4663C1976428E505B190272BD20921DDAC19BBDA8AA966BC05AE8BCFEDFDBC5F82FEE7CDACD6040347EB7DAE75F40D9534916EEAE7113C5F0B7CBD25D683E02E1F0B103D1EF064B0281800C27E1097CEB5B2007466B3CF7B9111DD11715C1388619414E910687577483DA014EDAD1DAF0DCCF04DC445495ACCC09C376F3B49146CA4C1BDF847DF80CDEC932EFE883D3E412099D86A093B6FAF536C1856D41F1135DDF4DD84BA3E80EC5429CA5D6C7CC80AE41BF018F70FD21C8AB9994DA2FC01DB5483D79DB51C7CF5E67 */
    /* SKByHMK = 5CBB649D1E0156463C21ADA719ABA77AD54F613636FEB8B6111B29C4D569A5E2868ED03316FD1D99DB95C6B8708D723F36A8A294B03D0CD3E911B87345FEFD01D78B101665F539F5CDCB23A3DAB858D9569A6E3E1AEC1ED2E26FFEC1F51E0A8AFA67B9F90B96DEBF3E28ECFA1F9EA51BB2FECE89F1DAD845299F070C5CE9D04935702933F3FFD70AC7820FE246E1A5ACCF7B615B4C976B464A9E887CA6C6F773E9C02F3CBB0B14CD8630187A2B18DFA7B6B987EF5FF7836DC435B6268E6AFD3D6AFF6B0E95247842386E3BF110018CAE1F9897C8A07507A4A9A6B64A8DCD68128CB199DC4F8F21AEC908FE994B641FCE7F24B82DD7B2CBA7DC26EF2F0582555413C0E5A31DB4E09A5198170C3E1E1FCB617E1787DAFB7E17FFF66B011765ACA86098D980586599EAB5912E25CDB9B547FAA969CE111259EA24029207FCD98509E7CA858F96F7D02A51869A07DFCEAAB417DEE1AA907E4BE98A3B44462716CAE9C0A98F09961BE8235AB137CEBF86415186724845517792CD25EC908F8C057581199B34CA9BCE8DFA7F8AA6E807F716DD22F03B50806CFAE0B761D5DCB8D5768271F0DBD93E062348EDC58A456CFA2C47AC0A498C49F074E672631076725EF4C6AE44D2D528EAF075BD1C2E43F745F4CE309DC2150CB0122CA8E973C8FF151BE9E8F4B63879681FAB40C165D22239C984F02FBAC1A532854713CC4ABA4CBBFF8E8B81E160F0328C48C04A7784C95EC65548BE92847E0D54B9E0D85E9B26FCE5577F7A26D7E37D6689C5BFC9412BED5B0D1955574907896873C03A3E69118D7DEFCCDC4675AFC7A2F04AA1AC1CABC0816FAE16F396228647D9EE11BD79FDBEBF06BA979C748EE675042A41BC59A86B64566DB7391D7994108AE378AC771B108E025FC5E582E027A00AA59663EC531717C3CDD075862D440867ECEA39B9C28D24E740090566B09C909DD4C7436D6E746AFC969054A46F06BEAF481AB85569EFA076EA6EF5C4030357602416E765B33EDEE4907D3599BAC967484FA5D732A7230A754D1413E43B8D08BB4DBEFAF49C59702CDD017C8F39E1157B7742C8A69A32FDBB9EAA5DB156FC57612AED56A44A71DBA20B42F3333EC22E835D4CDCF599004E16BB3D1133243BA44CE7EBDCF4675DE120CEF792EEFC44FC8EF2D7D73C7EAA9B2DB2BAADB44B722850040EFA4DFE72A57520017497990F31C724C01B0345910FEA9C286B78B33D725132E3C817805F7EB31C65A7B8BECAC38908C9AF2E2087A60EBD9BDE4BB3D8A07C8A03D3C561BE5DDCD6B58FDE9DA610577DA0A3536D90EC57E5C8C9F7C2AE03B9D68038810F2D34F6F063B0CC97E6050DB15934B6CDEDB7826A42C8196D4FAD59F023D91588CAB5ABB0412E1C3D7413F8DDFD72AA08611EFE7BCC48FD17D24D6695EB8035449DF8DC2BACB1D9FFD58FF67463A7C9BF2460DAFA3FE4632409043D3D4FEC62A6C6FA5116640875F62FF5E06FC00FCDA940C53CE4F8DF553D1D01E9068721F4EE434A2CE12C75F6264483682421931713529BDAEFE5F6F48C7A2732AFC4C4F2F098A84D0F58E0A845ADE0107B8A8158DD7C9B830E08C037008333860495CDCFCE1A54788B1E701FE54E1C4B122C08EDECD6DA682975C170F78B5106B57F80016971311CFC1C3ABBE3A760BAC20D5359CDCA397B5D997FA81E2AD03B */
    /* Key = 0123456789ABCDEFFEDCBA9876543210 */
    /* KeyByPK = 3DED547A1CCBD6BBE65C9498929A9ADD0FF2E2C3ED9D029EEB80078D159BEEF133AB6A29A233FE523280EAD7EF236421EB433698796AD7E3B65ACBA39ED1E5CE97D8D5AC6E091E1C7AC635FBE83C01E990FE62213106ACDA966D0D14BC9EB1FA2500C3ED91F07F366F5E9D9EB4D5CA27AC2BBC54A03525D65704EFE9776EB12973B8E4971D64DB487B7AAB1537EC3CCADAA61C525B934A45EA8D198FBDA978FE75B784CD6A091EC3582D44A3060E33E38FD730B622B86BEFD18B8DE01BF3D475C2DB447EDDF4D6A1812C99461340AE741C0AAE4066EBFB5CDD582E5E5639935033532BBE245EBA1BB38CD97F5D3B39286A5EEA6A8F3F2C644447EBDAB530F3E2 */
    /* KeyByHMK = A2C0B0F8F7F5EE21FB5C6AEBE714E53A */

    memcpy(bSK,
           "\x5C\xBB\x64\x9D\x1E\x01\x56\x46" \
           "\x3C\x21\xAD\xA7\x19\xAB\xA7\x7A" \
           "\xD5\x4F\x61\x36\x36\xFE\xB8\xB6" \
           "\x11\x1B\x29\xC4\xD5\x69\xA5\xE2" \
           "\x86\x8E\xD0\x33\x16\xFD\x1D\x99" \
           "\xDB\x95\xC6\xB8\x70\x8D\x72\x3F" \
           "\x36\xA8\xA2\x94\xB0\x3D\x0C\xD3" \
           "\xE9\x11\xB8\x73\x45\xFE\xFD\x01" \
           "\xD7\x8B\x10\x16\x65\xF5\x39\xF5" \
           "\xCD\xCB\x23\xA3\xDA\xB8\x58\xD9" \
           "\x56\x9A\x6E\x3E\x1A\xEC\x1E\xD2" \
           "\xE2\x6F\xFE\xC1\xF5\x1E\x0A\x8A" \
           "\xFA\x67\xB9\xF9\x0B\x96\xDE\xBF" \
           "\x3E\x28\xEC\xFA\x1F\x9E\xA5\x1B" \
           "\xB2\xFE\xCE\x89\xF1\xDA\xD8\x45" \
           "\x29\x9F\x07\x0C\x5C\xE9\xD0\x49" \
           "\x35\x70\x29\x33\xF3\xFF\xD7\x0A" \
           "\xC7\x82\x0F\xE2\x46\xE1\xA5\xAC" \
           "\xCF\x7B\x61\x5B\x4C\x97\x6B\x46" \
           "\x4A\x9E\x88\x7C\xA6\xC6\xF7\x73" \
           "\xE9\xC0\x2F\x3C\xBB\x0B\x14\xCD" \
           "\x86\x30\x18\x7A\x2B\x18\xDF\xA7" \
           "\xB6\xB9\x87\xEF\x5F\xF7\x83\x6D" \
           "\xC4\x35\xB6\x26\x8E\x6A\xFD\x3D" \
           "\x6A\xFF\x6B\x0E\x95\x24\x78\x42" \
           "\x38\x6E\x3B\xF1\x10\x01\x8C\xAE" \
           "\x1F\x98\x97\xC8\xA0\x75\x07\xA4" \
           "\xA9\xA6\xB6\x4A\x8D\xCD\x68\x12" \
           "\x8C\xB1\x99\xDC\x4F\x8F\x21\xAE" \
           "\xC9\x08\xFE\x99\x4B\x64\x1F\xCE" \
           "\x7F\x24\xB8\x2D\xD7\xB2\xCB\xA7" \
           "\xDC\x26\xEF\x2F\x05\x82\x55\x54" \
           "\x13\xC0\xE5\xA3\x1D\xB4\xE0\x9A" \
           "\x51\x98\x17\x0C\x3E\x1E\x1F\xCB" \
           "\x61\x7E\x17\x87\xDA\xFB\x7E\x17" \
           "\xFF\xF6\x6B\x01\x17\x65\xAC\xA8" \
           "\x60\x98\xD9\x80\x58\x65\x99\xEA" \
           "\xB5\x91\x2E\x25\xCD\xB9\xB5\x47" \
           "\xFA\xA9\x69\xCE\x11\x12\x59\xEA" \
           "\x24\x02\x92\x07\xFC\xD9\x85\x09" \
           "\xE7\xCA\x85\x8F\x96\xF7\xD0\x2A" \
           "\x51\x86\x9A\x07\xDF\xCE\xAA\xB4" \
           "\x17\xDE\xE1\xAA\x90\x7E\x4B\xE9" \
           "\x8A\x3B\x44\x46\x27\x16\xCA\xE9" \
           "\xC0\xA9\x8F\x09\x96\x1B\xE8\x23" \
           "\x5A\xB1\x37\xCE\xBF\x86\x41\x51" \
           "\x86\x72\x48\x45\x51\x77\x92\xCD" \
           "\x25\xEC\x90\x8F\x8C\x05\x75\x81" \
           "\x19\x9B\x34\xCA\x9B\xCE\x8D\xFA" \
           "\x7F\x8A\xA6\xE8\x07\xF7\x16\xDD" \
           "\x22\xF0\x3B\x50\x80\x6C\xFA\xE0" \
           "\xB7\x61\xD5\xDC\xB8\xD5\x76\x82" \
           "\x71\xF0\xDB\xD9\x3E\x06\x23\x48" \
           "\xED\xC5\x8A\x45\x6C\xFA\x2C\x47" \
           "\xAC\x0A\x49\x8C\x49\xF0\x74\xE6" \
           "\x72\x63\x10\x76\x72\x5E\xF4\xC6" \
           "\xAE\x44\xD2\xD5\x28\xEA\xF0\x75" \
           "\xBD\x1C\x2E\x43\xF7\x45\xF4\xCE" \
           "\x30\x9D\xC2\x15\x0C\xB0\x12\x2C" \
           "\xA8\xE9\x73\xC8\xFF\x15\x1B\xE9" \
           "\xE8\xF4\xB6\x38\x79\x68\x1F\xAB" \
           "\x40\xC1\x65\xD2\x22\x39\xC9\x84" \
           "\xF0\x2F\xBA\xC1\xA5\x32\x85\x47" \
           "\x13\xCC\x4A\xBA\x4C\xBB\xFF\x8E" \
           "\x8B\x81\xE1\x60\xF0\x32\x8C\x48" \
           "\xC0\x4A\x77\x84\xC9\x5E\xC6\x55" \
           "\x48\xBE\x92\x84\x7E\x0D\x54\xB9" \
           "\xE0\xD8\x5E\x9B\x26\xFC\xE5\x57" \
           "\x7F\x7A\x26\xD7\xE3\x7D\x66\x89" \
           "\xC5\xBF\xC9\x41\x2B\xED\x5B\x0D" \
           "\x19\x55\x57\x49\x07\x89\x68\x73" \
           "\xC0\x3A\x3E\x69\x11\x8D\x7D\xEF" \
           "\xCC\xDC\x46\x75\xAF\xC7\xA2\xF0" \
           "\x4A\xA1\xAC\x1C\xAB\xC0\x81\x6F" \
           "\xAE\x16\xF3\x96\x22\x86\x47\xD9" \
           "\xEE\x11\xBD\x79\xFD\xBE\xBF\x06" \
           "\xBA\x97\x9C\x74\x8E\xE6\x75\x04" \
           "\x2A\x41\xBC\x59\xA8\x6B\x64\x56" \
           "\x6D\xB7\x39\x1D\x79\x94\x10\x8A" \
           "\xE3\x78\xAC\x77\x1B\x10\x8E\x02" \
           "\x5F\xC5\xE5\x82\xE0\x27\xA0\x0A" \
           "\xA5\x96\x63\xEC\x53\x17\x17\xC3" \
           "\xCD\xD0\x75\x86\x2D\x44\x08\x67" \
           "\xEC\xEA\x39\xB9\xC2\x8D\x24\xE7" \
           "\x40\x09\x05\x66\xB0\x9C\x90\x9D" \
           "\xD4\xC7\x43\x6D\x6E\x74\x6A\xFC" \
           "\x96\x90\x54\xA4\x6F\x06\xBE\xAF" \
           "\x48\x1A\xB8\x55\x69\xEF\xA0\x76" \
           "\xEA\x6E\xF5\xC4\x03\x03\x57\x60" \
           "\x24\x16\xE7\x65\xB3\x3E\xDE\xE4" \
           "\x90\x7D\x35\x99\xBA\xC9\x67\x48" \
           "\x4F\xA5\xD7\x32\xA7\x23\x0A\x75" \
           "\x4D\x14\x13\xE4\x3B\x8D\x08\xBB" \
           "\x4D\xBE\xFA\xF4\x9C\x59\x70\x2C" \
           "\xDD\x01\x7C\x8F\x39\xE1\x15\x7B" \
           "\x77\x42\xC8\xA6\x9A\x32\xFD\xBB" \
           "\x9E\xAA\x5D\xB1\x56\xFC\x57\x61" \
           "\x2A\xED\x56\xA4\x4A\x71\xDB\xA2" \
           "\x0B\x42\xF3\x33\x3E\xC2\x2E\x83" \
           "\x5D\x4C\xDC\xF5\x99\x00\x4E\x16" \
           "\xBB\x3D\x11\x33\x24\x3B\xA4\x4C" \
           "\xE7\xEB\xDC\xF4\x67\x5D\xE1\x20" \
           "\xCE\xF7\x92\xEE\xFC\x44\xFC\x8E" \
           "\xF2\xD7\xD7\x3C\x7E\xAA\x9B\x2D" \
           "\xB2\xBA\xAD\xB4\x4B\x72\x28\x50" \
           "\x04\x0E\xFA\x4D\xFE\x72\xA5\x75" \
           "\x20\x01\x74\x97\x99\x0F\x31\xC7" \
           "\x24\xC0\x1B\x03\x45\x91\x0F\xEA" \
           "\x9C\x28\x6B\x78\xB3\x3D\x72\x51" \
           "\x32\xE3\xC8\x17\x80\x5F\x7E\xB3" \
           "\x1C\x65\xA7\xB8\xBE\xCA\xC3\x89" \
           "\x08\xC9\xAF\x2E\x20\x87\xA6\x0E" \
           "\xBD\x9B\xDE\x4B\xB3\xD8\xA0\x7C" \
           "\x8A\x03\xD3\xC5\x61\xBE\x5D\xDC" \
           "\xD6\xB5\x8F\xDE\x9D\xA6\x10\x57" \
           "\x7D\xA0\xA3\x53\x6D\x90\xEC\x57" \
           "\xE5\xC8\xC9\xF7\xC2\xAE\x03\xB9" \
           "\xD6\x80\x38\x81\x0F\x2D\x34\xF6" \
           "\xF0\x63\xB0\xCC\x97\xE6\x05\x0D" \
           "\xB1\x59\x34\xB6\xCD\xED\xB7\x82" \
           "\x6A\x42\xC8\x19\x6D\x4F\xAD\x59" \
           "\xF0\x23\xD9\x15\x88\xCA\xB5\xAB" \
           "\xB0\x41\x2E\x1C\x3D\x74\x13\xF8" \
           "\xDD\xFD\x72\xAA\x08\x61\x1E\xFE" \
           "\x7B\xCC\x48\xFD\x17\xD2\x4D\x66" \
           "\x95\xEB\x80\x35\x44\x9D\xF8\xDC" \
           "\x2B\xAC\xB1\xD9\xFF\xD5\x8F\xF6" \
           "\x74\x63\xA7\xC9\xBF\x24\x60\xDA" \
           "\xFA\x3F\xE4\x63\x24\x09\x04\x3D" \
           "\x3D\x4F\xEC\x62\xA6\xC6\xFA\x51" \
           "\x16\x64\x08\x75\xF6\x2F\xF5\xE0" \
           "\x6F\xC0\x0F\xCD\xA9\x40\xC5\x3C" \
           "\xE4\xF8\xDF\x55\x3D\x1D\x01\xE9" \
           "\x06\x87\x21\xF4\xEE\x43\x4A\x2C" \
           "\xE1\x2C\x75\xF6\x26\x44\x83\x68" \
           "\x24\x21\x93\x17\x13\x52\x9B\xDA" \
           "\xEF\xE5\xF6\xF4\x8C\x7A\x27\x32" \
           "\xAF\xC4\xC4\xF2\xF0\x98\xA8\x4D" \
           "\x0F\x58\xE0\xA8\x45\xAD\xE0\x10" \
           "\x7B\x8A\x81\x58\xDD\x7C\x9B\x83" \
           "\x0E\x08\xC0\x37\x00\x83\x33\x86" \
           "\x04\x95\xCD\xCF\xCE\x1A\x54\x78" \
           "\x8B\x1E\x70\x1F\xE5\x4E\x1C\x4B" \
           "\x12\x2C\x08\xED\xEC\xD6\xDA\x68" \
           "\x29\x75\xC1\x70\xF7\x8B\x51\x06" \
           "\xB5\x7F\x80\x01\x69\x71\x31\x1C" \
           "\xFC\x1C\x3A\xBB\xE3\xA7\x60\xBA" \
           "\xC2\x0D\x53\x59\xCD\xCA\x39\x7B" \
           "\x5D\x99\x7F\xA8\x1E\x2A\xD0\x3B" \
           , 1192);
    nSKLen = 1192;

    memcpy(bKeyByPK,
           "\x3D\xED\x54\x7A\x1C\xCB\xD6\xBB" \
           "\xE6\x5C\x94\x98\x92\x9A\x9A\xDD" \
           "\x0F\xF2\xE2\xC3\xED\x9D\x02\x9E" \
           "\xEB\x80\x07\x8D\x15\x9B\xEE\xF1" \
           "\x33\xAB\x6A\x29\xA2\x33\xFE\x52" \
           "\x32\x80\xEA\xD7\xEF\x23\x64\x21" \
           "\xEB\x43\x36\x98\x79\x6A\xD7\xE3" \
           "\xB6\x5A\xCB\xA3\x9E\xD1\xE5\xCE" \
           "\x97\xD8\xD5\xAC\x6E\x09\x1E\x1C" \
           "\x7A\xC6\x35\xFB\xE8\x3C\x01\xE9" \
           "\x90\xFE\x62\x21\x31\x06\xAC\xDA" \
           "\x96\x6D\x0D\x14\xBC\x9E\xB1\xFA" \
           "\x25\x00\xC3\xED\x91\xF0\x7F\x36" \
           "\x6F\x5E\x9D\x9E\xB4\xD5\xCA\x27" \
           "\xAC\x2B\xBC\x54\xA0\x35\x25\xD6" \
           "\x57\x04\xEF\xE9\x77\x6E\xB1\x29" \
           "\x73\xB8\xE4\x97\x1D\x64\xDB\x48" \
           "\x7B\x7A\xAB\x15\x37\xEC\x3C\xCA" \
           "\xDA\xA6\x1C\x52\x5B\x93\x4A\x45" \
           "\xEA\x8D\x19\x8F\xBD\xA9\x78\xFE" \
           "\x75\xB7\x84\xCD\x6A\x09\x1E\xC3" \
           "\x58\x2D\x44\xA3\x06\x0E\x33\xE3" \
           "\x8F\xD7\x30\xB6\x22\xB8\x6B\xEF" \
           "\xD1\x8B\x8D\xE0\x1B\xF3\xD4\x75" \
           "\xC2\xDB\x44\x7E\xDD\xF4\xD6\xA1" \
           "\x81\x2C\x99\x46\x13\x40\xAE\x74" \
           "\x1C\x0A\xAE\x40\x66\xEB\xFB\x5C" \
           "\xDD\x58\x2E\x5E\x56\x39\x93\x50" \
           "\x33\x53\x2B\xBE\x24\x5E\xBA\x1B" \
           "\xB3\x8C\xD9\x7F\x5D\x3B\x39\x28" \
           "\x6A\x5E\xEA\x6A\x8F\x3F\x2C\x64" \
           "\x44\x47\xEB\xDA\xB5\x30\xF3\xE2" \
           , 256);
    nKeyByPKLen = 256;

    memcpy(bKeyByHMKExp,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21" \
           "\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A" \
           , 16);
    nKeyByHMKLenExp = 16;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, nSKLen);
    printf("[IN ]nPKLen = %d\n", nSKLen);
    DspHex("[IN ]bKeyByPK =", bKeyByPK, nKeyByPKLen);
    printf("[IN ]nKeyByPKLen = %d\n", nKeyByPKLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPITransKeyIntoSK(nSock, nPadMode, bSK, nSKLen, bKeyByPK, \
                                nKeyByPKLen, bKeyByHMK, &nKeyByHMKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "私钥转加密，RSA-2048，PKCS#1，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bKeyByHMK    =", bKeyByHMK, nKeyByHMKLen);
    DspHex("[OUT]bKeyByHMKExp =", bKeyByHMKExp, nKeyByHMKLenExp);
    ASSERT_OUT_HEX(bKeyByHMK, bKeyByHMKExp, nKeyByHMKLenExp);
    ASSERT_OUT(nKeyByHMKLen, nKeyByHMKLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}


void PrivateAnalyse_Test_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  BYTE bSK[1280];
	  int  nSKLen;
	  int  nAlgo;
	  BYTE bKEK[32];
	  BYTE bD[276];
	  BYTE bDExp[276];
	  int  nDLen;
	  int  nDLenExp;
	  BYTE bP[144];
	  BYTE bPExp[144];
	  int  nPLen;
	  int  nPLenExp;
	  BYTE bQ[144];
	  BYTE bQExp[144];
	  int  nQLen;
	  int  nQLenExp;
	  BYTE bDmP1[144];
	  BYTE bDmP1Exp[144];
	  int  nDmP1Len;
	  int  nDmP1LenExp;
	  BYTE bDmQ1[144];
	  BYTE bDmQ1Exp[144];
	  int  nDmQ1Len;
	  int  nDmQ1LenExp;
	  BYTE bCoef[144];
	  BYTE bCoefExp[144];
	  int  nCoefLen;
	  int  nCoefLenExp;

    bufclr(bSK);
    bufclr(bKEK);
    bufclr(bD);
    bufclr(bDExp);
    bufclr(bP);
    bufclr(bPExp);
    bufclr(bQ);
    bufclr(bQExp);
    bufclr(bDmP1);
    bufclr(bDmP1Exp);
    bufclr(bDmQ1);
    bufclr(bDmQ1Exp);
    bufclr(bCoef);
    bufclr(bCoefExp);
    nDLen = 0;
    nPLen = 0;
    nQLen = 0;
    nDmP1Len = 0;
    nDmQ1Len = 0;
    nCoefLen = 0;

    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKEK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           , 8);

    memcpy(bDExp,
           "\x28\x1C\xDC\xEA\x07\xD0\xFD\x31\x82\x3F\xBD\xBC\xE2\x84\xF9\xBA"
           "\x7D\xA0\xAE\x17\xCF\x7B\x22\x4D\xD7\xF1\xFA\xE4\x0E\xD0\x10\x00"
           "\x19\xDC\x86\xEB\x1C\xFF\x65\xC1\x7C\xA4\xF3\x06\x1E\xE6\x92\xA2"
           "\xF1\x77\x27\x3F\xB4\x10\xE1\x9D\x3C\x38\x83\xE0\xE5\x51\x5C\xDD"
           , 64);
    nDLenExp = 8 + 64;
    memcpy(bPExp,
           "\xD8\x9C\x65\x90\x43\x3C\x62\xB4\xB7\x22\x91\x5C\x99\x53\x41\xDC"
           "\xB0\x2E\x5E\xF3\x73\x28\x9B\xF5\xE9\x5C\x6D\x59\x53\xCB\x72\xB9"
           , 32);
    nPLenExp = 8 + 32;
    memcpy(bQExp,
           "\x9F\xCF\x14\xC1\x84\xC1\xC6\xAC\xD4\xF8\x38\xBF\x07\xB7\x2C\xC9"
           "\x4C\x88\xF4\xED\x4E\x1E\x7E\x5A\x09\xEF\xAC\x45\x55\x3F\x49\xC3"
           , 32);
    nQLenExp = 8 + 32;
    memcpy(bDmP1Exp,
           "\x7C\x55\xAA\x6A\xED\x69\x7F\x9E\xAB\xAA\x1E\xC2\x92\xEC\x64\x0C"
           "\x42\x9B\xDC\x23\xC4\x21\x2A\x9C\xBF\xC7\xC2\x62\x6F\x12\xB8\x8E"
           , 32);
    nDmP1LenExp = 8 + 32;
    memcpy(bDmQ1Exp,
           "\x79\x9C\x86\x1C\x40\x3B\x4D\xAC\xCA\x2C\x44\x4E\x7F\xD3\xE9\xE1"
           "\x42\x08\x73\x6F\xED\x38\x34\x08\x0A\xC1\x62\x13\x51\x0E\x81\xEF"
           , 32);
    nDmQ1LenExp = 8 + 32;
    memcpy(bCoefExp,
           "\x41\xBB\x73\x7E\x61\xA9\xCB\x1E\x7A\xB2\xFA\x64\x12\xFB\xE4\x26"
           "\x78\x44\x55\xAB\x4D\x59\x46\x93\x61\xA0\x59\xC9\x1D\x7C\xF4\xEE"
           , 32);
    nCoefLenExp = 8 + 32;

    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    DspHex("[IN ]bSK      =", bSK, 320);
    printf("[IN ]nSKLen   = %d\n", nSKLen);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bKEK     =", bKEK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateAnalyse(nSock, bSK, nSKLen, nAlgo, bKEK, bD, &nDLen, \
                               bP, &nPLen, bQ, &nQLen, bDmP1, &nDmP1Len, bDmQ1, \
                               &nDmQ1Len, bCoef, &nCoefLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-512，单倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bD, bDExp, 64);
    ASSERT_OUT(nDLen, nDLenExp);
    ASSERT_OUT_HEX(bP, bPExp, 32);
    ASSERT_OUT(nPLen, nPLenExp);
    ASSERT_OUT_HEX(bQ, bQExp, 32);
    ASSERT_OUT(nQLen, nQLenExp);
    ASSERT_OUT_HEX(bDmP1, bDmP1Exp, 32);
    ASSERT_OUT(nDmP1Len, nDmP1LenExp);
    ASSERT_OUT_HEX(bDmQ1, bDmQ1Exp, 32);
    ASSERT_OUT(nDmQ1Len, nDmQ1LenExp);
    ASSERT_OUT_HEX(bCoef, bCoefExp, 32);
    ASSERT_OUT(nCoefLen, nCoefLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateAnalyse_Test_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  BYTE bSK[1280];
	  int  nSKLen;
	  int  nAlgo;
	  BYTE bKEK[32];
	  BYTE bD[276];
	  BYTE bDExp[276];
	  int  nDLen;
	  int  nDLenExp;
	  BYTE bP[144];
	  BYTE bPExp[144];
	  int  nPLen;
	  int  nPLenExp;
	  BYTE bQ[144];
	  BYTE bQExp[144];
	  int  nQLen;
	  int  nQLenExp;
	  BYTE bDmP1[144];
	  BYTE bDmP1Exp[144];
	  int  nDmP1Len;
	  int  nDmP1LenExp;
	  BYTE bDmQ1[144];
	  BYTE bDmQ1Exp[144];
	  int  nDmQ1Len;
	  int  nDmQ1LenExp;
	  BYTE bCoef[144];
	  BYTE bCoefExp[144];
	  int  nCoefLen;
	  int  nCoefLenExp;

    bufclr(bSK);
    bufclr(bKEK);
    bufclr(bD);
    bufclr(bDExp);
    bufclr(bP);
    bufclr(bPExp);
    bufclr(bQ);
    bufclr(bQExp);
    bufclr(bDmP1);
    bufclr(bDmP1Exp);
    bufclr(bDmQ1);
    bufclr(bDmQ1Exp);
    bufclr(bCoef);
    bufclr(bCoefExp);
    nDLen = 0;
    nPLen = 0;
    nQLen = 0;
    nDmP1Len = 0;
    nDmQ1Len = 0;
    nCoefLen = 0;

    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    nAlgo = 2;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKEK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           , 16);

    memcpy(bDExp,
           "\x97\x77\xED\xD4\x4E\x33\xE9\xF5\x3B\xD0\x51\x6D\xF2\x6B\x2F\x54"
           "\xE4\xEC\x70\x52\x60\x30\xA7\x95\xC7\xE9\x72\xE0\xA4\x73\xEC\xD8"
           "\x32\xBD\x90\x20\xFC\xB1\x0F\xCE\xB3\x17\x63\xFB\x1C\x8A\xD7\x89"
           "\xDF\xB9\xD7\x27\x8D\xCF\x38\xAC\x0D\xF1\x30\xC5\x5B\x95\x69\x40"
           , 64);
    nDLenExp = 8 + 64;
    memcpy(bPExp,
           "\x29\x8F\xD9\xC0\xFD\xEB\x3F\x99\xDC\xF5\xF4\x9B\xCF\x90\x8F\x25"
           "\x68\xA9\x38\xD0\x70\x20\x3D\x1A\xC8\x3B\x9C\xF7\x25\x98\x91\xC2"
           , 32);
    nPLenExp = 8 + 32;
    memcpy(bQExp,
           "\x7B\x7F\x94\x80\xFC\x1E\xCF\x5F\x7A\x9C\xD8\x0E\x0C\xA3\x8D\x1D"
           "\x0D\xA5\xC1\x01\x95\xA0\x86\x47\xA0\xF8\x56\xFD\xFD\x4C\xB8\x05"
           , 32);
    nQLenExp = 8 + 32;
    memcpy(bDmP1Exp,
           "\xC5\xEC\x05\x0E\xF0\xF1\xB7\xE6\x00\x8A\x7B\x69\xD2\x4F\x5E\xF7"
           "\x8F\x59\xCE\x3D\x7E\xAC\x9F\x13\x70\xDF\x03\x0D\xB6\xE8\x02\x18"
           , 32);
    nDmP1LenExp = 8 + 32;
    memcpy(bDmQ1Exp,
           "\xED\x01\xA5\x87\x45\xBE\x9F\xF0\x81\x56\xD3\xAD\xDE\xBD\xDF\x84"
           "\x1C\x51\x6D\x80\x7C\x49\x2F\x4E\x9E\x90\x4F\x96\xB2\xE3\x8A\xA9"
           , 32);
    nDmQ1LenExp = 8 + 32;
    memcpy(bCoefExp,
           "\xD5\xAE\xC6\xEB\x18\xDB\xA8\xC3\xD4\xE6\x0D\x30\x0A\x26\xCA\x87"
           "\x1B\x1C\xFA\xEE\x5C\x85\x04\x56\x50\x9F\xEC\x0B\x37\xFD\x36\x9F"
           , 32);
    nCoefLenExp = 8 + 32;

    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    DspHex("[IN ]bSK      =", bSK, 320);
    printf("[IN ]nSKLen   = %d\n", nSKLen);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bKEK     =", bKEK, 16);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateAnalyse(nSock, bSK, nSKLen, nAlgo, bKEK, bD, &nDLen, \
                               bP, &nPLen, bQ, &nQLen, bDmP1, &nDmP1Len, bDmQ1, \
                               &nDmQ1Len, bCoef, &nCoefLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-512，双倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bD, bDExp, 64);
    ASSERT_OUT(nDLen, nDLenExp);
    ASSERT_OUT_HEX(bP, bPExp, 32);
    ASSERT_OUT(nPLen, nPLenExp);
    ASSERT_OUT_HEX(bQ, bQExp, 32);
    ASSERT_OUT(nQLen, nQLenExp);
    ASSERT_OUT_HEX(bDmP1, bDmP1Exp, 32);
    ASSERT_OUT(nDmP1Len, nDmP1LenExp);
    ASSERT_OUT_HEX(bDmQ1, bDmQ1Exp, 32);
    ASSERT_OUT(nDmQ1Len, nDmQ1LenExp);
    ASSERT_OUT_HEX(bCoef, bCoefExp, 32);
    ASSERT_OUT(nCoefLen, nCoefLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateAnalyse_Test_03(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  BYTE bSK[1280];
	  int  nSKLen;
	  int  nAlgo;
	  BYTE bKEK[32];
	  BYTE bD[276];
	  BYTE bDExp[276];
	  int  nDLen;
	  int  nDLenExp;
	  BYTE bP[144];
	  BYTE bPExp[144];
	  int  nPLen;
	  int  nPLenExp;
	  BYTE bQ[144];
	  BYTE bQExp[144];
	  int  nQLen;
	  int  nQLenExp;
	  BYTE bDmP1[144];
	  BYTE bDmP1Exp[144];
	  int  nDmP1Len;
	  int  nDmP1LenExp;
	  BYTE bDmQ1[144];
	  BYTE bDmQ1Exp[144];
	  int  nDmQ1Len;
	  int  nDmQ1LenExp;
	  BYTE bCoef[144];
	  BYTE bCoefExp[144];
	  int  nCoefLen;
	  int  nCoefLenExp;

    bufclr(bSK);
    bufclr(bKEK);
    bufclr(bD);
    bufclr(bDExp);
    bufclr(bP);
    bufclr(bPExp);
    bufclr(bQ);
    bufclr(bQExp);
    bufclr(bDmP1);
    bufclr(bDmP1Exp);
    bufclr(bDmQ1);
    bufclr(bDmQ1Exp);
    bufclr(bCoef);
    bufclr(bCoefExp);
    nDLen = 0;
    nPLen = 0;
    nQLen = 0;
    nDmP1Len = 0;
    nDmQ1Len = 0;
    nCoefLen = 0;

    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    nAlgo = 3;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8796 A5B4 C3D2 E1F0 */
    memcpy(bKEK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           "\x59\x99\xC3\x06\xAB\x84\x01\xB2"
           , 24);

    memcpy(bDExp,
           "\x48\x7B\x59\x56\x36\x16\x37\x94\xEF\xA9\x3B\xA8\xF2\x36\x7B\xB6"
           "\xF2\x55\x77\x1B\xF0\x66\x30\x87\xA3\xB6\xAD\xB2\x5C\xC7\x9F\xA8"
           "\x0F\xBA\x1D\xA7\x30\xF5\x8F\xF3\xE6\xA9\x16\x3E\x7E\x65\xEA\x77"
           "\xC1\x5D\xF5\x59\x15\x32\x58\x90\x33\x4D\x9D\x69\xA9\x44\x93\x46"
           , 64);
    nDLenExp = 8 + 64;
    memcpy(bPExp,
           "\x7E\x50\x43\xBF\xF3\xD7\xA0\xBB\x3B\x6B\xDE\x5E\x90\xEA\xA9\xAF"
           "\x0F\x55\x4C\x3F\x83\x80\x7C\x24\x02\xCD\x35\x49\x3A\xF2\x87\xDA"
           , 32);
    nPLenExp = 8 + 32;
    memcpy(bQExp,
           "\xE8\x3B\x06\xC0\x0D\xC7\x18\x50\x78\xA4\x4F\xE2\x6D\x93\xD8\x64"
           "\x61\x52\x7B\x5C\x06\x70\x08\x58\xC2\xBA\x4E\xB8\x76\xEB\x2B\x41"
           , 32);
    nQLenExp = 8 + 32;
    memcpy(bDmP1Exp,
           "\xD1\x3D\x91\xAF\xD7\xCF\xA1\x39\x32\x87\x75\x50\x78\xC4\xF9\x82"
           "\xFC\x55\x0A\xF8\x41\x8E\x44\xFB\x0A\x45\xE9\xC6\x6F\xEF\x3D\x24"
           , 32);
    nDmP1LenExp = 8 + 32;
    memcpy(bDmQ1Exp,
           "\x9F\x3A\x6A\x8C\x20\x99\x2D\xA7\x82\xBF\xD1\x5E\x22\xCD\x5E\x13"
           "\x36\x16\xF9\x13\x19\x4B\x28\x4E\xFB\x9D\xD6\x88\x00\x59\x7F\x43"
           , 32);
    nDmQ1LenExp = 8 + 32;
    memcpy(bCoefExp,
           "\xC6\xC0\x76\x80\x30\x52\xC8\x54\x38\x21\x4A\x4C\x34\x00\x06\x12"
           "\xC9\x9D\x16\xB6\xBD\x66\x75\xF3\x0F\x9C\x43\x91\x25\x9D\x7A\x0F"
           , 32);
    nCoefLenExp = 8 + 32;


    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    DspHex("[IN ]bSK      =", bSK, 320);
    printf("[IN ]nSKLen   = %d\n", nSKLen);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bKEK     =", bKEK, 24);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateAnalyse(nSock, bSK, nSKLen, nAlgo, bKEK, bD, &nDLen, \
                               bP, &nPLen, bQ, &nQLen, bDmP1, &nDmP1Len, bDmQ1, \
                               &nDmQ1Len, bCoef, &nCoefLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-512，三倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bD, bDExp, 64);
    ASSERT_OUT(nDLen, nDLenExp);
    ASSERT_OUT_HEX(bP, bPExp, 32);
    ASSERT_OUT(nPLen, nPLenExp);
    ASSERT_OUT_HEX(bQ, bQExp, 32);
    ASSERT_OUT(nQLen, nQLenExp);
    ASSERT_OUT_HEX(bDmP1, bDmP1Exp, 32);
    ASSERT_OUT(nDmP1Len, nDmP1LenExp);
    ASSERT_OUT_HEX(bDmQ1, bDmQ1Exp, 32);
    ASSERT_OUT(nDmQ1Len, nDmQ1LenExp);
    ASSERT_OUT_HEX(bCoef, bCoefExp, 32);
    ASSERT_OUT(nCoefLen, nCoefLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateAnalyse_Test_04(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  BYTE bSK[1280];
	  int  nSKLen;
	  int  nAlgo;
	  BYTE bKEK[32];
	  BYTE bD[276];
	  BYTE bDExp[276];
	  int  nDLen;
	  int  nDLenExp;
	  BYTE bP[144];
	  BYTE bPExp[144];
	  int  nPLen;
	  int  nPLenExp;
	  BYTE bQ[144];
	  BYTE bQExp[144];
	  int  nQLen;
	  int  nQLenExp;
	  BYTE bDmP1[144];
	  BYTE bDmP1Exp[144];
	  int  nDmP1Len;
	  int  nDmP1LenExp;
	  BYTE bDmQ1[144];
	  BYTE bDmQ1Exp[144];
	  int  nDmQ1Len;
	  int  nDmQ1LenExp;
	  BYTE bCoef[144];
	  BYTE bCoefExp[144];
	  int  nCoefLen;
	  int  nCoefLenExp;

    bufclr(bSK);
    bufclr(bKEK);
    bufclr(bD);
    bufclr(bDExp);
    bufclr(bP);
    bufclr(bPExp);
    bufclr(bQ);
    bufclr(bQExp);
    bufclr(bDmP1);
    bufclr(bDmP1Exp);
    bufclr(bDmQ1);
    bufclr(bDmQ1Exp);
    bufclr(bCoef);
    bufclr(bCoefExp);
    nDLen = 0;
    nPLen = 0;
    nQLen = 0;
    nDmP1Len = 0;
    nDmQ1Len = 0;
    nCoefLen = 0;

    memcpy(bSK,
           "\x3B\xD4\x50\x5C\x7E\x86\x10\xCE\x25\x5C\xB9\x39\xC2\xD4\x61\x5C"
           "\x7F\xC2\xC4\x74\xE5\x22\x06\xCD\x50\x53\xAF\x84\x02\xF7\xE6\x54"
           "\x85\x44\x18\x4D\xE9\x05\x89\xF5\x5D\x0E\xC0\x55\x6A\xD2\x53\xA5"
           "\x36\x71\x2D\xD5\xFD\xEA\x8A\x45\x4C\xC6\x00\x3B\xE7\x01\x70\x1C"
           "\xEC\xA6\xD1\xF4\x7D\xF0\xD5\xF5\xB6\x5A\x00\x43\xBC\xF0\x6A\x79"
           "\xFF\xD3\x30\xB8\x5F\xFA\xEA\xE0\xD1\x9E\x6C\x02\xAE\x9A\x13\xF0"
           "\x09\xED\xB1\x9C\x0A\xBE\xA9\xB7\x93\x66\xBB\x08\xC6\x0A\xA2\xFD"
           "\xFE\x19\xBF\x9E\x9E\x7C\x1C\xCF\xBB\xF6\x3F\x4D\x1A\x35\xF9\x26"
           "\x2A\xF4\x84\x29\x43\x79\xE7\x3D\x9B\x58\xF9\x30\xE1\x27\x3B\xC0"
           "\xD7\xE7\xEF\xF8\x52\x50\x2C\x85\x65\x1B\x1C\x3D\x2D\xA9\x73\x8F"
           "\xCA\x54\xF3\x60\xE4\x84\x67\xAC\xEB\xAA\x24\x30\xC9\x98\x9D\x4B"
           "\x2E\xF3\xD7\xE1\x93\xCA\xC0\x63\x3F\xD1\xE4\xAF\x08\x37\x63\xB5"
           "\x8A\xDB\x3E\x66\x44\x4E\x01\x7F\x75\x92\xB4\x5D\x79\x6C\x94\x9B"
           "\x4C\x55\x2F\x9A\x26\xD9\x54\x65\x67\x41\x4A\xAC\x1F\x7C\x4A\xFE"
           "\x1E\xDD\xDD\xE1\x51\x3A\xB2\xE2\x92\xFA\x3F\x8D\xFF\xEE\x78\x0A"
           "\xBB\xFB\xD6\x94\xE3\x39\x48\xF8\xF1\xC0\x3A\x36\xF4\x65\xF6\xB9"
           "\x2A\x2C\xEE\x71\x11\xAA\x7B\x55\xBF\x9D\x13\x0F\x74\x47\x05\x87"
           "\x27\xF0\x9F\x65\x6E\xED\xAF\x2B\x78\x69\xFE\x3A\x40\xA3\xDB\x58"
           "\xCC\x5C\x83\xC5\x0E\x9B\xF3\xB5\x8B\x6D\xA8\xBE\x0C\x5E\x38\x2A"
           "\x12\x8C\x3E\x40\xA1\x03\x43\x20\x6B\x4B\x3D\x65\x8C\x96\x13\x5F"
           "\x58\x56\x87\x88\x20\x0A\x12\xD8\x42\x95\x55\x5D\xDD\x74\x23\xF3"
           "\x05\x77\x04\x02\xBC\x97\x6E\xED\xEB\x33\x10\x4B\x8C\x58\x0C\xDF"
           "\x9A\x54\xCD\xB9\x69\xAA\x0B\x15\x13\x8B\x95\x87\x55\xFC\x05\x0A"
           "\x81\x5E\x00\x9D\x50\x9D\x7D\x73\x94\x6B\x78\x30\x40\xC7\xF4\x89"
           "\x76\x9F\x1D\x3B\x69\xAE\x65\x5C\xF5\xAB\xF8\xC0\x33\x0F\xA3\x02"
           "\xA4\x41\x96\x86\x47\x75\x2F\x3B\xC4\x3D\xE8\x5A\x88\xAB\xB9\x74"
           "\xB9\x8F\xA7\xDC\xBE\x35\xE0\xA1\x31\xA1\xEE\xAC\xD3\x01\x97\x67"
           "\x65\x1D\x81\x74\x38\x11\xEF\xC5\x0F\xDD\x6B\x70\x98\xF8\xDC\x91"
           "\xFA\x20\xDD\x34\x9F\xB4\xB2\x09\x6B\x90\xD7\x81\xBA\xD4\x34\xEA"
           "\x24\x83\x49\x86\x3C\xDF\x51\x98\xDB\xA2\x68\x53\xC3\x41\x47\x3B"
           "\x70\x13\x1B\xC7\xB1\x4B\x64\xD3\xD1\x46\xF6\x97\x04\x65\x8C\x24"
           "\x13\xD0\xE5\x85\x7D\xBF\x31\x3A\xB5\x49\x14\xF1\x3F\xFA\xB5\xC1"
           "\x47\x61\x69\x76\x6E\xD2\x9D\x84\xA0\x88\xD6\x65\x35\x6E\xD4\xEB"
           "\x57\x1D\x9F\xF5\xB5\x10\x5D\x12\x05\xA1\xF2\x5A\x37\x4D\x9A\x65"
           "\xBA\xE8\x69\x9B\x02\x93\xAD\x7A\x84\xB0\x6E\xF2\xB6\xB3\x86\x11"
           "\x8F\xF8\xB2\x23\x4E\xD4\x33\x74\x9C\xB4\x91\xD8\x57\x01\x18\x14"
           "\x8A\x63\x13\xFB\x17\x1B\x91\x0E\x35\x71\xD2\x0A\x73\xCD\x99\xA9"
           "\x5C\x10\xD3\xDE\x93\xF4\x5A\x63\xCB\x08\x1E\x8F\x38\x0E\x1A\xB1"
           "\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78"
           , 616);
    nSKLen = 616;
    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKEK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           , 8);

    memcpy(bDExp,
           "\xB8\xF3\x10\xF8\xB6\x89\x63\x8B\x8E\xB5\x91\x1C\x29\xE6\x4F\x0E"
           "\x34\x82\x5F\xDA\xAE\x75\x6F\xFF\x19\xB6\xA3\x6E\x54\x0A\x1C\x18"
           "\xFC\x9F\x20\xE6\xF4\x74\xF2\x29\x82\xDB\x4A\xB3\xAF\x17\x77\xAA"
           "\x6D\xB0\x33\x43\x00\x97\xA3\x1E\x3A\x44\x23\xAE\x0A\x64\xEC\xB3"
           "\x77\xEA\x36\x54\x34\x4E\x3F\x89\x13\x3A\xB4\x81\x17\x58\xD9\x57"
           "\xDC\x02\xC0\x7F\x9A\x3E\x11\xDB\x7C\x60\x8E\xA6\x6D\x6B\x27\x06"
           "\x99\x85\xC7\x5B\xF3\xFC\x84\x9D\xA5\xA5\x53\x7F\xE7\x44\xE2\x48"
           "\x44\x5D\x65\x17\x5B\xE4\xFD\xAE\x39\x58\x50\xF9\x93\xF9\xC0\x66"
           , 128);
    nDLenExp = 8 + 128;
    memcpy(bPExp,
           "\x97\x5F\x33\x41\x1A\xA0\x89\x9C\x12\xA4\x75\x94\xF8\x5E\xE3\x42"
           "\xD5\xCA\x40\x7B\x3E\x2F\x5D\xF2\xF9\xBC\x7B\xC7\x04\x04\x75\x0D"
           "\xE6\xB0\xE6\xF2\x31\xB8\xF3\x5D\x0C\x3C\xDD\xEE\xF5\x97\xAA\xE5"
           "\xB3\xD9\x3D\xE4\xD2\x03\xD2\x2A\xE7\x3A\x5E\xAB\x6C\x08\x13\x44"
           , 64);
    nPLenExp = 8 + 64;
    memcpy(bQExp,
           "\xB3\x4C\x23\x3F\x1A\x5F\x6D\xC2\x04\x4F\x27\xB4\xBF\x85\x79\x42"
           "\xC1\x7C\xC2\xE4\x48\xAA\xF1\x76\x54\x2B\x79\x6B\xEE\x83\x40\xAF"
           "\x9A\xD9\x10\xFA\xBC\xD8\xA7\x73\x0C\x27\x62\x63\x08\xA7\x85\xCE"
           "\x4F\x17\xA7\x1D\x29\xB6\x65\x57\xB3\x10\x33\xC3\xA2\xC7\xC8\x4C"
           , 64);
    nQLenExp = 8 + 64;
    memcpy(bDmP1Exp,
           "\x68\x7D\x99\xFF\xE1\x97\x27\x44\x45\x44\x5D\xC2\x78\xF5\xE2\x3D"
           "\xB0\x96\x43\x2A\x95\xD6\x0C\x1D\x6C\xBD\x82\xB9\x21\x0E\xD9\x49"
           "\x1E\x13\xFD\x71\x90\xC9\xE1\xAA\x7F\x05\xCF\x7E\x8C\x3B\x97\x68"
           "\xB6\x5A\x03\xF2\x88\xD9\x65\x59\x07\x36\x6D\x9B\x2A\x1E\x59\x43"
           , 64);
    nDmP1LenExp = 8 + 64;
    memcpy(bDmQ1Exp,
           "\x3A\x60\xF3\xAC\xC8\x33\xAF\xE2\x6B\x1F\x94\xAD\x28\xCE\xAF\x5C"
           "\xF0\x3B\x0C\x58\xEC\x0E\x55\x5D\x2B\x86\xF9\x0D\x57\x86\xAC\x52"
           "\x89\xDD\x3C\x07\x8B\xB0\xA5\xB9\xE9\x8D\xF2\xC8\xA5\x31\x12\xDB"
           "\x84\x5E\x9A\x44\xC7\x61\xA3\xF5\x85\x4B\x30\x84\x8B\xE4\x90\x31"
           , 64);
    nDmQ1LenExp = 8 + 64;
    memcpy(bCoefExp,
           "\x97\x4E\x9E\x0A\x40\x68\x3B\x4C\xC0\x18\x6D\x53\x24\x66\xD3\x9E"
           "\xB6\x80\x9C\x04\xAA\x5D\x72\xE5\x0A\xA4\x14\x63\x78\xEA\xE4\x36"
           "\x30\x18\x07\xFB\x5D\x1E\x0E\x4C\x2E\x22\xF3\xBC\x5D\x46\xC1\xFD"
           "\x14\x08\xD3\x3A\x86\x86\x7A\xA9\x1E\x5D\xF4\xCD\xCD\x5B\x4E\x2A"
           , 64);
    nCoefLenExp = 8 + 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    DspHex("[IN ]bSK      =", bSK, 616);
    printf("[IN ]nSKLen   = %d\n", nSKLen);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bKEK     =", bKEK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateAnalyse(nSock, bSK, nSKLen, nAlgo, bKEK, bD, &nDLen, \
                               bP, &nPLen, bQ, &nQLen, bDmP1, &nDmP1Len, bDmQ1, \
                               &nDmQ1Len, bCoef, &nCoefLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1024，单倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bD, bDExp, 128);
    ASSERT_OUT(nDLen, nDLenExp);
    ASSERT_OUT_HEX(bP, bPExp, 64);
    ASSERT_OUT(nPLen, nPLenExp);
    ASSERT_OUT_HEX(bQ, bQExp, 64);
    ASSERT_OUT(nQLen, nQLenExp);
    ASSERT_OUT_HEX(bDmP1, bDmP1Exp, 64);
    ASSERT_OUT(nDmP1Len, nDmP1LenExp);
    ASSERT_OUT_HEX(bDmQ1, bDmQ1Exp, 64);
    ASSERT_OUT(nDmQ1Len, nDmQ1LenExp);
    ASSERT_OUT_HEX(bCoef, bCoefExp, 64);
    ASSERT_OUT(nCoefLen, nCoefLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateAnalyse_Test_05(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  BYTE bSK[1280];
	  int  nSKLen;
	  int  nAlgo;
	  BYTE bKEK[32];
	  BYTE bD[276];
	  BYTE bDExp[276];
	  int  nDLen;
	  int  nDLenExp;
	  BYTE bP[144];
	  BYTE bPExp[144];
	  int  nPLen;
	  int  nPLenExp;
	  BYTE bQ[144];
	  BYTE bQExp[144];
	  int  nQLen;
	  int  nQLenExp;
	  BYTE bDmP1[144];
	  BYTE bDmP1Exp[144];
	  int  nDmP1Len;
	  int  nDmP1LenExp;
	  BYTE bDmQ1[144];
	  BYTE bDmQ1Exp[144];
	  int  nDmQ1Len;
	  int  nDmQ1LenExp;
	  BYTE bCoef[144];
	  BYTE bCoefExp[144];
	  int  nCoefLen;
	  int  nCoefLenExp;

    bufclr(bSK);
    bufclr(bKEK);
    bufclr(bD);
    bufclr(bDExp);
    bufclr(bP);
    bufclr(bPExp);
    bufclr(bQ);
    bufclr(bQExp);
    bufclr(bDmP1);
    bufclr(bDmP1Exp);
    bufclr(bDmQ1);
    bufclr(bDmQ1Exp);
    bufclr(bCoef);
    bufclr(bCoefExp);
    nDLen = 0;
    nPLen = 0;
    nQLen = 0;
    nDmP1Len = 0;
    nDmQ1Len = 0;
    nCoefLen = 0;

    memcpy(bSK,
           "\x3B\xD4\x50\x5C\x7E\x86\x10\xCE\x25\x5C\xB9\x39\xC2\xD4\x61\x5C"
           "\x7F\xC2\xC4\x74\xE5\x22\x06\xCD\x50\x53\xAF\x84\x02\xF7\xE6\x54"
           "\x85\x44\x18\x4D\xE9\x05\x89\xF5\x5D\x0E\xC0\x55\x6A\xD2\x53\xA5"
           "\x36\x71\x2D\xD5\xFD\xEA\x8A\x45\x4C\xC6\x00\x3B\xE7\x01\x70\x1C"
           "\xEC\xA6\xD1\xF4\x7D\xF0\xD5\xF5\xB6\x5A\x00\x43\xBC\xF0\x6A\x79"
           "\xFF\xD3\x30\xB8\x5F\xFA\xEA\xE0\xD1\x9E\x6C\x02\xAE\x9A\x13\xF0"
           "\x09\xED\xB1\x9C\x0A\xBE\xA9\xB7\x93\x66\xBB\x08\xC6\x0A\xA2\xFD"
           "\xFE\x19\xBF\x9E\x9E\x7C\x1C\xCF\xBB\xF6\x3F\x4D\x1A\x35\xF9\x26"
           "\x2A\xF4\x84\x29\x43\x79\xE7\x3D\x9B\x58\xF9\x30\xE1\x27\x3B\xC0"
           "\xD7\xE7\xEF\xF8\x52\x50\x2C\x85\x65\x1B\x1C\x3D\x2D\xA9\x73\x8F"
           "\xCA\x54\xF3\x60\xE4\x84\x67\xAC\xEB\xAA\x24\x30\xC9\x98\x9D\x4B"
           "\x2E\xF3\xD7\xE1\x93\xCA\xC0\x63\x3F\xD1\xE4\xAF\x08\x37\x63\xB5"
           "\x8A\xDB\x3E\x66\x44\x4E\x01\x7F\x75\x92\xB4\x5D\x79\x6C\x94\x9B"
           "\x4C\x55\x2F\x9A\x26\xD9\x54\x65\x67\x41\x4A\xAC\x1F\x7C\x4A\xFE"
           "\x1E\xDD\xDD\xE1\x51\x3A\xB2\xE2\x92\xFA\x3F\x8D\xFF\xEE\x78\x0A"
           "\xBB\xFB\xD6\x94\xE3\x39\x48\xF8\xF1\xC0\x3A\x36\xF4\x65\xF6\xB9"
           "\x2A\x2C\xEE\x71\x11\xAA\x7B\x55\xBF\x9D\x13\x0F\x74\x47\x05\x87"
           "\x27\xF0\x9F\x65\x6E\xED\xAF\x2B\x78\x69\xFE\x3A\x40\xA3\xDB\x58"
           "\xCC\x5C\x83\xC5\x0E\x9B\xF3\xB5\x8B\x6D\xA8\xBE\x0C\x5E\x38\x2A"
           "\x12\x8C\x3E\x40\xA1\x03\x43\x20\x6B\x4B\x3D\x65\x8C\x96\x13\x5F"
           "\x58\x56\x87\x88\x20\x0A\x12\xD8\x42\x95\x55\x5D\xDD\x74\x23\xF3"
           "\x05\x77\x04\x02\xBC\x97\x6E\xED\xEB\x33\x10\x4B\x8C\x58\x0C\xDF"
           "\x9A\x54\xCD\xB9\x69\xAA\x0B\x15\x13\x8B\x95\x87\x55\xFC\x05\x0A"
           "\x81\x5E\x00\x9D\x50\x9D\x7D\x73\x94\x6B\x78\x30\x40\xC7\xF4\x89"
           "\x76\x9F\x1D\x3B\x69\xAE\x65\x5C\xF5\xAB\xF8\xC0\x33\x0F\xA3\x02"
           "\xA4\x41\x96\x86\x47\x75\x2F\x3B\xC4\x3D\xE8\x5A\x88\xAB\xB9\x74"
           "\xB9\x8F\xA7\xDC\xBE\x35\xE0\xA1\x31\xA1\xEE\xAC\xD3\x01\x97\x67"
           "\x65\x1D\x81\x74\x38\x11\xEF\xC5\x0F\xDD\x6B\x70\x98\xF8\xDC\x91"
           "\xFA\x20\xDD\x34\x9F\xB4\xB2\x09\x6B\x90\xD7\x81\xBA\xD4\x34\xEA"
           "\x24\x83\x49\x86\x3C\xDF\x51\x98\xDB\xA2\x68\x53\xC3\x41\x47\x3B"
           "\x70\x13\x1B\xC7\xB1\x4B\x64\xD3\xD1\x46\xF6\x97\x04\x65\x8C\x24"
           "\x13\xD0\xE5\x85\x7D\xBF\x31\x3A\xB5\x49\x14\xF1\x3F\xFA\xB5\xC1"
           "\x47\x61\x69\x76\x6E\xD2\x9D\x84\xA0\x88\xD6\x65\x35\x6E\xD4\xEB"
           "\x57\x1D\x9F\xF5\xB5\x10\x5D\x12\x05\xA1\xF2\x5A\x37\x4D\x9A\x65"
           "\xBA\xE8\x69\x9B\x02\x93\xAD\x7A\x84\xB0\x6E\xF2\xB6\xB3\x86\x11"
           "\x8F\xF8\xB2\x23\x4E\xD4\x33\x74\x9C\xB4\x91\xD8\x57\x01\x18\x14"
           "\x8A\x63\x13\xFB\x17\x1B\x91\x0E\x35\x71\xD2\x0A\x73\xCD\x99\xA9"
           "\x5C\x10\xD3\xDE\x93\xF4\x5A\x63\xCB\x08\x1E\x8F\x38\x0E\x1A\xB1"
           "\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78"
           , 616);
    nSKLen = 616;
    nAlgo = 2;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKEK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           , 16);

    memcpy(bDExp,
           "\xB5\x68\xC6\x39\x71\xD3\x32\x97\xE6\x67\xA1\xC0\x81\xF8\x29\xFC"
           "\x54\xDB\x0B\x3B\x5D\x56\x9A\x3E\xE4\x80\x82\xDC\xCC\x8E\xBE\x7B"
           "\x9C\x81\x48\x3D\x36\x4E\x19\xE3\x83\x72\x23\x59\xC9\xA0\x0A\xF7"
           "\x5E\xD3\xD2\xFF\xA6\xE0\x13\xAD\xE2\xCF\xA0\x12\x55\x8D\xE9\x0F"
           "\x37\x2B\x0E\x9E\x88\x16\x81\xC5\xBC\xA2\x74\x52\xA7\xCB\xAC\xD1"
           "\x6B\x86\x8E\xC1\x58\x01\x3D\xE0\x97\xDC\x61\x46\x2A\x20\x87\xCB"
           "\x35\x27\x44\x18\xBB\x70\xBE\x39\x65\xB7\xA0\x98\xC3\xC4\x42\x35"
           "\xAA\x69\xAD\xEC\xE0\xE9\xAD\x1D\xB3\x9F\x96\x06\x3B\xE6\x2F\xA8"
           , 128);
    nDLenExp = 8 + 128;
    memcpy(bPExp,
           "\xA5\x6C\xE6\x20\x1C\xDE\x02\x22\x5A\x2A\xD3\xDA\x0F\xA5\x72\x52"
           "\xCD\x1F\x2B\xD1\x68\x60\x76\x0C\x00\x4A\x0C\x66\xDB\xC3\xFF\x23"
           "\xE1\x60\x7D\x4A\xBD\xC2\x29\xBA\x75\x57\xC6\xA2\xB4\xC7\x23\x35"
           "\xE4\xD9\x95\x3E\xD2\xF2\xC3\xDF\xBB\x27\x3F\x96\x6F\x9A\x38\xCF"
           , 64);
    nPLenExp = 8 + 64;
    memcpy(bQExp,
           "\x33\xF3\x5D\x00\x22\x35\x20\xEB\x1A\x91\x03\x2E\x8D\x15\xA3\x0D"
           "\x0F\xBD\xD9\x80\x61\x78\x3F\xEA\xAB\x09\xC9\x62\xF4\xCB\x65\x37"
           "\x1C\x79\xDD\x4D\x8B\xFE\x0B\xAC\x65\x32\xAC\x01\x13\x23\x41\x2E"
           "\x8F\xD0\xF4\x57\x86\x7B\x8F\xFF\xD1\x14\x14\x0E\x77\x60\xFC\x60"
           , 64);
    nQLenExp = 8 + 64;
    memcpy(bDmP1Exp,
           "\x4A\x8D\x92\xB1\x6D\xDF\xA0\xB0\x4D\x11\xB0\xB3\x24\x44\x11\x0B"
           "\xA3\xB3\x76\x19\x0A\x2E\xFC\xE4\xBF\xFB\x15\x32\x39\x18\x5E\x15"
           "\x10\xE3\x4B\x01\x1F\x7E\x79\xBC\x11\x7C\x0B\x08\x3A\x51\xAA\x10"
           "\xFF\xF3\xD0\xA3\x16\x4D\x25\x98\xC7\x59\x11\xBB\xBB\x1E\x8E\x90"
           , 64);
    nDmP1LenExp = 8 + 64;
    memcpy(bDmQ1Exp,
           "\x9C\xC0\x21\x24\xC1\x53\x11\x4E\x3F\x9E\xFC\xCB\x0D\xA9\xB7\xA2"
           "\x04\x8B\x06\x5A\x59\xC4\xFE\xD6\xF7\xBF\x91\x7E\xD1\x95\x1A\xA0"
           "\xD2\x8C\x5D\x3D\x42\x3D\x17\xF0\x8A\x91\xCD\x61\x32\xCB\xF4\x9F"
           "\xFC\x80\xBD\xE3\x8C\x44\x14\xEC\x1D\x2E\x9F\x5E\x68\xCE\xB1\xEB"
           , 64);
    nDmQ1LenExp = 8 + 64;
    memcpy(bCoefExp,
           "\x46\xC6\x96\x7C\x12\x0F\xAA\xFE\xD2\xFE\x4C\xAC\x16\x9E\x96\x47"
           "\x45\xC0\xDB\xCB\xBC\x2F\xB4\x89\x68\xF5\xCC\xAB\xA3\x40\xAD\xDA"
           "\xB0\x10\x1E\xD4\xA2\x44\x84\xBB\xBD\x34\x93\x36\x4F\xB7\x17\x88"
           "\x87\x49\xFC\x6E\x6A\x0E\xE1\x63\xAD\x57\x32\x9D\x0D\xB0\x19\x1A"
           , 64);
    nCoefLenExp = 8 + 64;

    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    DspHex("[IN ]bSK      =", bSK, 616);
    printf("[IN ]nSKLen   = %d\n", nSKLen);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bKEK     =", bKEK, 16);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateAnalyse(nSock, bSK, nSKLen, nAlgo, bKEK, bD, &nDLen, \
                               bP, &nPLen, bQ, &nQLen, bDmP1, &nDmP1Len, bDmQ1, \
                               &nDmQ1Len, bCoef, &nCoefLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1024，双倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bD, bDExp, 128);
    ASSERT_OUT(nDLen, nDLenExp);
    ASSERT_OUT_HEX(bP, bPExp, 64);
    ASSERT_OUT(nPLen, nPLenExp);
    ASSERT_OUT_HEX(bQ, bQExp, 64);
    ASSERT_OUT(nQLen, nQLenExp);
    ASSERT_OUT_HEX(bDmP1, bDmP1Exp, 64);
    ASSERT_OUT(nDmP1Len, nDmP1LenExp);
    ASSERT_OUT_HEX(bDmQ1, bDmQ1Exp, 64);
    ASSERT_OUT(nDmQ1Len, nDmQ1LenExp);
    ASSERT_OUT_HEX(bCoef, bCoefExp, 64);
    ASSERT_OUT(nCoefLen, nCoefLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateAnalyse_Test_06(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  BYTE bSK[1280];
	  int  nSKLen;
	  int  nAlgo;
	  BYTE bKEK[32];
	  BYTE bD[276];
	  BYTE bDExp[276];
	  int  nDLen;
	  int  nDLenExp;
	  BYTE bP[144];
	  BYTE bPExp[144];
	  int  nPLen;
	  int  nPLenExp;
	  BYTE bQ[144];
	  BYTE bQExp[144];
	  int  nQLen;
	  int  nQLenExp;
	  BYTE bDmP1[144];
	  BYTE bDmP1Exp[144];
	  int  nDmP1Len;
	  int  nDmP1LenExp;
	  BYTE bDmQ1[144];
	  BYTE bDmQ1Exp[144];
	  int  nDmQ1Len;
	  int  nDmQ1LenExp;
	  BYTE bCoef[144];
	  BYTE bCoefExp[144];
	  int  nCoefLen;
	  int  nCoefLenExp;

    bufclr(bSK);
    bufclr(bKEK);
    bufclr(bD);
    bufclr(bDExp);
    bufclr(bP);
    bufclr(bPExp);
    bufclr(bQ);
    bufclr(bQExp);
    bufclr(bDmP1);
    bufclr(bDmP1Exp);
    bufclr(bDmQ1);
    bufclr(bDmQ1Exp);
    bufclr(bCoef);
    bufclr(bCoefExp);
    nDLen = 0;
    nPLen = 0;
    nQLen = 0;
    nDmP1Len = 0;
    nDmQ1Len = 0;
    nCoefLen = 0;

    memcpy(bSK,
           "\x3B\xD4\x50\x5C\x7E\x86\x10\xCE\x25\x5C\xB9\x39\xC2\xD4\x61\x5C"
           "\x7F\xC2\xC4\x74\xE5\x22\x06\xCD\x50\x53\xAF\x84\x02\xF7\xE6\x54"
           "\x85\x44\x18\x4D\xE9\x05\x89\xF5\x5D\x0E\xC0\x55\x6A\xD2\x53\xA5"
           "\x36\x71\x2D\xD5\xFD\xEA\x8A\x45\x4C\xC6\x00\x3B\xE7\x01\x70\x1C"
           "\xEC\xA6\xD1\xF4\x7D\xF0\xD5\xF5\xB6\x5A\x00\x43\xBC\xF0\x6A\x79"
           "\xFF\xD3\x30\xB8\x5F\xFA\xEA\xE0\xD1\x9E\x6C\x02\xAE\x9A\x13\xF0"
           "\x09\xED\xB1\x9C\x0A\xBE\xA9\xB7\x93\x66\xBB\x08\xC6\x0A\xA2\xFD"
           "\xFE\x19\xBF\x9E\x9E\x7C\x1C\xCF\xBB\xF6\x3F\x4D\x1A\x35\xF9\x26"
           "\x2A\xF4\x84\x29\x43\x79\xE7\x3D\x9B\x58\xF9\x30\xE1\x27\x3B\xC0"
           "\xD7\xE7\xEF\xF8\x52\x50\x2C\x85\x65\x1B\x1C\x3D\x2D\xA9\x73\x8F"
           "\xCA\x54\xF3\x60\xE4\x84\x67\xAC\xEB\xAA\x24\x30\xC9\x98\x9D\x4B"
           "\x2E\xF3\xD7\xE1\x93\xCA\xC0\x63\x3F\xD1\xE4\xAF\x08\x37\x63\xB5"
           "\x8A\xDB\x3E\x66\x44\x4E\x01\x7F\x75\x92\xB4\x5D\x79\x6C\x94\x9B"
           "\x4C\x55\x2F\x9A\x26\xD9\x54\x65\x67\x41\x4A\xAC\x1F\x7C\x4A\xFE"
           "\x1E\xDD\xDD\xE1\x51\x3A\xB2\xE2\x92\xFA\x3F\x8D\xFF\xEE\x78\x0A"
           "\xBB\xFB\xD6\x94\xE3\x39\x48\xF8\xF1\xC0\x3A\x36\xF4\x65\xF6\xB9"
           "\x2A\x2C\xEE\x71\x11\xAA\x7B\x55\xBF\x9D\x13\x0F\x74\x47\x05\x87"
           "\x27\xF0\x9F\x65\x6E\xED\xAF\x2B\x78\x69\xFE\x3A\x40\xA3\xDB\x58"
           "\xCC\x5C\x83\xC5\x0E\x9B\xF3\xB5\x8B\x6D\xA8\xBE\x0C\x5E\x38\x2A"
           "\x12\x8C\x3E\x40\xA1\x03\x43\x20\x6B\x4B\x3D\x65\x8C\x96\x13\x5F"
           "\x58\x56\x87\x88\x20\x0A\x12\xD8\x42\x95\x55\x5D\xDD\x74\x23\xF3"
           "\x05\x77\x04\x02\xBC\x97\x6E\xED\xEB\x33\x10\x4B\x8C\x58\x0C\xDF"
           "\x9A\x54\xCD\xB9\x69\xAA\x0B\x15\x13\x8B\x95\x87\x55\xFC\x05\x0A"
           "\x81\x5E\x00\x9D\x50\x9D\x7D\x73\x94\x6B\x78\x30\x40\xC7\xF4\x89"
           "\x76\x9F\x1D\x3B\x69\xAE\x65\x5C\xF5\xAB\xF8\xC0\x33\x0F\xA3\x02"
           "\xA4\x41\x96\x86\x47\x75\x2F\x3B\xC4\x3D\xE8\x5A\x88\xAB\xB9\x74"
           "\xB9\x8F\xA7\xDC\xBE\x35\xE0\xA1\x31\xA1\xEE\xAC\xD3\x01\x97\x67"
           "\x65\x1D\x81\x74\x38\x11\xEF\xC5\x0F\xDD\x6B\x70\x98\xF8\xDC\x91"
           "\xFA\x20\xDD\x34\x9F\xB4\xB2\x09\x6B\x90\xD7\x81\xBA\xD4\x34\xEA"
           "\x24\x83\x49\x86\x3C\xDF\x51\x98\xDB\xA2\x68\x53\xC3\x41\x47\x3B"
           "\x70\x13\x1B\xC7\xB1\x4B\x64\xD3\xD1\x46\xF6\x97\x04\x65\x8C\x24"
           "\x13\xD0\xE5\x85\x7D\xBF\x31\x3A\xB5\x49\x14\xF1\x3F\xFA\xB5\xC1"
           "\x47\x61\x69\x76\x6E\xD2\x9D\x84\xA0\x88\xD6\x65\x35\x6E\xD4\xEB"
           "\x57\x1D\x9F\xF5\xB5\x10\x5D\x12\x05\xA1\xF2\x5A\x37\x4D\x9A\x65"
           "\xBA\xE8\x69\x9B\x02\x93\xAD\x7A\x84\xB0\x6E\xF2\xB6\xB3\x86\x11"
           "\x8F\xF8\xB2\x23\x4E\xD4\x33\x74\x9C\xB4\x91\xD8\x57\x01\x18\x14"
           "\x8A\x63\x13\xFB\x17\x1B\x91\x0E\x35\x71\xD2\x0A\x73\xCD\x99\xA9"
           "\x5C\x10\xD3\xDE\x93\xF4\x5A\x63\xCB\x08\x1E\x8F\x38\x0E\x1A\xB1"
           "\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78"
           , 616);
    nSKLen = 616;
    nAlgo = 3;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8796 A5B4 C3D2 E1F0 */
    memcpy(bKEK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           "\x59\x99\xC3\x06\xAB\x84\x01\xB2"
           , 24);

    memcpy(bDExp,
           "\x57\xA3\x42\x5E\xBA\x23\xAC\x7E\x0D\xAD\x32\xD2\xFC\x71\x37\x0A"
           "\xC9\x75\x76\xA3\x4D\xBC\x68\x7D\x84\x2C\xE0\x2A\xC5\xB3\x9D\xA7"
           "\xFB\x06\xF1\xFC\xF2\x63\x5C\x12\x4E\xD5\x71\x93\x07\x22\xEA\x78"
           "\xC7\xDC\xE9\x4E\xE1\x18\xA6\x8D\x90\xED\x21\x62\x91\xF0\x01\x6A"
           "\x4D\x4B\x56\x11\x91\x76\x25\x59\xF4\x87\x02\xE2\x45\x63\xDA\x96"
           "\x2D\x66\x0A\x60\x5A\xC6\xFF\xC8\xC7\xC4\xA2\xDC\x93\x89\xF4\xCB"
           "\x77\x6E\x98\xE6\xD7\x67\x4E\x87\xF1\xFB\x9A\xDA\x57\x13\x42\xD9"
           "\x13\xE2\x23\xE2\xFB\xAA\x80\xE3\x49\x80\xDA\xE9\x54\x7F\xD8\xEE"
           , 128);
    nDLenExp = 8 + 128;
    memcpy(bPExp,
           "\xF5\x1E\xCF\x05\x61\x4B\xCA\x3E\xD7\x67\xB6\x43\x62\x3E\x0E\x74"
           "\x43\x38\x12\xD8\x39\x61\x69\x83\x3F\x45\x21\xD7\x5F\xB3\x08\xC4"
           "\x3D\x4B\x20\x28\xF8\xC3\x04\x3C\xD5\x52\xDB\x72\xA3\xDC\xE1\xDB"
           "\x90\xE4\x69\x9C\xAB\x79\x26\x42\x58\x6C\x5B\x7C\x03\xEE\x58\x42"
           , 64);
    nPLenExp = 8 + 64;
    memcpy(bQExp,
           "\x79\x8A\x94\x9E\x03\x79\x07\x4F\x42\x11\x78\x7F\xE3\x44\xBD\xD1"
           "\x7E\xD4\x28\x10\x6A\xC7\x68\x6A\x49\xF3\x14\xE2\x7C\x4F\x6B\x04"
           "\xF3\xA5\x89\x74\xC0\x72\x9C\x4D\xFA\x82\xF7\x72\xC9\x7B\x50\x30"
           "\x20\xA9\x65\x1F\xEB\xE0\x85\x04\xD3\x3B\x2F\x2B\x15\x8A\xE0\x42"
           , 64);
    nQLenExp = 8 + 64;
    memcpy(bDmP1Exp,
           "\x46\x71\x1D\x84\x3F\x9F\xF9\xF6\xFE\x19\xC7\x21\xC1\xF8\x29\xCC"
           "\x24\xF4\x62\xA9\xCF\x52\xAA\xE1\x0C\x71\xB5\x78\xA4\x19\xA2\x30"
           "\xA1\x58\xB3\xD6\x20\x84\xD2\xA5\x45\x02\x88\x1C\x66\x17\xC3\x9D"
           "\x5B\xC1\x47\x77\xFB\x25\x7E\x09\xC9\x7F\x1E\xE6\x1D\x11\x72\xE4"
           , 64);
    nDmP1LenExp = 8 + 64;
    memcpy(bDmQ1Exp,
           "\xC9\x34\x24\xDC\xA1\x67\x17\x91\x48\x0D\x37\x0C\x96\x77\x5F\x0A"
           "\xA4\x6A\xC8\xB2\xDB\x70\xAE\x8E\xBB\xF7\xAB\xAD\xA0\x7D\x40\xBB"
           "\x14\x77\x82\xA5\x10\xCB\xEE\x82\xA7\xD5\xBA\x8D\x24\x07\x61\xA3"
           "\xCB\x45\xE8\xFB\x49\x17\xA6\xD5\xD4\xDB\x13\x41\xB1\xA5\x07\xF6"
           , 64);
    nDmQ1LenExp = 8 + 64;
    memcpy(bCoefExp,
           "\xA7\xE0\xB7\x22\xA6\x59\xEA\xF2\x03\xA1\x21\x7F\x73\x4E\x23\x4F"
           "\x9A\xEC\xB0\xA7\xD6\xB7\x6B\xF1\xEC\x43\x07\x83\xE7\x58\x86\xFD"
           "\x3A\xA3\x9F\x92\xBB\xE3\x14\x53\x57\x6A\x48\xD3\xB8\x87\x45\x2B"
           "\xB4\x11\x38\x07\xB5\x59\x4C\x36\xD7\x19\xF0\xDA\xC4\x42\x92\x05"
           , 64);
    nCoefLenExp = 8 + 64;


    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    DspHex("[IN ]bSK      =", bSK, 616);
    printf("[IN ]nSKLen   = %d\n", nSKLen);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bKEK     =", bKEK, 24);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateAnalyse(nSock, bSK, nSKLen, nAlgo, bKEK, bD, &nDLen, \
                               bP, &nPLen, bQ, &nQLen, bDmP1, &nDmP1Len, bDmQ1, \
                               &nDmQ1Len, bCoef, &nCoefLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1024，三倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bD, bDExp, 128);
    ASSERT_OUT(nDLen, nDLenExp);
    ASSERT_OUT_HEX(bP, bPExp, 64);
    ASSERT_OUT(nPLen, nPLenExp);
    ASSERT_OUT_HEX(bQ, bQExp, 64);
    ASSERT_OUT(nQLen, nQLenExp);
    ASSERT_OUT_HEX(bDmP1, bDmP1Exp, 64);
    ASSERT_OUT(nDmP1Len, nDmP1LenExp);
    ASSERT_OUT_HEX(bDmQ1, bDmQ1Exp, 64);
    ASSERT_OUT(nDmQ1Len, nDmQ1LenExp);
    ASSERT_OUT_HEX(bCoef, bCoefExp, 64);
    ASSERT_OUT(nCoefLen, nCoefLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateAnalyse_Test_07(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  BYTE bSK[1280];
	  int  nSKLen;
	  int  nAlgo;
	  BYTE bKEK[32];
	  BYTE bD[276];
	  BYTE bDExp[276];
	  int  nDLen;
	  int  nDLenExp;
	  BYTE bP[144];
	  BYTE bPExp[144];
	  int  nPLen;
	  int  nPLenExp;
	  BYTE bQ[144];
	  BYTE bQExp[144];
	  int  nQLen;
	  int  nQLenExp;
	  BYTE bDmP1[144];
	  BYTE bDmP1Exp[144];
	  int  nDmP1Len;
	  int  nDmP1LenExp;
	  BYTE bDmQ1[144];
	  BYTE bDmQ1Exp[144];
	  int  nDmQ1Len;
	  int  nDmQ1LenExp;
	  BYTE bCoef[144];
	  BYTE bCoefExp[144];
	  int  nCoefLen;
	  int  nCoefLenExp;

    bufclr(bSK);
    bufclr(bKEK);
    bufclr(bD);
    bufclr(bDExp);
    bufclr(bP);
    bufclr(bPExp);
    bufclr(bQ);
    bufclr(bQExp);
    bufclr(bDmP1);
    bufclr(bDmP1Exp);
    bufclr(bDmQ1);
    bufclr(bDmQ1Exp);
    bufclr(bCoef);
    bufclr(bCoefExp);
    nDLen = 0;
    nPLen = 0;
    nQLen = 0;
    nDmP1Len = 0;
    nDmQ1Len = 0;
    nCoefLen = 0;

    memcpy(bSK,
           "\xDF\x00\x50\x67\x45\x67\xCB\xA9\xF3\x62\x34\x84\x08\x05\xEE\x96"
           "\x70\x77\x07\xC3\x71\x70\xAD\xC0\xE9\x02\xE7\x50\x58\xCB\x00\xCF"
           "\x55\xAA\xB9\xE0\x3D\x47\x8D\xC8\x38\x3A\x78\x92\xB2\x54\x98\xEF"
           "\x5A\x46\x80\x77\x58\x05\x1E\x94\xA8\x62\xE6\xFA\x5C\x54\x15\x48"
           "\x2D\xDB\x8C\x41\x31\x90\x9F\xE9\x4D\x87\x7A\x21\xB9\xA3\x13\xE5"
           "\xE0\xED\x09\x27\x17\xB6\xB1\xAA\x23\xBE\x5F\x80\x9F\x25\xF2\xE1"
           "\x7A\xB2\xCB\x36\xF2\xE5\x2A\x6F\x63\xD1\x4C\xD6\x53\x07\xBF\x83"
           "\x4F\x59\xE1\x20\x63\x9C\x33\x38\x88\xD3\x79\x7D\xF1\x47\x6E\x16"
           "\x3F\x38\xF3\xCF\x0D\x25\xF4\xD5\x28\x76\x55\x5C\x22\x54\x1B\xAD"
           "\xCC\xB6\x21\x81\xFC\x32\xE0\xCF\x8C\x30\x3A\x96\x31\x48\x02\x7E"
           "\x0E\x2A\x4B\x99\x46\x5C\xCA\x23\x82\x41\xA6\x9B\x8A\x71\xF4\x4E"
           "\x7A\xCF\xBE\x9D\xEC\x18\x90\x04\xF2\x6F\x9F\xD9\x76\xFD\x43\x17"
           "\x81\xF0\xD7\xB8\x1B\xE6\x7C\xBB\x5F\xB9\x9D\x8E\x96\x4D\xC5\xE3"
           "\x7A\x98\xBA\x11\x2B\x52\x62\xA3\x48\x6F\x9C\x8F\x3F\x4A\x88\xF4"
           "\xEA\x82\x59\xBD\x2D\x55\x06\x8F\x51\x8D\x37\xA0\xB0\xF4\xA7\x23"
           "\x76\x86\xFF\x68\xEA\x6C\x64\xFE\xC0\xCD\x6C\x48\x20\xCB\xD2\x77"
           "\x31\x73\xD8\x50\x5A\x13\x84\x98\x8D\x0A\xF1\xB9\x8A\xD8\x87\x54"
           "\xDC\xB4\xBA\x6A\x0E\x7D\x04\x4D\x7C\x6C\xF6\xE3\x50\x65\xEF\xC2"
           "\x9C\x70\x39\x70\x99\x60\x53\x70\x88\x1D\xA2\x56\x1A\x78\xB8\x15"
           "\x17\x81\x3F\xEC\x07\x0A\xE0\x33\x7A\x82\x0B\xE2\x21\x53\x1B\x27"
           "\x7C\x06\x69\x00\x82\xB3\xAB\x74\xE9\x43\xDD\xCC\x69\x2C\xF8\x51"
           "\xAF\xEB\xEE\x15\x6E\xE0\x35\xA8\x6A\x0D\x35\x8A\x01\x98\x68\x8A"
           "\xC5\x71\xAA\x8C\xDB\x31\xC7\x04\x5D\xEF\x33\x50\x1A\x66\xC9\xBF"
           "\x85\xE8\x30\xBF\x8E\x36\x86\xA3\xB0\xBF\x18\x8E\xA0\x93\xB3\x5C"
           "\xD2\xD3\x6E\x57\x86\x14\x30\x5D\xC5\x29\x0B\x5A\xEF\xEA\xA3\x9C"
           "\xC0\xDD\x9B\xDF\x67\xB9\xAF\x01\xC4\x0C\x83\xE1\x36\x95\x4E\xB6"
           "\xF2\x61\x4F\xB8\x09\x8E\x66\x90\x23\xE7\x6D\xD1\x71\xF4\xF4\xE7"
           "\xF4\x3B\x54\x8D\x91\x05\x89\xB5\xFE\x78\xBA\x30\x87\xF5\xB5\xE6"
           "\xE8\x55\x5B\xCA\x64\xAF\x89\x59\xA0\x50\x8A\x7D\x19\x40\xDF\x49"
           "\x31\xEA\xEF\x76\x70\x2E\x1F\xC7\x05\x7E\xA0\x2A\x42\x17\xA2\x0A"
           "\x32\xAC\x36\x7F\x31\xFF\x11\xED\x06\x13\x03\xC6\xDF\xEF\xC4\x27"
           "\x8C\x29\xE3\x36\xE6\xDE\xBC\xE8\x7B\xB5\x7B\x9A\xCB\x93\xF1\x21"
           "\x26\x38\x94\xDA\xF5\x1B\xD7\x2F\xA9\x3C\xEC\xE3\xDC\xD6\xD8\xFC"
           "\x03\x4D\xE1\x49\xA2\x22\x6E\xFD\x57\x80\xAB\xF4\xFA\xD5\xC2\x53"
           "\xCE\x6D\xB2\x61\xE3\xA8\x22\xD8\xD2\x9C\xFE\x85\xE2\x80\xA0\x9D"
           "\x1E\xAF\x00\x3F\xF2\x36\xE1\xE5\xBC\x32\x73\x7E\xD0\x6E\x18\x66"
           "\x48\x64\x91\x0E\xB6\x70\x82\xAA\x40\xFA\x2D\xB5\x27\x0A\x71\x17"
           "\x15\x96\xD4\x2B\xEF\xB4\x82\xA2\x4C\x7C\x08\x2B\x9E\xD6\x99\x56"
           "\x20\x08\xCD\x7D\x6B\x5E\x38\x53\x67\x13\x38\xED\x16\x44\x71\x12"
           "\x97\x4B\x84\xE7\xCE\x12\x53\x70\x46\x6A\x71\x51\xAD\x8B\x71\x2D"
           "\xE5\x4C\xF7\xFF\xCE\x39\xB3\xA0\xB1\x46\x26\x4F\x1A\x63\x0C\xB9"
           "\xEE\x8F\xC7\x8E\x61\x24\xD0\xFB\xD4\x33\x00\xFD\x85\x23\x8B\x12"
           "\x09\x49\x7D\xA8\xE2\x9D\x2E\xFD"
           , 680);
    nSKLen = 680;
    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKEK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           , 8);

    memcpy(bDExp,
           "\xF4\x02\x1F\x96\x7F\xDF\xF8\xF6\xAC\xBB\xBD\x3F\x2F\x4A\x33\x85"
           "\x65\xA6\x70\xD6\xDC\xCE\xE7\x63\x1F\x58\xEB\x18\x83\x7E\xDA\xFC"
           "\xD8\x14\xA6\xD7\x23\x65\x87\xFD\xB8\xAD\xCA\xA0\xFB\xAF\x74\xEA"
           "\xD3\x7F\x54\xB6\x78\x9F\x67\xED\x55\xF8\x85\x4F\xD7\x45\xDA\xFC"
           "\x50\x71\xCC\xE5\xB6\xF9\xA9\xB1\xCA\xE4\x92\xC2\x0F\x49\xFC\x7F"
           "\xBA\x9B\xA4\x27\xE1\x9A\x7E\xBA\x3B\x80\xFC\xA7\x51\xBF\xE9\x7A"
           "\x03\x07\x27\x85\x4F\x66\x87\x71\xAF\x9D\x6B\x9C\x20\x2A\xC9\xCB"
           "\x52\xF1\x88\x09\x8B\x34\x5F\x7B\x65\xC7\x24\x5E\x0E\x8F\x58\xB0"
           "\x9F\x35\xA7\x65\xB0\x47\xE8\xA6\xC3\x0E\x9F\xFE\x4C\x31\x08\x75"
           , 144);
    nDLenExp = 8 + 144;
    memcpy(bPExp,
           "\x55\xC4\xD2\x74\x1A\xD7\x17\x37\xBF\x46\xC5\xCE\x59\xE6\x3B\x06"
           "\x30\x3F\x2D\x91\xBC\x43\x80\xFE\x49\x8C\x8F\xEB\x3E\x4F\xA8\xB9"
           "\x80\x5F\x78\xA7\x36\x8F\x03\x79\xF2\x9A\x6D\xB3\x71\xCA\x73\xF0"
           "\x5A\x4A\x30\x96\x2B\x0D\xBD\x89\xFF\x33\x9F\xFA\xB6\x82\xA6\xCF"
           "\x31\x4F\x40\xAA\x79\x2C\x3A\x2A"
           , 72);
    nPLenExp = 8 + 72;
    memcpy(bQExp,
           "\x8C\xAD\x63\xBD\xBD\x2C\xBF\x7B\x05\x01\x5F\xF3\xB4\xF5\xAC\x29"
           "\x42\x98\xFD\xA4\x33\x1A\x1B\x3E\x29\x6A\xDE\x97\x55\x74\xF0\x81"
           "\x00\xF5\x6B\xC6\xC0\x8D\x63\xAE\xD4\x49\xC2\x55\x08\x2A\xE9\xC6"
           "\xDD\xDA\xD8\x2D\x59\x3F\xA3\x98\x75\x93\x69\xA5\x5B\xCD\x3D\x2F"
           "\x74\x88\x40\x11\x68\xAC\xF3\x6A"
           , 72);
    nQLenExp = 8 + 72;
    memcpy(bDmP1Exp,
           "\xC7\x31\xC1\x97\xA6\xD9\xFC\x90\xCB\x9B\x96\x88\xFB\x78\x56\x0C"
           "\x3E\xB0\x04\xBF\x06\xF7\xAA\x03\x32\x87\xB4\x81\xD7\x1C\x6F\xCF"
           "\x85\xB4\x46\xA6\x34\xC7\x7D\x3D\x48\xDB\xD1\x7C\xA6\xCE\x00\x28"
           "\xB4\x2F\x21\xC5\x5A\x8E\xAC\x91\x48\xB7\x29\xF7\x03\xDE\x17\x82"
           "\xD5\x54\x20\xB8\x05\x95\xF5\xB2"
           , 72);
    nDmP1LenExp = 8 + 72;
    memcpy(bDmQ1Exp,
           "\xFC\xA9\xE1\x80\xD5\x60\x96\xCB\x64\x63\x06\x52\x4B\x08\x6D\xCB"
           "\x5A\xE6\xFD\xB6\x88\xB5\x01\x34\x40\x76\xBC\x79\x1E\xBB\x1C\xD5"
           "\xB7\xC4\x0A\x2C\xCC\x30\x74\xBC\x92\x3E\x77\xA9\x26\x71\x98\x7D"
           "\xE8\xA6\x49\xB4\x64\xFD\xC1\xD3\x34\x85\x1D\x44\xD7\xB2\x80\x3B"
           "\xFE\xAA\x79\x55\x58\x00\xF2\xCE"
           , 72);
    nDmQ1LenExp = 8 + 72;
    memcpy(bCoefExp,
           "\x53\xBF\x9A\x80\x88\x0D\x8B\xF2\xCD\x38\x89\xAD\x37\x23\x90\x6F"
           "\x99\x09\xDC\xF2\x91\x22\x1D\x71\x56\xDD\x79\x74\xF0\x9E\xC3\x93"
           "\x9C\x81\xFC\x73\xA2\x76\xF2\x32\xB3\xFC\xDF\xCA\x9D\x8D\x94\x0D"
           "\xB3\x0B\xB1\xB7\x90\xFA\xDC\x4D\x17\x83\xAE\x0E\x6A\xF7\xAB\x73"
           "\x9D\xE9\x1C\x59\x3F\x39\xFB\xD0"
           , 72);
    nCoefLenExp = 8 + 72;

    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    DspHex("[IN ]bSK      =", bSK, 680);
    printf("[IN ]nSKLen   = %d\n", nSKLen);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bKEK     =", bKEK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateAnalyse(nSock, bSK, nSKLen, nAlgo, bKEK, bD, &nDLen, \
                               bP, &nPLen, bQ, &nQLen, bDmP1, &nDmP1Len, bDmQ1, \
                               &nDmQ1Len, bCoef, &nCoefLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1152，单倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bD, bDExp, 144);
    ASSERT_OUT(nDLen, nDLenExp);
    ASSERT_OUT_HEX(bP, bPExp, 72);
    ASSERT_OUT(nPLen, nPLenExp);
    ASSERT_OUT_HEX(bQ, bQExp, 72);
    ASSERT_OUT(nQLen, nQLenExp);
    ASSERT_OUT_HEX(bDmP1, bDmP1Exp, 72);
    ASSERT_OUT(nDmP1Len, nDmP1LenExp);
    ASSERT_OUT_HEX(bDmQ1, bDmQ1Exp, 72);
    ASSERT_OUT(nDmQ1Len, nDmQ1LenExp);
    ASSERT_OUT_HEX(bCoef, bCoefExp, 72);
    ASSERT_OUT(nCoefLen, nCoefLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateAnalyse_Test_08(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  BYTE bSK[1280];
	  int  nSKLen;
	  int  nAlgo;
	  BYTE bKEK[32];
	  BYTE bD[276];
	  BYTE bDExp[276];
	  int  nDLen;
	  int  nDLenExp;
	  BYTE bP[144];
	  BYTE bPExp[144];
	  int  nPLen;
	  int  nPLenExp;
	  BYTE bQ[144];
	  BYTE bQExp[144];
	  int  nQLen;
	  int  nQLenExp;
	  BYTE bDmP1[144];
	  BYTE bDmP1Exp[144];
	  int  nDmP1Len;
	  int  nDmP1LenExp;
	  BYTE bDmQ1[144];
	  BYTE bDmQ1Exp[144];
	  int  nDmQ1Len;
	  int  nDmQ1LenExp;
	  BYTE bCoef[144];
	  BYTE bCoefExp[144];
	  int  nCoefLen;
	  int  nCoefLenExp;

    bufclr(bSK);
    bufclr(bKEK);
    bufclr(bD);
    bufclr(bDExp);
    bufclr(bP);
    bufclr(bPExp);
    bufclr(bQ);
    bufclr(bQExp);
    bufclr(bDmP1);
    bufclr(bDmP1Exp);
    bufclr(bDmQ1);
    bufclr(bDmQ1Exp);
    bufclr(bCoef);
    bufclr(bCoefExp);
    nDLen = 0;
    nPLen = 0;
    nQLen = 0;
    nDmP1Len = 0;
    nDmQ1Len = 0;
    nCoefLen = 0;

    memcpy(bSK,
           "\xDF\x00\x50\x67\x45\x67\xCB\xA9\xF3\x62\x34\x84\x08\x05\xEE\x96"
           "\x70\x77\x07\xC3\x71\x70\xAD\xC0\xE9\x02\xE7\x50\x58\xCB\x00\xCF"
           "\x55\xAA\xB9\xE0\x3D\x47\x8D\xC8\x38\x3A\x78\x92\xB2\x54\x98\xEF"
           "\x5A\x46\x80\x77\x58\x05\x1E\x94\xA8\x62\xE6\xFA\x5C\x54\x15\x48"
           "\x2D\xDB\x8C\x41\x31\x90\x9F\xE9\x4D\x87\x7A\x21\xB9\xA3\x13\xE5"
           "\xE0\xED\x09\x27\x17\xB6\xB1\xAA\x23\xBE\x5F\x80\x9F\x25\xF2\xE1"
           "\x7A\xB2\xCB\x36\xF2\xE5\x2A\x6F\x63\xD1\x4C\xD6\x53\x07\xBF\x83"
           "\x4F\x59\xE1\x20\x63\x9C\x33\x38\x88\xD3\x79\x7D\xF1\x47\x6E\x16"
           "\x3F\x38\xF3\xCF\x0D\x25\xF4\xD5\x28\x76\x55\x5C\x22\x54\x1B\xAD"
           "\xCC\xB6\x21\x81\xFC\x32\xE0\xCF\x8C\x30\x3A\x96\x31\x48\x02\x7E"
           "\x0E\x2A\x4B\x99\x46\x5C\xCA\x23\x82\x41\xA6\x9B\x8A\x71\xF4\x4E"
           "\x7A\xCF\xBE\x9D\xEC\x18\x90\x04\xF2\x6F\x9F\xD9\x76\xFD\x43\x17"
           "\x81\xF0\xD7\xB8\x1B\xE6\x7C\xBB\x5F\xB9\x9D\x8E\x96\x4D\xC5\xE3"
           "\x7A\x98\xBA\x11\x2B\x52\x62\xA3\x48\x6F\x9C\x8F\x3F\x4A\x88\xF4"
           "\xEA\x82\x59\xBD\x2D\x55\x06\x8F\x51\x8D\x37\xA0\xB0\xF4\xA7\x23"
           "\x76\x86\xFF\x68\xEA\x6C\x64\xFE\xC0\xCD\x6C\x48\x20\xCB\xD2\x77"
           "\x31\x73\xD8\x50\x5A\x13\x84\x98\x8D\x0A\xF1\xB9\x8A\xD8\x87\x54"
           "\xDC\xB4\xBA\x6A\x0E\x7D\x04\x4D\x7C\x6C\xF6\xE3\x50\x65\xEF\xC2"
           "\x9C\x70\x39\x70\x99\x60\x53\x70\x88\x1D\xA2\x56\x1A\x78\xB8\x15"
           "\x17\x81\x3F\xEC\x07\x0A\xE0\x33\x7A\x82\x0B\xE2\x21\x53\x1B\x27"
           "\x7C\x06\x69\x00\x82\xB3\xAB\x74\xE9\x43\xDD\xCC\x69\x2C\xF8\x51"
           "\xAF\xEB\xEE\x15\x6E\xE0\x35\xA8\x6A\x0D\x35\x8A\x01\x98\x68\x8A"
           "\xC5\x71\xAA\x8C\xDB\x31\xC7\x04\x5D\xEF\x33\x50\x1A\x66\xC9\xBF"
           "\x85\xE8\x30\xBF\x8E\x36\x86\xA3\xB0\xBF\x18\x8E\xA0\x93\xB3\x5C"
           "\xD2\xD3\x6E\x57\x86\x14\x30\x5D\xC5\x29\x0B\x5A\xEF\xEA\xA3\x9C"
           "\xC0\xDD\x9B\xDF\x67\xB9\xAF\x01\xC4\x0C\x83\xE1\x36\x95\x4E\xB6"
           "\xF2\x61\x4F\xB8\x09\x8E\x66\x90\x23\xE7\x6D\xD1\x71\xF4\xF4\xE7"
           "\xF4\x3B\x54\x8D\x91\x05\x89\xB5\xFE\x78\xBA\x30\x87\xF5\xB5\xE6"
           "\xE8\x55\x5B\xCA\x64\xAF\x89\x59\xA0\x50\x8A\x7D\x19\x40\xDF\x49"
           "\x31\xEA\xEF\x76\x70\x2E\x1F\xC7\x05\x7E\xA0\x2A\x42\x17\xA2\x0A"
           "\x32\xAC\x36\x7F\x31\xFF\x11\xED\x06\x13\x03\xC6\xDF\xEF\xC4\x27"
           "\x8C\x29\xE3\x36\xE6\xDE\xBC\xE8\x7B\xB5\x7B\x9A\xCB\x93\xF1\x21"
           "\x26\x38\x94\xDA\xF5\x1B\xD7\x2F\xA9\x3C\xEC\xE3\xDC\xD6\xD8\xFC"
           "\x03\x4D\xE1\x49\xA2\x22\x6E\xFD\x57\x80\xAB\xF4\xFA\xD5\xC2\x53"
           "\xCE\x6D\xB2\x61\xE3\xA8\x22\xD8\xD2\x9C\xFE\x85\xE2\x80\xA0\x9D"
           "\x1E\xAF\x00\x3F\xF2\x36\xE1\xE5\xBC\x32\x73\x7E\xD0\x6E\x18\x66"
           "\x48\x64\x91\x0E\xB6\x70\x82\xAA\x40\xFA\x2D\xB5\x27\x0A\x71\x17"
           "\x15\x96\xD4\x2B\xEF\xB4\x82\xA2\x4C\x7C\x08\x2B\x9E\xD6\x99\x56"
           "\x20\x08\xCD\x7D\x6B\x5E\x38\x53\x67\x13\x38\xED\x16\x44\x71\x12"
           "\x97\x4B\x84\xE7\xCE\x12\x53\x70\x46\x6A\x71\x51\xAD\x8B\x71\x2D"
           "\xE5\x4C\xF7\xFF\xCE\x39\xB3\xA0\xB1\x46\x26\x4F\x1A\x63\x0C\xB9"
           "\xEE\x8F\xC7\x8E\x61\x24\xD0\xFB\xD4\x33\x00\xFD\x85\x23\x8B\x12"
           "\x09\x49\x7D\xA8\xE2\x9D\x2E\xFD"
           , 680);
    nSKLen = 680;
    nAlgo = 2;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKEK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           , 16);

    memcpy(bDExp,
           "\xB7\xFE\x36\x05\x9B\x00\x3D\x64\x22\x12\xE2\x64\xB6\xC5\x16\x85"
           "\xC9\x6B\x9C\x4B\x5B\x8F\xC2\xA2\x0B\xDA\xD9\x96\xBD\x3D\x5E\xC2"
           "\xD9\x17\xCF\x8C\xF8\x44\x68\x84\xAD\x33\xA0\xC9\xC5\xA5\xC3\xFF"
           "\xDD\xC5\x16\xF3\x3B\xE3\x01\x89\x91\xBB\x10\xDE\x01\x7E\x14\xC9"
           "\x95\x0D\xFC\x42\x21\xBB\xE7\x74\x99\x59\x8F\xC6\xCC\xAD\x19\x28"
           "\xFD\x9C\xC8\xBC\x28\xF2\xE2\x36\xEA\x29\xD4\x8A\xC6\x69\xD0\xE9"
           "\xA8\xEB\xCA\x4B\xD8\x0B\xB7\x61\xF0\x4D\x57\x89\x8F\x31\x8C\xF3"
           "\x5A\xB0\x22\x01\x7B\x2E\xB3\xBF\xBA\xB4\x51\x72\x89\x62\xD4\xDB"
           "\x4F\x06\x1C\x72\x2C\x59\x93\x62\x03\x5C\xE2\x68\x03\x12\x27\xD4"
           , 144);
    nDLenExp = 8 + 144;
    memcpy(bPExp,
           "\x8B\xE2\x30\xA6\x33\x07\x69\x42\x42\x2E\x92\xB1\x57\xEE\xE8\xDF"
           "\xD7\x63\xED\x41\xEC\x11\x3C\xCB\x52\x9F\x0D\x6D\x9A\x4D\x63\x9B"
           "\x4A\xA3\x95\x02\x68\xA7\x07\x82\xE4\x37\xF1\xC7\x02\xC1\x0D\xE0"
           "\x7A\xBC\x3A\xEE\xF5\xD7\xF0\x1C\xAD\x3A\x58\x10\xB4\x00\x6A\x22"
           "\x70\x36\xAE\x64\x8D\x39\x09\xC4"
           , 72);
    nPLenExp = 8 + 72;
    memcpy(bQExp,
           "\x8F\xFF\x20\xC6\xE6\x34\xAB\x0C\x7E\x20\x1D\x77\x9E\x74\x63\xF0"
           "\x4A\xBF\x3C\xFD\xD9\x40\xE9\xA6\xBA\xA7\x75\x03\x97\x2E\x2B\xB6"
           "\xE8\x52\xCF\x47\x5B\x89\xA6\x7A\x57\x44\x6C\x29\x84\x18\x84\x3C"
           "\x48\xB0\x34\xE3\x8B\xE2\xBD\x3C\xBD\xFE\x8A\xC4\xDB\xE0\xA1\x62"
           "\x37\xC0\x12\xAE\x20\x49\xFB\x95"
           , 72);
    nQLenExp = 8 + 72;
    memcpy(bDmP1Exp,
           "\x00\x84\xC1\x10\x98\xC9\x33\xC8\xDD\x34\x7C\x27\x62\x85\xEC\xDD"
           "\x24\x14\x01\xE9\x44\x14\x3E\x29\x2C\x38\xBC\xB1\x1A\x0A\x3B\x3F"
           "\x37\x65\x0A\xAD\x55\x01\x6E\x04\x04\x3C\xEF\x2F\x30\xEB\x8B\xF4"
           "\xBA\x1E\xB7\xD6\xBE\xCE\x98\xE0\x49\x94\x50\xF6\x88\x71\x4F\xBB"
           "\xBD\xF5\x2E\x97\xE9\x25\xB1\x2A"
           , 72);
    nDmP1LenExp = 8 + 72;
    memcpy(bDmQ1Exp,
           "\xCF\xAB\x42\xB4\xC9\xEB\x31\xD0\xF6\xB1\xDA\x6B\x2A\x88\x86\xAA"
           "\xEC\x19\x67\x51\x37\x70\xCF\x05\x71\x21\xB5\x87\xC7\x4D\x81\xC7"
           "\xC2\xD4\xA8\xF8\x18\xFB\xED\x38\x06\x34\x5F\x54\x86\x52\x16\xFC"
           "\x0B\x37\x2F\x90\x3E\xB9\x64\xDC\x5C\x16\x0D\x76\x42\x7A\x23\x8A"
           "\xFD\xBE\x17\x4D\x6B\x9A\xF6\x71"
           , 72);
    nDmQ1LenExp = 8 + 72;
    memcpy(bCoefExp,
           "\xDC\x96\x8B\x11\xCC\x85\x7C\x9C\x8A\x9B\x5D\x0D\x5F\x49\x7B\x4E"
           "\xBE\x66\xD4\xD9\x5B\x48\xDF\xB0\x47\xE4\x3C\x51\x25\x30\x7D\x7E"
           "\xA2\xBB\xDB\xE1\x26\xFC\x1B\x9F\x67\x74\x54\x42\xD5\xAA\x0A\x2C"
           "\x08\x96\xF6\x42\x84\x43\x5B\x2B\x02\xA5\x89\x57\x2C\x8C\xBE\xA7"
           "\x1D\x5B\x2B\x42\x81\x68\x17\xAA"
           , 72);
    nCoefLenExp = 8 + 72;

    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    DspHex("[IN ]bSK      =", bSK, 680);
    printf("[IN ]nSKLen   = %d\n", nSKLen);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bKEK     =", bKEK, 16);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateAnalyse(nSock, bSK, nSKLen, nAlgo, bKEK, bD, &nDLen, \
                               bP, &nPLen, bQ, &nQLen, bDmP1, &nDmP1Len, bDmQ1, \
                               &nDmQ1Len, bCoef, &nCoefLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1152，双倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bD, bDExp, 144);
    ASSERT_OUT(nDLen, nDLenExp);
    ASSERT_OUT_HEX(bP, bPExp, 72);
    ASSERT_OUT(nPLen, nPLenExp);
    ASSERT_OUT_HEX(bQ, bQExp, 72);
    ASSERT_OUT(nQLen, nQLenExp);
    ASSERT_OUT_HEX(bDmP1, bDmP1Exp, 72);
    ASSERT_OUT(nDmP1Len, nDmP1LenExp);
    ASSERT_OUT_HEX(bDmQ1, bDmQ1Exp, 72);
    ASSERT_OUT(nDmQ1Len, nDmQ1LenExp);
    ASSERT_OUT_HEX(bCoef, bCoefExp, 72);
    ASSERT_OUT(nCoefLen, nCoefLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateAnalyse_Test_09(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  BYTE bSK[1280];
	  int  nSKLen;
	  int  nAlgo;
	  BYTE bKEK[32];
	  BYTE bD[276];
	  BYTE bDExp[276];
	  int  nDLen;
	  int  nDLenExp;
	  BYTE bP[144];
	  BYTE bPExp[144];
	  int  nPLen;
	  int  nPLenExp;
	  BYTE bQ[144];
	  BYTE bQExp[144];
	  int  nQLen;
	  int  nQLenExp;
	  BYTE bDmP1[144];
	  BYTE bDmP1Exp[144];
	  int  nDmP1Len;
	  int  nDmP1LenExp;
	  BYTE bDmQ1[144];
	  BYTE bDmQ1Exp[144];
	  int  nDmQ1Len;
	  int  nDmQ1LenExp;
	  BYTE bCoef[144];
	  BYTE bCoefExp[144];
	  int  nCoefLen;
	  int  nCoefLenExp;

    bufclr(bSK);
    bufclr(bKEK);
    bufclr(bD);
    bufclr(bDExp);
    bufclr(bP);
    bufclr(bPExp);
    bufclr(bQ);
    bufclr(bQExp);
    bufclr(bDmP1);
    bufclr(bDmP1Exp);
    bufclr(bDmQ1);
    bufclr(bDmQ1Exp);
    bufclr(bCoef);
    bufclr(bCoefExp);
    nDLen = 0;
    nPLen = 0;
    nQLen = 0;
    nDmP1Len = 0;
    nDmQ1Len = 0;
    nCoefLen = 0;

    memcpy(bSK,
           "\xDF\x00\x50\x67\x45\x67\xCB\xA9\xF3\x62\x34\x84\x08\x05\xEE\x96"
           "\x70\x77\x07\xC3\x71\x70\xAD\xC0\xE9\x02\xE7\x50\x58\xCB\x00\xCF"
           "\x55\xAA\xB9\xE0\x3D\x47\x8D\xC8\x38\x3A\x78\x92\xB2\x54\x98\xEF"
           "\x5A\x46\x80\x77\x58\x05\x1E\x94\xA8\x62\xE6\xFA\x5C\x54\x15\x48"
           "\x2D\xDB\x8C\x41\x31\x90\x9F\xE9\x4D\x87\x7A\x21\xB9\xA3\x13\xE5"
           "\xE0\xED\x09\x27\x17\xB6\xB1\xAA\x23\xBE\x5F\x80\x9F\x25\xF2\xE1"
           "\x7A\xB2\xCB\x36\xF2\xE5\x2A\x6F\x63\xD1\x4C\xD6\x53\x07\xBF\x83"
           "\x4F\x59\xE1\x20\x63\x9C\x33\x38\x88\xD3\x79\x7D\xF1\x47\x6E\x16"
           "\x3F\x38\xF3\xCF\x0D\x25\xF4\xD5\x28\x76\x55\x5C\x22\x54\x1B\xAD"
           "\xCC\xB6\x21\x81\xFC\x32\xE0\xCF\x8C\x30\x3A\x96\x31\x48\x02\x7E"
           "\x0E\x2A\x4B\x99\x46\x5C\xCA\x23\x82\x41\xA6\x9B\x8A\x71\xF4\x4E"
           "\x7A\xCF\xBE\x9D\xEC\x18\x90\x04\xF2\x6F\x9F\xD9\x76\xFD\x43\x17"
           "\x81\xF0\xD7\xB8\x1B\xE6\x7C\xBB\x5F\xB9\x9D\x8E\x96\x4D\xC5\xE3"
           "\x7A\x98\xBA\x11\x2B\x52\x62\xA3\x48\x6F\x9C\x8F\x3F\x4A\x88\xF4"
           "\xEA\x82\x59\xBD\x2D\x55\x06\x8F\x51\x8D\x37\xA0\xB0\xF4\xA7\x23"
           "\x76\x86\xFF\x68\xEA\x6C\x64\xFE\xC0\xCD\x6C\x48\x20\xCB\xD2\x77"
           "\x31\x73\xD8\x50\x5A\x13\x84\x98\x8D\x0A\xF1\xB9\x8A\xD8\x87\x54"
           "\xDC\xB4\xBA\x6A\x0E\x7D\x04\x4D\x7C\x6C\xF6\xE3\x50\x65\xEF\xC2"
           "\x9C\x70\x39\x70\x99\x60\x53\x70\x88\x1D\xA2\x56\x1A\x78\xB8\x15"
           "\x17\x81\x3F\xEC\x07\x0A\xE0\x33\x7A\x82\x0B\xE2\x21\x53\x1B\x27"
           "\x7C\x06\x69\x00\x82\xB3\xAB\x74\xE9\x43\xDD\xCC\x69\x2C\xF8\x51"
           "\xAF\xEB\xEE\x15\x6E\xE0\x35\xA8\x6A\x0D\x35\x8A\x01\x98\x68\x8A"
           "\xC5\x71\xAA\x8C\xDB\x31\xC7\x04\x5D\xEF\x33\x50\x1A\x66\xC9\xBF"
           "\x85\xE8\x30\xBF\x8E\x36\x86\xA3\xB0\xBF\x18\x8E\xA0\x93\xB3\x5C"
           "\xD2\xD3\x6E\x57\x86\x14\x30\x5D\xC5\x29\x0B\x5A\xEF\xEA\xA3\x9C"
           "\xC0\xDD\x9B\xDF\x67\xB9\xAF\x01\xC4\x0C\x83\xE1\x36\x95\x4E\xB6"
           "\xF2\x61\x4F\xB8\x09\x8E\x66\x90\x23\xE7\x6D\xD1\x71\xF4\xF4\xE7"
           "\xF4\x3B\x54\x8D\x91\x05\x89\xB5\xFE\x78\xBA\x30\x87\xF5\xB5\xE6"
           "\xE8\x55\x5B\xCA\x64\xAF\x89\x59\xA0\x50\x8A\x7D\x19\x40\xDF\x49"
           "\x31\xEA\xEF\x76\x70\x2E\x1F\xC7\x05\x7E\xA0\x2A\x42\x17\xA2\x0A"
           "\x32\xAC\x36\x7F\x31\xFF\x11\xED\x06\x13\x03\xC6\xDF\xEF\xC4\x27"
           "\x8C\x29\xE3\x36\xE6\xDE\xBC\xE8\x7B\xB5\x7B\x9A\xCB\x93\xF1\x21"
           "\x26\x38\x94\xDA\xF5\x1B\xD7\x2F\xA9\x3C\xEC\xE3\xDC\xD6\xD8\xFC"
           "\x03\x4D\xE1\x49\xA2\x22\x6E\xFD\x57\x80\xAB\xF4\xFA\xD5\xC2\x53"
           "\xCE\x6D\xB2\x61\xE3\xA8\x22\xD8\xD2\x9C\xFE\x85\xE2\x80\xA0\x9D"
           "\x1E\xAF\x00\x3F\xF2\x36\xE1\xE5\xBC\x32\x73\x7E\xD0\x6E\x18\x66"
           "\x48\x64\x91\x0E\xB6\x70\x82\xAA\x40\xFA\x2D\xB5\x27\x0A\x71\x17"
           "\x15\x96\xD4\x2B\xEF\xB4\x82\xA2\x4C\x7C\x08\x2B\x9E\xD6\x99\x56"
           "\x20\x08\xCD\x7D\x6B\x5E\x38\x53\x67\x13\x38\xED\x16\x44\x71\x12"
           "\x97\x4B\x84\xE7\xCE\x12\x53\x70\x46\x6A\x71\x51\xAD\x8B\x71\x2D"
           "\xE5\x4C\xF7\xFF\xCE\x39\xB3\xA0\xB1\x46\x26\x4F\x1A\x63\x0C\xB9"
           "\xEE\x8F\xC7\x8E\x61\x24\xD0\xFB\xD4\x33\x00\xFD\x85\x23\x8B\x12"
           "\x09\x49\x7D\xA8\xE2\x9D\x2E\xFD"
           , 680);
    nSKLen = 680;
    nAlgo = 3;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8796 A5B4 C3D2 E1F0 */
    memcpy(bKEK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           "\x59\x99\xC3\x06\xAB\x84\x01\xB2"
           , 24);

    memcpy(bDExp,
           "\x05\xF6\xC4\xCD\xDE\xF9\x36\xF8\x52\xFE\x32\x3F\x29\xC1\x99\x4F"
           "\xED\xAE\x20\xF0\x23\x05\x8D\x05\x2C\x52\x12\x26\x24\xA0\x49\x3C"
           "\x56\xE4\xC2\xF6\xE2\x96\xB5\x0A\x87\x22\x67\x46\x55\x65\x59\x44"
           "\x08\x74\x7C\xD4\xBC\xA3\x9F\xF9\x24\x50\xB8\xD8\xF8\xDE\x9E\x3D"
           "\x75\x82\x47\x19\xB8\x13\xCB\xCF\xDC\xC3\x80\x53\x4A\xAC\xDC\x85"
           "\x33\x5B\xAD\xEF\xFD\x13\xD7\xA3\xE6\x55\x5F\x9C\x54\xD6\x6F\xBC"
           "\x7E\xD4\xE2\x9F\xC9\xCC\x62\x12\x27\xDB\xA4\x83\x9E\x48\xAA\x60"
           "\x79\xC3\x30\x0D\xB1\x02\x7A\xF2\x85\x9D\x2E\x47\xE1\x79\x9A\xD2"
           "\x1E\x0A\x58\x2F\xFD\x9D\xF2\xFF\xFC\xA0\xF9\x0E\x1E\xB2\x23\xAD"
           , 144);
    nDLenExp = 8 + 144;
    memcpy(bPExp,
           "\x15\xE0\x2F\xFB\x00\xD4\x02\x03\xD1\x63\x7E\xD8\x10\xA6\x6C\x65"
           "\xCA\x6D\x45\xC7\xF0\xBB\x0D\x74\x14\x29\xF4\x0E\x97\x6F\x1E\xE5"
           "\x47\x69\x52\xF3\xAB\x23\x90\xE3\x87\xEF\x7E\x60\xBF\x03\xF4\x4D"
           "\x22\x03\x3F\xC7\x6F\x34\x81\x66\x7F\x8B\xE3\x00\x6B\x99\xCF\xEE"
           "\xA7\xC2\xDA\x57\xA9\x73\xDC\x18"
           , 72);
    nPLenExp = 8 + 72;
    memcpy(bQExp,
           "\x1F\xEB\x1F\xEF\x71\xFD\xD4\x4A\x1E\x08\x28\x9C\x2D\x97\x0F\x68"
           "\x43\x4F\xC2\xA4\xFF\x40\x0F\x68\xB3\xAF\xBD\xF7\xFB\x89\x82\xD6"
           "\x0D\x6C\xD6\x10\x23\x1B\x88\x3A\x99\xB0\x2D\x9A\x6B\xC4\x59\x2B"
           "\x15\x80\x89\x19\x88\xB4\xED\xB3\x6E\x2C\x28\x8A\xCC\x28\x56\x99"
           "\x2B\x4C\x74\xD9\x5F\xAA\x39\xF5"
           , 72);
    nQLenExp = 8 + 72;
    memcpy(bDmP1Exp,
           "\xEC\xFB\x6D\x21\xCF\xE8\x2B\x40\x2B\x88\x7B\x1E\x49\x20\x92\xB8"
           "\x3E\x82\x16\x0A\xD3\xC9\xAE\xF0\x73\xCD\x74\x7C\x4C\xEB\x95\xC6"
           "\x8A\x07\xAC\x40\x33\x25\xF9\x35\x14\xE9\xD9\x61\xA1\xDC\x2B\x0C"
           "\x71\xA6\x05\xEB\x30\x11\xF7\xDA\x46\x13\x02\x89\x5F\x2F\xD6\x74"
           "\x61\x2F\xB2\x72\x22\xE7\xA7\x11"
           , 72);
    nDmP1LenExp = 8 + 72;
    memcpy(bDmQ1Exp,
           "\xE3\x75\x36\x67\xB2\xC3\xAA\x1A\x54\x5F\x2B\xF4\xA7\x7A\x8D\x0F"
           "\xCC\xD6\x39\x57\xFD\x58\x3C\x30\xBD\x45\xC9\x63\xBD\x5A\xA9\xB0"
           "\x33\xBE\xB4\x54\x70\xE3\x04\xA0\xEC\x41\xB2\x29\x2B\xAD\x16\xCF"
           "\x3C\x11\x9C\x72\x5D\xA3\xA7\x47\x8C\xF2\xEF\x8E\x3E\x6D\x87\xB7"
           "\x43\xFA\xCE\x6A\x3F\x5A\x31\x6B"
           , 72);
    nDmQ1LenExp = 8 + 72;
    memcpy(bCoefExp,
           "\x22\x0C\xEF\xD4\x86\x8C\x1B\x43\x04\x20\xE8\x60\x1C\x8D\xCD\xB0"
           "\x58\x4B\x72\x8F\x2B\x93\x30\xF9\xB2\x5D\xAD\x76\x74\x67\x70\x41"
           "\x93\x34\x22\x73\xD3\xC1\x15\x58\x18\x0E\xC0\xAC\x17\x96\x38\x48"
           "\x6F\x4F\x57\x31\xD9\xBE\x09\x4A\xE0\xDA\x11\x87\x1E\x8B\x12\xD4"
           "\x1E\x74\x70\xE9\x10\xBE\xED\xDC"
           , 72);
    nCoefLenExp = 8 + 72;


    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    DspHex("[IN ]bSK      =", bSK, 680);
    printf("[IN ]nSKLen   = %d\n", nSKLen);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bKEK     =", bKEK, 24);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateAnalyse(nSock, bSK, nSKLen, nAlgo, bKEK, bD, &nDLen, \
                               bP, &nPLen, bQ, &nQLen, bDmP1, &nDmP1Len, bDmQ1, \
                               &nDmQ1Len, bCoef, &nCoefLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1152，三倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bD, bDExp, 144);
    ASSERT_OUT(nDLen, nDLenExp);
    ASSERT_OUT_HEX(bP, bPExp, 72);
    ASSERT_OUT(nPLen, nPLenExp);
    ASSERT_OUT_HEX(bQ, bQExp, 72);
    ASSERT_OUT(nQLen, nQLenExp);
    ASSERT_OUT_HEX(bDmP1, bDmP1Exp, 72);
    ASSERT_OUT(nDmP1Len, nDmP1LenExp);
    ASSERT_OUT_HEX(bDmQ1, bDmQ1Exp, 72);
    ASSERT_OUT(nDmQ1Len, nDmQ1LenExp);
    ASSERT_OUT_HEX(bCoef, bCoefExp, 72);
    ASSERT_OUT(nCoefLen, nCoefLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateAnalyse_Test_10(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  BYTE bSK[1280];
	  int  nSKLen;
	  int  nAlgo;
	  BYTE bKEK[32];
	  BYTE bD[276];
	  BYTE bDExp[276];
	  int  nDLen;
	  int  nDLenExp;
	  BYTE bP[144];
	  BYTE bPExp[144];
	  int  nPLen;
	  int  nPLenExp;
	  BYTE bQ[144];
	  BYTE bQExp[144];
	  int  nQLen;
	  int  nQLenExp;
	  BYTE bDmP1[144];
	  BYTE bDmP1Exp[144];
	  int  nDmP1Len;
	  int  nDmP1LenExp;
	  BYTE bDmQ1[144];
	  BYTE bDmQ1Exp[144];
	  int  nDmQ1Len;
	  int  nDmQ1LenExp;
	  BYTE bCoef[144];
	  BYTE bCoefExp[144];
	  int  nCoefLen;
	  int  nCoefLenExp;

    bufclr(bSK);
    bufclr(bKEK);
    bufclr(bD);
    bufclr(bDExp);
    bufclr(bP);
    bufclr(bPExp);
    bufclr(bQ);
    bufclr(bQExp);
    bufclr(bDmP1);
    bufclr(bDmP1Exp);
    bufclr(bDmQ1);
    bufclr(bDmQ1Exp);
    bufclr(bCoef);
    bufclr(bCoefExp);
    nDLen = 0;
    nPLen = 0;
    nQLen = 0;
    nDmP1Len = 0;
    nDmQ1Len = 0;
    nCoefLen = 0;

    memcpy(bSK,
           "\x21\xE5\x82\xE3\xD4\x2B\x83\xA7\x68\x16\x92\xEF\x49\x12\x6D\x45"
           "\xC5\x11\xC5\x1E\x9E\x67\x6F\xF9\x04\x47\x04\x31\x37\x69\xFD\x3D"
           "\x6C\x60\x8F\x08\xC7\xF3\xF1\x69\xDF\xCC\x66\x75\xEA\xB0\x61\x33"
           "\xAF\x7A\x12\x41\x94\x5A\x51\x39\xB5\xBE\xE7\x4C\x9D\x98\x77\x80"
           "\x6C\xB9\x2B\x98\x4E\x55\xEC\x57\x0E\x8A\x1F\xA8\x52\xDE\x44\xC5"
           "\x08\x2F\x21\xD9\x0E\xDD\xB5\x5E\xF3\xA1\x8C\xF1\xC3\xCB\x0A\x18"
           "\xD3\x80\x83\x10\xEB\x2E\x99\x59\x45\x7D\x2B\x92\xF5\x22\x7B\x49"
           "\x67\x02\x84\x5F\x56\x56\xBC\x95\x04\xA4\xB7\xB7\x53\xAE\x19\xF1"
           "\xF8\x7C\x3D\xEA\xDA\xDF\x52\x99\xF5\xB4\x15\xAB\x03\x8B\xBD\x6B"
           "\xC0\x8C\x86\xFC\x56\xCC\x3C\x0C\x38\x31\xBD\xB7\x28\x29\xAC\x0E"
           "\x24\xF2\x12\x6E\x6A\xFC\x01\x1C\x18\xC6\x3A\xCD\xD8\x0A\x64\x27"
           "\x93\x9D\x76\xAA\x27\x42\x7E\xEF\xFB\x83\x2A\xB5\xF3\xD0\x15\xC8"
           "\xEF\xF4\x3E\x5B\x5F\x3B\x4F\x96\x2C\x76\x6A\xD6\x69\xD7\x57\xC1"
           "\xF6\x40\xDF\x49\x7B\x4A\x9B\xE2\x7A\xE3\x09\x8B\xC9\x47\xA9\x14"
           "\x5F\x1D\xC1\x4A\x7F\x9D\xCF\xEF\x7D\x1A\x91\x6F\xC7\xA0\x41\x7F"
           "\x7B\xC3\x15\x00\xEC\x53\x34\x22\x95\xEE\xE7\x08\x39\x63\xF5\x54"
           "\xB6\xAD\x39\x45\xB5\x21\x5C\x34\x5E\x67\x7B\xD8\x97\x50\x91\x75"
           "\x6F\x68\x0A\x95\x8F\x24\xBE\x83\xDB\x44\x91\xE0\xD2\x99\x24\x99"
           "\xBD\x11\x2E\x15\xA9\xCC\xCD\x14\xD9\xBB\x5E\x56\x0F\x69\x9A\x18"
           "\x5A\x42\x25\xB1\x3F\x6B\x03\x18\x51\x9C\x36\x8F\xDB\x1E\xB9\x11"
           "\x3A\xEF\x24\xDB\x9B\x2E\xA2\x1B\x11\x73\x86\x5A\x4C\x12\x4F\xD8"
           "\xCB\x07\xEE\x99\xAC\x04\x10\x2B\x1C\xD7\xB8\xEB\xE7\x56\x2C\x8A"
           "\x12\x36\xDD\xA0\x11\x9D\xC8\x26\x37\x66\x0B\x21\x89\xC3\x7D\xA1"
           "\x40\x85\x91\xFF\x5E\x80\x70\xFB\x68\x28\x03\x8A\x6F\x09\xBC\xD6"
           "\xAC\xAF\xF4\x60\x67\x8D\xA8\x3E\x17\x5B\x5A\xE9\x3E\x17\xA9\x34"
           "\xA9\xD7\x29\xBE\xBE\xE3\xCD\x09\x74\x23\xC7\x21\xEE\xA2\x63\xA2"
           "\x33\x64\x92\x53\x31\x74\xF2\x96\x0C\xD0\x11\x30\xB6\x9F\xE0\xBA"
           "\x5B\x4C\xFA\xA0\xBB\x83\x1C\x74\xD8\x70\xE0\x4B\x2A\xAA\xBD\x88"
           "\x4A\x1E\xB5\x22\x63\xD7\x2E\xBD\xA4\x8E\x6C\xA3\x10\x29\xE8\x29"
           "\xA8\x43\x89\x66\xB7\x7E\x3D\xBE\x8C\xE3\xFC\x5A\xBF\x06\x0B\xCC"
           "\x34\x91\x9D\xE3\x85\x1D\xB7\x39\x03\xC3\x0C\x05\x17\xA4\x8D\xE0"
           "\xB3\x9E\x01\xF7\x80\xF4\xBB\xF0\x22\x23\xDA\xBD\xC4\x14\xBB\x78"
           "\x58\xC5\x7F\xC6\x09\x41\x54\xBB\x11\x96\xE6\xA3\x1A\xC9\x55\xBD"
           "\x0F\xF0\x3F\xBE\x61\x83\xCE\x26\x82\xA2\x8E\xD5\x0D\x2D\xB7\x66"
           "\xBC\x2E\xF0\xEB\xC3\x2F\x6A\x2A\xF5\xB9\x8B\xF0\x42\x4F\x65\x8B"
           "\xD1\x6E\x76\x88\x8C\x29\x34\xCF\x26\x27\x84\x8E\x6B\xA2\xEB\x16"
           "\x77\x2D\x21\x7E\xEC\x18\x4D\x04\xDA\xEF\x95\x1C\x29\x75\x18\x1C"
           "\x83\xCA\xB6\x72\xC3\x77\x46\x29\xBB\xFC\xDE\x1D\x78\x72\x76\x47"
           "\x20\x40\x90\xDC\xBC\xA3\x72\x33\x64\x7E\x18\xD9\xA4\xD2\x46\x9C"
           "\x77\x8B\xF9\x6D\x97\xB0\xD6\xA1\x20\x2C\x0D\xB6\xE3\x2C\x09\x8F"
           "\x07\xB6\x5F\xD3\xDB\x3B\xFD\x77\x69\x7D\x56\xE4\x35\x18\x3A\x9B"
           "\xF6\x22\x3A\x01\x35\x71\xBE\xA4\x48\x97\x8B\x45\x90\x46\x07\x0E"
           "\x17\x68\x9E\x00\x11\x6F\x4A\x25\x55\xA0\x9C\x74\xD9\x15\xFF\xF5"
           "\xE0\x59\xD6\x86\xA0\x91\xD8\x7F\x9A\xFF\xE4\xBD\xAB\xE3\xF0\x94"
           "\x49\x66\x36\x7F\xD3\xD3\x8E\x13\xB7\xFC\x89\xB7\xA9\x3C\x7B\x0E"
           "\x11\xAC\x66\xCE\x34\x34\xAE\x67\x70\xE0\x3A\xB6\x0E\x78\xFD\x94"
           "\xF1\xB5\x74\xD3\x47\x2A\x74\x40\x51\x39\xD1\x49\x73\x94\xB4\xF9"
           "\x4C\xB6\x4B\x11\x19\x2F\x7E\x34\x3E\x6B\x4F\x34\x5B\x83\x52\x47"
           "\x99\x0C\xD6\xDF\x7B\xA3\x95\xE2\xCC\x39\x2F\xC4\x92\x43\x38\x2F"
           "\xCB\xE6\x8C\x2D\xAD\xD0\x5E\xE9\xD5\x3D\x5E\x70\x2E\xA8\x66\xB0"
           "\xA6\xB8\x7C\xA4\x3A\x9E\x28\x3B\x0E\x46\x20\x84\xF8\x5E\x53\x9E"
           "\xCF\xDE\xF3\x0F\x1F\xE3\x8D\x51"
           , 824);
    nSKLen = 824;
    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKEK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           , 8);

    memcpy(bDExp,
           "\xC8\x3D\xEF\x0C\xCF\xA8\x62\x5C\x75\xB9\xED\x7B\x1C\x46\x57\x9C"
           "\x94\x97\x31\xC2\x51\xEE\x59\x72\x5B\xDB\x1A\xF3\xF0\x7B\x79\x05"
           "\xE7\x07\x4C\x9B\x37\x81\x9B\x0D\x7E\xB8\x01\x88\x46\xD3\xAA\x2A"
           "\x92\x06\x46\x4B\xA8\xE4\xA4\xB7\xA7\xB3\xFF\xA5\x39\xB9\xBD\xF3"
           "\xB3\x4D\x41\x7C\x6B\xBD\xEF\x92\xA0\x6D\x22\x49\x74\xB4\x72\xCB"
           "\xD1\xE7\x87\x59\x71\x7C\xAE\x06\xF5\x3F\x34\xA3\xA2\xDB\x6B\x61"
           "\x65\xFF\x41\xF2\x65\x94\xF1\x1B\x69\x0A\x35\x0D\x4B\x57\xB2\xC3"
           "\xEF\x11\x6C\xC3\x01\x56\x78\x3F\x7E\xBD\xC9\x6F\x4F\xE3\x03\x8A"
           "\x14\xEC\x94\x04\x79\xA0\x4C\xFB\x46\xF9\xCE\xF4\xF6\x3F\x6A\x0A"
           "\x02\xFD\xDA\xCA\xC9\xD1\x69\xA2\xD0\xB4\x49\xC1\x71\xE4\x3C\x5F"
           "\xDB\x65\x57\x8A\x21\x5F\xA8\xEB\x05\x63\x90\x03\xB2\x7A\x80\x14"
           , 176);
    nDLenExp = 8 + 176;
    memcpy(bPExp,
           "\x7B\x52\xFA\x2B\x94\xD1\x8C\xB9\x36\x10\xF2\x8E\x1C\x4C\xFD\xEB"
           "\x7B\x8C\xBA\xF4\xD9\x12\xC3\xBD\x83\x44\xEB\xF6\x36\x7D\x33\xFC"
           "\x8F\xA2\x67\x51\x2B\x6C\x33\x70\xC7\x29\x8E\x7C\x0C\x8D\x2B\x55"
           "\xDC\x90\xE0\x78\x09\x43\x02\x0F\x5F\xFB\xFC\xAA\x72\x85\xBC\x49"
           "\x9F\x35\xBB\xF1\x6A\x78\x25\x97\x95\xCB\x93\x30\x10\x0C\x99\x5D"
           "\x8B\xD1\x7A\x2A\x37\xBF\x45\xCC"
           , 88);
    nPLenExp = 8 + 88;
    memcpy(bQExp,
           "\x44\xE4\xEB\x14\xAE\x1B\x75\xBA\x3C\x9B\xCE\x52\xE2\x58\xFF\x5F"
           "\xDA\x31\x8D\x04\x0B\x3E\x03\x85\xB0\x33\xE3\x95\xF8\xC8\x44\x39"
           "\x37\xE3\xBB\xB1\xAE\x6C\x23\xCA\x81\x29\x78\x6C\x6B\x70\x65\x11"
           "\x7D\x27\x9A\xA1\xE2\x44\x96\x59\xD5\x57\xEE\x26\xBA\xA0\x92\xDD"
           "\xD6\x3B\x3F\x17\x4D\x29\x4F\x02\xCA\xFD\xD0\x88\x25\x39\xE5\x36"
           "\xC2\xE3\x1F\x73\x74\xC3\x3A\x5D"
           , 88);
    nQLenExp = 8 + 88;
    memcpy(bDmP1Exp,
           "\x2A\x27\x7C\xAE\x85\x67\x8E\xEE\x2D\x65\xE4\x4F\xFB\xED\x41\x53"
           "\xFF\xFC\xCB\x3E\x4A\x30\xE1\x38\xD6\x0C\x01\x85\x60\x48\x86\xD9"
           "\x02\x4B\x42\xED\xBB\x09\x36\x04\x46\xF3\x20\xD9\x67\xAC\xCD\x19"
           "\x84\xEE\x4E\xCA\x21\x5C\xC2\xFC\x1F\x9B\x5E\xDC\xE6\x70\xF8\x27"
           "\x47\x4A\x0A\x82\x7D\xD3\x49\xEB\x06\x6D\x58\x51\x83\x46\x9F\xC6"
           "\xE9\x5A\x0A\x31\x37\x4A\x2A\x73"
           , 88);
    nDmP1LenExp = 8 + 88;
    memcpy(bDmQ1Exp,
           "\x93\x29\x0F\x1C\x1E\xB8\x6E\xDC\x10\xFC\x80\x93\xEC\x87\x26\x2F"
           "\x5F\x52\xB8\x1C\xA7\x3E\x3E\x6E\x3A\x8B\xA5\xA6\x15\x22\x8B\x89"
           "\xD7\xB5\x72\x25\x97\x72\xD9\x3C\x5C\x51\x99\x2D\x19\xFE\x09\x9B"
           "\x8C\xE4\x27\xDE\x64\xEA\x2F\xAE\xA0\xE1\x00\x57\xFE\xB1\x78\xB5"
           "\xBC\xEA\x00\xF4\x7D\x84\x8E\xD3\xB4\x3C\xE3\xBC\xE8\xF2\x22\x1D"
           "\xBE\x70\xDB\x12\x90\xD3\x79\xDA"
           , 88);
    nDmQ1LenExp = 8 + 88;
    memcpy(bCoefExp,
           "\xE8\x73\xC4\x5E\x7C\xA5\x00\x86\xFF\x7C\x30\x81\xA5\x4A\x7C\x42"
           "\x52\x3F\x79\xE8\x14\xA0\x2E\x13\xC3\x76\x9A\x38\x20\xF5\x0A\xB2"
           "\x1F\x30\x2A\xE4\x59\x37\xF7\xC5\x46\xB0\x4B\x40\x4E\x77\x40\x4F"
           "\xAA\x40\x9A\x09\x52\xBA\x55\xBB\xBF\x68\x4F\x44\xCA\xD9\xD8\x0D"
           "\x4C\xBC\x46\x87\x01\x10\x86\xD8\x7D\x3F\xA2\x0B\xAE\x79\xAC\x59"
           "\x90\x5E\x1C\xD1\x2C\xB5\xE5\x69"
           , 88);
    nCoefLenExp = 8 + 88;

    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    DspHex("[IN ]bSK      =", bSK, 824);
    printf("[IN ]nSKLen   = %d\n", nSKLen);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bKEK     =", bKEK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateAnalyse(nSock, bSK, nSKLen, nAlgo, bKEK, bD, &nDLen, \
                               bP, &nPLen, bQ, &nQLen, bDmP1, &nDmP1Len, bDmQ1, \
                               &nDmQ1Len, bCoef, &nCoefLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1408，单倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bD, bDExp, 176);
    ASSERT_OUT(nDLen, nDLenExp);
    ASSERT_OUT_HEX(bP, bPExp, 88);
    ASSERT_OUT(nPLen, nPLenExp);
    ASSERT_OUT_HEX(bQ, bQExp, 88);
    ASSERT_OUT(nQLen, nQLenExp);
    ASSERT_OUT_HEX(bDmP1, bDmP1Exp, 88);
    ASSERT_OUT(nDmP1Len, nDmP1LenExp);
    ASSERT_OUT_HEX(bDmQ1, bDmQ1Exp, 88);
    ASSERT_OUT(nDmQ1Len, nDmQ1LenExp);
    ASSERT_OUT_HEX(bCoef, bCoefExp, 88);
    ASSERT_OUT(nCoefLen, nCoefLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateAnalyse_Test_11(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  BYTE bSK[1280];
	  int  nSKLen;
	  int  nAlgo;
	  BYTE bKEK[32];
	  BYTE bD[276];
	  BYTE bDExp[276];
	  int  nDLen;
	  int  nDLenExp;
	  BYTE bP[144];
	  BYTE bPExp[144];
	  int  nPLen;
	  int  nPLenExp;
	  BYTE bQ[144];
	  BYTE bQExp[144];
	  int  nQLen;
	  int  nQLenExp;
	  BYTE bDmP1[144];
	  BYTE bDmP1Exp[144];
	  int  nDmP1Len;
	  int  nDmP1LenExp;
	  BYTE bDmQ1[144];
	  BYTE bDmQ1Exp[144];
	  int  nDmQ1Len;
	  int  nDmQ1LenExp;
	  BYTE bCoef[144];
	  BYTE bCoefExp[144];
	  int  nCoefLen;
	  int  nCoefLenExp;

    bufclr(bSK);
    bufclr(bKEK);
    bufclr(bD);
    bufclr(bDExp);
    bufclr(bP);
    bufclr(bPExp);
    bufclr(bQ);
    bufclr(bQExp);
    bufclr(bDmP1);
    bufclr(bDmP1Exp);
    bufclr(bDmQ1);
    bufclr(bDmQ1Exp);
    bufclr(bCoef);
    bufclr(bCoefExp);
    nDLen = 0;
    nPLen = 0;
    nQLen = 0;
    nDmP1Len = 0;
    nDmQ1Len = 0;
    nCoefLen = 0;

    memcpy(bSK,
           "\x21\xE5\x82\xE3\xD4\x2B\x83\xA7\x68\x16\x92\xEF\x49\x12\x6D\x45"
           "\xC5\x11\xC5\x1E\x9E\x67\x6F\xF9\x04\x47\x04\x31\x37\x69\xFD\x3D"
           "\x6C\x60\x8F\x08\xC7\xF3\xF1\x69\xDF\xCC\x66\x75\xEA\xB0\x61\x33"
           "\xAF\x7A\x12\x41\x94\x5A\x51\x39\xB5\xBE\xE7\x4C\x9D\x98\x77\x80"
           "\x6C\xB9\x2B\x98\x4E\x55\xEC\x57\x0E\x8A\x1F\xA8\x52\xDE\x44\xC5"
           "\x08\x2F\x21\xD9\x0E\xDD\xB5\x5E\xF3\xA1\x8C\xF1\xC3\xCB\x0A\x18"
           "\xD3\x80\x83\x10\xEB\x2E\x99\x59\x45\x7D\x2B\x92\xF5\x22\x7B\x49"
           "\x67\x02\x84\x5F\x56\x56\xBC\x95\x04\xA4\xB7\xB7\x53\xAE\x19\xF1"
           "\xF8\x7C\x3D\xEA\xDA\xDF\x52\x99\xF5\xB4\x15\xAB\x03\x8B\xBD\x6B"
           "\xC0\x8C\x86\xFC\x56\xCC\x3C\x0C\x38\x31\xBD\xB7\x28\x29\xAC\x0E"
           "\x24\xF2\x12\x6E\x6A\xFC\x01\x1C\x18\xC6\x3A\xCD\xD8\x0A\x64\x27"
           "\x93\x9D\x76\xAA\x27\x42\x7E\xEF\xFB\x83\x2A\xB5\xF3\xD0\x15\xC8"
           "\xEF\xF4\x3E\x5B\x5F\x3B\x4F\x96\x2C\x76\x6A\xD6\x69\xD7\x57\xC1"
           "\xF6\x40\xDF\x49\x7B\x4A\x9B\xE2\x7A\xE3\x09\x8B\xC9\x47\xA9\x14"
           "\x5F\x1D\xC1\x4A\x7F\x9D\xCF\xEF\x7D\x1A\x91\x6F\xC7\xA0\x41\x7F"
           "\x7B\xC3\x15\x00\xEC\x53\x34\x22\x95\xEE\xE7\x08\x39\x63\xF5\x54"
           "\xB6\xAD\x39\x45\xB5\x21\x5C\x34\x5E\x67\x7B\xD8\x97\x50\x91\x75"
           "\x6F\x68\x0A\x95\x8F\x24\xBE\x83\xDB\x44\x91\xE0\xD2\x99\x24\x99"
           "\xBD\x11\x2E\x15\xA9\xCC\xCD\x14\xD9\xBB\x5E\x56\x0F\x69\x9A\x18"
           "\x5A\x42\x25\xB1\x3F\x6B\x03\x18\x51\x9C\x36\x8F\xDB\x1E\xB9\x11"
           "\x3A\xEF\x24\xDB\x9B\x2E\xA2\x1B\x11\x73\x86\x5A\x4C\x12\x4F\xD8"
           "\xCB\x07\xEE\x99\xAC\x04\x10\x2B\x1C\xD7\xB8\xEB\xE7\x56\x2C\x8A"
           "\x12\x36\xDD\xA0\x11\x9D\xC8\x26\x37\x66\x0B\x21\x89\xC3\x7D\xA1"
           "\x40\x85\x91\xFF\x5E\x80\x70\xFB\x68\x28\x03\x8A\x6F\x09\xBC\xD6"
           "\xAC\xAF\xF4\x60\x67\x8D\xA8\x3E\x17\x5B\x5A\xE9\x3E\x17\xA9\x34"
           "\xA9\xD7\x29\xBE\xBE\xE3\xCD\x09\x74\x23\xC7\x21\xEE\xA2\x63\xA2"
           "\x33\x64\x92\x53\x31\x74\xF2\x96\x0C\xD0\x11\x30\xB6\x9F\xE0\xBA"
           "\x5B\x4C\xFA\xA0\xBB\x83\x1C\x74\xD8\x70\xE0\x4B\x2A\xAA\xBD\x88"
           "\x4A\x1E\xB5\x22\x63\xD7\x2E\xBD\xA4\x8E\x6C\xA3\x10\x29\xE8\x29"
           "\xA8\x43\x89\x66\xB7\x7E\x3D\xBE\x8C\xE3\xFC\x5A\xBF\x06\x0B\xCC"
           "\x34\x91\x9D\xE3\x85\x1D\xB7\x39\x03\xC3\x0C\x05\x17\xA4\x8D\xE0"
           "\xB3\x9E\x01\xF7\x80\xF4\xBB\xF0\x22\x23\xDA\xBD\xC4\x14\xBB\x78"
           "\x58\xC5\x7F\xC6\x09\x41\x54\xBB\x11\x96\xE6\xA3\x1A\xC9\x55\xBD"
           "\x0F\xF0\x3F\xBE\x61\x83\xCE\x26\x82\xA2\x8E\xD5\x0D\x2D\xB7\x66"
           "\xBC\x2E\xF0\xEB\xC3\x2F\x6A\x2A\xF5\xB9\x8B\xF0\x42\x4F\x65\x8B"
           "\xD1\x6E\x76\x88\x8C\x29\x34\xCF\x26\x27\x84\x8E\x6B\xA2\xEB\x16"
           "\x77\x2D\x21\x7E\xEC\x18\x4D\x04\xDA\xEF\x95\x1C\x29\x75\x18\x1C"
           "\x83\xCA\xB6\x72\xC3\x77\x46\x29\xBB\xFC\xDE\x1D\x78\x72\x76\x47"
           "\x20\x40\x90\xDC\xBC\xA3\x72\x33\x64\x7E\x18\xD9\xA4\xD2\x46\x9C"
           "\x77\x8B\xF9\x6D\x97\xB0\xD6\xA1\x20\x2C\x0D\xB6\xE3\x2C\x09\x8F"
           "\x07\xB6\x5F\xD3\xDB\x3B\xFD\x77\x69\x7D\x56\xE4\x35\x18\x3A\x9B"
           "\xF6\x22\x3A\x01\x35\x71\xBE\xA4\x48\x97\x8B\x45\x90\x46\x07\x0E"
           "\x17\x68\x9E\x00\x11\x6F\x4A\x25\x55\xA0\x9C\x74\xD9\x15\xFF\xF5"
           "\xE0\x59\xD6\x86\xA0\x91\xD8\x7F\x9A\xFF\xE4\xBD\xAB\xE3\xF0\x94"
           "\x49\x66\x36\x7F\xD3\xD3\x8E\x13\xB7\xFC\x89\xB7\xA9\x3C\x7B\x0E"
           "\x11\xAC\x66\xCE\x34\x34\xAE\x67\x70\xE0\x3A\xB6\x0E\x78\xFD\x94"
           "\xF1\xB5\x74\xD3\x47\x2A\x74\x40\x51\x39\xD1\x49\x73\x94\xB4\xF9"
           "\x4C\xB6\x4B\x11\x19\x2F\x7E\x34\x3E\x6B\x4F\x34\x5B\x83\x52\x47"
           "\x99\x0C\xD6\xDF\x7B\xA3\x95\xE2\xCC\x39\x2F\xC4\x92\x43\x38\x2F"
           "\xCB\xE6\x8C\x2D\xAD\xD0\x5E\xE9\xD5\x3D\x5E\x70\x2E\xA8\x66\xB0"
           "\xA6\xB8\x7C\xA4\x3A\x9E\x28\x3B\x0E\x46\x20\x84\xF8\x5E\x53\x9E"
           "\xCF\xDE\xF3\x0F\x1F\xE3\x8D\x51"
           , 824);
    nSKLen = 824;
    nAlgo = 2;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKEK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           , 16);

    memcpy(bDExp,
           "\x2F\xEB\xED\x67\x80\xE3\xAA\x58\x88\xD4\x11\xAC\x98\x8D\xBF\x22"
           "\x98\x59\x17\x2E\x9A\x6B\x4F\x43\xAC\xF4\x7B\x03\xB8\x86\x40\x14"
           "\x6A\x7A\x94\xB6\xF8\x0C\xCE\x9D\xDF\xAF\xE9\xEF\xEC\x45\xAB\xCE"
           "\xA2\xFB\xC8\x9E\x82\xC1\x5B\x40\xDB\x9B\xA0\x25\x08\x23\x50\x3C"
           "\x35\x5D\xE7\x6A\x32\x8B\x98\x3F\xBA\xD3\xE0\xBF\x61\x44\x2F\x2E"
           "\x3D\x26\xF3\x17\x05\x5E\xAE\xA5\x0C\x07\xD1\x4D\xF7\xDB\x65\x93"
           "\x23\xD7\x72\x88\x03\x15\xC6\x66\x83\xC4\x0F\xC1\xA8\xCD\x38\x95"
           "\x15\x1A\x01\x79\xA0\x86\x22\xC2\x53\x5E\x03\x6D\xEC\x33\xB0\x67"
           "\x18\x8C\xF7\xBC\x6A\x4B\xDE\x0A\x2D\xB6\x14\x80\x3A\x44\x8D\xA3"
           "\x14\x8E\x40\x24\x92\xAE\x85\x08\x13\x97\xF5\x82\xE3\xA8\xAB\x11"
           "\xB2\x9C\xA8\xE5\x92\x62\x0A\x05\x75\x74\xF6\x13\x32\x95\x64\xDD"
           , 176);
    nDLenExp = 8 + 176;
    memcpy(bPExp,
           "\xCE\xDB\xD8\xD1\x12\xA9\xBE\x82\x2A\xC8\xBE\xCD\x7C\xA5\xD7\x1B"
           "\xC3\x73\x89\x5F\xD2\x09\xB5\x5D\xCA\xE1\x94\x9F\xBF\x64\x69\x6A"
           "\x9A\x71\x85\xB6\x71\x51\x4B\x16\xD9\x56\x13\x34\x5E\x0A\x51\xB1"
           "\xEA\xCB\x14\x64\xFC\x25\x77\xF0\x3A\xC4\x4B\x8E\xD7\x90\xB0\xA6"
           "\xE4\x69\x71\x9F\x9F\x40\x52\x0C\xF0\xAF\x12\x3F\x4F\x65\x7E\x0E"
           "\x2A\xBE\x5D\xC4\xCC\x27\x3B\xEA"
           , 88);
    nPLenExp = 8 + 88;
    memcpy(bQExp,
           "\xBD\x39\x5E\xFF\x20\xFE\x24\x0C\x14\xE0\x38\xCF\xFB\x77\xB0\xC5"
           "\xAF\xAC\xC7\x2C\xB1\x3C\x58\x05\x54\x29\x48\xA6\x61\xA3\xB8\x45"
           "\xDB\x45\xF7\x42\x92\x30\x24\x6F\x5E\xB9\xB7\x03\x65\x92\x64\x06"
           "\x30\xF9\x90\x25\x02\x03\x56\x49\xCD\x35\x98\x4A\xE4\x55\x18\xAB"
           "\x6E\x40\x6E\xD6\x43\xBD\x43\x9C\xA3\xA8\xAE\x5E\x3C\x20\x90\x46"
           "\x7E\x84\x1F\x47\xA3\x19\x06\xCF"
           , 88);
    nQLenExp = 8 + 88;
    memcpy(bDmP1Exp,
           "\x1D\x5C\xB6\x8E\x34\x17\x3D\xDA\xF1\xD2\x68\x8C\xDB\x7A\x49\x90"
           "\xC5\xB3\xBC\x92\x5F\xBF\x71\x64\xC1\x12\x37\xA2\x7F\xFA\x73\x28"
           "\xD9\x67\x3F\xA6\x77\x60\x16\xDD\x7D\x90\xA2\xAD\xA4\xB9\x84\x27"
           "\x3A\xC1\x17\xE1\x4E\xB0\x20\x93\xD2\xB2\xEC\x42\x0A\x7A\xED\x1E"
           "\x46\xDE\xB7\x3A\x4D\x67\xC5\x9B\xE9\x27\x05\x9B\x4C\x07\x33\x61"
           "\x22\x94\x02\xC3\xEB\x8E\x04\x16"
           , 88);
    nDmP1LenExp = 8 + 88;
    memcpy(bDmQ1Exp,
           "\xAF\xCA\x38\x98\x74\x6C\xDD\x76\x1E\x3B\xE0\x04\xE4\x8B\x35\x2E"
           "\xDD\x23\xF1\x7F\x7D\xED\xC7\x22\x89\x1C\xBF\x7B\x2C\x89\x26\x3C"
           "\x7E\x0F\xA8\x26\x71\x1F\x07\xA7\x37\xBB\x75\xFA\x34\x55\x44\x88"
           "\x3E\xC0\x30\xC4\x40\x14\x7E\x03\x12\x0B\x71\x87\xEE\x0E\x9F\xA0"
           "\x9A\x01\xD1\xCB\x7E\x2F\xB8\xB7\xD1\xD6\xC6\xDA\x0F\xA8\x8C\xB2"
           "\x56\x52\xF1\xC2\x7E\xA0\x88\x1F"
           , 88);
    nDmQ1LenExp = 8 + 88;
    memcpy(bCoefExp,
           "\x07\x78\x58\x0C\x9B\x75\x7B\x50\x68\xFC\xFD\x20\x60\x0C\xB4\x93"
           "\x1B\x27\xB9\xF4\xBE\x87\xE5\x17\x75\xB9\x55\x87\xB3\x74\x9E\xA4"
           "\xB3\xD3\x91\x36\xCB\x7D\x4E\x85\x82\x79\xDA\xC3\xD6\x45\xA0\xEB"
           "\x1D\xC1\x58\xA6\x5B\x85\x3A\x52\xD6\x44\xF3\x73\x0A\x75\xB8\x68"
           "\x9E\xBE\x1A\xFA\x21\x37\x36\x18\x20\x4E\x59\x30\xEA\x87\x49\x57"
           "\x2C\xCF\x5A\x83\x3C\xD9\xE2\xA7"
           , 88);
    nCoefLenExp = 8 + 88;

    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    DspHex("[IN ]bSK      =", bSK, 824);
    printf("[IN ]nSKLen   = %d\n", nSKLen);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bKEK     =", bKEK, 16);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateAnalyse(nSock, bSK, nSKLen, nAlgo, bKEK, bD, &nDLen, \
                               bP, &nPLen, bQ, &nQLen, bDmP1, &nDmP1Len, bDmQ1, \
                               &nDmQ1Len, bCoef, &nCoefLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1408，双倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bD, bDExp, 176);
    ASSERT_OUT(nDLen, nDLenExp);
    ASSERT_OUT_HEX(bP, bPExp, 88);
    ASSERT_OUT(nPLen, nPLenExp);
    ASSERT_OUT_HEX(bQ, bQExp, 88);
    ASSERT_OUT(nQLen, nQLenExp);
    ASSERT_OUT_HEX(bDmP1, bDmP1Exp, 88);
    ASSERT_OUT(nDmP1Len, nDmP1LenExp);
    ASSERT_OUT_HEX(bDmQ1, bDmQ1Exp, 88);
    ASSERT_OUT(nDmQ1Len, nDmQ1LenExp);
    ASSERT_OUT_HEX(bCoef, bCoefExp, 88);
    ASSERT_OUT(nCoefLen, nCoefLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateAnalyse_Test_12(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  BYTE bSK[1280];
	  int  nSKLen;
	  int  nAlgo;
	  BYTE bKEK[32];
	  BYTE bD[276];
	  BYTE bDExp[276];
	  int  nDLen;
	  int  nDLenExp;
	  BYTE bP[144];
	  BYTE bPExp[144];
	  int  nPLen;
	  int  nPLenExp;
	  BYTE bQ[144];
	  BYTE bQExp[144];
	  int  nQLen;
	  int  nQLenExp;
	  BYTE bDmP1[144];
	  BYTE bDmP1Exp[144];
	  int  nDmP1Len;
	  int  nDmP1LenExp;
	  BYTE bDmQ1[144];
	  BYTE bDmQ1Exp[144];
	  int  nDmQ1Len;
	  int  nDmQ1LenExp;
	  BYTE bCoef[144];
	  BYTE bCoefExp[144];
	  int  nCoefLen;
	  int  nCoefLenExp;

    bufclr(bSK);
    bufclr(bKEK);
    bufclr(bD);
    bufclr(bDExp);
    bufclr(bP);
    bufclr(bPExp);
    bufclr(bQ);
    bufclr(bQExp);
    bufclr(bDmP1);
    bufclr(bDmP1Exp);
    bufclr(bDmQ1);
    bufclr(bDmQ1Exp);
    bufclr(bCoef);
    bufclr(bCoefExp);
    nDLen = 0;
    nPLen = 0;
    nQLen = 0;
    nDmP1Len = 0;
    nDmQ1Len = 0;
    nCoefLen = 0;

    memcpy(bSK,
           "\x21\xE5\x82\xE3\xD4\x2B\x83\xA7\x68\x16\x92\xEF\x49\x12\x6D\x45"
           "\xC5\x11\xC5\x1E\x9E\x67\x6F\xF9\x04\x47\x04\x31\x37\x69\xFD\x3D"
           "\x6C\x60\x8F\x08\xC7\xF3\xF1\x69\xDF\xCC\x66\x75\xEA\xB0\x61\x33"
           "\xAF\x7A\x12\x41\x94\x5A\x51\x39\xB5\xBE\xE7\x4C\x9D\x98\x77\x80"
           "\x6C\xB9\x2B\x98\x4E\x55\xEC\x57\x0E\x8A\x1F\xA8\x52\xDE\x44\xC5"
           "\x08\x2F\x21\xD9\x0E\xDD\xB5\x5E\xF3\xA1\x8C\xF1\xC3\xCB\x0A\x18"
           "\xD3\x80\x83\x10\xEB\x2E\x99\x59\x45\x7D\x2B\x92\xF5\x22\x7B\x49"
           "\x67\x02\x84\x5F\x56\x56\xBC\x95\x04\xA4\xB7\xB7\x53\xAE\x19\xF1"
           "\xF8\x7C\x3D\xEA\xDA\xDF\x52\x99\xF5\xB4\x15\xAB\x03\x8B\xBD\x6B"
           "\xC0\x8C\x86\xFC\x56\xCC\x3C\x0C\x38\x31\xBD\xB7\x28\x29\xAC\x0E"
           "\x24\xF2\x12\x6E\x6A\xFC\x01\x1C\x18\xC6\x3A\xCD\xD8\x0A\x64\x27"
           "\x93\x9D\x76\xAA\x27\x42\x7E\xEF\xFB\x83\x2A\xB5\xF3\xD0\x15\xC8"
           "\xEF\xF4\x3E\x5B\x5F\x3B\x4F\x96\x2C\x76\x6A\xD6\x69\xD7\x57\xC1"
           "\xF6\x40\xDF\x49\x7B\x4A\x9B\xE2\x7A\xE3\x09\x8B\xC9\x47\xA9\x14"
           "\x5F\x1D\xC1\x4A\x7F\x9D\xCF\xEF\x7D\x1A\x91\x6F\xC7\xA0\x41\x7F"
           "\x7B\xC3\x15\x00\xEC\x53\x34\x22\x95\xEE\xE7\x08\x39\x63\xF5\x54"
           "\xB6\xAD\x39\x45\xB5\x21\x5C\x34\x5E\x67\x7B\xD8\x97\x50\x91\x75"
           "\x6F\x68\x0A\x95\x8F\x24\xBE\x83\xDB\x44\x91\xE0\xD2\x99\x24\x99"
           "\xBD\x11\x2E\x15\xA9\xCC\xCD\x14\xD9\xBB\x5E\x56\x0F\x69\x9A\x18"
           "\x5A\x42\x25\xB1\x3F\x6B\x03\x18\x51\x9C\x36\x8F\xDB\x1E\xB9\x11"
           "\x3A\xEF\x24\xDB\x9B\x2E\xA2\x1B\x11\x73\x86\x5A\x4C\x12\x4F\xD8"
           "\xCB\x07\xEE\x99\xAC\x04\x10\x2B\x1C\xD7\xB8\xEB\xE7\x56\x2C\x8A"
           "\x12\x36\xDD\xA0\x11\x9D\xC8\x26\x37\x66\x0B\x21\x89\xC3\x7D\xA1"
           "\x40\x85\x91\xFF\x5E\x80\x70\xFB\x68\x28\x03\x8A\x6F\x09\xBC\xD6"
           "\xAC\xAF\xF4\x60\x67\x8D\xA8\x3E\x17\x5B\x5A\xE9\x3E\x17\xA9\x34"
           "\xA9\xD7\x29\xBE\xBE\xE3\xCD\x09\x74\x23\xC7\x21\xEE\xA2\x63\xA2"
           "\x33\x64\x92\x53\x31\x74\xF2\x96\x0C\xD0\x11\x30\xB6\x9F\xE0\xBA"
           "\x5B\x4C\xFA\xA0\xBB\x83\x1C\x74\xD8\x70\xE0\x4B\x2A\xAA\xBD\x88"
           "\x4A\x1E\xB5\x22\x63\xD7\x2E\xBD\xA4\x8E\x6C\xA3\x10\x29\xE8\x29"
           "\xA8\x43\x89\x66\xB7\x7E\x3D\xBE\x8C\xE3\xFC\x5A\xBF\x06\x0B\xCC"
           "\x34\x91\x9D\xE3\x85\x1D\xB7\x39\x03\xC3\x0C\x05\x17\xA4\x8D\xE0"
           "\xB3\x9E\x01\xF7\x80\xF4\xBB\xF0\x22\x23\xDA\xBD\xC4\x14\xBB\x78"
           "\x58\xC5\x7F\xC6\x09\x41\x54\xBB\x11\x96\xE6\xA3\x1A\xC9\x55\xBD"
           "\x0F\xF0\x3F\xBE\x61\x83\xCE\x26\x82\xA2\x8E\xD5\x0D\x2D\xB7\x66"
           "\xBC\x2E\xF0\xEB\xC3\x2F\x6A\x2A\xF5\xB9\x8B\xF0\x42\x4F\x65\x8B"
           "\xD1\x6E\x76\x88\x8C\x29\x34\xCF\x26\x27\x84\x8E\x6B\xA2\xEB\x16"
           "\x77\x2D\x21\x7E\xEC\x18\x4D\x04\xDA\xEF\x95\x1C\x29\x75\x18\x1C"
           "\x83\xCA\xB6\x72\xC3\x77\x46\x29\xBB\xFC\xDE\x1D\x78\x72\x76\x47"
           "\x20\x40\x90\xDC\xBC\xA3\x72\x33\x64\x7E\x18\xD9\xA4\xD2\x46\x9C"
           "\x77\x8B\xF9\x6D\x97\xB0\xD6\xA1\x20\x2C\x0D\xB6\xE3\x2C\x09\x8F"
           "\x07\xB6\x5F\xD3\xDB\x3B\xFD\x77\x69\x7D\x56\xE4\x35\x18\x3A\x9B"
           "\xF6\x22\x3A\x01\x35\x71\xBE\xA4\x48\x97\x8B\x45\x90\x46\x07\x0E"
           "\x17\x68\x9E\x00\x11\x6F\x4A\x25\x55\xA0\x9C\x74\xD9\x15\xFF\xF5"
           "\xE0\x59\xD6\x86\xA0\x91\xD8\x7F\x9A\xFF\xE4\xBD\xAB\xE3\xF0\x94"
           "\x49\x66\x36\x7F\xD3\xD3\x8E\x13\xB7\xFC\x89\xB7\xA9\x3C\x7B\x0E"
           "\x11\xAC\x66\xCE\x34\x34\xAE\x67\x70\xE0\x3A\xB6\x0E\x78\xFD\x94"
           "\xF1\xB5\x74\xD3\x47\x2A\x74\x40\x51\x39\xD1\x49\x73\x94\xB4\xF9"
           "\x4C\xB6\x4B\x11\x19\x2F\x7E\x34\x3E\x6B\x4F\x34\x5B\x83\x52\x47"
           "\x99\x0C\xD6\xDF\x7B\xA3\x95\xE2\xCC\x39\x2F\xC4\x92\x43\x38\x2F"
           "\xCB\xE6\x8C\x2D\xAD\xD0\x5E\xE9\xD5\x3D\x5E\x70\x2E\xA8\x66\xB0"
           "\xA6\xB8\x7C\xA4\x3A\x9E\x28\x3B\x0E\x46\x20\x84\xF8\x5E\x53\x9E"
           "\xCF\xDE\xF3\x0F\x1F\xE3\x8D\x51"
           , 824);
    nSKLen = 824;
    nAlgo = 3;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8796 A5B4 C3D2 E1F0 */
    memcpy(bKEK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           "\x59\x99\xC3\x06\xAB\x84\x01\xB2"
           , 24);

    memcpy(bDExp,
           "\x5F\x69\x46\xA5\xE4\xC4\x08\xBF\x15\xD8\xD0\xA8\xD2\x84\x23\x0B"
           "\xAF\xB4\x5C\x2A\xF6\x20\x07\x26\x87\x1C\xBC\x2D\xEF\x5C\x04\x2B"
           "\x65\xCE\xA4\xC6\x07\x08\xAA\x53\x6B\x13\x53\xFD\x86\x12\x07\xE2"
           "\x10\xBA\x3A\x85\xD5\x79\x4E\xF8\x2A\x45\x03\x19\x80\x91\x2B\x6C"
           "\x64\x0C\x5E\x03\xDE\x86\x61\x9D\x6D\x76\x73\x68\x75\xB9\xAB\x70"
           "\xB3\x70\x6A\x99\x58\x4F\x63\x63\xBF\xAB\xAB\x6F\x77\xC1\x18\x3B"
           "\x4F\x91\xE7\xE2\x61\xF9\xB2\x05\x2C\x25\x03\x0D\x5B\x1E\x03\x6B"
           "\x1F\x10\x0D\x33\xE5\x81\x6D\xAD\x1F\xF8\x6E\xFB\x29\xF3\x8B\xA6"
           "\x32\x64\xAA\xFB\x47\x52\x5C\x47\x7F\x4B\x33\xA0\xAD\x9A\x3C\xB9"
           "\x01\x73\xCD\x6E\xF9\xDE\x18\x53\xC7\x08\x5E\xB7\xD5\xF6\x83\xEF"
           "\x0B\xDC\x5E\x18\x22\x43\xD2\x07\xA5\x20\x58\xA7\xF1\xB6\x2D\x73"
           , 176);
    nDLenExp = 8 + 176;
    memcpy(bPExp,
           "\xC6\xE2\x49\x4C\xD0\x5B\x5F\x8C\x10\xED\x30\x1F\xE3\xCF\xF4\xD7"
           "\xD8\xD6\x72\x54\x10\x17\xFE\x38\xAA\x5E\x19\x8D\x9B\x13\x0E\x65"
           "\x1C\xDC\x82\xCB\x5E\x89\x55\xFD\x14\xBC\x51\xC8\x1D\x22\x2B\x92"
           "\xAF\xDF\xEC\xC0\xA8\xA0\x5F\x3E\xC5\x19\xB0\x71\x57\xEE\x13\x43"
           "\x2A\xF4\x59\x6F\xC0\xFB\x90\xDB\x38\xA5\xF4\x12\x58\x30\xB0\xBD"
           "\x62\x3B\xFC\x05\xBF\x06\x12\xA5"
           , 88);
    nPLenExp = 8 + 88;
    memcpy(bQExp,
           "\x40\x47\x3B\x49\xC3\x65\xE8\xB5\xF3\xDC\x08\x89\x21\xBA\x3D\xEE"
           "\xEA\x47\x4E\x9C\xDF\x39\x8B\xED\x88\x92\x65\x8E\xD3\xFA\xD2\x38"
           "\x48\xCE\x88\x5B\x12\xD4\x06\x5B\x20\xFA\x39\x59\xC6\x4D\xA4\x64"
           "\x11\x56\xB2\x0A\xA0\x74\x88\xD2\x42\xB7\x53\x19\xA8\x26\x1C\xAB"
           "\xAA\x7D\x6D\xF5\x69\x33\x6A\x6B\x30\xB8\x97\x5F\xBF\xE2\x4F\x45"
           "\xBD\xAC\x61\xCC\x11\xA1\xF7\x88"
           , 88);
    nQLenExp = 8 + 88;
    memcpy(bDmP1Exp,
           "\x9F\x8B\x01\x3F\x71\x3D\x5E\x45\xA8\x2C\xCF\xA5\x76\xD9\x21\xA6"
           "\x02\xF4\x77\xDA\xF9\x18\x3C\xCF\x06\x23\x4B\x01\xCD\xB3\xC3\x35"
           "\x8A\x88\x6F\xEE\x96\xBB\xF9\x38\xCE\x4B\x94\x5F\x06\x93\xF2\x65"
           "\x6D\xD8\xAC\x81\xD0\xF9\x22\x17\xB4\xA6\x29\xAE\x3A\x39\x58\x80"
           "\xFB\x16\x27\xAB\x94\x3B\x8B\xC5\xBE\xF4\xB4\x09\xE1\x4A\x82\x0B"
           "\x52\x1B\xB7\xFF\x7D\x52\x57\xED"
           , 88);
    nDmP1LenExp = 8 + 88;
    memcpy(bDmQ1Exp,
           "\xBE\xC0\x42\x2C\xF5\x61\xB4\x71\x9F\x84\x5C\xAE\x7A\x74\x0E\xE6"
           "\x8B\xFB\x3D\xF4\x12\x35\x55\x73\x50\x2B\x96\x56\x77\xC6\xD1\x6C"
           "\xC1\xE2\x2A\x42\x5C\x82\x08\x69\xA0\xAB\x93\xCA\x3C\xBA\x1E\x77"
           "\x4C\x38\xD8\x58\x5A\xCA\xA6\x57\x05\x17\x2E\xF2\x22\xE3\x1C\xFF"
           "\x67\xE0\x58\xC5\x40\x5B\x23\x4D\xEA\x1B\x31\x90\x0A\xF4\x59\xB4"
           "\x4D\x0C\xD9\xC0\x99\x1D\x06\xCA"
           , 88);
    nDmQ1LenExp = 8 + 88;
    memcpy(bCoefExp,
           "\x2C\x0C\x2A\x53\x3C\x28\x86\x76\xCB\xEB\x9E\x2F\x44\x3D\x71\x9B"
           "\x84\xF5\xE7\x24\xD8\x03\x6C\x06\x2C\x2C\x86\x74\xE1\x5F\x80\x73"
           "\xEA\xFC\x38\x9C\xA6\xC6\x01\x76\xF5\xC1\x06\xC4\x33\xD2\x99\x84"
           "\xF5\xDB\xDC\x00\x0D\xFB\xBE\x35\x9B\x80\x76\xAB\xD1\xF9\xC4\x08"
           "\x51\x84\xF0\xF9\x02\x4F\x43\x16\xA4\xA3\xE0\xB5\x97\x7C\xFB\xBB"
           "\x20\x44\x0F\xAA\x41\x25\x2C\x6C"
           , 88);
    nCoefLenExp = 8 + 88;


    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    DspHex("[IN ]bSK      =", bSK, 824);
    printf("[IN ]nSKLen   = %d\n", nSKLen);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bKEK     =", bKEK, 24);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateAnalyse(nSock, bSK, nSKLen, nAlgo, bKEK, bD, &nDLen, \
                               bP, &nPLen, bQ, &nQLen, bDmP1, &nDmP1Len, bDmQ1, \
                               &nDmQ1Len, bCoef, &nCoefLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1408，三倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bD, bDExp, 176);
    ASSERT_OUT(nDLen, nDLenExp);
    ASSERT_OUT_HEX(bP, bPExp, 88);
    ASSERT_OUT(nPLen, nPLenExp);
    ASSERT_OUT_HEX(bQ, bQExp, 88);
    ASSERT_OUT(nQLen, nQLenExp);
    ASSERT_OUT_HEX(bDmP1, bDmP1Exp, 88);
    ASSERT_OUT(nDmP1Len, nDmP1LenExp);
    ASSERT_OUT_HEX(bDmQ1, bDmQ1Exp, 88);
    ASSERT_OUT(nDmQ1Len, nDmQ1LenExp);
    ASSERT_OUT_HEX(bCoef, bCoefExp, 88);
    ASSERT_OUT(nCoefLen, nCoefLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateAnalyse_Test_13(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  BYTE bSK[1280];
	  int  nSKLen;
	  int  nAlgo;
	  BYTE bKEK[32];
	  BYTE bD[276];
	  BYTE bDExp[276];
	  int  nDLen;
	  int  nDLenExp;
	  BYTE bP[144];
	  BYTE bPExp[144];
	  int  nPLen;
	  int  nPLenExp;
	  BYTE bQ[144];
	  BYTE bQExp[144];
	  int  nQLen;
	  int  nQLenExp;
	  BYTE bDmP1[144];
	  BYTE bDmP1Exp[144];
	  int  nDmP1Len;
	  int  nDmP1LenExp;
	  BYTE bDmQ1[144];
	  BYTE bDmQ1Exp[144];
	  int  nDmQ1Len;
	  int  nDmQ1LenExp;
	  BYTE bCoef[144];
	  BYTE bCoefExp[144];
	  int  nCoefLen;
	  int  nCoefLenExp;

    bufclr(bSK);
    bufclr(bKEK);
    bufclr(bD);
    bufclr(bDExp);
    bufclr(bP);
    bufclr(bPExp);
    bufclr(bQ);
    bufclr(bQExp);
    bufclr(bDmP1);
    bufclr(bDmP1Exp);
    bufclr(bDmQ1);
    bufclr(bDmQ1Exp);
    bufclr(bCoef);
    bufclr(bCoefExp);
    nDLen = 0;
    nPLen = 0;
    nQLen = 0;
    nDmP1Len = 0;
    nDmQ1Len = 0;
    nCoefLen = 0;

    memcpy(bSK,
           "\x6C\x18\x21\x1D\x3D\xDC\x38\xA8\xBA\x10\x33\x70\x83\x41\xB5\x37"
           "\xFE\x97\x6F\xB1\xF4\x21\x1A\xAD\x35\x77\xBD\x28\xB2\x57\x20\x10"
           "\x16\x13\x93\x89\x47\xC3\x73\xFC\xB9\x76\x48\x3A\x77\xCD\xA7\x0C"
           "\x17\xE9\xF1\x4C\xD0\xA7\xE1\xAA\x0D\x9A\x8C\x38\xD1\xE6\x83\xA6"
           "\x93\xD4\x55\x28\x6B\xB9\x0F\x81\x02\x7A\x78\x54\x00\x84\x94\xFB"
           "\x82\xCC\x8A\x78\xFC\x93\x45\x6E\xD3\x13\xD3\x1F\x18\x69\x73\x2A"
           "\x70\x86\x1F\xFB\x25\xE6\x2A\x64\xCC\x6F\x1F\x18\x26\x0D\x1C\x40"
           "\xAA\x5E\x52\x50\x22\x5A\xE4\x3C\xBC\x29\xFA\xCA\x30\xE3\x53\x40"
           "\x34\x35\xF1\xD0\xE2\x69\x1D\x34\x8E\x83\x96\xAC\xAA\xCF\x6C\x98"
           "\x3F\x4F\x8C\xEF\x8C\xB3\x3A\x04\xF5\x7C\xB1\x76\xA3\x32\x1B\xC1"
           "\x83\xAD\x70\xA5\xF9\x08\xB8\xD9\x2E\xED\x15\x65\xB0\x33\x30\x04"
           "\x1F\x69\x87\x1D\xFF\xBF\x0F\x59\xE3\x62\xE1\xE8\x2C\x03\x4B\x72"
           "\xB6\xAA\x8F\x73\xBA\xFE\xEE\xCC\xAF\x50\x87\x3D\xA0\x5F\x66\xA0"
           "\x88\x3A\x7F\xDF\xA1\x8E\x06\x08\x18\x2C\x1A\x16\xCE\x0C\x6E\x13"
           "\x4F\x2E\x26\x3B\xB8\xAF\x70\x5E\x70\x48\xED\xCE\x8D\x6C\x9B\x26"
           "\xD7\xFE\x95\x5F\xC6\x91\xB6\x81\x3F\x7C\x9A\xF1\x6D\x1B\xAB\x6E"
           "\x84\x10\x94\x5A\x07\x38\x56\x75\xF0\xEB\x3C\x5E\xA3\x0E\x85\x17"
           "\xFB\x5B\xD0\xFA\x84\x3D\x58\x4C\xFD\xF0\xE5\x37\x77\x29\xE2\x5A"
           "\x7C\x74\x87\x04\x9C\xF0\x7A\x2C\xE4\xD2\x0A\x1C\xD8\x8B\x37\x8C"
           "\x7F\x1C\x10\x6E\x73\xB2\x69\x4C\xBE\x1A\x84\x3C\xC8\xA7\xA3\x68"
           "\x48\x7E\x2F\xFD\x9B\x5F\x12\xAD\x15\x49\x3F\xC4\x10\x86\xAF\x56"
           "\x4D\xCB\xC6\xE8\xAD\x35\x72\x21\x24\xD9\xC3\xA3\x82\xF1\xB2\xAF"
           "\xD9\x88\xBF\xFB\xCB\x81\xF9\xF6\x3B\xC6\x1C\x34\xF0\x5A\x33\xE5"
           "\x41\x9B\xC2\xF9\xE2\x23\x0E\x2D\x11\xC5\xBF\x41\x91\x7B\xE9\x36"
           "\x07\xD8\x60\x00\x09\xDD\xD5\x86\xD7\x65\x50\x98\xBC\x5C\x0E\x60"
           "\xA0\xE5\x53\xEC\xA6\x9D\x11\x99\xEA\x25\x44\xF4\x50\x76\x0D\x4D"
           "\xE7\x72\x87\xCF\x6F\x7C\xF2\x27\xED\x73\xD7\xEF\x53\x6D\x0B\x99"
           "\x6B\x38\x44\xBC\xC0\x12\xF5\xD6\x92\x3F\x64\x81\x54\xC1\xEF\x04"
           "\x5C\x1F\x23\x7E\xF5\x38\xA7\x80\xFC\x17\xEF\x00\x3C\x8D\x09\xAB"
           "\xAA\xD0\x40\x14\xD7\xCB\xAC\xA1\x29\xE0\x12\xD5\xD4\xFF\x1B\xDD"
           "\xCA\x78\x2B\x1D\xEC\x9F\xA5\xAC\x67\x74\x31\x8C\xF6\x8F\x9A\x59"
           "\x7D\x84\xF1\x7E\x5D\xA4\xC9\x53\xEF\x58\x2D\x1F\x0F\x3A\x6D\x66"
           "\xFF\x06\x61\x1A\xDC\xDB\x19\x0C\xE6\x43\xC4\x4A\x2B\x3D\x8E\x79"
           "\xD4\x93\xA8\x9A\x1A\xF7\x91\x45\x77\x78\xAB\xE1\x77\x33\x26\xFF"
           "\x92\x0B\x96\xD5\xF3\xAF\x05\x0B\xC4\x53\x1B\x89\xEC\xDC\xD0\x12"
           "\x4A\x65\xF3\xAD\x43\x8C\x23\x35\x13\x79\x4E\xD8\x0D\x21\xC9\x61"
           "\x49\xCA\x48\x53\x48\xC6\xA1\x7E\xF0\x28\xA5\x97\x11\xB8\x18\x33"
           "\xAD\xEC\xEF\x6B\x5C\x71\x4A\xBE\x9F\x31\xB8\xA3\x98\xC5\x0C\x0B"
           "\x46\x51\xA2\xAE\x02\x6F\x98\x35\xF7\x4D\x21\x5E\xC3\xED\x61\xB0"
           "\x6B\x59\x79\x5A\xB9\xA8\x1C\xB0\xBA\x82\x67\xB9\x97\xBB\xD4\x4D"
           "\xF1\xA1\x56\x5C\x7D\xCB\x77\xD0\x28\xE0\xFF\x1C\xAA\x22\x07\x68"
           "\x9B\xF3\x80\xDE\x96\x1D\x03\xDD\x97\x8A\x69\xDA\x5C\x54\xD4\x80"
           "\x93\xB2\x0D\xCD\x43\xBA\xFC\xDF\x11\xCF\xFE\xCE\x3B\x74\x8E\x67"
           "\x17\x74\x8E\x29\xF9\x64\x97\x52\x8C\x7B\xC9\x71\xB3\x5E\x59\x86"
           "\x63\x38\xF6\x9E\x79\x43\x56\xD6\x6F\xE6\x26\x45\x62\x64\x26\xE0"
           "\xA7\xDC\x70\xCA\x5B\xCD\xE7\xC6\xE1\x1F\xFC\x97\x57\xA1\x2B\xC5"
           "\x12\xB6\x9E\x85\x37\x9E\x58\x48\x2F\x9A\x91\xB7\xB6\x7C\x28\x47"
           "\x1A\x73\x45\x41\xD4\x6E\xBE\xB5\xB7\x60\x1A\xF2\x8B\x04\x78\x38"
           "\x4B\xB6\x45\x8C\xA9\x3E\xE5\x7A\xBF\x1F\xC4\x86\x30\xB4\x0C\xB1"
           "\xC6\x9D\x80\x88\xD2\x49\xD9\x89\xD9\x50\xA8\xDE\xEC\xA5\x04\x7F"
           "\xFF\xEA\xC0\x2F\xCB\x37\x7A\xB6\x97\x59\xAD\x53\x29\x34\xB3\x79"
           "\x16\x3B\x3E\xF5\x7F\x14\xB3\x77\xF9\x2E\xE8\x3F\x04\xAE\xDE\x89"
           "\x73\x04\x32\xA7\x4C\xC0\x4D\x43\x0D\xC1\xE5\x21\x48\x32\xAA\xE1"
           "\x5E\x81\xB6\x23\x6A\x80\xCA\x17\x23\xFC\x5F\x47\xE1\x57\x14\x59"
           "\x46\x67\x0F\xBF\x6A\x57\x53\x10\x8E\xAB\xAA\x9C\x8A\xDD\xE0\x9D"
           "\xA2\xAC\x94\x87\x6A\x71\xD0\xAF\xE4\x8A\xCF\xEB\x23\x27\x00\xC2"
           "\x8B\x11\xA9\x2C\x02\xB5\x05\x03\x30\x7A\x0C\xEF\x7F\x5B\x1C\xE7"
           "\x64\xFF\x1E\x68\x78\x28\x1C\x6D\xA0\x16\x75\x36\x7F\x9F\xF9\xCD"
           "\x15\x3B\x8E\x26\xC3\xF1\x7A\xBC\x17\x42\x92\x7D\xA8\x4E\x22\x5F"
           "\xB9\x55\xF5\xB7\x2C\x10\x5E\x79\xBB\x81\x54\x32\xDC\x8D\xE7\x4B"
           "\xE3\xCB\xDB\x1D\x34\xA4\xBA\x5F\x1A\xFE\x43\x48\x46\xEF\x88\x67"
           "\xD5\xB6\xDD\x06\x99\x5C\xB3\x38\x45\xED\xD0\x21\x77\x22\xF4\xF3"
           "\x68\xD6\x90\x53\xB5\x1E\x36\x3C\x35\x08\xCF\xBE\x53\x8F\x59\xDB"
           "\x4D\xAA\xA2\xB4\xF9\x93\xAC\x4C\x0C\xE4\x5D\xDF\x79\x57\x3C\x8F"
           "\x42\x44\xEC\x0C\x09\xA9\xC6\xE8\xF9\xF0\x80\x2E\x76\x25\x2E\xC1"
           "\x72\x0E\x55\xD6\xB9\x78\x9A\xAE\x56\xFE\x8B\x35\x38\xAF\xE3\x80"
           "\x78\x57\x55\x15\xC9\xEC\xCC\xCB\x42\xC3\xC5\xDF\x8A\xAE\x67\xB0"
           "\xCD\x63\x8E\xFC\x28\x77\x7F\xD1\x31\xFD\x9D\xD2\x79\xC8\x0A\xE0"
           "\x1A\x86\x0D\xEB\x3B\xB4\x64\x49\xAA\x6B\x7B\x73\x27\xEC\x7D\x66"
           "\x6A\x4C\x37\xB3\xCD\x4E\x97\x97\x3C\xEF\x7E\x13\x45\x36\xAA\xFE"
           "\x2E\x16\x48\x90\x5F\x53\x63\x62\xC7\xAB\xC9\xC7\xB5\x9E\xFD\xA5"
           "\x8B\x0C\xCA\xD0\x1E\xBD\x51\x67\x98\x94\x63\x08\x13\xCC\x05\xB9"
           , 1152);
    nSKLen = 1152;
    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKEK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           , 8);

    memcpy(bDExp,
           "\x9C\xB5\xD4\x57\xDF\x61\x5A\xCD\x66\xA1\x94\xAE\x97\x2A\xEB\xC6"
           "\x8B\x39\xF0\xE3\x73\xA8\x08\xCB\x23\x5E\xE7\x24\x2E\xC8\xF6\xA1"
           "\xE5\xE7\x02\x39\x67\xE0\x3E\xA4\x52\x5F\x78\x61\xB7\xC8\xCD\xF2"
           "\xB5\xB8\x68\x72\x3B\x51\xEC\x63\x6A\x4A\x51\xE0\xB0\x2A\x8F\x6D"
           "\x67\xD5\x33\x2E\x92\x39\x10\xD6\xC0\x0F\x77\xF0\xC7\x6C\xDD\x0D"
           "\x2A\xB2\x47\x5C\x36\x85\x9D\xAF\xC2\x01\xCC\x64\x3F\x66\x95\x24"
           "\xBC\x03\x92\x05\x34\xBE\x75\x1F\xC7\x7B\x70\x98\x56\x72\xC7\x82"
           "\xA7\x42\x0A\x6A\xD8\xC6\xF3\x16\x1C\x73\x64\x65\x1D\x20\x51\x01"
           "\xB3\x34\xD0\x13\x01\xFB\xF2\xE1\xC2\xE1\x47\x4A\x95\xB2\x5B\x4D"
           "\xFE\x98\xCD\x0A\x6A\xA8\x39\xF3\x88\x19\x6B\x06\x7A\x4C\xB4\x42"
           "\x2A\x6A\xB3\x85\xEF\x9C\x50\x35\x3F\xB7\xF4\xED\x59\xE9\xCB\xBE"
           "\xB2\x72\x01\xC4\x0F\x2C\xD4\x36\x15\x98\xEA\x02\xF5\x58\xEF\xA7"
           "\x50\x8F\x89\x9C\xB8\x6D\x06\x18\x1A\x79\x6B\x29\xA4\x04\xD8\x52"
           "\xEE\x8B\xB9\xA6\xB3\x5A\xE0\xE3\xE1\x3A\x54\xC2\xEF\x1F\x24\xB4"
           "\xA2\xFC\xAC\xFE\x3D\x31\xAF\x90\xD2\xAB\xF8\x85\x57\xE5\xE5\xC2"
           "\x05\x9F\xF8\x9A\xCA\x5A\x24\xC5"
           , 248);
    nDLenExp = 8 + 248;
    memcpy(bPExp,
           "\xFF\x85\x5A\x25\x0A\x40\x15\xD4\xC4\x74\xC0\x8C\xFD\x64\xAD\xCA"
           "\x2C\x88\x84\xD0\xFF\x71\x07\x0A\xA3\xCC\xE2\xD7\xF1\x6A\x7D\xBD"
           "\x9F\x43\x45\x46\xCB\x25\x42\xA3\xE5\x40\x9B\x57\xBE\xFD\xFC\x07"
           "\xBF\xCD\x62\x88\xEE\x86\xBE\x79\x08\x36\xA6\x7B\x21\x4D\xE8\xC0"
           "\x93\x94\xC2\x02\x3B\xE3\x92\xDB\x16\xDA\x45\x69\x29\x7E\x5A\x0B"
           "\x42\x92\x1F\x5C\x32\xBC\x73\x85\xEA\xB8\x5B\x4D\x78\x57\x3D\x4D"
           "\x6C\x02\xEE\x22\xEC\x04\xFD\x4F\x2E\x51\xE0\x0B\x9A\x4D\xF2\x0E"
           "\xC8\x33\xE4\x6C\x88\x6A\xE9\x19\x15\x7D\x09\x53\xE8\xA7\x96\xBC"
           , 128);
    nPLenExp = 128;
    memcpy(bQExp,
           "\x1A\xB0\xB8\x08\x51\xAA\x5B\x8F\x86\xCE\x99\xB4\x4D\x01\x0B\x25"
           "\x01\xED\xC0\x8B\x6C\xCF\xA6\x01\xD9\x76\x83\xBB\x1E\xBA\x15\x8C"
           "\x61\x4D\xCF\xEC\x28\xBB\x5B\xEA\xD5\x56\x99\xA7\xE8\xEB\xD2\x21"
           "\x8F\x13\x9F\x0F\xB4\x5A\x75\x8C\xB7\xA9\xDD\xDA\x45\xE6\xF0\x37"
           "\x10\xFA\xBA\x0D\xFF\x74\x86\xF2\x60\x78\xDD\x40\xAC\x95\x34\x8C"
           "\xB4\x15\x0F\x75\x13\x9A\x4F\xA7\x62\xD5\xEE\x93\x85\x8A\xAE\xB0"
           "\xF8\x0E\x06\x87\xAC\x1F\xF7\x6F\x3E\xAB\x30\x89\x91\x9B\x1E\xCB"
           "\xEC\xDB\x35\x1D\x3D\xC2\x8B\xB4\xC8\x3B\x9C\x3A\xAC\x09\x4E\xE8"
           , 128);
    nQLenExp = 128;
    memcpy(bDmP1Exp,
           "\x13\x6B\xDF\xAA\x93\x3B\x6A\x6B\x6E\x07\x15\xC6\x12\x25\xE3\xAB"
           "\x76\x6A\xE6\x60\xE3\x98\x23\xEB\x79\x48\x2D\xA6\xDD\xAA\x8E\xBA"
           "\xD6\x68\x2E\x86\x7E\x44\x52\xBC\x06\xF8\xBB\xC6\x99\x24\xE3\xDE"
           "\x35\xD2\x8F\xDB\x1B\x4A\x87\x4A\x5F\x63\xE3\xBF\x91\x9D\x31\x52"
           "\xDC\xC2\x98\x88\x47\xB0\xC1\xA8\x5D\x70\xEE\xA8\x0F\xFA\x03\xFC"
           "\x03\x50\xD6\xC8\x3E\x27\xF4\x44\x38\x16\x39\xE9\x5E\x37\xAE\x8F"
           "\x35\x82\x1F\x0A\x12\xCB\x3D\x74\xDF\x84\x02\x2C\xB9\x2B\x93\xBF"
           "\xA2\xBA\x52\x79\xDC\x3F\x55\xF8\x14\xF1\x6D\x22\xFD\xA2\x59\x38"
           , 128);
    nDmP1LenExp = 128;
    memcpy(bDmQ1Exp,
           "\x75\xA6\x41\x1B\xF8\x6A\x36\xC2\x78\x5B\xB7\xB1\xC5\x74\x75\x72"
           "\xA1\x46\xE8\x77\x90\x0B\xAE\x4F\xC4\x11\x40\x05\xC8\x46\xF2\x2A"
           "\x80\x09\x3C\x9B\x65\x44\x12\x37\xA5\xF5\xB9\xCA\xCC\xDC\x81\xBA"
           "\x8A\xB2\xFF\x33\xBC\x24\x59\xB0\xC1\xE3\x61\x91\xB7\xD1\x08\x1E"
           "\xED\xE9\xFA\xBC\x08\xA4\xB5\x0C\xF9\xF3\x2B\x2C\x5B\x8F\x60\x42"
           "\x3F\x26\xED\x52\x6D\xD7\xAC\xD6\x19\x8E\x90\xE8\xCF\x88\x47\x7C"
           "\x71\x24\x2D\x64\xD8\x0D\xEC\xAB\x6F\xB7\x16\x8A\xE0\x54\xDE\xC8"
           "\xEB\xD9\xB1\xA0\x10\xE6\x57\x3C\x98\xAF\x50\x07\xA8\xD7\xA8\x8B"
           , 128);
    nDmQ1LenExp = 128;
    memcpy(bCoefExp,
           "\x36\x73\x69\x10\x7A\xE1\x0F\x8F\x52\x44\xB9\x05\x7F\x32\x99\x34"
           "\x20\x34\xEC\x3F\x18\x87\x0C\xC4\x21\xF3\x3C\x49\x40\x31\xA8\x0A"
           "\x16\x28\x54\x3D\xCE\xE3\x8A\x07\x65\x40\xFC\x86\xD3\x0E\x55\x58"
           "\x97\x28\xF2\x71\xBC\x8B\x7F\x12\x4F\x94\x5B\x58\x28\x28\x0D\xE2"
           "\x10\x24\xC7\xC9\x50\xCE\x61\x82\xA9\xC9\xCA\xB4\x4B\x48\xB4\x31"
           "\x20\x10\x83\x4C\x23\xDB\xC3\xFF\x22\xDB\x6C\xC4\x64\xC8\x80\x47"
           "\x8F\x27\x84\x16\x86\xFA\xE1\xEE\xDA\x93\x53\x7B\xC4\x83\x92\x6E"
           "\xC4\xDC\x4E\x27\xD6\xD2\x85\xD2\x08\xF3\x84\xFA\xE8\x48\x5E\x5A"
           , 128);
    nCoefLenExp = 128;

    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    DspHex("[IN ]bSK      =", bSK, 1152);
    printf("[IN ]nSKLen   = %d\n", nSKLen);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bKEK     =", bKEK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateAnalyse(nSock, bSK, nSKLen, nAlgo, bKEK, bD, &nDLen, \
                               bP, &nPLen, bQ, &nQLen, bDmP1, &nDmP1Len, bDmQ1, \
                               &nDmQ1Len, bCoef, &nCoefLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1984，单倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bD, bDExp, 248);
    ASSERT_OUT(nDLen, nDLenExp);
    ASSERT_OUT_HEX(bP, bPExp, 128);
    ASSERT_OUT(nPLen, nPLenExp);
    ASSERT_OUT_HEX(bQ, bQExp, 128);
    ASSERT_OUT(nQLen, nQLenExp);
    ASSERT_OUT_HEX(bDmP1, bDmP1Exp, 128);
    ASSERT_OUT(nDmP1Len, nDmP1LenExp);
    ASSERT_OUT_HEX(bDmQ1, bDmQ1Exp, 128);
    ASSERT_OUT(nDmQ1Len, nDmQ1LenExp);
    ASSERT_OUT_HEX(bCoef, bCoefExp, 128);
    ASSERT_OUT(nCoefLen, nCoefLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateAnalyse_Test_14(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  BYTE bSK[1280];
	  int  nSKLen;
	  int  nAlgo;
	  BYTE bKEK[32];
	  BYTE bD[276];
	  BYTE bDExp[276];
	  int  nDLen;
	  int  nDLenExp;
	  BYTE bP[144];
	  BYTE bPExp[144];
	  int  nPLen;
	  int  nPLenExp;
	  BYTE bQ[144];
	  BYTE bQExp[144];
	  int  nQLen;
	  int  nQLenExp;
	  BYTE bDmP1[144];
	  BYTE bDmP1Exp[144];
	  int  nDmP1Len;
	  int  nDmP1LenExp;
	  BYTE bDmQ1[144];
	  BYTE bDmQ1Exp[144];
	  int  nDmQ1Len;
	  int  nDmQ1LenExp;
	  BYTE bCoef[144];
	  BYTE bCoefExp[144];
	  int  nCoefLen;
	  int  nCoefLenExp;

    bufclr(bSK);
    bufclr(bKEK);
    bufclr(bD);
    bufclr(bDExp);
    bufclr(bP);
    bufclr(bPExp);
    bufclr(bQ);
    bufclr(bQExp);
    bufclr(bDmP1);
    bufclr(bDmP1Exp);
    bufclr(bDmQ1);
    bufclr(bDmQ1Exp);
    bufclr(bCoef);
    bufclr(bCoefExp);
    nDLen = 0;
    nPLen = 0;
    nQLen = 0;
    nDmP1Len = 0;
    nDmQ1Len = 0;
    nCoefLen = 0;

    memcpy(bSK,
           "\x6C\x18\x21\x1D\x3D\xDC\x38\xA8\xBA\x10\x33\x70\x83\x41\xB5\x37"
           "\xFE\x97\x6F\xB1\xF4\x21\x1A\xAD\x35\x77\xBD\x28\xB2\x57\x20\x10"
           "\x16\x13\x93\x89\x47\xC3\x73\xFC\xB9\x76\x48\x3A\x77\xCD\xA7\x0C"
           "\x17\xE9\xF1\x4C\xD0\xA7\xE1\xAA\x0D\x9A\x8C\x38\xD1\xE6\x83\xA6"
           "\x93\xD4\x55\x28\x6B\xB9\x0F\x81\x02\x7A\x78\x54\x00\x84\x94\xFB"
           "\x82\xCC\x8A\x78\xFC\x93\x45\x6E\xD3\x13\xD3\x1F\x18\x69\x73\x2A"
           "\x70\x86\x1F\xFB\x25\xE6\x2A\x64\xCC\x6F\x1F\x18\x26\x0D\x1C\x40"
           "\xAA\x5E\x52\x50\x22\x5A\xE4\x3C\xBC\x29\xFA\xCA\x30\xE3\x53\x40"
           "\x34\x35\xF1\xD0\xE2\x69\x1D\x34\x8E\x83\x96\xAC\xAA\xCF\x6C\x98"
           "\x3F\x4F\x8C\xEF\x8C\xB3\x3A\x04\xF5\x7C\xB1\x76\xA3\x32\x1B\xC1"
           "\x83\xAD\x70\xA5\xF9\x08\xB8\xD9\x2E\xED\x15\x65\xB0\x33\x30\x04"
           "\x1F\x69\x87\x1D\xFF\xBF\x0F\x59\xE3\x62\xE1\xE8\x2C\x03\x4B\x72"
           "\xB6\xAA\x8F\x73\xBA\xFE\xEE\xCC\xAF\x50\x87\x3D\xA0\x5F\x66\xA0"
           "\x88\x3A\x7F\xDF\xA1\x8E\x06\x08\x18\x2C\x1A\x16\xCE\x0C\x6E\x13"
           "\x4F\x2E\x26\x3B\xB8\xAF\x70\x5E\x70\x48\xED\xCE\x8D\x6C\x9B\x26"
           "\xD7\xFE\x95\x5F\xC6\x91\xB6\x81\x3F\x7C\x9A\xF1\x6D\x1B\xAB\x6E"
           "\x84\x10\x94\x5A\x07\x38\x56\x75\xF0\xEB\x3C\x5E\xA3\x0E\x85\x17"
           "\xFB\x5B\xD0\xFA\x84\x3D\x58\x4C\xFD\xF0\xE5\x37\x77\x29\xE2\x5A"
           "\x7C\x74\x87\x04\x9C\xF0\x7A\x2C\xE4\xD2\x0A\x1C\xD8\x8B\x37\x8C"
           "\x7F\x1C\x10\x6E\x73\xB2\x69\x4C\xBE\x1A\x84\x3C\xC8\xA7\xA3\x68"
           "\x48\x7E\x2F\xFD\x9B\x5F\x12\xAD\x15\x49\x3F\xC4\x10\x86\xAF\x56"
           "\x4D\xCB\xC6\xE8\xAD\x35\x72\x21\x24\xD9\xC3\xA3\x82\xF1\xB2\xAF"
           "\xD9\x88\xBF\xFB\xCB\x81\xF9\xF6\x3B\xC6\x1C\x34\xF0\x5A\x33\xE5"
           "\x41\x9B\xC2\xF9\xE2\x23\x0E\x2D\x11\xC5\xBF\x41\x91\x7B\xE9\x36"
           "\x07\xD8\x60\x00\x09\xDD\xD5\x86\xD7\x65\x50\x98\xBC\x5C\x0E\x60"
           "\xA0\xE5\x53\xEC\xA6\x9D\x11\x99\xEA\x25\x44\xF4\x50\x76\x0D\x4D"
           "\xE7\x72\x87\xCF\x6F\x7C\xF2\x27\xED\x73\xD7\xEF\x53\x6D\x0B\x99"
           "\x6B\x38\x44\xBC\xC0\x12\xF5\xD6\x92\x3F\x64\x81\x54\xC1\xEF\x04"
           "\x5C\x1F\x23\x7E\xF5\x38\xA7\x80\xFC\x17\xEF\x00\x3C\x8D\x09\xAB"
           "\xAA\xD0\x40\x14\xD7\xCB\xAC\xA1\x29\xE0\x12\xD5\xD4\xFF\x1B\xDD"
           "\xCA\x78\x2B\x1D\xEC\x9F\xA5\xAC\x67\x74\x31\x8C\xF6\x8F\x9A\x59"
           "\x7D\x84\xF1\x7E\x5D\xA4\xC9\x53\xEF\x58\x2D\x1F\x0F\x3A\x6D\x66"
           "\xFF\x06\x61\x1A\xDC\xDB\x19\x0C\xE6\x43\xC4\x4A\x2B\x3D\x8E\x79"
           "\xD4\x93\xA8\x9A\x1A\xF7\x91\x45\x77\x78\xAB\xE1\x77\x33\x26\xFF"
           "\x92\x0B\x96\xD5\xF3\xAF\x05\x0B\xC4\x53\x1B\x89\xEC\xDC\xD0\x12"
           "\x4A\x65\xF3\xAD\x43\x8C\x23\x35\x13\x79\x4E\xD8\x0D\x21\xC9\x61"
           "\x49\xCA\x48\x53\x48\xC6\xA1\x7E\xF0\x28\xA5\x97\x11\xB8\x18\x33"
           "\xAD\xEC\xEF\x6B\x5C\x71\x4A\xBE\x9F\x31\xB8\xA3\x98\xC5\x0C\x0B"
           "\x46\x51\xA2\xAE\x02\x6F\x98\x35\xF7\x4D\x21\x5E\xC3\xED\x61\xB0"
           "\x6B\x59\x79\x5A\xB9\xA8\x1C\xB0\xBA\x82\x67\xB9\x97\xBB\xD4\x4D"
           "\xF1\xA1\x56\x5C\x7D\xCB\x77\xD0\x28\xE0\xFF\x1C\xAA\x22\x07\x68"
           "\x9B\xF3\x80\xDE\x96\x1D\x03\xDD\x97\x8A\x69\xDA\x5C\x54\xD4\x80"
           "\x93\xB2\x0D\xCD\x43\xBA\xFC\xDF\x11\xCF\xFE\xCE\x3B\x74\x8E\x67"
           "\x17\x74\x8E\x29\xF9\x64\x97\x52\x8C\x7B\xC9\x71\xB3\x5E\x59\x86"
           "\x63\x38\xF6\x9E\x79\x43\x56\xD6\x6F\xE6\x26\x45\x62\x64\x26\xE0"
           "\xA7\xDC\x70\xCA\x5B\xCD\xE7\xC6\xE1\x1F\xFC\x97\x57\xA1\x2B\xC5"
           "\x12\xB6\x9E\x85\x37\x9E\x58\x48\x2F\x9A\x91\xB7\xB6\x7C\x28\x47"
           "\x1A\x73\x45\x41\xD4\x6E\xBE\xB5\xB7\x60\x1A\xF2\x8B\x04\x78\x38"
           "\x4B\xB6\x45\x8C\xA9\x3E\xE5\x7A\xBF\x1F\xC4\x86\x30\xB4\x0C\xB1"
           "\xC6\x9D\x80\x88\xD2\x49\xD9\x89\xD9\x50\xA8\xDE\xEC\xA5\x04\x7F"
           "\xFF\xEA\xC0\x2F\xCB\x37\x7A\xB6\x97\x59\xAD\x53\x29\x34\xB3\x79"
           "\x16\x3B\x3E\xF5\x7F\x14\xB3\x77\xF9\x2E\xE8\x3F\x04\xAE\xDE\x89"
           "\x73\x04\x32\xA7\x4C\xC0\x4D\x43\x0D\xC1\xE5\x21\x48\x32\xAA\xE1"
           "\x5E\x81\xB6\x23\x6A\x80\xCA\x17\x23\xFC\x5F\x47\xE1\x57\x14\x59"
           "\x46\x67\x0F\xBF\x6A\x57\x53\x10\x8E\xAB\xAA\x9C\x8A\xDD\xE0\x9D"
           "\xA2\xAC\x94\x87\x6A\x71\xD0\xAF\xE4\x8A\xCF\xEB\x23\x27\x00\xC2"
           "\x8B\x11\xA9\x2C\x02\xB5\x05\x03\x30\x7A\x0C\xEF\x7F\x5B\x1C\xE7"
           "\x64\xFF\x1E\x68\x78\x28\x1C\x6D\xA0\x16\x75\x36\x7F\x9F\xF9\xCD"
           "\x15\x3B\x8E\x26\xC3\xF1\x7A\xBC\x17\x42\x92\x7D\xA8\x4E\x22\x5F"
           "\xB9\x55\xF5\xB7\x2C\x10\x5E\x79\xBB\x81\x54\x32\xDC\x8D\xE7\x4B"
           "\xE3\xCB\xDB\x1D\x34\xA4\xBA\x5F\x1A\xFE\x43\x48\x46\xEF\x88\x67"
           "\xD5\xB6\xDD\x06\x99\x5C\xB3\x38\x45\xED\xD0\x21\x77\x22\xF4\xF3"
           "\x68\xD6\x90\x53\xB5\x1E\x36\x3C\x35\x08\xCF\xBE\x53\x8F\x59\xDB"
           "\x4D\xAA\xA2\xB4\xF9\x93\xAC\x4C\x0C\xE4\x5D\xDF\x79\x57\x3C\x8F"
           "\x42\x44\xEC\x0C\x09\xA9\xC6\xE8\xF9\xF0\x80\x2E\x76\x25\x2E\xC1"
           "\x72\x0E\x55\xD6\xB9\x78\x9A\xAE\x56\xFE\x8B\x35\x38\xAF\xE3\x80"
           "\x78\x57\x55\x15\xC9\xEC\xCC\xCB\x42\xC3\xC5\xDF\x8A\xAE\x67\xB0"
           "\xCD\x63\x8E\xFC\x28\x77\x7F\xD1\x31\xFD\x9D\xD2\x79\xC8\x0A\xE0"
           "\x1A\x86\x0D\xEB\x3B\xB4\x64\x49\xAA\x6B\x7B\x73\x27\xEC\x7D\x66"
           "\x6A\x4C\x37\xB3\xCD\x4E\x97\x97\x3C\xEF\x7E\x13\x45\x36\xAA\xFE"
           "\x2E\x16\x48\x90\x5F\x53\x63\x62\xC7\xAB\xC9\xC7\xB5\x9E\xFD\xA5"
           "\x8B\x0C\xCA\xD0\x1E\xBD\x51\x67\x98\x94\x63\x08\x13\xCC\x05\xB9"
           , 1152);
    nSKLen = 1152;
    nAlgo = 2;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKEK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           , 16);

    memcpy(bDExp,
           "\xF8\xDD\xEB\x2A\xA6\x48\x4D\x3F\x2B\xFB\xCF\x1A\x51\x00\x32\xA4"
           "\xB3\x44\xAF\x26\xEC\x20\xCF\x05\x6E\x7B\x6F\xF5\xEA\x37\xC1\xC4"
           "\x55\x1D\xDA\x8A\x85\x9C\xD1\x66\x04\xA1\x35\x2A\x45\x9A\xB9\xC2"
           "\xE1\xD2\xA5\xE3\x39\xDD\x3D\x04\xE1\xFD\x6A\x9A\x07\x39\x2E\xF2"
           "\xED\xE7\xB4\x40\x8E\x41\xA7\xAC\x42\xBC\x0B\xDA\xBF\x6E\xB4\x94"
           "\xC6\xEE\x30\x82\xCA\x16\xF7\x5D\x1A\xF5\x97\x9E\x3C\xE5\xAA\x03"
           "\x54\x5D\x87\x9E\xF3\x9C\x4E\xE1\xF7\xAD\x80\x62\xEB\x30\x9A\xD3"
           "\x75\x88\xF3\x08\x0F\x10\xB8\x58\x60\x0B\xFF\x00\x75\xE8\xEF\x33"
           "\xFB\xB2\xAE\x3B\xE7\x70\xF8\x32\x04\xD6\xF0\x9B\x97\x1D\x57\x16"
           "\x35\x86\x00\xCE\x7A\x4C\x73\xF2\x11\x36\x0A\xAA\xE4\x0E\x6D\xD8"
           "\xED\x93\x1C\xE6\x50\x79\x82\xE5\xEA\x69\x94\x97\x3C\x01\xAB\x24"
           "\xE5\x07\xE6\xE9\xC5\x67\xF0\x14\x29\x55\x5C\xF7\x43\x48\xE9\xBC"
           "\x55\xCD\x14\x59\xF4\xAD\x15\xE0\x7E\xD0\x7A\x31\x51\xCE\xE9\x28"
           "\x1A\x1D\x91\x4E\x8A\xAA\xCE\x27\xF6\x9F\x86\x79\x5D\x95\xF0\xD0"
           "\x02\x0F\x8F\xEF\x0C\xD3\xF3\xBE\xF3\x65\x6F\xC9\x89\x1C\xA4\xFC"
           "\x24\xE1\x0A\x8C\xD6\x9B\x33\xA8"
           , 248);
    nDLenExp = 8 + 248;
    memcpy(bPExp,
           "\x9E\x72\xD6\x66\xB3\xF0\x19\xC0\xD0\xF9\x20\x34\xCF\x77\xC8\x24"
           "\xEA\x95\x06\xAA\xF5\xF9\x4F\x59\xF8\xD8\x40\xA5\x87\x44\xA5\xC4"
           "\xE9\xE2\xCA\xE9\x67\xF4\xC2\x22\x96\x4C\xAA\xF1\xC6\x60\xB7\xA7"
           "\x5B\x0B\x03\x79\x7F\xB2\xAD\xDD\x7C\x93\x56\xFF\x5B\x6E\x61\x82"
           "\x71\xFB\x3E\x4A\x1F\x1D\xBA\xCF\xF7\x50\x99\xED\x9F\x79\x20\x19"
           "\x07\x49\xF4\x26\xD5\x1D\x5A\x30\x6E\xE8\x37\x31\x7F\xA5\x85\x3A"
           "\x7E\xFB\x4A\x2F\xA7\xF9\xBC\x3E\x59\xAD\x5F\x2F\xA3\x6D\xFE\x43"
           "\xDA\xE9\x53\xA4\xF6\x7E\x65\xFA\xB0\x84\xE3\x25\x30\x63\x2F\xDC"
           , 128);
    nPLenExp = 128;
    memcpy(bQExp,
           "\x50\xBF\x88\x00\x4C\x44\xDB\x6B\x52\xF0\x63\x07\x45\x63\xEF\x69"
           "\xE4\x6E\x82\x0B\xCC\xCE\x91\x10\x36\x8F\x22\x84\x9B\x43\xC3\x24"
           "\x27\x3F\xEA\x2A\xB3\x07\x91\x8B\x9F\x4D\x5B\x00\x4D\x80\x0E\xE4"
           "\xEA\x1D\x44\x17\x0B\x39\x27\x6B\x04\x4E\x6E\x6B\x36\x09\x25\xDD"
           "\xF0\xCB\x70\x3F\x39\x0D\x71\x6F\xEE\xF0\xC5\x7B\xFD\xB5\x18\xF7"
           "\xD5\x5F\xDB\x0A\x4D\x79\x43\x5D\x1B\x2E\x73\x6C\xCE\x0E\x06\xAD"
           "\xC7\xCA\x2E\x03\x76\xCA\x5A\x9C\xBB\xC6\x9C\xED\x97\x9A\x1B\xBD"
           "\x18\x51\x12\xAF\xEF\xAF\xCC\xAD\x1E\x89\xDA\x36\x6E\x8A\xDD\x01"
           , 128);
    nQLenExp = 128;
    memcpy(bDmP1Exp,
           "\xA8\x6C\x63\x83\x6A\x75\x50\x0C\xFF\x90\x0D\x25\x70\x64\xE1\x1D"
           "\x06\x52\x80\x5A\xA8\x99\x6A\x00\x18\x35\x34\x37\x7D\x2E\x0B\x02"
           "\x00\xC8\x5D\x4C\x7C\x32\x05\xA3\xAC\xDB\xC1\xDD\x8F\x71\x0C\x0D"
           "\xC4\x7C\xE5\x75\xD2\x19\xEF\x39\xE2\x33\x5C\x0C\x9A\x26\x75\x67"
           "\x26\xB2\x9A\x98\xF3\xCC\x21\xF1\xC5\xD3\x88\xE7\x27\x08\xC6\x5B"
           "\x47\xF6\xC5\xF9\x3C\xE7\x06\x71\xAF\x21\x94\x43\xC5\x39\xD6\x6C"
           "\x31\x2F\x7E\x91\xE3\x53\xD2\x3F\x3F\xED\xBD\xFB\x22\xBB\xD4\x00"
           "\x00\xE4\x2E\xB0\x70\x1D\x2C\xD3\x07\xDE\x74\xEE\x00\xF2\x75\xA6"
           , 128);
    nDmP1LenExp = 128;
    memcpy(bDmQ1Exp,
           "\xE7\x6F\x91\xA8\xEC\x7E\xC0\xFF\x65\x77\x4D\xC6\xC4\x70\x04\x3B"
           "\xA0\x54\x80\xA3\x00\xB6\x40\x05\x56\x1C\x5A\xE8\x96\xF6\x48\x0D"
           "\x05\x2C\x71\xD8\x21\x2F\x9D\x0F\x18\x27\xF0\xC2\xA5\xBF\xA7\xDA"
           "\x41\xA7\x10\xCB\x04\x18\xE3\xF8\x31\x55\xDC\xB8\xB2\x09\x37\x3E"
           "\xB7\xB4\x9F\x8E\xAB\xC0\x57\x05\xFE\x34\xEA\xEE\xCE\x0C\x00\x52"
           "\xD2\x8F\x13\xAE\x34\x13\xB9\x24\x57\xDA\xE6\x88\xA6\x4F\x3C\x95"
           "\x27\x35\x61\x37\x28\x41\x02\xDD\x54\xBC\x76\xC1\x07\x22\x49\x33"
           "\xB8\x86\x06\xCD\x53\xFD\xD9\x5F\x61\x45\xB8\xB9\xB8\x22\x50\xFC"
           , 128);
    nDmQ1LenExp = 128;
    memcpy(bCoefExp,
           "\xFE\x04\xEB\xC3\x2A\x7D\x85\x0D\x36\xCB\xD7\xD4\xAB\xB0\xC8\xC0"
           "\xC5\x4E\x28\x8B\xB7\xF6\x34\x30\x65\xF6\x71\xAF\x3E\x63\x65\x9F"
           "\x0D\x13\x89\x2C\x86\x08\x4C\xA1\xE4\xE7\xED\xE0\xEA\xE3\x8C\x13"
           "\x6E\x86\xFC\x3D\x3B\x68\x9C\x14\xFD\x3C\x5D\x9A\x7D\xD7\xE9\xA5"
           "\x87\x9F\x34\xD8\x47\x15\xBF\x20\xB2\x08\xEE\x3A\x06\x39\x48\x56"
           "\x77\x0C\x4F\x4B\xFE\x4C\x85\xA3\x49\x37\xBD\xF8\x54\x5D\x63\xDB"
           "\x3C\x85\x4F\xBB\x54\xCC\xFF\xFC\xF0\x0C\x62\xA0\x0D\x15\x1B\x37"
           "\xE4\x6E\x7C\xC6\x4E\x71\x53\x69\xDB\x76\x7A\x11\x4E\xFA\x8A\xD8"
           , 128);
    nCoefLenExp = 128;

    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    DspHex("[IN ]bSK      =", bSK, 1152);
    printf("[IN ]nSKLen   = %d\n", nSKLen);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bKEK     =", bKEK, 16);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateAnalyse(nSock, bSK, nSKLen, nAlgo, bKEK, bD, &nDLen, \
                               bP, &nPLen, bQ, &nQLen, bDmP1, &nDmP1Len, bDmQ1, \
                               &nDmQ1Len, bCoef, &nCoefLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1984，双倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bD, bDExp, 248);
    ASSERT_OUT(nDLen, nDLenExp);
    ASSERT_OUT_HEX(bP, bPExp, 128);
    ASSERT_OUT(nPLen, nPLenExp);
    ASSERT_OUT_HEX(bQ, bQExp, 128);
    ASSERT_OUT(nQLen, nQLenExp);
    ASSERT_OUT_HEX(bDmP1, bDmP1Exp, 128);
    ASSERT_OUT(nDmP1Len, nDmP1LenExp);
    ASSERT_OUT_HEX(bDmQ1, bDmQ1Exp, 128);
    ASSERT_OUT(nDmQ1Len, nDmQ1LenExp);
    ASSERT_OUT_HEX(bCoef, bCoefExp, 128);
    ASSERT_OUT(nCoefLen, nCoefLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateAnalyse_Test_15(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  BYTE bSK[1280];
	  int  nSKLen;
	  int  nAlgo;
	  BYTE bKEK[32];
	  BYTE bD[276];
	  BYTE bDExp[276];
	  int  nDLen;
	  int  nDLenExp;
	  BYTE bP[144];
	  BYTE bPExp[144];
	  int  nPLen;
	  int  nPLenExp;
	  BYTE bQ[144];
	  BYTE bQExp[144];
	  int  nQLen;
	  int  nQLenExp;
	  BYTE bDmP1[144];
	  BYTE bDmP1Exp[144];
	  int  nDmP1Len;
	  int  nDmP1LenExp;
	  BYTE bDmQ1[144];
	  BYTE bDmQ1Exp[144];
	  int  nDmQ1Len;
	  int  nDmQ1LenExp;
	  BYTE bCoef[144];
	  BYTE bCoefExp[144];
	  int  nCoefLen;
	  int  nCoefLenExp;

    bufclr(bSK);
    bufclr(bKEK);
    bufclr(bD);
    bufclr(bDExp);
    bufclr(bP);
    bufclr(bPExp);
    bufclr(bQ);
    bufclr(bQExp);
    bufclr(bDmP1);
    bufclr(bDmP1Exp);
    bufclr(bDmQ1);
    bufclr(bDmQ1Exp);
    bufclr(bCoef);
    bufclr(bCoefExp);
    nDLen = 0;
    nPLen = 0;
    nQLen = 0;
    nDmP1Len = 0;
    nDmQ1Len = 0;
    nCoefLen = 0;

    memcpy(bSK,
           "\x6C\x18\x21\x1D\x3D\xDC\x38\xA8\xBA\x10\x33\x70\x83\x41\xB5\x37"
           "\xFE\x97\x6F\xB1\xF4\x21\x1A\xAD\x35\x77\xBD\x28\xB2\x57\x20\x10"
           "\x16\x13\x93\x89\x47\xC3\x73\xFC\xB9\x76\x48\x3A\x77\xCD\xA7\x0C"
           "\x17\xE9\xF1\x4C\xD0\xA7\xE1\xAA\x0D\x9A\x8C\x38\xD1\xE6\x83\xA6"
           "\x93\xD4\x55\x28\x6B\xB9\x0F\x81\x02\x7A\x78\x54\x00\x84\x94\xFB"
           "\x82\xCC\x8A\x78\xFC\x93\x45\x6E\xD3\x13\xD3\x1F\x18\x69\x73\x2A"
           "\x70\x86\x1F\xFB\x25\xE6\x2A\x64\xCC\x6F\x1F\x18\x26\x0D\x1C\x40"
           "\xAA\x5E\x52\x50\x22\x5A\xE4\x3C\xBC\x29\xFA\xCA\x30\xE3\x53\x40"
           "\x34\x35\xF1\xD0\xE2\x69\x1D\x34\x8E\x83\x96\xAC\xAA\xCF\x6C\x98"
           "\x3F\x4F\x8C\xEF\x8C\xB3\x3A\x04\xF5\x7C\xB1\x76\xA3\x32\x1B\xC1"
           "\x83\xAD\x70\xA5\xF9\x08\xB8\xD9\x2E\xED\x15\x65\xB0\x33\x30\x04"
           "\x1F\x69\x87\x1D\xFF\xBF\x0F\x59\xE3\x62\xE1\xE8\x2C\x03\x4B\x72"
           "\xB6\xAA\x8F\x73\xBA\xFE\xEE\xCC\xAF\x50\x87\x3D\xA0\x5F\x66\xA0"
           "\x88\x3A\x7F\xDF\xA1\x8E\x06\x08\x18\x2C\x1A\x16\xCE\x0C\x6E\x13"
           "\x4F\x2E\x26\x3B\xB8\xAF\x70\x5E\x70\x48\xED\xCE\x8D\x6C\x9B\x26"
           "\xD7\xFE\x95\x5F\xC6\x91\xB6\x81\x3F\x7C\x9A\xF1\x6D\x1B\xAB\x6E"
           "\x84\x10\x94\x5A\x07\x38\x56\x75\xF0\xEB\x3C\x5E\xA3\x0E\x85\x17"
           "\xFB\x5B\xD0\xFA\x84\x3D\x58\x4C\xFD\xF0\xE5\x37\x77\x29\xE2\x5A"
           "\x7C\x74\x87\x04\x9C\xF0\x7A\x2C\xE4\xD2\x0A\x1C\xD8\x8B\x37\x8C"
           "\x7F\x1C\x10\x6E\x73\xB2\x69\x4C\xBE\x1A\x84\x3C\xC8\xA7\xA3\x68"
           "\x48\x7E\x2F\xFD\x9B\x5F\x12\xAD\x15\x49\x3F\xC4\x10\x86\xAF\x56"
           "\x4D\xCB\xC6\xE8\xAD\x35\x72\x21\x24\xD9\xC3\xA3\x82\xF1\xB2\xAF"
           "\xD9\x88\xBF\xFB\xCB\x81\xF9\xF6\x3B\xC6\x1C\x34\xF0\x5A\x33\xE5"
           "\x41\x9B\xC2\xF9\xE2\x23\x0E\x2D\x11\xC5\xBF\x41\x91\x7B\xE9\x36"
           "\x07\xD8\x60\x00\x09\xDD\xD5\x86\xD7\x65\x50\x98\xBC\x5C\x0E\x60"
           "\xA0\xE5\x53\xEC\xA6\x9D\x11\x99\xEA\x25\x44\xF4\x50\x76\x0D\x4D"
           "\xE7\x72\x87\xCF\x6F\x7C\xF2\x27\xED\x73\xD7\xEF\x53\x6D\x0B\x99"
           "\x6B\x38\x44\xBC\xC0\x12\xF5\xD6\x92\x3F\x64\x81\x54\xC1\xEF\x04"
           "\x5C\x1F\x23\x7E\xF5\x38\xA7\x80\xFC\x17\xEF\x00\x3C\x8D\x09\xAB"
           "\xAA\xD0\x40\x14\xD7\xCB\xAC\xA1\x29\xE0\x12\xD5\xD4\xFF\x1B\xDD"
           "\xCA\x78\x2B\x1D\xEC\x9F\xA5\xAC\x67\x74\x31\x8C\xF6\x8F\x9A\x59"
           "\x7D\x84\xF1\x7E\x5D\xA4\xC9\x53\xEF\x58\x2D\x1F\x0F\x3A\x6D\x66"
           "\xFF\x06\x61\x1A\xDC\xDB\x19\x0C\xE6\x43\xC4\x4A\x2B\x3D\x8E\x79"
           "\xD4\x93\xA8\x9A\x1A\xF7\x91\x45\x77\x78\xAB\xE1\x77\x33\x26\xFF"
           "\x92\x0B\x96\xD5\xF3\xAF\x05\x0B\xC4\x53\x1B\x89\xEC\xDC\xD0\x12"
           "\x4A\x65\xF3\xAD\x43\x8C\x23\x35\x13\x79\x4E\xD8\x0D\x21\xC9\x61"
           "\x49\xCA\x48\x53\x48\xC6\xA1\x7E\xF0\x28\xA5\x97\x11\xB8\x18\x33"
           "\xAD\xEC\xEF\x6B\x5C\x71\x4A\xBE\x9F\x31\xB8\xA3\x98\xC5\x0C\x0B"
           "\x46\x51\xA2\xAE\x02\x6F\x98\x35\xF7\x4D\x21\x5E\xC3\xED\x61\xB0"
           "\x6B\x59\x79\x5A\xB9\xA8\x1C\xB0\xBA\x82\x67\xB9\x97\xBB\xD4\x4D"
           "\xF1\xA1\x56\x5C\x7D\xCB\x77\xD0\x28\xE0\xFF\x1C\xAA\x22\x07\x68"
           "\x9B\xF3\x80\xDE\x96\x1D\x03\xDD\x97\x8A\x69\xDA\x5C\x54\xD4\x80"
           "\x93\xB2\x0D\xCD\x43\xBA\xFC\xDF\x11\xCF\xFE\xCE\x3B\x74\x8E\x67"
           "\x17\x74\x8E\x29\xF9\x64\x97\x52\x8C\x7B\xC9\x71\xB3\x5E\x59\x86"
           "\x63\x38\xF6\x9E\x79\x43\x56\xD6\x6F\xE6\x26\x45\x62\x64\x26\xE0"
           "\xA7\xDC\x70\xCA\x5B\xCD\xE7\xC6\xE1\x1F\xFC\x97\x57\xA1\x2B\xC5"
           "\x12\xB6\x9E\x85\x37\x9E\x58\x48\x2F\x9A\x91\xB7\xB6\x7C\x28\x47"
           "\x1A\x73\x45\x41\xD4\x6E\xBE\xB5\xB7\x60\x1A\xF2\x8B\x04\x78\x38"
           "\x4B\xB6\x45\x8C\xA9\x3E\xE5\x7A\xBF\x1F\xC4\x86\x30\xB4\x0C\xB1"
           "\xC6\x9D\x80\x88\xD2\x49\xD9\x89\xD9\x50\xA8\xDE\xEC\xA5\x04\x7F"
           "\xFF\xEA\xC0\x2F\xCB\x37\x7A\xB6\x97\x59\xAD\x53\x29\x34\xB3\x79"
           "\x16\x3B\x3E\xF5\x7F\x14\xB3\x77\xF9\x2E\xE8\x3F\x04\xAE\xDE\x89"
           "\x73\x04\x32\xA7\x4C\xC0\x4D\x43\x0D\xC1\xE5\x21\x48\x32\xAA\xE1"
           "\x5E\x81\xB6\x23\x6A\x80\xCA\x17\x23\xFC\x5F\x47\xE1\x57\x14\x59"
           "\x46\x67\x0F\xBF\x6A\x57\x53\x10\x8E\xAB\xAA\x9C\x8A\xDD\xE0\x9D"
           "\xA2\xAC\x94\x87\x6A\x71\xD0\xAF\xE4\x8A\xCF\xEB\x23\x27\x00\xC2"
           "\x8B\x11\xA9\x2C\x02\xB5\x05\x03\x30\x7A\x0C\xEF\x7F\x5B\x1C\xE7"
           "\x64\xFF\x1E\x68\x78\x28\x1C\x6D\xA0\x16\x75\x36\x7F\x9F\xF9\xCD"
           "\x15\x3B\x8E\x26\xC3\xF1\x7A\xBC\x17\x42\x92\x7D\xA8\x4E\x22\x5F"
           "\xB9\x55\xF5\xB7\x2C\x10\x5E\x79\xBB\x81\x54\x32\xDC\x8D\xE7\x4B"
           "\xE3\xCB\xDB\x1D\x34\xA4\xBA\x5F\x1A\xFE\x43\x48\x46\xEF\x88\x67"
           "\xD5\xB6\xDD\x06\x99\x5C\xB3\x38\x45\xED\xD0\x21\x77\x22\xF4\xF3"
           "\x68\xD6\x90\x53\xB5\x1E\x36\x3C\x35\x08\xCF\xBE\x53\x8F\x59\xDB"
           "\x4D\xAA\xA2\xB4\xF9\x93\xAC\x4C\x0C\xE4\x5D\xDF\x79\x57\x3C\x8F"
           "\x42\x44\xEC\x0C\x09\xA9\xC6\xE8\xF9\xF0\x80\x2E\x76\x25\x2E\xC1"
           "\x72\x0E\x55\xD6\xB9\x78\x9A\xAE\x56\xFE\x8B\x35\x38\xAF\xE3\x80"
           "\x78\x57\x55\x15\xC9\xEC\xCC\xCB\x42\xC3\xC5\xDF\x8A\xAE\x67\xB0"
           "\xCD\x63\x8E\xFC\x28\x77\x7F\xD1\x31\xFD\x9D\xD2\x79\xC8\x0A\xE0"
           "\x1A\x86\x0D\xEB\x3B\xB4\x64\x49\xAA\x6B\x7B\x73\x27\xEC\x7D\x66"
           "\x6A\x4C\x37\xB3\xCD\x4E\x97\x97\x3C\xEF\x7E\x13\x45\x36\xAA\xFE"
           "\x2E\x16\x48\x90\x5F\x53\x63\x62\xC7\xAB\xC9\xC7\xB5\x9E\xFD\xA5"
           "\x8B\x0C\xCA\xD0\x1E\xBD\x51\x67\x98\x94\x63\x08\x13\xCC\x05\xB9"
           , 1152);
    nSKLen = 1152;
    nAlgo = 3;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8796 A5B4 C3D2 E1F0 */
    memcpy(bKEK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           "\x59\x99\xC3\x06\xAB\x84\x01\xB2"
           , 24);

    memcpy(bDExp,
           "\xFA\xD2\x8B\xCB\xD9\xFB\x2C\x62\xDB\xC0\x11\x33\x20\xA9\xDD\x4E"
           "\xA3\x55\x50\xFD\xBB\x88\xC8\x39\xAB\x5E\x84\x30\xDE\x65\x0B\xD0"
           "\xE8\xDB\x38\x65\x13\x41\xAE\x32\x24\xE7\x31\x72\x6C\x98\xE8\x18"
           "\x06\xBD\x08\xFE\xD4\x71\x06\x4E\x68\x71\xD1\xE0\x84\x3B\x7D\xAB"
           "\x2F\x68\x71\x43\x7D\x5E\x8F\xD1\x1F\x91\xC5\x8B\x6A\x46\x3A\x36"
           "\xBD\x24\xD0\xA0\xB7\xAE\x63\x5D\xB0\x82\xD7\x68\xD8\x1E\x51\xE1"
           "\xB6\x76\xB1\x78\xBC\x8C\xC2\xBC\x45\x52\x82\xD7\x38\x38\x06\x4F"
           "\x31\x6A\x25\xB9\x20\xD0\x74\x59\xF1\x58\xE8\xF4\x5E\x4C\x06\xE2"
           "\x49\xD3\x4E\x00\xCC\x49\xEC\x81\xB4\xCB\xBD\xFE\xA5\x24\xBC\x24"
           "\xD7\x80\xBF\xA9\xB9\x34\x27\xAC\xEC\xE0\xEB\x59\x6E\x06\xC2\xFE"
           "\xEB\xFB\x69\x4E\xF1\xB7\x4C\x8A\xB7\x27\x73\x89\x3F\xB7\x54\xA7"
           "\xDD\x73\xFA\x43\x95\x30\x04\x4F\x2A\x04\xA4\xBE\x03\x60\xCB\xAD"
           "\x94\x33\xC1\x79\x2F\x4A\xCA\x05\x6B\xF0\x8E\xA0\x5A\x1C\x47\x74"
           "\x31\x8C\xE3\x09\x88\x4D\x66\x98\x99\xE5\x7D\x09\x74\xD0\x19\x81"
           "\x68\xBA\x13\x4D\x76\xE6\xDC\x9D\xB5\x75\x61\x4C\x2B\x1B\x53\x39"
           "\xDA\xE5\x70\xC4\xCF\x80\x6F\x32"
           , 248);
    nDLenExp = 8 + 248;
    memcpy(bPExp,
           "\xE5\x19\x84\xFA\xC1\xEA\x45\xBD\xDC\x3A\x90\xC4\x4A\x9D\xB6\x2C"
           "\x0B\x41\x57\xD1\x18\x14\xAC\xFE\xA9\xF5\xCF\x08\xBA\x6E\xB9\x1B"
           "\x98\x4E\xDD\xFA\xEA\xCB\x81\xBE\xD8\x4A\xB2\xA8\x38\xC9\xC0\x9D"
           "\x2E\x96\xE3\xAB\x22\xB9\xEB\xD1\x1F\xF1\xBC\x18\x86\xAF\x51\x8C"
           "\x51\xCF\xDB\xEC\x79\x7D\x60\x81\xC6\x19\x37\xCC\x62\x2E\x48\x48"
           "\xDF\xD3\x98\x54\x1D\x0D\xF5\xFF\x56\x88\x9C\x90\xBF\xD4\x83\x44"
           "\x60\x42\x05\x42\x20\x2F\xF3\x4E\x02\xF6\xD4\x75\x77\x1C\xFB\x1B"
           "\x71\xCC\xA9\xCE\x64\x11\x1E\x0C\x20\x58\x5D\xB2\x59\x3A\xF6\xF6"
           , 128);
    nPLenExp = 128;
    memcpy(bQExp,
           "\xFB\x74\xDE\xF1\x4B\x50\xA0\x98\x50\x94\x3C\xB5\x63\x0D\x1C\x2B"
           "\x07\x88\xA3\xBD\xF1\xF5\xBC\xA7\x4F\xDF\xEB\x8E\xAB\x0D\x88\x0E"
           "\x1D\x9A\x54\xBE\x6D\xC1\x80\x70\x54\x24\x3A\x48\x54\xCC\xD3\x26"
           "\xBA\x02\xB9\x2F\x59\xBC\xB9\xF1\x16\xBC\xE7\xC4\x85\xC9\x9C\x29"
           "\xE0\x05\x56\x43\xED\x14\xE8\x32\x1D\x39\x9D\xC5\x33\x3B\x4D\xA9"
           "\x69\x54\x6A\x81\x30\xF3\xB0\x2B\x66\x24\x21\x85\xEC\x07\x90\x53"
           "\x5D\x91\xA7\xC9\xCC\x87\x45\x00\xC8\x0D\xA2\xED\xA2\xE1\x0C\xEC"
           "\x45\xB6\x89\xF3\x32\xE8\x92\x6B\x2D\xFB\x41\xFB\x9D\xE6\x3E\x7C"
           , 128);
    nQLenExp = 128;
    memcpy(bDmP1Exp,
           "\x60\x90\xD7\x7B\x2D\xEE\x1A\xDE\x0D\x9E\x9F\x46\xFB\xB1\x50\x4C"
           "\xE9\x27\x2C\x29\xFA\xB3\x62\x04\xC1\xE6\x9D\x8A\xE0\xEB\xD0\x74"
           "\x82\x51\x00\x91\x91\x34\x05\xB7\x1E\x73\x6E\x7D\x97\x41\xCB\xBC"
           "\x2B\x11\x90\xC3\xEE\xAF\x9C\x5F\x62\xD3\xC2\x60\x25\xB6\x60\x79"
           "\x53\xD8\x05\x1E\x23\x46\xB3\xA3\xDE\x5C\x0D\xD4\x75\xD2\xDD\x1C"
           "\x33\x64\x81\xC2\x5B\xDA\x88\x47\x1A\x3C\xE4\x45\x01\x97\xBA\xB9"
           "\x0C\x30\xFA\x3F\xBF\xD6\xEE\xE8\x8D\x4D\x2D\xA1\xCE\xE9\xBD\x33"
           "\x5F\xEB\x3C\x3B\xAF\x18\xD1\x6B\x4A\xD4\xAE\x3F\x4B\x75\x18\x03"
           , 128);
    nDmP1LenExp = 128;
    memcpy(bDmQ1Exp,
           "\x45\x9F\xD5\x81\x3F\x8E\xE2\x6C\x8A\xE8\xFD\xAE\x8D\x1A\xD3\xDF"
           "\x38\x4B\xEE\x96\x9B\x8A\x80\x63\xF7\x48\xD3\xD2\x21\xD1\x8A\x2F"
           "\x2B\x9C\x50\xBF\x3C\x3A\x05\xCE\x9C\x82\x71\x59\xC0\xEB\x7F\x32"
           "\x3A\xA3\xC6\x51\xB5\xF4\xB1\xF1\xD4\xC7\x82\x5A\x5A\x93\xAD\x60"
           "\xD6\x79\x6E\x28\xF1\x59\xFD\x28\x7B\x60\xFD\xF8\xF6\xE1\x24\xF7"
           "\x2D\x4B\x40\x96\xBD\x47\xF3\xF7\x06\xDD\xE8\xDA\x9F\xD0\x6D\x77"
           "\xAF\x51\xCB\xC1\xFE\x67\xE3\x6D\x34\xF3\x41\xA8\x67\xAC\x24\x64"
           "\x89\xB9\x0F\xDE\x89\x58\x0B\xD5\xFA\xAD\x53\xA2\xBD\x51\xC7\x47"
           , 128);
    nDmQ1LenExp = 128;
    memcpy(bCoefExp,
           "\x3D\xE9\x48\x93\xF8\x91\x16\x11\x93\xF9\x8F\x7E\xB9\xAC\x59\xA0"
           "\xF4\x59\x08\x6F\x87\xAF\xDA\x2E\xEA\x75\xD4\x52\x75\x7A\x23\x05"
           "\x63\x57\xDA\x43\xFA\xB0\x13\x03\x7C\xC5\x44\xC9\x58\x6C\xF7\x07"
           "\xC9\xEB\x12\xED\x23\x1E\x74\x98\x67\xE2\x5D\x62\x6A\x6B\x93\xBF"
           "\x1E\xD0\x9F\xFC\x7E\xE9\x9B\xDF\xAE\x0D\xB1\x07\xE8\xF8\x0D\x48"
           "\x95\xEA\x44\xCA\xD4\x8F\xDC\x18\xCC\x1A\x0F\x46\x61\x43\x99\x77"
           "\x9A\x91\x36\x8F\xDF\xA7\xCB\xDF\x52\x2D\x51\xE4\x76\xF8\xCE\x43"
           "\xAC\x93\xC2\x8A\xAA\xDF\xCC\x91\x6D\xCE\xE2\x65\x82\x95\x5E\x17"
           , 128);
    nCoefLenExp = 128;


    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    DspHex("[IN ]bSK      =", bSK, 1152);
    printf("[IN ]nSKLen   = %d\n", nSKLen);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bKEK     =", bKEK, 24);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateAnalyse(nSock, bSK, nSKLen, nAlgo, bKEK, bD, &nDLen, \
                               bP, &nPLen, bQ, &nQLen, bDmP1, &nDmP1Len, bDmQ1, \
                               &nDmQ1Len, bCoef, &nCoefLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1984，三倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bD, bDExp, 248);
    ASSERT_OUT(nDLen, nDLenExp);
    ASSERT_OUT_HEX(bP, bPExp, 128);
    ASSERT_OUT(nPLen, nPLenExp);
    ASSERT_OUT_HEX(bQ, bQExp, 128);
    ASSERT_OUT(nQLen, nQLenExp);
    ASSERT_OUT_HEX(bDmP1, bDmP1Exp, 128);
    ASSERT_OUT(nDmP1Len, nDmP1LenExp);
    ASSERT_OUT_HEX(bDmQ1, bDmQ1Exp, 128);
    ASSERT_OUT(nDmQ1Len, nDmQ1LenExp);
    ASSERT_OUT_HEX(bCoef, bCoefExp, 128);
    ASSERT_OUT(nCoefLen, nCoefLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateAnalyse_Test_16(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  BYTE bSK[1280];
	  int  nSKLen;
	  int  nAlgo;
	  BYTE bKEK[32];
	  BYTE bD[276];
	  BYTE bDExp[276];
	  int  nDLen;
	  int  nDLenExp;
	  BYTE bP[144];
	  BYTE bPExp[144];
	  int  nPLen;
	  int  nPLenExp;
	  BYTE bQ[144];
	  BYTE bQExp[144];
	  int  nQLen;
	  int  nQLenExp;
	  BYTE bDmP1[144];
	  BYTE bDmP1Exp[144];
	  int  nDmP1Len;
	  int  nDmP1LenExp;
	  BYTE bDmQ1[144];
	  BYTE bDmQ1Exp[144];
	  int  nDmQ1Len;
	  int  nDmQ1LenExp;
	  BYTE bCoef[144];
	  BYTE bCoefExp[144];
	  int  nCoefLen;
	  int  nCoefLenExp;

    bufclr(bSK);
    bufclr(bKEK);
    bufclr(bD);
    bufclr(bDExp);
    bufclr(bP);
    bufclr(bPExp);
    bufclr(bQ);
    bufclr(bQExp);
    bufclr(bDmP1);
    bufclr(bDmP1Exp);
    bufclr(bDmQ1);
    bufclr(bDmQ1Exp);
    bufclr(bCoef);
    bufclr(bCoefExp);
    nDLen = 0;
    nPLen = 0;
    nQLen = 0;
    nDmP1Len = 0;
    nDmQ1Len = 0;
    nCoefLen = 0;

    memcpy(bSK,
           "\xB6\xF8\xDC\x3E\x12\x98\x52\xB8\xB1\x84\xC0\x51\x97\xD1\xBE\x87"
           "\x70\x24\xD7\xE1\x4A\x71\xC3\x20\xA9\xEE\x78\x93\xF8\x99\x5C\x1A"
           "\xE5\x32\x78\x65\x85\x07\xEB\x5E\x26\x79\x2F\x1E\xE1\x6E\x6E\xB9"
           "\xF7\x6A\x23\x46\x09\x92\xD0\x54\xD2\xCA\x6C\xB6\xCE\xB0\x0B\x1C"
           "\x83\xD3\xEB\x1B\x6F\x47\x05\x82\xBF\x68\x23\x24\x90\xDD\xA0\x4C"
           "\xAD\x00\xC2\xD6\xBE\x7D\x8C\x5C\xBF\x1B\xF6\xE1\x73\x51\x9E\x6D"
           "\x62\x46\xBF\x62\xD5\xA6\xD6\x93\x17\x5D\xEE\xEF\x03\x82\x5E\x89"
           "\xA5\x42\xF3\x09\xB1\x20\x11\x48\x39\x90\x8A\xBD\xAA\xE3\xA8\x12"
           "\x4E\xD2\x36\x25\x16\x60\x73\x35\x44\x99\x56\xFE\xED\xF1\xC7\x48"
           "\x57\x57\x56\x27\x7C\x94\xC5\x2D\x6B\x77\xFB\xDC\x82\xD8\xD0\xE0"
           "\x2D\x0E\x4D\x64\x5B\x98\x07\x49\x8A\x29\x70\xD9\xDE\xA9\x44\xC5"
           "\xDE\x71\xCE\xF5\xE0\x63\x40\x28\xF4\xD6\x6D\x86\x14\xCF\x70\x24"
           "\x5B\x05\xAE\xC7\xE9\x69\x7B\x42\xAB\xF6\x53\xA3\x97\x1C\x93\x61"
           "\xCE\x7E\x8F\x38\xF1\x85\xC6\xB8\x2C\x6F\x11\x3E\xA6\xF1\x18\xF8"
           "\x85\xAD\xF2\xE3\x32\x82\x51\x0D\xEB\x12\x68\xC0\x1B\xCD\xF2\x3A"
           "\xB5\x55\xCD\x1A\x92\x9D\x31\xDF\xA6\xB2\x7A\xEE\x99\xA1\x39\x62"
           "\xC9\xE5\xFD\x47\xD0\x37\xCE\x6C\x08\x33\x31\x58\x38\x7B\x3F\x77"
           "\xFF\x4B\x01\xFC\x24\x58\x33\x24\xEB\xA6\xE2\xEE\x33\x1B\x67\x52"
           "\x81\x19\x16\x3A\xFA\x23\x82\x1B\x61\xEE\x5B\xDD\x08\x83\xA4\x5D"
           "\xCC\x57\x5A\xBF\xA5\x5C\x6E\xD7\xB0\xA2\xB6\x73\x52\x92\x9E\x5C"
           "\x46\x8D\x3E\xFB\x15\x1C\xB2\x7E\xD0\x90\x09\x61\x4F\x98\xFF\xEE"
           "\x8C\x40\x99\x83\x62\x1C\x2A\x29\xA9\x35\x58\x08\xF7\x97\xE6\xC7"
           "\x74\x50\xC9\x7D\xBF\xA2\x61\x51\x57\xD2\xDB\xDD\xE7\x19\xEF\x75"
           "\x26\xC0\x48\x56\xD9\x38\xFC\xF6\xF1\xEC\x6E\x96\x72\xCE\x2F\x19"
           "\xCA\x17\x76\x25\xFA\xDB\x0A\xBF\x4E\xD3\x6F\x65\xE2\xA3\x53\x9F"
           "\x0F\x91\xCF\xA8\x32\x9D\x83\xF1\x62\x54\xA3\x3E\x89\xF9\xD3\x20"
           "\xE8\x10\xE5\xE8\x6A\x73\x40\x90\x9A\x9D\x21\xD0\x9E\xEE\xFA\x44"
           "\x29\x42\x36\x61\xF0\x89\x9E\xE2\xFA\xBE\x06\x74\x7A\xAC\x2A\xF6"
           "\xA6\xFE\xE0\x7E\x17\x7C\xDA\xA7\x4B\xA3\x33\xD0\x66\x40\x56\x07"
           "\xB5\x21\x1A\x1E\x17\x3B\x43\x62\x9C\x0D\x16\xFA\xF3\x09\x93\x99"
           "\x56\x6C\xFD\x6A\xB7\x64\x04\x77\x33\x61\x13\x13\xD0\x93\x30\xD7"
           "\x78\xAE\xD3\x91\x30\xC2\x2C\x81\x39\x88\x9F\xE3\x9B\x4F\xF0\xC8"
           "\xFF\xA0\xA7\xED\x5F\xC3\xD7\xFE\x9C\xA7\x85\x7D\x1E\x7E\xA6\x7C"
           "\xD7\x6C\xEF\x3A\xAD\xE2\xFE\x2E\xAD\x45\x17\x9E\xC8\xA9\x71\xAB"
           "\xBF\xB6\xE3\x16\xEC\x4B\xF5\xA7\x9D\x20\x72\x87\xB4\x7E\x80\x89"
           "\xD6\xEF\x8C\xEA\x5D\xD5\xD2\x26\x9B\x3E\x58\x2C\xEB\xE6\x07\x1A"
           "\x05\x01\xD6\xBB\xFB\xA4\x2C\x31\x7A\xC0\x03\xB2\x14\x3D\x95\x41"
           "\xB5\xE3\x35\xA8\x86\xCF\x8C\x68\xFE\x01\x75\x0F\x3B\x77\x56\xA2"
           "\xCF\x29\x24\xFE\x99\x37\x02\x75\x65\x0E\xD6\xD2\x82\x9A\x93\x74"
           "\xAD\xBE\x1E\x56\x13\xC4\x29\x53\x35\x57\x4B\x46\x22\x4B\xB8\x50"
           "\x53\x71\x44\x27\xA8\xBC\x5B\x31\x0A\x32\xD4\x0F\xFF\xB2\x32\x5F"
           "\x39\xCD\xB1\x90\x77\x70\x23\xF9\xF4\x85\xDA\xE9\x16\x9D\xD5\xA0"
           "\x2A\x71\xF9\xF4\x40\x7D\xD1\x24\x5D\xBF\x93\xB3\x7F\x0D\x95\x67"
           "\x19\x51\x18\xA0\x99\x7A\x84\x44\x71\x9A\x08\x0D\x98\x25\x2E\xA6"
           "\x55\x6B\xEC\xA9\xA0\x72\xA4\xEF\x41\xC4\x20\x67\xA8\x86\xC9\x82"
           "\x86\xE8\x58\x5B\xA6\x8B\xCB\x30\xED\xF7\x7B\x0E\x6A\x6F\x6C\x39"
           "\x7A\x48\xA8\xE1\x9C\xEE\xC5\xDF\x08\x4B\xC9\x0A\x5D\xA0\x34\x42"
           "\xB5\x79\x5C\x29\xAF\xA9\xF8\x84\x31\xBE\x94\x21\x29\x17\x82\x99"
           "\x81\xB4\x9E\x2B\xC9\x78\xC5\xA6\x25\xD7\x28\xEE\x3A\xD2\x3B\xD8"
           "\x05\xCE\xEA\x07\x92\xD4\x8B\x4D\x64\xB4\x7F\x57\x9D\x2A\xFB\x80"
           "\xFF\x16\x09\xE2\x9A\xAC\x7E\x32\x2D\x2B\xE7\xA2\x9F\x9F\x63\xAF"
           "\x59\x62\xC6\x8D\x51\xD9\x2F\x6B\xF2\xB8\xEA\x9B\xAE\x30\x7A\xBB"
           "\x76\xC7\xDE\xB7\xF8\xF0\x33\x2E\x69\x65\xC0\x89\x2B\x82\x72\xAE"
           "\x8B\x65\x53\xEF\x96\xA4\xCC\xE6\xAB\x80\x9D\x23\x51\xCB\x77\x5B"
           "\xAB\x75\x5A\x70\x7B\x9C\xBE\xD6\x44\xCD\x0A\x3A\x1C\xF8\xD7\xC8"
           "\x9E\x68\x2B\xA2\xB6\x30\xC4\xE7\x3A\xF2\xDA\xE4\x15\xDE\x80\xD5"
           "\x03\xF6\x06\x3E\x19\x0B\x09\xF5\xE1\xED\xE9\x82\x79\x02\xD7\x21"
           "\x5C\x71\xFE\x15\xCB\xB5\x85\xB1\x12\x75\xF2\x94\xFC\xB7\x24\x14"
           "\xFF\xDE\xA6\x49\x7D\x61\xF8\xAE\x83\x40\x97\xC6\x13\x8F\xD6\xE2"
           "\xDA\xE8\x9D\x66\x71\x4A\x22\x1F\xF9\x55\x79\xAA\xE0\xE6\xD7\x29"
           "\x3D\x44\x2E\xC0\xB9\x4D\x64\x65\x2A\x0E\x4A\xB8\x62\xC1\x84\x2E"
           "\x3F\x6F\xEB\x79\xDF\xCF\xAA\x83\xB9\x7C\x73\x7E\x48\x88\x44\x03"
           "\xEA\x4F\x09\xCD\x72\x37\xA7\x49\x37\x6E\x52\x57\xFC\x64\x17\xE5"
           "\x9E\x36\x4D\xD7\x33\x82\xA5\x42\x3F\x37\x96\xE9\x00\x70\x91\x7E"
           "\x1F\xFF\xCD\xD3\x39\xD8\x27\x8F\x67\x81\x51\xF8\x03\xB5\x3A\xB9"
           "\x57\x64\x16\xBF\x7F\x0C\xD6\x74\xE7\x37\xB2\xFD\xF4\x20\x1B\x4C"
           "\xFD\xFC\x5C\xEF\x78\x30\x05\x38\xD7\x51\xE8\xD3\x16\x0A\x7D\x8C"
           "\xBA\x84\x9D\x1F\xF5\x6F\xE7\x15\x41\x1D\x3E\x40\x4D\x98\x64\x46"
           "\x43\x35\xA6\xBB\x0B\x0D\xF3\x39\x1D\xF9\x2B\x8C\x8E\xBD\x43\x9B"
           "\x39\x39\x10\x04\x06\x0B\x31\x7C\xF0\x1E\xE1\x70\xB1\x55\xD1\x59"
           "\xBE\x38\x24\xC8\x3E\x53\x30\xF7\x0F\xCE\x37\xCD\x5C\xF7\x90\x33"
           "\x85\x7F\x4D\x02\xAB\xEA\x50\x12\x18\xF3\x6E\x56\xA8\xEE\x38\x08"
           "\x8F\x94\x95\xAE\xE3\x74\x54\xCF\x0B\x88\x16\x7D\x2E\xBA\xAB\xCE"
           "\xCD\x7B\xA5\x62\x51\x84\x6A\x30\x0E\xF6\x44\x6C\x62\xDB\x9B\x21"
           "\xCA\x09\x0C\xBD\xE5\x09\x1C\xFA\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78"
           , 1200);
    nSKLen = 1200;
    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKEK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           , 8);

    memcpy(bDExp,
           "\x05\xD9\xAD\xFF\x03\x8B\x93\x06\x7E\xB4\x3A\xDF\xA1\x78\xCF\x9D"
           "\xD7\x3C\x0F\x32\xCC\x92\xB7\xDF\xF5\xF0\xE0\xFC\xAB\xBF\xA7\x8C"
           "\xE0\x4C\x34\xD3\x73\xEE\xE8\x13\xA7\x93\x87\x7B\x52\xB1\x7E\x0C"
           "\xB6\x53\xDE\x7B\x3E\xCB\x60\x6A\xEB\xDF\x99\x60\x5B\xDA\xE5\x31"
           "\x61\xEC\x0F\xB7\x9D\x98\x13\x7F\xC3\x0C\x9E\xB3\xC9\xFC\xE2\x09"
           "\xA6\x1A\xB1\x40\x8D\x7A\x89\x5C\x9C\x69\xCB\xF6\x06\x5D\xBD\x5D"
           "\x0C\xA7\xB4\x71\x69\x5F\x89\x55\x0F\x66\xFA\x9A\xF1\x6B\x9A\x8F"
           "\xDE\x55\x66\x2C\xBB\xEC\x48\x41\x4B\xE8\x56\x0E\x17\x6B\x36\x02"
           "\x96\xF6\xB9\x93\x4F\x88\x49\x2A\x4C\x5E\x68\x32\x4D\x61\xD2\xEF"
           "\x0F\xC5\xBF\x82\x4B\xB2\xC6\x2A\x3E\x79\x42\x29\xE1\x01\x16\xAE"
           "\x5E\xF8\xA1\x66\xFB\xCF\xEA\x15\xD1\x0D\x48\x2B\x73\xDA\x16\x4D"
           "\xE6\x39\x73\x2C\x76\x24\x2D\xCD\xCA\x56\xE6\x4F\xEA\xE6\x76\x37"
           "\xE4\x8C\x01\x5E\x04\x29\xF7\xA4\x3D\x85\xA1\x66\xBD\x17\x9B\x3D"
           "\x8C\xFE\x7C\x65\xE4\xC8\xEC\x28\xF0\xBC\x77\x9B\xEA\x58\x66\x88"
           "\xEE\xFB\xBC\xBF\x4C\xF2\x97\xB9\xB5\x82\x9E\xB1\x79\xE0\x83\xA2"
           "\x90\x21\x4A\x51\x26\xEE\x88\x1E\xFE\x00\x70\x82\xA6\xF8\xCF\xBB"
           , 256);
    nDLenExp = 8 + 256;
    memcpy(bPExp,
           "\x16\x61\x6F\xAA\xE3\x5C\x0D\x73\x52\x69\x7F\x06\x67\xBA\x4F\x59"
           "\xEA\x2F\x55\x2F\x46\xE6\xE3\x49\xF4\xAC\x83\x56\x44\x5A\x4E\x12"
           "\x0C\x6C\xD0\x05\x67\xAC\xCA\x5B\x81\xA6\x74\x37\x6F\x6F\x38\xDC"
           "\xD3\xCB\x10\x2C\x5E\x7A\xA5\xCA\x51\xC0\x1F\x98\xC6\x74\x83\xD0"
           "\x91\x3C\xA3\x94\xC6\x9F\xA9\xE8\x60\xED\x19\xA6\x40\x53\x01\x42"
           "\xC8\xEB\x92\xE5\x33\x81\xF2\x67\x96\xCA\x3F\x00\xF8\x4A\xDA\xE9"
           "\x05\x05\xDC\x00\x3B\x0B\xFE\x39\x1F\x26\x82\xC0\xB8\x3E\x59\x69"
           "\x71\xB2\xC5\x43\x9C\xA2\x26\xF4\x9D\xC0\xF0\x43\xBA\x85\x1B\x50"
           , 128);
    nPLenExp = 8 + 128;
    memcpy(bQExp,
           "\x72\xA2\x4F\x81\xA4\x7C\xAC\xD1\xC1\x84\x99\xD5\x54\x47\x95\x00"
           "\xE3\xE9\xE6\x9D\xB8\x8F\xA6\x5D\xA0\x61\xC8\x5D\xCB\x4F\xCF\x44"
           "\x92\x91\x2E\xA9\xDE\xAB\xDB\x0A\x32\xFC\xA7\x54\x3C\xF2\xBD\x28"
           "\xB2\xFD\x68\xC8\x8E\xA9\xBE\xB6\xCF\xD7\x87\x7B\x2F\x59\xD5\x53"
           "\x8B\xE9\x5D\x74\x4A\x1D\x22\x02\xA6\x1A\x81\xB2\x21\xAC\x90\x37"
           "\xEE\x25\xC7\xFD\x2A\x17\x94\x69\x33\xEE\x39\x33\x09\xE3\x21\xD2"
           "\x29\x7F\xD1\xA9\x5E\x4E\x55\x59\x19\x6B\xA9\x5E\x83\x32\x20\x66"
           "\xEB\x6B\x22\x1F\x7E\xB3\x87\xA5\xE5\xEE\x54\xE2\xF8\xCF\x2C\xB3"
           , 128);
    nQLenExp = 8 + 128;
    memcpy(bDmP1Exp,
           "\x4A\xC6\x5B\x99\x23\x93\x11\x0A\x8C\x2C\x57\x3C\x18\xAD\xBA\x8A"
           "\xA7\x46\x48\x8F\xB2\xCE\x81\x0D\x8E\x0D\xC1\x4B\x84\xC3\xAA\xAE"
           "\x52\xF3\x59\x7F\x91\x2D\xE2\x08\xD6\x33\x9D\x87\xAE\xF3\x11\xC1"
           "\x5B\x53\x8D\x74\xCC\xFF\xA4\x2E\x2E\xDD\xDA\x3F\x80\x24\xF2\x28"
           "\xEB\x08\x4A\x43\x92\x5F\x67\x90\xBA\x0A\x04\x6B\x8E\x99\xA1\xEF"
           "\xB9\xBA\x46\x9D\x1F\xC3\xFF\x17\x44\xDE\x76\x17\xEE\xC2\xBA\xCF"
           "\x6D\xC3\xB2\xBE\xCF\xCD\xA7\x7A\xD2\x3E\xF3\x4D\x8D\x47\x09\x35"
           "\xC7\xCB\x34\xA5\x93\x7A\x59\x1D\xE2\x85\xC2\x8A\xB9\x7E\xD4\x76"
           , 128);
    nDmP1LenExp = 8 + 128;
    memcpy(bDmQ1Exp,
           "\x1C\xD0\xA3\xD6\x29\x0D\x14\x9C\x2D\x81\xCD\x12\xDF\x8E\x89\xDB"
           "\xCF\x76\x0C\xB4\x6C\xF4\xE3\x7D\xDA\x01\x6A\xD3\x12\xD3\xF5\x11"
           "\x49\x1F\xA8\x76\x39\x4A\xE7\x3F\xAD\x6D\x6D\xED\x39\x16\xFF\x5A"
           "\x10\x93\x4E\x6F\x7C\xC8\x6E\x88\xC6\x23\xA8\xD8\x3E\x89\x81\xC0"
           "\x9D\xB8\x12\xC1\xCF\xCE\xAB\xCA\xB2\x0F\x7D\x86\x93\x17\x60\x7C"
           "\x36\x29\x17\x94\x67\x25\x0B\x78\xA6\x08\x13\x71\x61\x0B\x14\xB8"
           "\xD8\x0A\x5C\x30\x90\x47\x54\x53\x34\xA1\x9D\xBC\x6B\x0F\xF3\xAF"
           "\x46\x9E\x7C\x52\x2D\xD8\xD0\x3D\xF2\xB6\x64\xE5\x89\x9D\xC5\x9D"
           , 128);
    nDmQ1LenExp = 8 + 128;
    memcpy(bCoefExp,
           "\xC9\x8D\x2A\x36\xA2\x91\x63\xEC\x22\x93\x18\xF8\xE7\xB0\xE5\xF2"
           "\x65\x6C\x51\x64\xD4\x01\xEC\x21\xCB\xFB\x5B\x55\xF5\xC0\xEC\x87"
           "\x8F\x25\x1A\x12\x74\xBB\x1B\x96\x6F\x4C\x31\xB6\xCF\x32\xA6\xDF"
           "\xEB\x7B\x61\x12\x13\xEB\x88\x55\x88\xE1\x04\x15\xBF\x0B\x55\x66"
           "\x8C\xAE\x71\x73\x96\x03\xF3\x5E\xC3\x8A\xF0\x93\x85\x4D\x1F\xEE"
           "\xB9\xBD\x16\xD6\x2E\x29\xEE\x95\xBA\x08\xC4\x2B\x0B\xCE\xB4\xAC"
           "\xCE\xC9\x22\xA0\xB9\xE5\xD0\x31\x9F\x24\xE3\x8E\x1D\xE2\x43\xC2"
           "\xF4\x59\x29\x36\x40\xE8\x62\xF7\x0E\xDC\xF0\xFA\xBC\x43\x43\xAA"
           , 128);
    nCoefLenExp = 8 + 128;

    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    DspHex("[IN ]bSK      =", bSK, 1200);
    printf("[IN ]nSKLen   = %d\n", nSKLen);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bKEK     =", bKEK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateAnalyse(nSock, bSK, nSKLen, nAlgo, bKEK, bD, &nDLen, \
                               bP, &nPLen, bQ, &nQLen, bDmP1, &nDmP1Len, bDmQ1, \
                               &nDmQ1Len, bCoef, &nCoefLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-2048，单倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bD, bDExp, 256);
    ASSERT_OUT(nDLen, nDLenExp);
    ASSERT_OUT_HEX(bP, bPExp, 128);
    ASSERT_OUT(nPLen, nPLenExp);
    ASSERT_OUT_HEX(bQ, bQExp, 128);
    ASSERT_OUT(nQLen, nQLenExp);
    ASSERT_OUT_HEX(bDmP1, bDmP1Exp, 128);
    ASSERT_OUT(nDmP1Len, nDmP1LenExp);
    ASSERT_OUT_HEX(bDmQ1, bDmQ1Exp, 128);
    ASSERT_OUT(nDmQ1Len, nDmQ1LenExp);
    ASSERT_OUT_HEX(bCoef, bCoefExp, 128);
    ASSERT_OUT(nCoefLen, nCoefLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateAnalyse_Test_17(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  BYTE bSK[1280];
	  int  nSKLen;
	  int  nAlgo;
	  BYTE bKEK[32];
	  BYTE bD[276];
	  BYTE bDExp[276];
	  int  nDLen;
	  int  nDLenExp;
	  BYTE bP[144];
	  BYTE bPExp[144];
	  int  nPLen;
	  int  nPLenExp;
	  BYTE bQ[144];
	  BYTE bQExp[144];
	  int  nQLen;
	  int  nQLenExp;
	  BYTE bDmP1[144];
	  BYTE bDmP1Exp[144];
	  int  nDmP1Len;
	  int  nDmP1LenExp;
	  BYTE bDmQ1[144];
	  BYTE bDmQ1Exp[144];
	  int  nDmQ1Len;
	  int  nDmQ1LenExp;
	  BYTE bCoef[144];
	  BYTE bCoefExp[144];
	  int  nCoefLen;
	  int  nCoefLenExp;

    bufclr(bSK);
    bufclr(bKEK);
    bufclr(bD);
    bufclr(bDExp);
    bufclr(bP);
    bufclr(bPExp);
    bufclr(bQ);
    bufclr(bQExp);
    bufclr(bDmP1);
    bufclr(bDmP1Exp);
    bufclr(bDmQ1);
    bufclr(bDmQ1Exp);
    bufclr(bCoef);
    bufclr(bCoefExp);
    nDLen = 0;
    nPLen = 0;
    nQLen = 0;
    nDmP1Len = 0;
    nDmQ1Len = 0;
    nCoefLen = 0;

    memcpy(bSK,
           "\xB6\xF8\xDC\x3E\x12\x98\x52\xB8\xB1\x84\xC0\x51\x97\xD1\xBE\x87"
           "\x70\x24\xD7\xE1\x4A\x71\xC3\x20\xA9\xEE\x78\x93\xF8\x99\x5C\x1A"
           "\xE5\x32\x78\x65\x85\x07\xEB\x5E\x26\x79\x2F\x1E\xE1\x6E\x6E\xB9"
           "\xF7\x6A\x23\x46\x09\x92\xD0\x54\xD2\xCA\x6C\xB6\xCE\xB0\x0B\x1C"
           "\x83\xD3\xEB\x1B\x6F\x47\x05\x82\xBF\x68\x23\x24\x90\xDD\xA0\x4C"
           "\xAD\x00\xC2\xD6\xBE\x7D\x8C\x5C\xBF\x1B\xF6\xE1\x73\x51\x9E\x6D"
           "\x62\x46\xBF\x62\xD5\xA6\xD6\x93\x17\x5D\xEE\xEF\x03\x82\x5E\x89"
           "\xA5\x42\xF3\x09\xB1\x20\x11\x48\x39\x90\x8A\xBD\xAA\xE3\xA8\x12"
           "\x4E\xD2\x36\x25\x16\x60\x73\x35\x44\x99\x56\xFE\xED\xF1\xC7\x48"
           "\x57\x57\x56\x27\x7C\x94\xC5\x2D\x6B\x77\xFB\xDC\x82\xD8\xD0\xE0"
           "\x2D\x0E\x4D\x64\x5B\x98\x07\x49\x8A\x29\x70\xD9\xDE\xA9\x44\xC5"
           "\xDE\x71\xCE\xF5\xE0\x63\x40\x28\xF4\xD6\x6D\x86\x14\xCF\x70\x24"
           "\x5B\x05\xAE\xC7\xE9\x69\x7B\x42\xAB\xF6\x53\xA3\x97\x1C\x93\x61"
           "\xCE\x7E\x8F\x38\xF1\x85\xC6\xB8\x2C\x6F\x11\x3E\xA6\xF1\x18\xF8"
           "\x85\xAD\xF2\xE3\x32\x82\x51\x0D\xEB\x12\x68\xC0\x1B\xCD\xF2\x3A"
           "\xB5\x55\xCD\x1A\x92\x9D\x31\xDF\xA6\xB2\x7A\xEE\x99\xA1\x39\x62"
           "\xC9\xE5\xFD\x47\xD0\x37\xCE\x6C\x08\x33\x31\x58\x38\x7B\x3F\x77"
           "\xFF\x4B\x01\xFC\x24\x58\x33\x24\xEB\xA6\xE2\xEE\x33\x1B\x67\x52"
           "\x81\x19\x16\x3A\xFA\x23\x82\x1B\x61\xEE\x5B\xDD\x08\x83\xA4\x5D"
           "\xCC\x57\x5A\xBF\xA5\x5C\x6E\xD7\xB0\xA2\xB6\x73\x52\x92\x9E\x5C"
           "\x46\x8D\x3E\xFB\x15\x1C\xB2\x7E\xD0\x90\x09\x61\x4F\x98\xFF\xEE"
           "\x8C\x40\x99\x83\x62\x1C\x2A\x29\xA9\x35\x58\x08\xF7\x97\xE6\xC7"
           "\x74\x50\xC9\x7D\xBF\xA2\x61\x51\x57\xD2\xDB\xDD\xE7\x19\xEF\x75"
           "\x26\xC0\x48\x56\xD9\x38\xFC\xF6\xF1\xEC\x6E\x96\x72\xCE\x2F\x19"
           "\xCA\x17\x76\x25\xFA\xDB\x0A\xBF\x4E\xD3\x6F\x65\xE2\xA3\x53\x9F"
           "\x0F\x91\xCF\xA8\x32\x9D\x83\xF1\x62\x54\xA3\x3E\x89\xF9\xD3\x20"
           "\xE8\x10\xE5\xE8\x6A\x73\x40\x90\x9A\x9D\x21\xD0\x9E\xEE\xFA\x44"
           "\x29\x42\x36\x61\xF0\x89\x9E\xE2\xFA\xBE\x06\x74\x7A\xAC\x2A\xF6"
           "\xA6\xFE\xE0\x7E\x17\x7C\xDA\xA7\x4B\xA3\x33\xD0\x66\x40\x56\x07"
           "\xB5\x21\x1A\x1E\x17\x3B\x43\x62\x9C\x0D\x16\xFA\xF3\x09\x93\x99"
           "\x56\x6C\xFD\x6A\xB7\x64\x04\x77\x33\x61\x13\x13\xD0\x93\x30\xD7"
           "\x78\xAE\xD3\x91\x30\xC2\x2C\x81\x39\x88\x9F\xE3\x9B\x4F\xF0\xC8"
           "\xFF\xA0\xA7\xED\x5F\xC3\xD7\xFE\x9C\xA7\x85\x7D\x1E\x7E\xA6\x7C"
           "\xD7\x6C\xEF\x3A\xAD\xE2\xFE\x2E\xAD\x45\x17\x9E\xC8\xA9\x71\xAB"
           "\xBF\xB6\xE3\x16\xEC\x4B\xF5\xA7\x9D\x20\x72\x87\xB4\x7E\x80\x89"
           "\xD6\xEF\x8C\xEA\x5D\xD5\xD2\x26\x9B\x3E\x58\x2C\xEB\xE6\x07\x1A"
           "\x05\x01\xD6\xBB\xFB\xA4\x2C\x31\x7A\xC0\x03\xB2\x14\x3D\x95\x41"
           "\xB5\xE3\x35\xA8\x86\xCF\x8C\x68\xFE\x01\x75\x0F\x3B\x77\x56\xA2"
           "\xCF\x29\x24\xFE\x99\x37\x02\x75\x65\x0E\xD6\xD2\x82\x9A\x93\x74"
           "\xAD\xBE\x1E\x56\x13\xC4\x29\x53\x35\x57\x4B\x46\x22\x4B\xB8\x50"
           "\x53\x71\x44\x27\xA8\xBC\x5B\x31\x0A\x32\xD4\x0F\xFF\xB2\x32\x5F"
           "\x39\xCD\xB1\x90\x77\x70\x23\xF9\xF4\x85\xDA\xE9\x16\x9D\xD5\xA0"
           "\x2A\x71\xF9\xF4\x40\x7D\xD1\x24\x5D\xBF\x93\xB3\x7F\x0D\x95\x67"
           "\x19\x51\x18\xA0\x99\x7A\x84\x44\x71\x9A\x08\x0D\x98\x25\x2E\xA6"
           "\x55\x6B\xEC\xA9\xA0\x72\xA4\xEF\x41\xC4\x20\x67\xA8\x86\xC9\x82"
           "\x86\xE8\x58\x5B\xA6\x8B\xCB\x30\xED\xF7\x7B\x0E\x6A\x6F\x6C\x39"
           "\x7A\x48\xA8\xE1\x9C\xEE\xC5\xDF\x08\x4B\xC9\x0A\x5D\xA0\x34\x42"
           "\xB5\x79\x5C\x29\xAF\xA9\xF8\x84\x31\xBE\x94\x21\x29\x17\x82\x99"
           "\x81\xB4\x9E\x2B\xC9\x78\xC5\xA6\x25\xD7\x28\xEE\x3A\xD2\x3B\xD8"
           "\x05\xCE\xEA\x07\x92\xD4\x8B\x4D\x64\xB4\x7F\x57\x9D\x2A\xFB\x80"
           "\xFF\x16\x09\xE2\x9A\xAC\x7E\x32\x2D\x2B\xE7\xA2\x9F\x9F\x63\xAF"
           "\x59\x62\xC6\x8D\x51\xD9\x2F\x6B\xF2\xB8\xEA\x9B\xAE\x30\x7A\xBB"
           "\x76\xC7\xDE\xB7\xF8\xF0\x33\x2E\x69\x65\xC0\x89\x2B\x82\x72\xAE"
           "\x8B\x65\x53\xEF\x96\xA4\xCC\xE6\xAB\x80\x9D\x23\x51\xCB\x77\x5B"
           "\xAB\x75\x5A\x70\x7B\x9C\xBE\xD6\x44\xCD\x0A\x3A\x1C\xF8\xD7\xC8"
           "\x9E\x68\x2B\xA2\xB6\x30\xC4\xE7\x3A\xF2\xDA\xE4\x15\xDE\x80\xD5"
           "\x03\xF6\x06\x3E\x19\x0B\x09\xF5\xE1\xED\xE9\x82\x79\x02\xD7\x21"
           "\x5C\x71\xFE\x15\xCB\xB5\x85\xB1\x12\x75\xF2\x94\xFC\xB7\x24\x14"
           "\xFF\xDE\xA6\x49\x7D\x61\xF8\xAE\x83\x40\x97\xC6\x13\x8F\xD6\xE2"
           "\xDA\xE8\x9D\x66\x71\x4A\x22\x1F\xF9\x55\x79\xAA\xE0\xE6\xD7\x29"
           "\x3D\x44\x2E\xC0\xB9\x4D\x64\x65\x2A\x0E\x4A\xB8\x62\xC1\x84\x2E"
           "\x3F\x6F\xEB\x79\xDF\xCF\xAA\x83\xB9\x7C\x73\x7E\x48\x88\x44\x03"
           "\xEA\x4F\x09\xCD\x72\x37\xA7\x49\x37\x6E\x52\x57\xFC\x64\x17\xE5"
           "\x9E\x36\x4D\xD7\x33\x82\xA5\x42\x3F\x37\x96\xE9\x00\x70\x91\x7E"
           "\x1F\xFF\xCD\xD3\x39\xD8\x27\x8F\x67\x81\x51\xF8\x03\xB5\x3A\xB9"
           "\x57\x64\x16\xBF\x7F\x0C\xD6\x74\xE7\x37\xB2\xFD\xF4\x20\x1B\x4C"
           "\xFD\xFC\x5C\xEF\x78\x30\x05\x38\xD7\x51\xE8\xD3\x16\x0A\x7D\x8C"
           "\xBA\x84\x9D\x1F\xF5\x6F\xE7\x15\x41\x1D\x3E\x40\x4D\x98\x64\x46"
           "\x43\x35\xA6\xBB\x0B\x0D\xF3\x39\x1D\xF9\x2B\x8C\x8E\xBD\x43\x9B"
           "\x39\x39\x10\x04\x06\x0B\x31\x7C\xF0\x1E\xE1\x70\xB1\x55\xD1\x59"
           "\xBE\x38\x24\xC8\x3E\x53\x30\xF7\x0F\xCE\x37\xCD\x5C\xF7\x90\x33"
           "\x85\x7F\x4D\x02\xAB\xEA\x50\x12\x18\xF3\x6E\x56\xA8\xEE\x38\x08"
           "\x8F\x94\x95\xAE\xE3\x74\x54\xCF\x0B\x88\x16\x7D\x2E\xBA\xAB\xCE"
           "\xCD\x7B\xA5\x62\x51\x84\x6A\x30\x0E\xF6\x44\x6C\x62\xDB\x9B\x21"
           "\xCA\x09\x0C\xBD\xE5\x09\x1C\xFA\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78"
           , 1200);
    nSKLen = 1200;
    nAlgo = 2;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 */
    memcpy(bKEK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           , 16);

    memcpy(bDExp,
           "\xA7\x77\x0A\xC7\xE7\xAA\x06\x25\x11\x9A\x0C\x10\xC6\xF7\xDB\xFA"
           "\xAE\x8C\x2E\x21\xAC\xDA\x38\xF3\xD1\x9E\x29\x60\x40\x0E\xB9\xEC"
           "\xED\xF0\xF0\xBB\xAC\x08\x81\xA4\x42\xD5\x80\x47\x33\x47\x7D\xB7"
           "\x85\x7C\x41\xC6\x03\x0F\x4F\xA5\x37\xD4\xF7\xC1\xAD\xEA\x8D\x0A"
           "\xBE\x01\x73\x4D\xE4\xCB\xA6\xB9\x81\x7C\x0D\x97\x6A\x3F\x22\x91"
           "\x02\x81\x9E\x11\x9D\x88\x2E\x81\xE8\xD9\x4F\xD1\x36\x4F\x69\xE1"
           "\x81\x2D\xC5\x9C\x81\x63\xF7\xC5\xA5\x9F\x2E\x8B\x9E\xC6\x55\x36"
           "\x19\x60\x2B\xAE\x10\x87\x8E\xE6\x1F\x1A\xBB\xF3\xD6\x25\x66\xAA"
           "\x62\xF4\x97\x33\x24\xFF\xBF\x8C\x7F\x74\x13\x3A\x1B\x3D\xD0\x14"
           "\x0B\x42\x69\xC6\x5C\x90\xAA\xE7\x07\xE8\xBC\x99\x87\x56\x1E\x76"
           "\x42\x87\x6B\x3F\x45\xEA\x9D\x12\xA4\x33\x24\x61\x0F\x26\xAD\xA1"
           "\xE4\x62\x97\x4D\xF3\xA0\x34\x10\xCB\x66\x94\x79\x03\xD4\xEA\x3F"
           "\xB2\xF6\xEB\xEF\x07\x77\x6B\xFB\x66\x6A\x53\x7D\x4C\x4E\x66\xD6"
           "\x41\x0E\x2E\xF6\xA5\xC6\x22\x07\x1A\x56\x18\xBB\x72\x90\xEF\x65"
           "\xA8\x7B\x84\x9B\x49\x7E\x0F\x32\x9B\x1F\x84\x67\x6E\x91\xD8\x9B"
           "\xDB\x28\x59\x25\x27\x14\x92\x22\x5B\x04\xF9\xD0\x96\xC2\x46\xF2"
           , 256);
    nDLenExp = 8 + 256;
    memcpy(bPExp,
           "\xCB\xE9\xC3\x4B\x17\x56\x61\x05\x71\x78\xFC\xB6\x6E\x82\x00\x42"
           "\x96\x67\x1D\xE6\x18\xBA\x18\x87\xC8\x67\x68\x58\x95\xEA\x4F\x52"
           "\xA1\x3D\xC9\x47\xFF\x98\x1E\x8C\xC5\x70\xC5\xF6\x9D\x2C\x0B\xED"
           "\x86\x62\x45\x9B\x79\xB5\x34\xDB\x27\x0A\x51\x8A\x27\x89\x05\x72"
           "\x28\xA7\x8E\x47\xE2\x53\x44\x3C\xE0\xB4\x65\xCA\x07\x75\x4F\x10"
           "\x75\x34\xB9\xF7\xF6\x43\x4A\xEF\x4C\xC2\x2B\xCA\x5D\xA4\x54\x64"
           "\x1B\xCE\xFA\xF6\xCA\xAE\xBA\xD0\x13\x1A\x58\x49\x5C\xD1\x29\x14"
           "\x51\xB1\xC0\x33\x03\x98\x03\x25\xB1\x61\xE4\x71\x6B\xA7\xC7\xDB"
           , 128);
    nPLenExp = 8 + 128;
    memcpy(bQExp,
           "\xED\xEA\x7A\x0D\x2F\xE4\x73\x04\x58\x6C\x1C\xB6\x60\x6F\xBD\x71"
           "\x09\x31\x6B\x52\x1C\xCC\xD7\xE1\x27\xD4\xC7\xB8\xAA\x60\x50\xB7"
           "\xF5\x4D\xA5\x4C\x4D\x29\xE9\x30\x34\x13\x29\xA2\x40\x16\x53\x8F"
           "\xC0\x19\x29\x1A\x46\x31\x12\xE4\xAE\x9A\x9F\x41\x3F\xF6\xCD\x1E"
           "\x2A\xFA\x6B\xE0\xDB\x41\xEF\x45\x97\xAF\x4F\xA6\xEA\x33\x86\x1E"
           "\x69\x73\x33\x5F\x1D\xDD\xFA\xB6\x8A\x07\x12\xAA\xAB\xCB\xE5\x06"
           "\x3B\xD0\xBC\xCE\x21\x2B\xDC\xF6\x42\xD7\x5C\x40\xB9\x76\x68\x7A"
           "\x08\x23\x94\x2D\x09\x9C\xD5\x31\x3E\x28\x08\x89\xFE\xDD\x4F\x5F"
           , 128);
    nQLenExp = 8 + 128;
    memcpy(bDmP1Exp,
           "\x8B\x97\x07\x91\xAF\x88\x98\x62\xCF\x77\x44\x2A\x3B\xF0\x63\x53"
           "\x47\x07\x9F\xA3\x93\x82\x19\x39\xE7\x19\xE4\x83\xC2\x66\x4C\xD4"
           "\xBF\xF3\x6A\x81\xCD\x4A\xDF\xBA\x54\x2B\x3B\xE3\x33\x00\x97\x5B"
           "\x79\x2D\xA8\x6B\x62\x82\x73\x1B\x94\x9F\x77\x25\x09\x1B\x09\xC5"
           "\x13\x5D\xF4\x70\x62\x72\x58\x65\x1B\x6B\x9D\x86\xBC\x6E\xEF\x15"
           "\xDB\x2D\xA1\x67\x39\xE9\xF2\xFB\x1B\x27\xD6\x8E\x2C\x50\xB4\x8C"
           "\xA2\xAF\x6D\x1D\xFA\xF3\xE1\x12\x48\x72\xB7\x01\x3D\x99\xBD\x8A"
           "\xF6\x1E\x7A\x35\x39\xC5\xCB\x53\xCB\xE0\x37\xAB\xBA\xC4\x8E\x45"
           , 128);
    nDmP1LenExp = 8 + 128;
    memcpy(bDmQ1Exp,
           "\x67\xA4\xFC\xA9\x48\x0B\xD9\xCA\x6E\xB3\xDA\xB3\x10\xA4\x72\x30"
           "\x72\xC2\x75\xC1\x29\xE2\x14\xFE\x77\x6F\x11\xFD\xCA\x7B\x84\x11"
           "\xAE\xBD\x3D\xCF\x15\x3B\x1E\x7F\xE9\x91\x9D\x6A\xFF\xDE\x66\x9D"
           "\x4A\x66\xBC\x57\x8C\xB6\x85\xAB\x90\x2D\xEA\x0C\x07\xDD\x67\x53"
           "\xDD\x54\x16\x88\x97\x3B\x15\x83\xC3\xD2\xB5\x96\x69\x88\x1D\x59"
           "\x76\x28\x94\xAC\x04\x98\xFC\x68\xAD\x0F\x8B\xEE\xD7\x1A\xCD\xF3"
           "\xCB\x98\xFF\xD5\x5F\xFF\x5F\x4F\x9E\x7A\xBC\x68\x58\x68\x1C\xBD"
           "\x7D\x05\x43\xEF\xB2\xFE\x70\xCF\xEB\x16\x2C\xA0\x20\xB6\x42\x44"
           , 128);
    nDmQ1LenExp = 8 + 128;
    memcpy(bCoefExp,
           "\x08\x6E\x41\xB5\x76\xCE\x04\x17\x50\x50\x40\xCD\x63\x09\x0B\x18"
           "\x5A\x69\x9B\x1E\x6F\x52\xF0\xF7\xBB\x88\x2A\xF7\x25\x04\x66\xD9"
           "\x2E\x5B\x83\x9B\x08\xF0\xDB\x64\x52\x36\x8B\xE6\x9B\x0F\x3F\x58"
           "\x70\x2A\x79\xDE\x5A\x14\x76\x72\xEE\xD9\x7C\x11\x76\x3E\x9A\x6D"
           "\xB4\x03\xC8\x64\xBD\xEE\xF3\x2E\x34\x88\xD9\x12\x21\x7B\x58\xFA"
           "\x87\x2F\xDC\x34\xD1\xF9\xE9\x7B\x2F\xBC\xF1\x2C\xCE\x9B\xB5\xB9"
           "\xC9\x3A\xDE\xED\x3F\xA3\x1B\xD0\xA7\xCC\x0F\xBF\x4A\xF3\xE2\x3C"
           "\xFA\x27\x71\xAB\xC0\xBD\x44\xF3\x1E\x3E\x26\x29\xF1\x38\x18\xD7"
           , 128);
    nCoefLenExp = 8 + 128;

    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    DspHex("[IN ]bSK      =", bSK, 1200);
    printf("[IN ]nSKLen   = %d\n", nSKLen);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bKEK     =", bKEK, 16);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateAnalyse(nSock, bSK, nSKLen, nAlgo, bKEK, bD, &nDLen, \
                               bP, &nPLen, bQ, &nQLen, bDmP1, &nDmP1Len, bDmQ1, \
                               &nDmQ1Len, bCoef, &nCoefLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-2048，双倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bD, bDExp, 256);
    ASSERT_OUT(nDLen, nDLenExp);
    ASSERT_OUT_HEX(bP, bPExp, 128);
    ASSERT_OUT(nPLen, nPLenExp);
    ASSERT_OUT_HEX(bQ, bQExp, 128);
    ASSERT_OUT(nQLen, nQLenExp);
    ASSERT_OUT_HEX(bDmP1, bDmP1Exp, 128);
    ASSERT_OUT(nDmP1Len, nDmP1LenExp);
    ASSERT_OUT_HEX(bDmQ1, bDmQ1Exp, 128);
    ASSERT_OUT(nDmQ1Len, nDmQ1LenExp);
    ASSERT_OUT_HEX(bCoef, bCoefExp, 128);
    ASSERT_OUT(nCoefLen, nCoefLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateAnalyse_Test_18(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  BYTE bSK[1280];
	  int  nSKLen;
	  int  nAlgo;
	  BYTE bKEK[32];
	  BYTE bD[276];
	  BYTE bDExp[276];
	  int  nDLen;
	  int  nDLenExp;
	  BYTE bP[144];
	  BYTE bPExp[144];
	  int  nPLen;
	  int  nPLenExp;
	  BYTE bQ[144];
	  BYTE bQExp[144];
	  int  nQLen;
	  int  nQLenExp;
	  BYTE bDmP1[144];
	  BYTE bDmP1Exp[144];
	  int  nDmP1Len;
	  int  nDmP1LenExp;
	  BYTE bDmQ1[144];
	  BYTE bDmQ1Exp[144];
	  int  nDmQ1Len;
	  int  nDmQ1LenExp;
	  BYTE bCoef[144];
	  BYTE bCoefExp[144];
	  int  nCoefLen;
	  int  nCoefLenExp;

    bufclr(bSK);
    bufclr(bKEK);
    bufclr(bD);
    bufclr(bDExp);
    bufclr(bP);
    bufclr(bPExp);
    bufclr(bQ);
    bufclr(bQExp);
    bufclr(bDmP1);
    bufclr(bDmP1Exp);
    bufclr(bDmQ1);
    bufclr(bDmQ1Exp);
    bufclr(bCoef);
    bufclr(bCoefExp);
    nDLen = 0;
    nPLen = 0;
    nQLen = 0;
    nDmP1Len = 0;
    nDmQ1Len = 0;
    nCoefLen = 0;

    memcpy(bSK,
           "\xB6\xF8\xDC\x3E\x12\x98\x52\xB8\xB1\x84\xC0\x51\x97\xD1\xBE\x87"
           "\x70\x24\xD7\xE1\x4A\x71\xC3\x20\xA9\xEE\x78\x93\xF8\x99\x5C\x1A"
           "\xE5\x32\x78\x65\x85\x07\xEB\x5E\x26\x79\x2F\x1E\xE1\x6E\x6E\xB9"
           "\xF7\x6A\x23\x46\x09\x92\xD0\x54\xD2\xCA\x6C\xB6\xCE\xB0\x0B\x1C"
           "\x83\xD3\xEB\x1B\x6F\x47\x05\x82\xBF\x68\x23\x24\x90\xDD\xA0\x4C"
           "\xAD\x00\xC2\xD6\xBE\x7D\x8C\x5C\xBF\x1B\xF6\xE1\x73\x51\x9E\x6D"
           "\x62\x46\xBF\x62\xD5\xA6\xD6\x93\x17\x5D\xEE\xEF\x03\x82\x5E\x89"
           "\xA5\x42\xF3\x09\xB1\x20\x11\x48\x39\x90\x8A\xBD\xAA\xE3\xA8\x12"
           "\x4E\xD2\x36\x25\x16\x60\x73\x35\x44\x99\x56\xFE\xED\xF1\xC7\x48"
           "\x57\x57\x56\x27\x7C\x94\xC5\x2D\x6B\x77\xFB\xDC\x82\xD8\xD0\xE0"
           "\x2D\x0E\x4D\x64\x5B\x98\x07\x49\x8A\x29\x70\xD9\xDE\xA9\x44\xC5"
           "\xDE\x71\xCE\xF5\xE0\x63\x40\x28\xF4\xD6\x6D\x86\x14\xCF\x70\x24"
           "\x5B\x05\xAE\xC7\xE9\x69\x7B\x42\xAB\xF6\x53\xA3\x97\x1C\x93\x61"
           "\xCE\x7E\x8F\x38\xF1\x85\xC6\xB8\x2C\x6F\x11\x3E\xA6\xF1\x18\xF8"
           "\x85\xAD\xF2\xE3\x32\x82\x51\x0D\xEB\x12\x68\xC0\x1B\xCD\xF2\x3A"
           "\xB5\x55\xCD\x1A\x92\x9D\x31\xDF\xA6\xB2\x7A\xEE\x99\xA1\x39\x62"
           "\xC9\xE5\xFD\x47\xD0\x37\xCE\x6C\x08\x33\x31\x58\x38\x7B\x3F\x77"
           "\xFF\x4B\x01\xFC\x24\x58\x33\x24\xEB\xA6\xE2\xEE\x33\x1B\x67\x52"
           "\x81\x19\x16\x3A\xFA\x23\x82\x1B\x61\xEE\x5B\xDD\x08\x83\xA4\x5D"
           "\xCC\x57\x5A\xBF\xA5\x5C\x6E\xD7\xB0\xA2\xB6\x73\x52\x92\x9E\x5C"
           "\x46\x8D\x3E\xFB\x15\x1C\xB2\x7E\xD0\x90\x09\x61\x4F\x98\xFF\xEE"
           "\x8C\x40\x99\x83\x62\x1C\x2A\x29\xA9\x35\x58\x08\xF7\x97\xE6\xC7"
           "\x74\x50\xC9\x7D\xBF\xA2\x61\x51\x57\xD2\xDB\xDD\xE7\x19\xEF\x75"
           "\x26\xC0\x48\x56\xD9\x38\xFC\xF6\xF1\xEC\x6E\x96\x72\xCE\x2F\x19"
           "\xCA\x17\x76\x25\xFA\xDB\x0A\xBF\x4E\xD3\x6F\x65\xE2\xA3\x53\x9F"
           "\x0F\x91\xCF\xA8\x32\x9D\x83\xF1\x62\x54\xA3\x3E\x89\xF9\xD3\x20"
           "\xE8\x10\xE5\xE8\x6A\x73\x40\x90\x9A\x9D\x21\xD0\x9E\xEE\xFA\x44"
           "\x29\x42\x36\x61\xF0\x89\x9E\xE2\xFA\xBE\x06\x74\x7A\xAC\x2A\xF6"
           "\xA6\xFE\xE0\x7E\x17\x7C\xDA\xA7\x4B\xA3\x33\xD0\x66\x40\x56\x07"
           "\xB5\x21\x1A\x1E\x17\x3B\x43\x62\x9C\x0D\x16\xFA\xF3\x09\x93\x99"
           "\x56\x6C\xFD\x6A\xB7\x64\x04\x77\x33\x61\x13\x13\xD0\x93\x30\xD7"
           "\x78\xAE\xD3\x91\x30\xC2\x2C\x81\x39\x88\x9F\xE3\x9B\x4F\xF0\xC8"
           "\xFF\xA0\xA7\xED\x5F\xC3\xD7\xFE\x9C\xA7\x85\x7D\x1E\x7E\xA6\x7C"
           "\xD7\x6C\xEF\x3A\xAD\xE2\xFE\x2E\xAD\x45\x17\x9E\xC8\xA9\x71\xAB"
           "\xBF\xB6\xE3\x16\xEC\x4B\xF5\xA7\x9D\x20\x72\x87\xB4\x7E\x80\x89"
           "\xD6\xEF\x8C\xEA\x5D\xD5\xD2\x26\x9B\x3E\x58\x2C\xEB\xE6\x07\x1A"
           "\x05\x01\xD6\xBB\xFB\xA4\x2C\x31\x7A\xC0\x03\xB2\x14\x3D\x95\x41"
           "\xB5\xE3\x35\xA8\x86\xCF\x8C\x68\xFE\x01\x75\x0F\x3B\x77\x56\xA2"
           "\xCF\x29\x24\xFE\x99\x37\x02\x75\x65\x0E\xD6\xD2\x82\x9A\x93\x74"
           "\xAD\xBE\x1E\x56\x13\xC4\x29\x53\x35\x57\x4B\x46\x22\x4B\xB8\x50"
           "\x53\x71\x44\x27\xA8\xBC\x5B\x31\x0A\x32\xD4\x0F\xFF\xB2\x32\x5F"
           "\x39\xCD\xB1\x90\x77\x70\x23\xF9\xF4\x85\xDA\xE9\x16\x9D\xD5\xA0"
           "\x2A\x71\xF9\xF4\x40\x7D\xD1\x24\x5D\xBF\x93\xB3\x7F\x0D\x95\x67"
           "\x19\x51\x18\xA0\x99\x7A\x84\x44\x71\x9A\x08\x0D\x98\x25\x2E\xA6"
           "\x55\x6B\xEC\xA9\xA0\x72\xA4\xEF\x41\xC4\x20\x67\xA8\x86\xC9\x82"
           "\x86\xE8\x58\x5B\xA6\x8B\xCB\x30\xED\xF7\x7B\x0E\x6A\x6F\x6C\x39"
           "\x7A\x48\xA8\xE1\x9C\xEE\xC5\xDF\x08\x4B\xC9\x0A\x5D\xA0\x34\x42"
           "\xB5\x79\x5C\x29\xAF\xA9\xF8\x84\x31\xBE\x94\x21\x29\x17\x82\x99"
           "\x81\xB4\x9E\x2B\xC9\x78\xC5\xA6\x25\xD7\x28\xEE\x3A\xD2\x3B\xD8"
           "\x05\xCE\xEA\x07\x92\xD4\x8B\x4D\x64\xB4\x7F\x57\x9D\x2A\xFB\x80"
           "\xFF\x16\x09\xE2\x9A\xAC\x7E\x32\x2D\x2B\xE7\xA2\x9F\x9F\x63\xAF"
           "\x59\x62\xC6\x8D\x51\xD9\x2F\x6B\xF2\xB8\xEA\x9B\xAE\x30\x7A\xBB"
           "\x76\xC7\xDE\xB7\xF8\xF0\x33\x2E\x69\x65\xC0\x89\x2B\x82\x72\xAE"
           "\x8B\x65\x53\xEF\x96\xA4\xCC\xE6\xAB\x80\x9D\x23\x51\xCB\x77\x5B"
           "\xAB\x75\x5A\x70\x7B\x9C\xBE\xD6\x44\xCD\x0A\x3A\x1C\xF8\xD7\xC8"
           "\x9E\x68\x2B\xA2\xB6\x30\xC4\xE7\x3A\xF2\xDA\xE4\x15\xDE\x80\xD5"
           "\x03\xF6\x06\x3E\x19\x0B\x09\xF5\xE1\xED\xE9\x82\x79\x02\xD7\x21"
           "\x5C\x71\xFE\x15\xCB\xB5\x85\xB1\x12\x75\xF2\x94\xFC\xB7\x24\x14"
           "\xFF\xDE\xA6\x49\x7D\x61\xF8\xAE\x83\x40\x97\xC6\x13\x8F\xD6\xE2"
           "\xDA\xE8\x9D\x66\x71\x4A\x22\x1F\xF9\x55\x79\xAA\xE0\xE6\xD7\x29"
           "\x3D\x44\x2E\xC0\xB9\x4D\x64\x65\x2A\x0E\x4A\xB8\x62\xC1\x84\x2E"
           "\x3F\x6F\xEB\x79\xDF\xCF\xAA\x83\xB9\x7C\x73\x7E\x48\x88\x44\x03"
           "\xEA\x4F\x09\xCD\x72\x37\xA7\x49\x37\x6E\x52\x57\xFC\x64\x17\xE5"
           "\x9E\x36\x4D\xD7\x33\x82\xA5\x42\x3F\x37\x96\xE9\x00\x70\x91\x7E"
           "\x1F\xFF\xCD\xD3\x39\xD8\x27\x8F\x67\x81\x51\xF8\x03\xB5\x3A\xB9"
           "\x57\x64\x16\xBF\x7F\x0C\xD6\x74\xE7\x37\xB2\xFD\xF4\x20\x1B\x4C"
           "\xFD\xFC\x5C\xEF\x78\x30\x05\x38\xD7\x51\xE8\xD3\x16\x0A\x7D\x8C"
           "\xBA\x84\x9D\x1F\xF5\x6F\xE7\x15\x41\x1D\x3E\x40\x4D\x98\x64\x46"
           "\x43\x35\xA6\xBB\x0B\x0D\xF3\x39\x1D\xF9\x2B\x8C\x8E\xBD\x43\x9B"
           "\x39\x39\x10\x04\x06\x0B\x31\x7C\xF0\x1E\xE1\x70\xB1\x55\xD1\x59"
           "\xBE\x38\x24\xC8\x3E\x53\x30\xF7\x0F\xCE\x37\xCD\x5C\xF7\x90\x33"
           "\x85\x7F\x4D\x02\xAB\xEA\x50\x12\x18\xF3\x6E\x56\xA8\xEE\x38\x08"
           "\x8F\x94\x95\xAE\xE3\x74\x54\xCF\x0B\x88\x16\x7D\x2E\xBA\xAB\xCE"
           "\xCD\x7B\xA5\x62\x51\x84\x6A\x30\x0E\xF6\x44\x6C\x62\xDB\x9B\x21"
           "\xCA\x09\x0C\xBD\xE5\x09\x1C\xFA\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78"
           , 1200);
    nSKLen = 1200;
    nAlgo = 3;
    /* 0123 4567 89AB CDEF FEDC BA98 7654 3210 8796 A5B4 C3D2 E1F0 */
    memcpy(bKEK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21\xFB\x5C\x6A\xEB\xE7\x14\xE5\x3A"
           "\x59\x99\xC3\x06\xAB\x84\x01\xB2"
           , 24);

    memcpy(bDExp,
           "\x40\x8B\xC9\xDC\x08\x10\xE4\xC3\x6B\x2D\x57\x85\xAD\xA1\x60\xB7"
           "\x07\x18\x84\x28\xEB\x12\xD4\x2B\x07\x9A\xEB\x68\xEC\x6E\xC3\xD9"
           "\xEA\x04\x2B\x53\x7E\x38\x5A\x28\x54\x5C\x28\xF1\x1D\x95\xE9\x6A"
           "\xEF\x6E\x49\x80\x0A\x7C\x78\x13\x88\xF3\xBB\xBD\x96\x74\xF8\x1D"
           "\xEF\x8C\x2F\x2A\xCE\x4B\xAA\x5C\xE9\xDC\x69\x74\x42\x8E\x54\x41"
           "\xE3\xE3\xD3\x48\xD3\xDB\x00\xAA\xA8\x04\xF2\x32\xC1\xC5\x93\x3A"
           "\xD6\x4B\x37\x72\x8A\x9C\xB6\x93\x7C\x7D\x79\xCB\xE8\x96\xBC\x8F"
           "\x00\x2F\x3C\x77\x94\xCD\x3E\xB0\x35\xD5\xA8\x2D\xD8\x8B\xBB\x73"
           "\x8A\x7A\x9F\x56\x77\x58\x06\x40\x44\xCD\x05\x07\x2B\x47\x3B\xBA"
           "\xA2\x02\xF1\x08\x76\xD9\x02\x21\x39\x85\x05\x21\xD0\xE7\xBF\x1E"
           "\x84\x4D\xCA\x97\x5F\x28\xEA\x30\x2D\x71\x1D\x2B\xD2\x45\x40\x9E"
           "\xDE\xF4\xBB\xBB\xC5\x59\xAE\x1C\x9A\x7F\xE0\x67\x4A\x3F\xDD\x95"
           "\xD9\x56\xDF\x9E\x88\xA6\xD5\xC4\x58\x97\xCB\x66\x6D\x12\x21\xB1"
           "\x2B\x38\x5C\x31\x98\x69\x86\xE6\x5B\x90\xC2\x6E\x38\x94\xD7\xCF"
           "\x1D\xEF\xC3\xB4\xDA\x6E\x2E\x09\xFA\xE5\x5E\x2D\x52\x9A\x30\x8E"
           "\xBA\x50\x91\x18\x80\xBE\x16\xB5\x56\xE0\x4C\x1B\xCE\xDD\x2B\xBE"
           , 256);
    nDLenExp = 8 + 256;
    memcpy(bPExp,
           "\x99\x17\x7B\x68\x52\x84\x8B\xE8\xA0\xE6\xB2\xBB\x6A\xBF\xC0\x0A"
           "\xAC\x1F\x70\x6A\xDE\x7A\x25\x01\xF8\x3E\xE9\xC2\x99\x59\x78\xC3"
           "\x6B\x31\x6A\x90\x09\x9B\x48\x45\x6B\x9A\xAD\x2B\xC3\x26\x5E\xD8"
           "\x71\x6C\x4C\x16\x09\xF4\x18\x4B\xE9\x12\x46\x53\xE9\x08\x6B\x3D"
           "\xF1\xFC\x49\x86\x2A\x23\x57\x90\x39\xAB\x72\x4F\xE5\x1E\xBB\x59"
           "\x45\xD1\xB0\xA4\x55\xA2\x53\x7E\xED\xCD\x61\x32\x84\x6A\x61\xB5"
           "\xE0\x06\x7C\x6B\xE0\x7A\x33\x32\x8B\xB6\x80\x7E\x81\x26\xC2\x3B"
           "\x9C\x5A\x3C\x12\xEE\x4D\x1A\xE5\x03\x94\x68\x1E\x41\x84\xEE\xAA"
           , 128);
    nPLenExp = 8 + 128;
    memcpy(bQExp,
           "\xAF\xCA\x2D\x91\xBD\xA6\xC4\xAE\x8E\x25\x6B\x4A\xCE\x5D\xF1\xE3"
           "\xF3\xF5\x3F\xA1\x81\x73\x2D\xA7\x6D\xCE\xF0\xD3\x3B\xA5\x57\x2C"
           "\x8D\xCC\x4F\x7D\x67\x1C\xFD\x8F\x7D\x63\xBE\xBB\x2C\xDE\xFD\xF1"
           "\x85\x9C\xE1\x6D\x01\x41\x21\xB9\x85\xC6\x52\x5E\x3C\x66\x73\x32"
           "\xC3\xDC\xE4\x4F\xCC\x93\x4F\x54\x91\x57\x0E\x63\x99\xD3\x0C\xBA"
           "\x12\x7D\x9E\x7E\xFE\xA1\xBD\xD8\xE0\x66\x59\x2E\xA1\x28\x74\x1E"
           "\x87\xC8\x20\x31\x9B\xEC\xC3\x3F\x53\xB1\x3C\xBD\xAE\xCB\x90\xBB"
           "\x10\xBA\xD4\xE6\x9B\x8C\x67\x0B\x1C\xF0\xEB\x1F\x5F\x78\x52\x3A"
           , 128);
    nQLenExp = 8 + 128;
    memcpy(bDmP1Exp,
           "\x9B\x05\xA7\x08\x11\xD0\x73\xAB\xB5\xAD\x2F\xE5\xB9\x8E\x80\xFA"
           "\x22\x5D\x95\x01\x44\xF3\xBC\x70\x34\x74\x4B\xFC\xFC\xCC\x6F\x5A"
           "\x1D\x8C\x83\x46\xD8\xBB\x5B\x88\xCD\x10\xA2\x78\x10\xB4\x03\xB6"
           "\xD3\x09\x4A\x0A\xA4\xE3\xC1\x3D\x71\x33\xF8\x23\xAD\x23\xB3\x36"
           "\x06\xE0\xF6\x61\xC7\x7D\x43\x75\xF4\x02\xFA\xDC\x91\x3B\x4E\x71"
           "\xEA\x83\xB2\x5E\x31\xC8\xCC\xBE\x24\x3B\xF4\xF5\x16\xFC\x8C\x87"
           "\xE8\xEA\x9F\x5F\x9A\x9E\x1A\xE9\x61\x00\x8B\xF0\xA6\xA2\x58\xA1"
           "\x83\xEB\x4C\x36\x72\x50\x96\x82\xF8\xE8\x53\x92\x8A\x2C\x8B\x53"
           , 128);
    nDmP1LenExp = 8 + 128;
    memcpy(bDmQ1Exp,
           "\xEF\xC8\x70\x55\x9D\xEA\x99\x3E\xC3\x66\x10\x66\xDF\xF3\x06\x71"
           "\x0E\xD3\x90\x69\x05\x6C\x71\x84\xAD\xDA\xE6\x4C\x3B\x3B\x76\x7F"
           "\x9A\xD1\xC5\x3C\x3E\xB6\x5B\x95\x9B\x7D\x40\xAB\x42\xB3\xE0\x2F"
           "\x46\x4E\x8D\x8B\xBF\x45\x1E\x8D\xEE\xAF\x94\x3F\x14\x83\x43\xF2"
           "\xA8\x88\x8C\xA9\x56\x7E\xA6\x40\x35\x63\x12\xB9\x5B\x79\x66\x34"
           "\xE1\x66\x45\x35\x61\x78\xDB\x70\x4D\x13\xE0\xFA\x2A\x99\x56\xF4"
           "\x01\xE3\x73\xBA\x41\x2D\x17\x2E\xEF\xD6\x3A\x7A\x27\xC5\x98\xC5"
           "\x02\x70\x68\x81\xA4\x7F\x7F\x04\x2C\xF7\x70\x66\xED\xD2\x59\x94"
           , 128);
    nDmQ1LenExp = 8 + 128;
    memcpy(bCoefExp,
           "\x1D\x73\x18\x2C\x9A\xA0\x8F\xAD\x82\x9D\x1A\x36\x32\xCD\x2A\xF5"
           "\xEA\xB3\x90\x41\x26\x5E\x11\x19\x6B\xC3\x95\x8B\x05\x74\x21\x93"
           "\xBC\x57\xCA\x59\xBE\x95\xC8\xE7\x7F\xC3\x84\xF7\x20\x0E\x89\x0D"
           "\xFB\xFA\x00\x0D\xCD\xF4\x21\x42\x80\x60\x06\x31\x55\x89\x2A\x3D"
           "\x1D\x52\x62\x17\xD3\x1F\x0E\x2B\x5F\xF8\x30\x8D\xCF\x82\xD0\x94"
           "\x62\x15\x46\xD8\xE6\x5A\xAC\x40\x56\xC5\xF5\xDF\xFF\x3E\x87\x63"
           "\x4E\x0E\x26\x4B\xC7\x04\xF8\x96\xAB\x0B\x3F\xD5\x92\x19\xE7\x6F"
           "\xD3\x99\xEC\xEA\x68\xC8\xE4\x68\x5E\x8E\x8B\xA7\x6F\x64\x87\x5B"
           , 128);
    nCoefLenExp = 8 + 128;

    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    DspHex("[IN ]bSK      =", bSK, 1200);
    printf("[IN ]nSKLen   = %d\n", nSKLen);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bKEK     =", bKEK, 24);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateAnalyse(nSock, bSK, nSKLen, nAlgo, bKEK, bD, &nDLen, \
                               bP, &nPLen, bQ, &nQLen, bDmP1, &nDmP1Len, bDmQ1, \
                               &nDmQ1Len, bCoef, &nCoefLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-2048，三倍长密钥，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    ASSERT_OUT_HEX(bD, bDExp, 256);
    ASSERT_OUT(nDLen, nDLenExp);
    ASSERT_OUT_HEX(bP, bPExp, 128);
    ASSERT_OUT(nPLen, nPLenExp);
    ASSERT_OUT_HEX(bQ, bQExp, 128);
    ASSERT_OUT(nQLen, nQLenExp);
    ASSERT_OUT_HEX(bDmP1, bDmP1Exp, 128);
    ASSERT_OUT(nDmP1Len, nDmP1LenExp);
    ASSERT_OUT_HEX(bDmQ1, bDmQ1Exp, 128);
    ASSERT_OUT(nDmQ1Len, nDmQ1LenExp);
    ASSERT_OUT_HEX(bCoef, bCoefExp, 128);
    ASSERT_OUT(nCoefLen, nCoefLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateAnalyse_Test_19(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  BYTE bSK[1280];
	  int  nSKLen;
	  int  nAlgo;
	  BYTE bKEK[32];
	  BYTE bD[276];
	  BYTE bDExp[276];
	  int  nDLen;
	  int  nDLenExp;
	  BYTE bP[144];
	  BYTE bPExp[144];
	  int  nPLen;
	  int  nPLenExp;
	  BYTE bQ[144];
	  BYTE bQExp[144];
	  int  nQLen;
	  int  nQLenExp;
	  BYTE bDmP1[144];
	  BYTE bDmP1Exp[144];
	  int  nDmP1Len;
	  int  nDmP1LenExp;
	  BYTE bDmQ1[144];
	  BYTE bDmQ1Exp[144];
	  int  nDmQ1Len;
	  int  nDmQ1LenExp;
	  BYTE bCoef[144];
	  BYTE bCoefExp[144];
	  int  nCoefLen;
	  int  nCoefLenExp;

    bufclr(bSK);
    bufclr(bKEK);
    bufclr(bD);
    bufclr(bDExp);
    bufclr(bP);
    bufclr(bPExp);
    bufclr(bQ);
    bufclr(bQExp);
    bufclr(bDmP1);
    bufclr(bDmP1Exp);
    bufclr(bDmQ1);
    bufclr(bDmQ1Exp);
    bufclr(bCoef);
    bufclr(bCoefExp);
    nDLen = 0;
    nPLen = 0;
    nQLen = 0;
    nDmP1Len = 0;
    nDmQ1Len = 0;
    nCoefLen = 0;

    nSock = -1;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKEK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           , 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    DspHex("[IN ]bSK      =", bSK, 320);
    printf("[IN ]nSKLen   = %d\n", nSKLen);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bKEK     =", bKEK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateAnalyse(nSock, bSK, nSKLen, nAlgo, bKEK, bD, &nDLen, \
                               bP, &nPLen, bQ, &nQLen, bDmP1, &nDmP1Len, bDmQ1, \
                               &nDmQ1Len, bCoef, &nCoefLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[-1]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void PrivateAnalyse_Test_20(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  BYTE bSK[1280];
	  int  nSKLen;
	  int  nAlgo;
	  BYTE bKEK[32];
	  BYTE bD[276];
	  BYTE bDExp[276];
	  int  nDLen;
	  int  nDLenExp;
	  BYTE bP[144];
	  BYTE bPExp[144];
	  int  nPLen;
	  int  nPLenExp;
	  BYTE bQ[144];
	  BYTE bQExp[144];
	  int  nQLen;
	  int  nQLenExp;
	  BYTE bDmP1[144];
	  BYTE bDmP1Exp[144];
	  int  nDmP1Len;
	  int  nDmP1LenExp;
	  BYTE bDmQ1[144];
	  BYTE bDmQ1Exp[144];
	  int  nDmQ1Len;
	  int  nDmQ1LenExp;
	  BYTE bCoef[144];
	  BYTE bCoefExp[144];
	  int  nCoefLen;
	  int  nCoefLenExp;

    bufclr(bSK);
    bufclr(bKEK);
    bufclr(bD);
    bufclr(bDExp);
    bufclr(bP);
    bufclr(bPExp);
    bufclr(bQ);
    bufclr(bQExp);
    bufclr(bDmP1);
    bufclr(bDmP1Exp);
    bufclr(bDmQ1);
    bufclr(bDmQ1Exp);
    bufclr(bCoef);
    bufclr(bCoefExp);
    nDLen = 0;
    nPLen = 0;
    nQLen = 0;
    nDmP1Len = 0;
    nDmQ1Len = 0;
    nCoefLen = 0;

    nSock = 8;
    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKEK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           , 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    DspHex("[IN ]bSK      =", bSK, 320);
    printf("[IN ]nSKLen   = %d\n", nSKLen);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bKEK     =", bKEK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateAnalyse(nSock, bSK, nSKLen, nAlgo, bKEK, bD, &nDLen, \
                               bP, &nPLen, bQ, &nQLen, bDmP1, &nDmP1Len, bDmQ1, \
                               &nDmQ1Len, bCoef, &nCoefLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 3, "无效Socket ID[8]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    nSock = SM_SOCK;

    XXX_TEST_END_XXX
}

void PrivateAnalyse_Test_21(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  BYTE bSK[1280];
	  int  nSKLen;
	  int  nAlgo;
	  BYTE bKEK[32];
	  BYTE bD[276];
	  BYTE bDExp[276];
	  int  nDLen;
	  int  nDLenExp;
	  BYTE bP[144];
	  BYTE bPExp[144];
	  int  nPLen;
	  int  nPLenExp;
	  BYTE bQ[144];
	  BYTE bQExp[144];
	  int  nQLen;
	  int  nQLenExp;
	  BYTE bDmP1[144];
	  BYTE bDmP1Exp[144];
	  int  nDmP1Len;
	  int  nDmP1LenExp;
	  BYTE bDmQ1[144];
	  BYTE bDmQ1Exp[144];
	  int  nDmQ1Len;
	  int  nDmQ1LenExp;
	  BYTE bCoef[144];
	  BYTE bCoefExp[144];
	  int  nCoefLen;
	  int  nCoefLenExp;

    bufclr(bSK);
    bufclr(bKEK);
    bufclr(bD);
    bufclr(bDExp);
    bufclr(bP);
    bufclr(bPExp);
    bufclr(bQ);
    bufclr(bQExp);
    bufclr(bDmP1);
    bufclr(bDmP1Exp);
    bufclr(bDmQ1);
    bufclr(bDmQ1Exp);
    bufclr(bCoef);
    bufclr(bCoefExp);
    nDLen = 0;
    nPLen = 0;
    nQLen = 0;
    nDmP1Len = 0;
    nDmQ1Len = 0;
    nCoefLen = 0;

    nSKLen = 0;
    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKEK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           , 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    DspHex("[IN ]bSK      =", bSK, 0);
    printf("[IN ]nSKLen   = %d\n", nSKLen);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bKEK     =", bKEK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateAnalyse(nSock, bSK, nSKLen, nAlgo, bKEK, bD, &nDLen, \
                               bP, &nPLen, bQ, &nQLen, bDmP1, &nDmP1Len, bDmQ1, \
                               &nDmQ1Len, bCoef, &nCoefLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "私钥长度=0测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateAnalyse_Test_22(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  BYTE bSK[1280];
	  int  nSKLen;
	  int  nAlgo;
	  BYTE bKEK[32];
	  BYTE bD[276];
	  BYTE bDExp[276];
	  int  nDLen;
	  int  nDLenExp;
	  BYTE bP[144];
	  BYTE bPExp[144];
	  int  nPLen;
	  int  nPLenExp;
	  BYTE bQ[144];
	  BYTE bQExp[144];
	  int  nQLen;
	  int  nQLenExp;
	  BYTE bDmP1[144];
	  BYTE bDmP1Exp[144];
	  int  nDmP1Len;
	  int  nDmP1LenExp;
	  BYTE bDmQ1[144];
	  BYTE bDmQ1Exp[144];
	  int  nDmQ1Len;
	  int  nDmQ1LenExp;
	  BYTE bCoef[144];
	  BYTE bCoefExp[144];
	  int  nCoefLen;
	  int  nCoefLenExp;

    bufclr(bSK);
    bufclr(bKEK);
    bufclr(bD);
    bufclr(bDExp);
    bufclr(bP);
    bufclr(bPExp);
    bufclr(bQ);
    bufclr(bQExp);
    bufclr(bDmP1);
    bufclr(bDmP1Exp);
    bufclr(bDmQ1);
    bufclr(bDmQ1Exp);
    bufclr(bCoef);
    bufclr(bCoefExp);
    nDLen = 0;
    nPLen = 0;
    nQLen = 0;
    nDmP1Len = 0;
    nDmQ1Len = 0;
    nCoefLen = 0;

    nSKLen = 4096;
    nAlgo = 1;
    /* 0123 4567 89AB CDEF */
    memcpy(bKEK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           , 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    DspHex("[IN ]bSK      =", bSK, 0);
    printf("[IN ]nSKLen   = %d\n", nSKLen);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bKEK     =", bKEK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateAnalyse(nSock, bSK, nSKLen, nAlgo, bKEK, bD, &nDLen, \
                               bP, &nPLen, bQ, &nQLen, bDmP1, &nDmP1Len, bDmQ1, \
                               &nDmQ1Len, bCoef, &nCoefLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "私钥长度=4096测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateAnalyse_Test_23(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  BYTE bSK[1280];
	  int  nSKLen;
	  int  nAlgo;
	  BYTE bKEK[32];
	  BYTE bD[276];
	  BYTE bDExp[276];
	  int  nDLen;
	  int  nDLenExp;
	  BYTE bP[144];
	  BYTE bPExp[144];
	  int  nPLen;
	  int  nPLenExp;
	  BYTE bQ[144];
	  BYTE bQExp[144];
	  int  nQLen;
	  int  nQLenExp;
	  BYTE bDmP1[144];
	  BYTE bDmP1Exp[144];
	  int  nDmP1Len;
	  int  nDmP1LenExp;
	  BYTE bDmQ1[144];
	  BYTE bDmQ1Exp[144];
	  int  nDmQ1Len;
	  int  nDmQ1LenExp;
	  BYTE bCoef[144];
	  BYTE bCoefExp[144];
	  int  nCoefLen;
	  int  nCoefLenExp;

    bufclr(bSK);
    bufclr(bKEK);
    bufclr(bD);
    bufclr(bDExp);
    bufclr(bP);
    bufclr(bPExp);
    bufclr(bQ);
    bufclr(bQExp);
    bufclr(bDmP1);
    bufclr(bDmP1Exp);
    bufclr(bDmQ1);
    bufclr(bDmQ1Exp);
    bufclr(bCoef);
    bufclr(bCoefExp);
    nDLen = 0;
    nPLen = 0;
    nQLen = 0;
    nDmP1Len = 0;
    nDmQ1Len = 0;
    nCoefLen = 0;

    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    nAlgo = 0;
    /* 0123 4567 89AB CDEF */
    memcpy(bKEK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           , 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    DspHex("[IN ]bSK      =", bSK, 320);
    printf("[IN ]nSKLen   = %d\n", nSKLen);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bKEK     =", bKEK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateAnalyse(nSock, bSK, nSKLen, nAlgo, bKEK, bD, &nDLen, \
                               bP, &nPLen, bQ, &nQLen, bDmP1, &nDmP1Len, bDmQ1, \
                               &nDmQ1Len, bCoef, &nCoefLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效算法类型[0]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void PrivateAnalyse_Test_24(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  BYTE bSK[1280];
	  int  nSKLen;
	  int  nAlgo;
	  BYTE bKEK[32];
	  BYTE bD[276];
	  BYTE bDExp[276];
	  int  nDLen;
	  int  nDLenExp;
	  BYTE bP[144];
	  BYTE bPExp[144];
	  int  nPLen;
	  int  nPLenExp;
	  BYTE bQ[144];
	  BYTE bQExp[144];
	  int  nQLen;
	  int  nQLenExp;
	  BYTE bDmP1[144];
	  BYTE bDmP1Exp[144];
	  int  nDmP1Len;
	  int  nDmP1LenExp;
	  BYTE bDmQ1[144];
	  BYTE bDmQ1Exp[144];
	  int  nDmQ1Len;
	  int  nDmQ1LenExp;
	  BYTE bCoef[144];
	  BYTE bCoefExp[144];
	  int  nCoefLen;
	  int  nCoefLenExp;

    bufclr(bSK);
    bufclr(bKEK);
    bufclr(bD);
    bufclr(bDExp);
    bufclr(bP);
    bufclr(bPExp);
    bufclr(bQ);
    bufclr(bQExp);
    bufclr(bDmP1);
    bufclr(bDmP1Exp);
    bufclr(bDmQ1);
    bufclr(bDmQ1Exp);
    bufclr(bCoef);
    bufclr(bCoefExp);
    nDLen = 0;
    nPLen = 0;
    nQLen = 0;
    nDmP1Len = 0;
    nDmQ1Len = 0;
    nCoefLen = 0;

    memcpy(bSK,
           "\x6A\xAB\x98\x67\x4E\x12\x27\x4C\x39\x0D\x99\xD8\x77\x36\x7B\x36"
           "\x2C\x63\x6A\x9D\x44\x61\xA9\xAE\x1C\xF4\x77\xB7\x19\xF5\x0D\x84"
           "\xB8\x80\x96\x34\x20\x4A\x96\x21\x89\x79\xB0\x14\xE9\x83\x2A\xCB"
           "\x20\xA2\x25\xD3\x83\xDC\x88\x73\x20\x6F\x2F\xFC\x25\x4E\xAA\xEC"
           "\x86\xEE\x9C\x94\x53\x97\x48\x5B\x87\xBF\x28\x6D\x57\x3F\xA9\x91"
           "\xE7\x2D\x64\xDD\x8D\x95\x9A\xDE\x17\xB2\x80\x91\x17\x68\x7F\x42"
           "\x3F\x7B\x40\xF3\x29\x30\x99\x86\x95\x92\xE6\xB8\x99\xD3\x4A\xCB"
           "\xD2\x42\xE0\xC8\xA3\x80\x30\x7C\x33\x8B\xFE\xC2\x9D\xB0\x63\x4C"
           "\xC2\x00\x72\xC2\xB4\xB0\xC5\xF5\x10\x15\xE0\x8C\x0C\x44\x19\xAF"
           "\x93\xD6\xCE\x71\x77\xBD\xBB\x80\x5F\xA4\xE1\x17\xCD\x57\x0F\xC9"
           "\x2C\xEC\x93\x6C\x40\x71\x12\x87\x01\x2A\xCF\x46\xBD\xB6\x7B\x0E"
           "\xDE\x64\xD8\x62\x90\x6B\x7C\x89\xA0\xAB\xAD\x16\x24\xE2\x22\xE5"
           "\x0D\x82\x16\x83\xBF\xBA\x8B\xEB\x4F\x1C\x31\x32\xBC\xC3\x59\xB7"
           "\x14\xFB\x53\xBB\x12\x9C\x23\x9B\xC8\xB4\xB9\x5B\x2E\x20\xE9\x65"
           "\x7F\x14\x93\x87\xCE\xD7\x90\xFC\xBF\x14\x47\xD6\x64\x56\x1B\xC4"
           "\x7A\x03\xF0\x13\xBE\xA3\x66\x89\x42\x1E\x17\xF4\xF1\x68\xED\x55"
           "\xAE\x6F\x2C\x1B\x37\xCB\x8A\x1D\x28\xA9\xFC\xA1\x49\x73\x2C\x2E"
           "\x20\xB3\x7B\x12\x3D\x1E\x85\x58\x1C\x77\xF2\xD6\xA1\xAA\x54\x0D"
           "\xB3\x8F\x50\x62\x4C\x94\x9E\x2B\x8E\x32\x36\x00\xEF\x23\x50\x44"
           "\x69\x8C\x5A\xBD\xB2\x5D\x66\x28\x0D\x82\x66\x9D\xD5\x52\x9B\x49"
           , 320);
    nSKLen = 320;
    nAlgo = 4;
    /* 0123 4567 89AB CDEF */
    memcpy(bKEK,
           "\xA2\xC0\xB0\xF8\xF7\xF5\xEE\x21"
           , 8);

    XXX_INPUT_XXX
    printf("[IN ]nSock    = %d\n", nSock);
    DspHex("[IN ]bSK      =", bSK, 320);
    printf("[IN ]nSKLen   = %d\n", nSKLen);
    printf("[IN ]nAlgo    = %d\n", nAlgo);
    DspHex("[IN ]bKEK     =", bKEK, 8);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateAnalyse(nSock, bSK, nSKLen, nAlgo, bKEK, bD, &nDLen, \
                               bP, &nPLen, bQ, &nQLen, bDmP1, &nDmP1Len, bDmQ1, \
                               &nDmQ1Len, bCoef, &nCoefLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 1, "无效算法类型[3]测试未失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void GenRsaKey_Test_00(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nIndex;
    int  nModLen;
    char szExp[10];
    BYTE bPK[2048];
    int  nPKLen;
    BYTE bSK[2048];
    int  nSKLen;

    bufclr(szExp);
    bufclr(bPK);
    bufclr(bSK);
    nPKLen = 0;
    nSKLen = 0;

    nIndex = 4;
    nModLen = 2048;
    memcpy(szExp, "03", 2);

    XXX_INPUT_XXX
    printf("[IN ]nSock   = %d\n", nSock);
    printf("[IN ]nIndex  = %d\n", nIndex);
    printf("[IN ]nModLen = %d\n", nModLen);
    printf("[IN ]szExp   = %s\n", szExp);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIGenRsaKey(nSock, nIndex, nModLen, szExp, bPK, &nPKLen, bSK, &nSKLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "索引号=0，密钥模长=2048，公钥指数=03，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bPK     =", bPK, nPKLen + 8);
    printf("[OUT]nPKLen  = %d\n", nPKLen);
    DspHex("[OUT]bSK     =", bSK, nSKLen + 8);
    printf("[OUT]nSKLen  = %d\n", nSKLen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}


//zhaomx   20170215
void PublicCalc_Test1_21(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

    int  nFlag;
     int  nPadMode;
     BYTE bPK[512];
     int  nPKLen;
     BYTE bInData[144];
     int  nInDataLen;
     BYTE bOutData[512];
     int  nOutDataLen;
     BYTE bOutDataExp[512];
     int  nOutDataLenExp;

    bufclr(bPK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 1;
    nPadMode = 1;
    memcpy(bPK,
           "\x30\x81\x97\x02\x81\x91\x00\xB4\xD4\xCD\x27\x2B\x0C\x7A\xBA\xA9"
           "\x32\x54\xA6\x0A\xD3\xDD\xAE\x80\x31\x47\x07\xC8\x48\x4F\x76\x03"
           "\x7C\x24\x4A\x59\x54\x0E\x99\x25\xD1\x3C\xB6\xE0\x20\xDB\xCB\x20"
           "\xB5\x23\x8F\x55\xDE\xF4\x31\xCD\x51\xE2\x1B\x07\xDC\xCC\x41\x6A"
           "\xAA\xBB\x0C\x5E\x3A\x61\x11\xA0\x90\xE0\xA9\x38\x86\x1C\x78\xE9"
           "\xAA\x75\xF2\x02\x38\x36\x19\x53\x4C\xE9\x21\x88\x43\x05\x8C\x7D"
           "\xDB\x60\x26\x36\x87\x24\xA7\xD5\x36\x39\x14\xD1\xEF\x66\x78\x1C"
           "\xBE\xD1\x56\xF9\x70\x77\xF7\xE0\xF1\x1B\x9D\x8D\x9C\xB6\x26\x5A"
           "\xE6\x3A\xC8\x18\x9F\x48\x03\x3D\x85\x06\x21\x71\xB2\x2C\x70\x98"
           "\x40\xA5\x39\xA0\xBD\x8D\xDB\x02\x01\x03"
           , 154);
    nPKLen = 154;
    memcpy(bInData,
           "\x0C\xBC\xF6\x9A\xE4\xAA\xAA\xC5\xBC\x07\xD3\x59\xA2\x07\xF9\xFD"
           "\x3B\xC4\xD6\xB5\x42\x08\x96\x97\x86\xE2\xC8\xD1\xD9\x20\x9A\x1A"
           "\xA1\x27\xDE\xEB\x59\x5B\x3A\x04\xE1\xA6\x0D\xC9\x19\x7A\xF8\x58"
           "\x1F\x1B\x17\x2D\xF2\x13\x5B\xBD\x2C\x58\x5C\xAB\x17\x6E\xBA\xFD"
           "\xD6\x83\x63\x08\xA4\xD9\x91\xBF"
           , 72);
    nInDataLen = 72;
    memset(bOutDataExp, 0x42, 72);
    bOutDataExp[0] = 0x30;
    bOutDataExp[71] = 0x39;

    nOutDataLenExp = 72;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bPK =", bPK, 154);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHex("[IN ]bInData =", bInData, 144);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPublicCalc(nSock, nFlag, nPadMode, bPK, nPKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-1152，PKCS#1填充，加密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 144);
   // ASSERT_OUT_HEX(bOutData, bOutDataExp, 72);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

//zhaomx     2017-2-15
void PrivateCalc_Test1_24(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nFlag;
	  int  nPadMode;
	  BYTE bSK[1280];
	  int  nSKLen;
	  BYTE bInData[512];
	  int  nInDataLen;
	  BYTE bOutData[512];
	  int  nOutDataLen;
	  BYTE bOutDataExp[512];
	  int  nOutDataLenExp;

    bufclr(bSK);
    bufclr(bInData);
    bufclr(bOutData);
    bufclr(bOutDataExp);

    nFlag = 0;
    nPadMode = 1;
    memcpy(bSK,
                "\x3B\xD4\x50\x5C\x7E\x86\x10\xCE\x25\x76\x6E\x01\x97\xE9\xDE\x97\x94\x23\xE8\x34"
		"\x0C\x20\xC0\xEE\x1F\x70"
		"\xE8\xC4\x44\x90\x82\x68\x7C\xA5\x9A\x11\x35\xAE\xE5\x61\x5E\x0E\xFE\x9A\x82\xFD"
		"\x9F\x6F\x28\x62\xDE\x83\xDD\x00\x22\x99\xE2\x89\x96\x5A\x20\x6D\x90\x4F\x2D\x12"
		"\x7B\xED\x16\x4F\x83\x2B\x82\xF5\xDA\x60\xA4\xEE\xD8\x8F\xB8\x21\xE4\x11\x03\xFB"
		"\x30\xAD\xE6\x0D\xA3\x11\xA7\xAA\xFC\xD5\xBB\xCD\x73\x21\x17\x65\x9B\x9F\xAC\x9C"
		"\x7E\x00\x45\x4A\x71\x0C\x69\x78\x07\x0D\x88\x3C\xEA\x68\x78\xA8\x07\x69\x2C\x05"
		"\xC8\x65\x1F\x8D\xA0\x28\x90\xFF\xDB\x26\x8F\x93\xCE\xB9\x1E\xB1\x89\x5A\xD9\x68"
		"\x01\xEA\x5B\x69\x15\x44\xFC\x14\x92\x8C\xD8\xAF\x39\xCC\x31\x55\x34\xA3\xFB\x82"
		"\x22\x12\x95\x0D\x0D\x20\xA0\xD6\x8C\x6A\xF3\xEC\x88\x6D\xFB\x83\x79\x58\x3C\xFE"
		"\x82\x92\xCE\x6B\xC5\x0D\xD5\x38\xAF\xC5\x66\xBA\x9A\xE0\xA4\x07\x41\x71\xF7\x46"
		"\xE8\xE6\xDB\x84\xE8\xA8\xF7\x34\x2D\xD1\xEF\xB2\x50\x31\xB5\xAD\xC2\x1C\xE7\x96"
		"\x05\x5E\x22\x7B\xF9\x36\xC3\x27\x04\xD7\xF5\x51\x3F\xD9\xBD\xFE\xF4\x67\x65\x95"
		"\x34\xF7\x73\xE0\xFC\x78\x02\x9B\x76\x1A\x9F\x06\x93\xEB\x6F\x13\x9D\x4E\xB6\x1B"
		"\x62\xCC\x17\x12\x22\x5B\x05\xD1\xFD\x8B\x59\xD8\x69\x0E\x26\xB3\x86\x38\x6D\x1A"
		"\x7F\x59\x33\xF3\x76\x8C\xE6\xDB\x7F\x44\x27\x07\xF0\x5B\x61\x89\xF0\xA7\x0F\xB3"
		"\xF6\x17\x08\x7E\xEC\x2F\xC4\xBF\x65\x57\x51\xA4\x14\x3B\xEA\x57\xC6\xBA\xA6\x51"
		"\xA2\x35\x86\x42\xA6\x75\xC8\x3C\x24\x48\x8B\x3E\xAB\x55\x3D\xF1\x46\xAB\xF0\xCA"
		"\x3C\xBF\x26\x38\x1A\x3E\x14\x59\xE3\xCA\x0A\x65\xE7\x32\x7C\xBE\x18\x7D\xCD\xFB"
		"\x09\x4F\x2C\x21\x51\x18\x09\xF6\xD4\x00\xC0\x69\x05\x48\x88\xAD\x8A\x59\x67\x0F"
		"\x95\xAD\xF5\xE4\x66\xA3\x16\x90\x72\x40\xD1\xDA\x82\x1C\x32\x4F\xBE\x30\xAE\xCC"
		"\xC2\xB3\xB9\xA1\xC9\x68\xDD\x7D\x21\xAB\x62\xE6\x53\xC6\x3B\xD4\x27\x8A\x6B\x3C"
		"\x93\x14\x11\x69\xBA\x53\xE4\x81\x91\x51\x3D\xA1\x6F\x51\x79\xCA\x0E\x10\x22\x38"
		"\x4F\x4C\x6F\x1B\x7B\x80\xA2\xD8\x2A\x41\x87\x0E\x43\xE9\x9B\xB8\x1A\xF0\xD7\x29"
		"\x24\xD3\x73\x0A\x4C\xBF\x6B\xAB\x88\x12\xCC\x8A\x98\x69\x97\xF8\x6F\xB6\xA2\x0E"
		"\xE6\x6B\x38\x31\x65\x30\xD4\xD9\x3C\x56\x21\x42\x5D\x8A\x57\xF9\xB9\xCB\xA9\x32"
		"\x52\xFF\x0B\xC1\x49\xDF\x52\xE7\x4E\x12\x7F\xA0\x40\xB9\x4A\x03\xD7\x0F\x2D\x92"
		"\x70\x9A\xB7\xDE\xCF\x50\xBF\x6A\xE8\x06\xAB\x05\x7C\x2B\xFD\xD3\xCE\xCB\x29\x36"
		"\x7E\x09\xCC\x49\xB9\x78\xB7\xF0\x33\x87\x60\x33\x31\x96\x0D\x6C\xEB\x78\x34\x1B"
		"\xE3\xF8\x20\xAD\xA7\x07\x74\xCC\xD3\x8E\xD9\xCD\x9E\x87\x39\xE7\x76\x3D\x90\xF9"
		"\x20\x0D\x3B\x3A\x26\x4A\xBB\x55\x38\x59\xB8\x47\x27\x76\x0F\x4D\xD9\x2D\xD3\xB5"
		"\xE9\xAE\x6B\xCB\x2C\xCA\x65\x8B\xFD\x78" 
           , 616);
    nSKLen = 616;
    memcpy(bInData,
		"\x40\xBB\x6E\xD6\x00\xF5\xC9\x8B\x88\xBF"
		"\x02\xD1\x9B\xAB\x4E\x9C\x58\xA2\x0C\x0D\xB0\x81\xA0\xFF\xFA\xF4\xA0\x7C\x41\x60"
		"\xC0\x90\x16\x5A\x2C\x39\x6C\x02\x45\xBD\x53\x57\x6E\xB6\x59\xB8\x1D\x1F\x0E\xCE"
		"\x09\x1D\x24\x08\x7B\xB2\x3D\xB4\xB8\x57\x3E\x7B\x11\x89\xFD\xC3\x70\x1B\x74\xC3"
		"\x70\xC7\x14\x9B\xC4\x1C\x0E\x79\xEA\xF9\x00\x9A\xD7\xEA\x47\xF5\xE4\x8A\xBC\xCA"
		"\xA3\x02\x9E\x11\x4F\x80\xC2\xF1\x63\xE8\x40\x9D\x06\xF2\x88\x0D\x31\x4D\xA0\x8D"
		"\x3D\x5B\xFB\x93\x93\x82\x12\x67\x85\xF2\x3B\xE8\xC8\xA0\x10\xFE\xA4\x33"
           , 128);
    nInDataLen = 128;

    memset(bOutDataExp, 0x42, 1);

    memcpy(bOutDataExp,
                "\x77\x77\x77\x77\x77\x77\x77\x77"
		"\x88\x88\x88\x88\x88\x88\x88\x88"
		"\x99\x99\x99\x99\x99\x99\x99\x99"
	
            ,24);
    
    nOutDataLenExp = 24;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nFlag = %d\n", nFlag);
    printf("[IN ]nPadMode = %d\n", nPadMode);
    DspHex("[IN ]bSK =", bSK, 616);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHex("[IN ]bInData =", bInData, 128);
    printf("[IN ]nInDataLen = %d\n", nInDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIPrivateCalc(nSock, nFlag, nPadMode, bSK, nSKLen, bInData, \
                           nInDataLen, bOutData, &nOutDataLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "RSA-2048，PKCS#1填充，解密，测试未成功");
    XXX_RESULT_XXX



    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData    =", bOutData, 24);
    DspHex("[OUT]bOutDataExp =", bOutDataExp, 24);
    ASSERT_OUT_HEX(bOutData, bOutDataExp, 24);
    ASSERT_OUT(nOutDataLen, nOutDataLenExp);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

void VerifyARQC_Test_00(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nIccType;
	  BYTE bKey[32];
	  BYTE bCardFactor[8];
	  BYTE bSessionFactor[8];
	  BYTE bData[38];
	  int  nDataLen;
	  BYTE bARQC[8];

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bData);
    bufclr(bARQC);

    nIccType = 0;
    memcpy(bKey,
           "\x1C\x26\x35\x8B\xBA\x4D\xBF\xBF\x19\xAB\xC1\xF6\xA0\xE1\x27\x8A"
           , 16);
    memcpy(bCardFactor,
           "\x48\x00\x18\x99\x00\x00\x17\x01"
           , 8);
    memcpy(bSessionFactor,
           "\x01\xC2"
           , 2);
    memcpy(bData,
           "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x56\x00\x00"
           "\x18\x00\x00\x01\x56\x12\x08\x13\x30\x00\x00\x00\x00\x7D\x00\x01"
           "\xC2\x99\xA0\xB8\x06"
           , 37);
    nDataLen = 37;
    memcpy(bARQC, 
           "\xE4\xC1\xB9\x62\xB9\x73\x6D\x0B"
           , 8);

   XXX_INPUT_XXX

    DspHex("[IN ]bKey           =", bKey, 16);

    DspHex("[IN ]bCardFactor    =", bCardFactor, 8);
    DspHex("[IN ]bSessionFactor =", bSessionFactor, 2);
    XXX_INPUT_XXX


    /* Call Test Target Function Start */
    nRet = SMAPIVerifyARQC(nSock, nIccType, bKey, bCardFactor, bSessionFactor, \
                    bData, nDataLen, bARQC);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "PBOC卡，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

//zhaomx   2017-2-23
void EncryptWithDerivedKey_Test1_02(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nType;
	  int  nIccType;
	  int  nMode;
	  BYTE bKey[32];
	  BYTE bCardFactor[8];
	  BYTE bSessionFactor[8];
	  BYTE bIV[8];
	  BYTE bInData[256];
	  int  nInLen;
	  BYTE bOutData[256];
	  int  nOutLen;

    bufclr(bKey);
    bufclr(bCardFactor);
    bufclr(bSessionFactor);
    bufclr(bIV);
    bufclr(bInData);
    bufclr(bOutData);

    nType = 0;
    nIccType = 0;
    nMode = 0;
    memcpy(bKey, "\x97\xC9\x08\xD8\x38\x0B\xDB\x78\x22\x75\x61\xF4\xF2\x7F\xAB\xB4", 16);
    memcpy(bCardFactor, "\x25\x00\x00\x00\x00\x00\x89\x01", 8);
    memcpy(bSessionFactor, "\x00\x02", 2);

    memcpy(bInData, "\xAE\xF3\xB9\x41\x5E\xD5\x97\xFC\x89\xA9\xEE\xE4\xD5\xD7\xE6\x5E",16);
    nInLen = 16;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEncryptWithDerivedKey(nSock, nType, nIccType, nMode, bKey, bCardFactor,
                               bSessionFactor, bIV, bInData, nInLen, bOutData, &nOutLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "PBOC卡，ECB解密，测试未成功");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    DspHex("[OUT]bOutData =", bOutData, 8);
    printf("[OUT]nOutLen  = %d\n", nOutLen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

//zhaomx    2017-04-12   
void EccSign_Test1_01(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

	  int  nEcMark;
	  int  nPad;
	  BYTE bPK[1280];
	  int  nPKLen;
	  BYTE bSK[540];
	  int  nSKLen;
	  BYTE bData[2048];
	  int  nDataLen;
	  BYTE bSign[512];
	  int  nSignLen;

    bufclr(bPK);
    bufclr(bSK);
    bufclr(bData);
    bufclr(bSign);

    nEcMark = 17;
    nPad = 0;
    /* PK 04695BC3452B4DF79EBA188AC61C51A33A243F497A4D76D272F3771827BD80A944E1DA925A4853860EE0D883F3A2F43AA8F265C95F60A9102A7495551034D6C021 */
    /* SK 7BAD1BC2D566F4AC0F93E830E2E9A1E756C063E94FBDEABF68A29DD720B44B30 */
    memcpy(bPK,
           "\x69\x5B\xC3\x45\x2B\x4D\xF7\x9E\xBA\x18\x8A\xC6\x1C\x51\xA3" \
           "\x3A\x24\x3F\x49\x7A\x4D\x76\xD2\x72\xF3\x77\x18\x27\xBD\x80\xA9" \
           "\x44\xE1\xDA\x92\x5A\x48\x53\x86\x0E\xE0\xD8\x83\xF3\xA2\xF4\x3A" \
           "\xA8\xF2\x65\xC9\x5F\x60\xA9\x10\x2A\x74\x95\x55\x10\x34\xD6\xC0" \
           "\x21" \
           , 64);
    nPKLen = 64;
    memcpy(bSK,
           "\xC3\xE0\x99\x39\x13\x86\x91\xAA\x60\x90\x31\xAA\xDA\x12\x31\x49"
           "\x5D\x23\xD8\x9A\xA3\x2D\x7B\x3E\x4C\x4D\x10\xD4\x63\x13\x08\xFD"
           , 32);
    nSKLen = 32;
    /* 0BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB9 */
    memset(bData, 0x42, 256);
    bData[0] = 0x30;
    bData[255] = 0x39;
    nDataLen = 256;

    XXX_INPUT_XXX
    printf("[IN ]nSock = %d\n", nSock);
    printf("[IN ]nEcMark = %d\n", nEcMark);
    printf("[IN ]nPad = %d\n", nPad);
    DspHexExt("[IN ]bPK =", bPK, nPKLen);
    printf("[IN ]nPKLen = %d\n", nPKLen);
    DspHexExt("[IN ]bSK =", bSK, nSKLen);
    printf("[IN ]nSKLen = %d\n", nSKLen);
    DspHexExt("[IN ]bData =", bData, 256);
    printf("[IN ]nDataLen = %d\n", nDataLen);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    nRet = SMAPIEccSign(nSock, nEcMark, nPad, bPK, nPKLen, bSK, nSKLen, bData, \
                           nDataLen, bSign, &nSignLen);
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "SM2签名，256字节数据，测试失败");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    printf("[VERIFY]请确认以下结果:\n");
    DspHexExt("[OUT]bSign    =", bSign, nSignLen);
    printf("[OUT]nSignLen = %d", nSignLen);
    XXX_OUTPUT_XXX

    XXX_TEST_END_XXX
}

//zhaomx  2017-06-05
void testOpenDevice()
{
	int nRet=-1;
	char szAddr[20];
	UINT nPort;

	/*begin open device and session*/

	strcpy(szAddr, "10.1.100.138");
	nPort = 8;

	fprintf(stderr, "SDF_OpenDevice szAddr :0x%s\n", szAddr);
	fprintf(stderr, "SDF_OpenDevice nPort :0x%d\n", nPort);
        printf("1111111111111111111111111 \n");
	nRet = SDF_OpenDevice((void **)&nDeviceHandle, szAddr, nPort);
	if (nRet)
	{
		fprintf(stderr, "SDF_OpenDevice error:0x%x\n", nRet);
		fflush(stderr);
	}
 

}

void testSDF_Encrypt2Decrypt()
{
	int nRet, uiAlgID, uiEncDataLength, puiDataLength, hKeyHandle=0;
	unsigned char pucKey[48], pucIV[16] = {0}, pucEncData[4096] = {0}, pucData[4096] = {0};

	/**/
	//uiAlgID = 0x90000001;//des,ecb
	//uiAlgID = 0x90000002;//des,cbc
	//uiAlgID = 0x00000401;//sm4.ecb
	uiAlgID = 0x00000402;//sm4.cbc
	str2hex("23232323232323234545454545454545", pucKey, 32);
	//str2hex("1000000000000002", pucIV, 16);
	str2hex("10000000000000021000000000000002", pucIV, 32);

	puiDataLength = 128;
	memset(pucData, 0x11, puiDataLength);
	pucData[0] = 0x22;
	pucData[127] = 0x33;

	//会话密钥
        printf("44444444444444444444444444444,%d\n",nHandle);
	nRet = SDF_ImportKey(nHandle, pucKey, 16, (void **)&hKeyHandle);
	if(nRet)
	{
		fprintf(stderr, "SDF_ImportKey error:0x%x\n", nRet);
		fflush(stderr);
		return;
	}
	//加密
	data_dump("SDF_Encrypt plain Data",pucData, puiDataLength);
	nRet = SDF_Encrypt(nHandle, hKeyHandle, uiAlgID, pucIV,pucData, puiDataLength, pucEncData, &uiEncDataLength);
	if(nRet)
	{
		fprintf(stderr, "SDF_Decrypt error:0x%x\n", nRet);
		fflush(stderr);
		return;
	}

	data_dump("SDF_Encrypt cipher Data",pucEncData, uiEncDataLength);
	memset(pucData, 0, sizeof(pucData));
	puiDataLength = 0;
	//解密
	nRet = SDF_Decrypt(nHandle, hKeyHandle, uiAlgID, pucIV, pucEncData, uiEncDataLength, pucData, &puiDataLength);
	if(nRet)
	{
		fprintf(stderr, "SDF_Decrypt error:0x%x\n", nRet);
		fflush(stderr);
		return;
	}

	data_dump("SDF_Decrypt plain Data",pucData, puiDataLength);

	//销毁句柄
	SDF_DestoryKey(nHandle, hKeyHandle);

	return ;
}


void TestFuncTemplate(void)
{
    XXX_TEST_START_XXX
    int  nRet;
    int  nSock = SM_SOCK;

/*▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼*/
    XXX_CASE_XXX(1)

    XXX_INPUT_XXX
    XXX_INPUT_NONE_XXX
    printf("[IN ]nSock = %d\n", nSock);
    XXX_INPUT_XXX

    /* Call Test Target Function Start */
    /* Call Test Target Function End */

    XXX_RESULT_XXX
    ASSERT_RESULT(nRet, 0, "");
    XXX_RESULT_XXX

    XXX_OUTPUT_XXX
    XXX_OUTPUT_NONE_XXX
    printf("[OUT]\n");
    XXX_OUTPUT_XXX
/*▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲*/

    XXX_TEST_END_XXX
}

/*
 *  <<LEVEL Premise>>
 */
TESTFUNC TestFunc_P[] =
{
    ConnectSM_Test_01,
    ConnectSM_Test_02,
    ConnectSM_Test_03,
    ConnectSM_Test_04,
    ConnectSM_Test_05,
    ConnectSM_Test_06,
    DisconnectSM_Test_02,
    DisconnectSM_Test_03,
    DisconnectSM_Test_01,
    NULL
};

/*
 *  <<LEVEL Basic>>
 */
TESTFUNC TestFunc_B[] =
{
    ConnectSM_Test_01,
/*
    EncryptPinX98A_Test_03,
    EncryptPinX98B_Test_03,
    DecryptPinX98A_Test_03,
    DecryptPinX98B_Test_03,
    CalcMAC_Test_01,
    CalcMAC_Test_02,
    CalcMAC_Test_03,
    TranslateBlock_Test_01,
    TranslateBlock_Test_02,
    TranslateBlock_Test_03,
    TranslateKeyOutOf_Test_01,
    TranslateKeyOutOf_Test_02,
    TranslateKeyOutOf_Test_03,
    TranslateKeyOutOf_Test_04,
    TranslateKeyOutOf_Test_05,
    TranslateKeyOutOf_Test_06,
    TranslateKeyInTo_Test_01,
    TranslateKeyInTo_Test_02,
    TranslateKeyInTo_Test_03,
    TranslateKeyInTo_Test_04,
    TranslateKeyInTo_Test_05,
    TranslateKeyInTo_Test_06,
*/
/*
    GenerateKey_Test_01,
    GenerateKey_Test_02,
    GenerateKey_Test_03,
*/
    HideBlock_Test_01,
    HideBlock_Test_02,

    RevealBlock_Test_01,
    RevealBlock_Test_02,
/*
    EncryptKey_Test_01,
    EncryptKey_Test_02,
    EncryptKey_Test_03,
    EncryptBlock_Test_01,
    EncryptBlock_Test_02,
    EncryptBlock_Test_03,


    DecryptBlock_Test_01,
    DecryptBlock_Test_02,
    DecryptBlock_Test_03,
    EncryptCBC_Test_01,
    EncryptCBC_Test_02,
    EncryptCBC_Test_03,
    EncryptCBC_Test_16,
    EncryptCBC_Test_17,
    EncryptCBC_Test_18,
    DecryptCBC_Test_01,
    DecryptCBC_Test_02,
    DecryptCBC_Test_03,
    DecryptCBC_Test_16,
    DecryptCBC_Test_17,
    DecryptCBC_Test_18,


    CalCVV_Test_01,
    CalCVV_Test_02,
    CalPVV_Test_01,
    CalPVV_Test_02,
    IBM3624_Test_01,
    IBM3624_Test_02,
    GenRandDigits_Test_02,
    GenRandDigits_Test_03,
    GenRandDigits_Test_04,
    GenRandDigits_Test_05,
    GenRandDigits_Test_06,
    GenRandDigits_Test_07,
    GenRandDigits_Test_08,
    VerifyCheckValue_Test_01,
    VerifyCheckValue_Test_02,
    VerifyCheckValue_Test_03,
    GetHsmStatus_Test_01,

    GenRsaKey_Test_01,
    GenRsaKey_Test_02,
    GenRsaKey_Test_03,
    GenRsaKey_Test_04,
    GenRsaKey_Test_05,
    GenRsaKey_Test_06,


    Digest_Test_01,
    Digest_Test_02,
    Digest_Test_03,
    Digest_Test_04,
    Digest_Test_05,
    Digest_Test_06,
    Digest_Test_19,


    PublicCalc_Test_01,
    PublicCalc_Test_02,
    PublicCalc_Test_03,
    PublicCalc_Test_04,
    PublicCalc_Test_05,
    PublicCalc_Test_06,
    PublicCalc_Test_07,
    PublicCalc_Test_08,
    PublicCalc_Test_09,
    PublicCalc_Test_10,
    PublicCalc_Test_11,
    PublicCalc_Test_12,
    PublicCalc_Test_13,
    PublicCalc_Test_14,
    PublicCalc_Test_15,
    PublicCalc_Test_16,
    PublicCalc_Test_17,
    PublicCalc_Test_18,
    PublicCalc_Test_19,
    PublicCalc_Test_20,
    PublicCalc_Test_21,
    PublicCalc_Test_22,
    PublicCalc_Test_23,
    PublicCalc_Test_24,
    PublicCalc_Test_25,
    PublicCalc_Test_26,
    PublicCalc_Test_27,
    PublicCalc_Test_28,
    PublicCalc_Test_29,
    PublicCalc_Test_30,


    PrivateCalc_Test_01,
    PrivateCalc_Test_02,
    PrivateCalc_Test_03,
    PrivateCalc_Test_04,
    PrivateCalc_Test_05,
    PrivateCalc_Test_06,
    PrivateCalc_Test_07,
    PrivateCalc_Test_08,
    PrivateCalc_Test_09,
    PrivateCalc_Test_10,
    PrivateCalc_Test_11,
    PrivateCalc_Test_12,
    PrivateCalc_Test_13,
    PrivateCalc_Test_14,
    PrivateCalc_Test_15,
    PrivateCalc_Test_16,
    PrivateCalc_Test_17,
    PrivateCalc_Test_18,
    PrivateCalc_Test_19,
    PrivateCalc_Test_20,
    PrivateCalc_Test_21,
    PrivateCalc_Test_22,
    PrivateCalc_Test_23,
    PrivateCalc_Test_24,
    PrivateCalc_Test_25,
    PrivateCalc_Test_26,
    PrivateCalc_Test_27,
    PrivateCalc_Test_28,
    PrivateCalc_Test_29,
    PrivateCalc_Test_30,
*/
/*
    PrivateSign_Test_01,
    PrivateSign_Test_02,
    PrivateSign_Test_03,
    PrivateSign_Test_04,
    PrivateSign_Test_05,
    PrivateSign_Test_07,
    PrivateSign_Test_08,
    PrivateSign_Test_09,
    PrivateSign_Test_10,
    PrivateSign_Test_11,
    PrivateSign_Test_12,
    PrivateSign_Test_13,
    PrivateSign_Test_14,
    PrivateSign_Test_15,
    PrivateSign_Test_16,
    PrivateSign_Test_17,
    PrivateSign_Test_18,
    PrivateSign_Test_19,
    PrivateSign_Test_20,
    PrivateSign_Test_21,
    PrivateSign_Test_22,
    PrivateSign_Test_23,
    PrivateSign_Test_24,
    PrivateSign_Test_25,
    PrivateSign_Test_26,
    PrivateSign_Test_27,
    PrivateSign_Test_28,
    PrivateSign_Test_29,
    PrivateSign_Test_30,
    PrivateSign_Test_31,
    PrivateSign_Test_32,
    PrivateSign_Test_33,
    PrivateSign_Test_34,
    PrivateSign_Test_35,
    PrivateSign_Test_36,
*/
/*
    VerifySign_Test_01,
    VerifySign_Test_02,
    VerifySign_Test_03,
    VerifySign_Test_04,
    VerifySign_Test_05,
    VerifySign_Test_07,
    VerifySign_Test_08,
    VerifySign_Test_09,
    VerifySign_Test_10,
    VerifySign_Test_11,
    VerifySign_Test_12,
    VerifySign_Test_13,
    VerifySign_Test_14,
    VerifySign_Test_15,
    VerifySign_Test_16,
    VerifySign_Test_17,
    VerifySign_Test_18,
    VerifySign_Test_19,
    VerifySign_Test_20,
    VerifySign_Test_21,
    VerifySign_Test_22,
    VerifySign_Test_23,
    VerifySign_Test_24,
    VerifySign_Test_25,
    VerifySign_Test_26,
    VerifySign_Test_27,
    VerifySign_Test_28,
    VerifySign_Test_29,
    VerifySign_Test_30,
    VerifySign_Test_31,
    VerifySign_Test_32,
    VerifySign_Test_33,
    VerifySign_Test_34,
    VerifySign_Test_35,
    VerifySign_Test_36,
*/
/*
    TransKeyOutofPK_Test_01,
    TransKeyOutofPK_Test_02,
    TransKeyOutofPK_Test_03,
    TransKeyOutofPK_Test_04,
    TransKeyOutofPK_Test_05,
    TransKeyOutofPK_Test_06,
    TransKeyOutofPK_Test_07,
    TransKeyOutofPK_Test_08,
    TransKeyOutofPK_Test_09,
    TransKeyOutofPK_Test_10,
    TransKeyOutofPK_Test_11,
    TransKeyOutofPK_Test_12,
    TransKeyOutofPK_Test_13,
    TransKeyOutofPK_Test_14,
    TransKeyOutofPK_Test_15,
    TransKeyOutofPK_Test_16,
    TransKeyOutofPK_Test_17,
    TransKeyOutofPK_Test_18,
    TransKeyOutofPK_Test_19,
    TransKeyOutofPK_Test_20,
    TransKeyOutofPK_Test_21,
    TransKeyOutofPK_Test_22,
    TransKeyOutofPK_Test_23,
    TransKeyOutofPK_Test_24,
    TransKeyOutofPK_Test_25,
    TransKeyOutofPK_Test_26,
    TransKeyOutofPK_Test_27,
    TransKeyOutofPK_Test_28,
    TransKeyOutofPK_Test_29,
    TransKeyOutofPK_Test_30,
    TransKeyOutofPK_Test_31,
    TransKeyOutofPK_Test_32,
    TransKeyOutofPK_Test_33,
    TransKeyOutofPK_Test_34,
    TransKeyOutofPK_Test_35,
    TransKeyOutofPK_Test_36,
    TransKeyOutofPK_Test_38,
    TransKeyOutofPK_Test_39,
    TransKeyOutofPK_Test_40,
    TransKeyOutofPK_Test_41,
    TransKeyOutofPK_Test_42,
*/
/*
    PrivateAnalyse_Test_01,
    PrivateAnalyse_Test_02,
    PrivateAnalyse_Test_03,
    PrivateAnalyse_Test_04,
    PrivateAnalyse_Test_05,
    PrivateAnalyse_Test_06,
    PrivateAnalyse_Test_07,
    PrivateAnalyse_Test_08,
    PrivateAnalyse_Test_09,
    PrivateAnalyse_Test_10,
    PrivateAnalyse_Test_11,
    PrivateAnalyse_Test_12,
    PrivateAnalyse_Test_13,
    PrivateAnalyse_Test_14,
    PrivateAnalyse_Test_15,
    PrivateAnalyse_Test_16,
    PrivateAnalyse_Test_17,
    PrivateAnalyse_Test_18,
*/
    DisconnectSM_Test_01,
    NULL
};

/*
 *  <<LEVEL G>>
 */
TESTFUNC TestFunc_G[] =
{
    ConnectSM_Test_01,
/*
    EncryptPinX98A_Test_01,
    EncryptPinX98A_Test_02,
    EncryptPinX98A_Test_04,
    EncryptPinX98A_Test_05,
    EncryptPinX98A_Test_06,
    EncryptPinX98A_Test_07,
    EncryptPinX98A_Test_08,
    EncryptPinX98A_Test_09,
    EncryptPinX98A_Test_12,
    EncryptPinX98A_Test_13,

    EncryptPinX98B_Test_01,
    EncryptPinX98B_Test_02,
    EncryptPinX98B_Test_04,
    EncryptPinX98B_Test_05,
    EncryptPinX98B_Test_06,
    EncryptPinX98B_Test_07,
    EncryptPinX98B_Test_08,
    EncryptPinX98B_Test_09,
    EncryptPinX98B_Test_12,
    EncryptPinX98B_Test_13,
    EncryptPinX98B_Test_18,
    EncryptPinX98B_Test_19,
    EncryptPinX98B_Test_20,
    EncryptPinX98B_Test_21,
    EncryptPinX98B_Test_22,
    EncryptPinX98B_Test_23,

    DecryptPinX98A_Test_01,
    DecryptPinX98A_Test_02,
    DecryptPinX98A_Test_04,
    DecryptPinX98A_Test_05,
    DecryptPinX98A_Test_06,
    DecryptPinX98A_Test_07,
    DecryptPinX98A_Test_08,
    DecryptPinX98A_Test_09,
    DecryptPinX98A_Test_12,
    DecryptPinX98A_Test_13,

    DecryptPinX98B_Test_01,
    DecryptPinX98B_Test_02,
    DecryptPinX98B_Test_04,
    DecryptPinX98B_Test_05,
    DecryptPinX98B_Test_06,
    DecryptPinX98B_Test_07,
    DecryptPinX98B_Test_08,
    DecryptPinX98B_Test_09,
    DecryptPinX98B_Test_12,
    DecryptPinX98B_Test_13,
    DecryptPinX98B_Test_18,
    DecryptPinX98B_Test_19,
    DecryptPinX98B_Test_20,
    DecryptPinX98B_Test_21,
    DecryptPinX98B_Test_22,
    DecryptPinX98B_Test_23,

    CalcMAC_Test_04,
    CalcMAC_Test_05,
    CalcMAC_Test_06,
    CalcMAC_Test_13,
    CalcMAC_Test_14,
    CalcMAC_Test_15,
    CalcMAC_Test_16,
    CalcMAC_Test_21,
    CalcMAC_Test_22,

    TranslateBlock_Test_04,
    TranslateBlock_Test_05,
    TranslateBlock_Test_06,
    TranslateBlock_Test_07,
    TranslateBlock_Test_08,
    TranslateBlock_Test_09,
    TranslateBlock_Test_16,
    TranslateBlock_Test_17,
    TranslateBlock_Test_18,
    TranslateBlock_Test_19,
    TranslateBlock_Test_20,

    TranslateKeyOutOf_Test_07,
    TranslateKeyOutOf_Test_08,
    TranslateKeyOutOf_Test_09,
    TranslateKeyOutOf_Test_14,
    TranslateKeyOutOf_Test_15,
    TranslateKeyOutOf_Test_16,
    TranslateKeyOutOf_Test_17,

    TranslateKeyInTo_Test_07,
    TranslateKeyInTo_Test_08,
    TranslateKeyInTo_Test_09,
    TranslateKeyInTo_Test_14,
    TranslateKeyInTo_Test_15,
    TranslateKeyInTo_Test_16,
    TranslateKeyInTo_Test_17,
    TranslateKeyInTo_Test_18,
    TranslateKeyInTo_Test_19,

    EncryptKey_Test_04,
    EncryptKey_Test_05,

    EncryptBlock_Test_04,
    EncryptBlock_Test_05,
    EncryptBlock_Test_06,
    EncryptBlock_Test_07,

    DecryptBlock_Test_04,
    DecryptBlock_Test_05,
    DecryptBlock_Test_06,
    DecryptBlock_Test_07,

    EncryptCBC_Test_04,
    EncryptCBC_Test_05,
    EncryptCBC_Test_06,
    EncryptCBC_Test_07,

    DecryptCBC_Test_04,
    DecryptCBC_Test_05,
    DecryptCBC_Test_06,
    DecryptCBC_Test_07,

    CalCVV_Test_03,
    CalCVV_Test_04,
    CalCVV_Test_10,
    CalCVV_Test_11,
    CalCVV_Test_16,
    CalCVV_Test_17,
    CalCVV_Test_19,
    CalCVV_Test_20,

    CalPVV_Test_03,
    CalPVV_Test_04,
    CalPVV_Test_14,
    CalPVV_Test_15,
    CalPVV_Test_16,
    CalPVV_Test_17,
    CalPVV_Test_18,
    CalPVV_Test_19,
    CalPVV_Test_20,
    CalPVV_Test_21,
    CalPVV_Test_22,
    CalPVV_Test_23,
    CalPVV_Test_24,
    CalPVV_Test_25,

    IBM3624_Test_03,
    IBM3624_Test_04,
    IBM3624_Test_14,
    IBM3624_Test_15,
    IBM3624_Test_16,
    IBM3624_Test_17,
    IBM3624_Test_18,
    IBM3624_Test_19,
    IBM3624_Test_20,

    GenRandDigits_Test_09,
    GenRandDigits_Test_10,
    GenRandDigits_Test_11,
    GenRandDigits_Test_12,

    VerifyCheckValue_Test_04,
    VerifyCheckValue_Test_05,

*/
    Digest_Test_12,
    Digest_Test_14,
    Digest_Test_15,
    Digest_Test_16,
    Digest_Test_17,
    Digest_Test_18,
    Digest_Test_20,

    DisconnectSM_Test_01,
    NULL
};

/*
 *  <<LEVEL KEY MNG IF>>
 *  江南科友
 */
TESTFUNC TestFunc_K[] =
{
    ConnectSM_Test_01,
/*
    //5.1 产生RSA 公私钥对（7.5.1 产生RSA 密钥对）  
    GenRsaKey_Test_00,     //true
    GenRsaKey_Test_01,     //RSA  512  true
    GenRsaKey_Test_02,     //true
    GenRsaKey_Test_03,     //true
    GenRsaKey_Test_04,     //true
    GenRsaKey_Test_05,     //true
    GenRsaKey_Test_06,     //true

    GenRsaKey_Test_07,    
    GenRsaKey_Test_08,    
    GenRsaKey_Test_09,    

    GenRsaKey_Test_10,    

    GenRsaKey_Test_11,    

    GenRsaKey_Test_12,    

    GenRsaKey_Test_13,    
    GenRsaKey_Test_14,    
  */ 

    //5.2 产生随机应用主密钥（7.2.1 产生密钥）     
  /*
    GenMasterKey_Test_01,
    GenMasterKey_Test_02,
    GenMasterKey_Test_03,
  */
    //5.3 导出应用主密钥（7.2.5 HMK 加密密钥）  
 /*
    ExportMasterKey_Test_01,
 
    ExportMasterKey_Test_02,
    ExportMasterKey_Test_03,
 */ 
    //5.4 计算信息摘要（7.4.7 产生消息摘要） zhaomx   2017-4-19    passed
/*
    Digest_Test_01,    //true

    Digest_Test_02,    //true
    Digest_Test_03,    //true
    Digest_Test_04,    //true
    Digest_Test_05,    //true
    Digest_Test_06,    //true
    Digest_Test_07,    //true
    Digest_Test_08,    //true
    Digest_Test_09,    //true

    Digest_Test_10,    //true
    Digest_Test_11,    //true
    Digest_Test_12,    //true
    Digest_Test_13,    //true
    Digest_Test_14,    //true
    Digest_Test_15,    //true
    Digest_Test_16,    //true
    Digest_Test_17,    //true
    Digest_Test_18,    //true
    Digest_Test_19,    //true
    Digest_Test_20,    //true
*/
 
    //5.5 公钥加解密（7.5.4 RSA 公钥运算） zhaomx   2017-4-12    passed
/*
    PublicCalc_Test_01,        //RSA-512   无填充，加密  true
    PublicCalc_Test_02,        //RSA-1024，无填充，加密  true
    PublicCalc_Test_03,        //RSA-1152，无填充，加密  true 
    PublicCalc_Test_04,        //RSA-1408，无填充，加密  true
    PublicCalc_Test_05,        //RSA-1984，无填充，加密  true
    PublicCalc_Test_06,        //RSA-2048，无填充，加密  true
    PublicCalc_Test_07,        //RSA-512， 无填充，解密  false
    PublicCalc_Test_08,        //RSA-1024，无填充，解密  true
    PublicCalc_Test_09,        //RSA-1152，无填充，解密  true
    PublicCalc_Test_10,        //RSA-1408，无填充，解密  true
    PublicCalc_Test_11,        //RSA-1984，无填充，解密  true
    PublicCalc_Test_12,        //RSA-2048，无填充，解密  true
    PublicCalc_Test_13,        //RSA-512，PKCS#1填充，加密   true
    PublicCalc_Test_14,        //RSA-1024，PKCS#1填充，加密  true
    PublicCalc_Test_15,        //RSA-1152，PKCS#1填充，加密  true
    PublicCalc_Test_16,        //RSA-1408，PKCS#1填充，加密  true
    PublicCalc_Test_17,        //RSA-1984，PKCS#1填充，加密  true
    PublicCalc_Test_18,        //RSA-2048，PKCS#1填充，加密  true
    PublicCalc_Test_19,        //RSA-512， PKCS#1填充，解密  true
    PublicCalc_Test_20,        //RSA-1024，PKCS#1填充，解密  true 
  
    PublicCalc_Test_21,        //RSA-1152，PKCS#1填充，解密  true 
    PublicCalc_Test_22,        //RSA-1408，PKCS#1填充，解密  true
    PublicCalc_Test_23,        //RSA-1984，PKCS#1填充，解密  true   
    PublicCalc_Test_24,        //RSA-2048，PKCS#1填充，解密  true
    PublicCalc_Test_25,        //RSA-512， OAEP填充，加密 true
    PublicCalc_Test_26,        //RSA-1024，OAEP填充，加密 true
    PublicCalc_Test_27,        //RSA-1152，OAEP填充，加密 true
    PublicCalc_Test_28,        //RSA-1408，OAEP填充，加密 true
    PublicCalc_Test_29,        //RSA-1984，OAEP填充，加密 true 
    PublicCalc_Test_30,        //RSA-2048，OAEP填充，加密 true  
*/
    //5.6 私钥加解密（7.5.5 RSA 私钥运算）  zhaomx   2017-4-12    passed
/*
    PrivateCalc_Test_01,         //RSA-512， 无填充，加密，true

    PrivateCalc_Test_02,         //RSA-1024，无填充，加密  true 
    PrivateCalc_Test_03,         //RSA-1152，无填充，加密  true
    PrivateCalc_Test_04,         //RSA-1408，无填充，加密  true 
    PrivateCalc_Test_05,         //RSA-1984，无填充，加密  true
    PrivateCalc_Test_06,         //RSA-2048，无填充，加密  true

    PrivateCalc_Test_07,         //RSA-512， 无填充，解密，true
    PrivateCalc_Test_08,         //RSA-1024，无填充，解密  true
    PrivateCalc_Test_09,         //RSA-1152，无填充，解密  true
    PrivateCalc_Test_10,         //RSA-1408，无填充，解密  true
    PrivateCalc_Test_11,         //RSA-1984，无填充，解密  true
    PrivateCalc_Test_12,         //RSA-2048，无填充，解密  true 
  
    PrivateCalc_Test_13,         //RSA-512，PKCS#1填充，加密，true
    PrivateCalc_Test_14,         //RSA-1024，PKCS#1填充，加密 true
    PrivateCalc_Test_15,         //RSA-1152，PKCS#1填充，加密 true
    PrivateCalc_Test_16,         //RSA-1408，PKCS#1填充，加密 true
    PrivateCalc_Test_17,         //RSA-1984，PKCS#1填充，加密 true 
    PrivateCalc_Test_18,         //RSA-2048，PKCS#1填充，加密 true

    PrivateCalc_Test_19,         //RSA-512， PKCS#1填充，解密，true
    PrivateCalc_Test_20,         //RSA-1024， PKCS#1填充，解密 true
    PrivateCalc_Test_21,         //RSA-1408， PKCS#1填充，解密 true
    PrivateCalc_Test_22,         //RSA-1984， PKCS#1填充，解密 true
    PrivateCalc_Test_23,         //RSA-2044， PKCS#1填充，解密 true   
    PrivateCalc_Test_24,         //RSA-2044， PKCS#1填充，解密 true


    PrivateCalc_Test_25,         //RSA-512，OAEP填充，解密， true  
    PrivateCalc_Test_26,         //RSA-1024，OAEP填充，解密  true
    PrivateCalc_Test_27,         //RSA-1152，OAEP填充，解密  true 
    PrivateCalc_Test_28,         //RSA-1408，OAEP填充，解密  true
    PrivateCalc_Test_29,         //RSA-1984，OAEP填充，解密  true  
    PrivateCalc_Test_30,         //RSA-2048，OAEP填充，解密  true
*/
    // 5.7 私钥签名（7.5.2 RSA 签名）   zhaomx  20170421   passed

    PrivateSign_Test_01,     //RSA-512，MD5，PKCS#1填充         true
    PrivateSign_Test_02,     //RSA-512，SHA-1，PKCS#1填充       true
/*
    PrivateSign_Test_03,     //RSA-512，SHA-224，PKCS#1填充     true

    PrivateSign_Test_04,     //RSA-512，SHA-256，PKCS#1填充     true
    PrivateSign_Test_05,     //RSA-512，SHA-384，PKCS#1填充     true


    PrivateSign_Test_06,     //RSA-512，SHA-512，PKCS#1填充     true

    PrivateSign_Test_07,     //RSA-1024，MD5，PKCS#1填充        true

    PrivateSign_Test_08,     //RSA-1024，SHA-1，PKCS#1填充      true

    PrivateSign_Test_09,     //RSA-1024，SHA-224，PKCS#1填充    true
 
    PrivateSign_Test_10,     //RSA-1024，SHA-256，PKCS#1填充    true
    PrivateSign_Test_11,     //RSA-1024，SHA-384，PKCS#1填充    true
    PrivateSign_Test_12,     //RSA-1024，SHA-512，PKCS#1填充    true


    PrivateSign_Test_13,     //RSA-1152，MD5，PKCS#1填充        true
    PrivateSign_Test_14,     //RSA-1152，SHA-1，PKCS#1填充      true
    PrivateSign_Test_15,     //RSA-1152，SHA-224，PKCS#1填充    true
    PrivateSign_Test_16,     //RSA-1152，SHA-256，PKCS#1填充    true
    PrivateSign_Test_17,     //RSA-1152，SHA-384，PKCS#1填充    true
    PrivateSign_Test_18,     //RSA-1152，SHA-512，PKCS#1填充    true
    PrivateSign_Test_19,     //RSA-1408，MD5，PKCS#1填充        true
    PrivateSign_Test_20,     //RSA-1408，SHA-1，PKCS#1填充      true
    PrivateSign_Test_21,     //RSA-1408，SHA-224，PKCS#1填充    true   
    PrivateSign_Test_22,     //RSA-1408，SHA-256，PKCS#1填充    true
    PrivateSign_Test_23,     //RSA-1408，SHA-384，PKCS#1填充    true
   
    PrivateSign_Test_24,     //RSA-1408，SHA-512，PKCS#1填充    true 
   
    PrivateSign_Test_25,     //RSA-1984，MD5，PKCS#1填充        true
    PrivateSign_Test_26,     //RSA-1984，SHA-1，PKCS#1填充      true
    PrivateSign_Test_27,     //RSA-1984，SHA-224，PKCS#1填充    true
    PrivateSign_Test_28,     //RSA-1984，SHA-256，PKCS#1填充    true
    PrivateSign_Test_29,     //RSA-1984，SHA-384，PKCS#1填充    true
    PrivateSign_Test_30,     //RSA-1984，SHA-512，PKCS#1填充    true
    PrivateSign_Test_31,     //RSA-2048，MD5，PKCS#1填充        true
    PrivateSign_Test_32,     //RSA-2048，SHA-1，PKCS#1填充      true
    PrivateSign_Test_33,     //RSA-2048，SHA-224，PKCS#1填充    true 
    PrivateSign_Test_34,     //RSA-2048，SHA-256，PKCS#1填充    true
    PrivateSign_Test_35,     //RSA-2048，SHA-384，PKCS#1填充    true
    PrivateSign_Test_36,     //RSA-2048，SHA-512，PKCS#1填充    true
*/
    //5.8  签名验证（7.5.3 RSA 验签） zhaomx  20170421   passed

    VerifySign_Test_01,     //RSA-512，MD5，PKCS#1填充，true
 
    VerifySign_Test_02,     //RSA-512，SHA-1，PKCS#1填充，true
/*
    VerifySign_Test_03,     //RSA-512，SHA-224，PKCS#1填充，true 

    VerifySign_Test_04,     //RSA-512，SHA-256，PKCS#1填充，true

    VerifySign_Test_05,     //RSA-512，SHA-384，PKCS#1填充，true
    VerifySign_Test_06,
    VerifySign_Test_07,     //RSA-1024，MD5，PKCS#1填充 true
    VerifySign_Test_08,     //RSA-1024，SHA-1，PKCS#1填充 true
    VerifySign_Test_09,     //RSA-1024，SHA-224，PKCS#1填充 true
    VerifySign_Test_10,     //RSA-1024，SHA-256，PKCS#1填充 true 
    VerifySign_Test_11,     //RSA-1024，SHA-384，PKCS#1填充 true
    VerifySign_Test_12,     //RSA-1024，SHA-512，PKCS#1填充，true
    VerifySign_Test_13,    //RSA-1152，MD5，PKCS#1填充 true
    VerifySign_Test_14,      //RSA-1152，SHA-1，PKCS#1填充 true  
    VerifySign_Test_15,      //RSA-1152，SHA-224，PKCS#1填充 true
    VerifySign_Test_16,      //RSA-1152，SHA-256，PKCS#1填充 true
    VerifySign_Test_17,     //RSA-1152，SHA-384，PKCS#1填充 true
    VerifySign_Test_18,     //RSA-1152，SHA-512，PKCS#1填充，true
    VerifySign_Test_19,       //RSA-1408，MD5，PKCS#1填充 true
    VerifySign_Test_20,      //RSA-1408，SHA-1，PKCS#1填充 true    
    VerifySign_Test_21,      //RSA-1408，SHA-224，PKCS#1填充 true  
    VerifySign_Test_22,      //RSA-1408，SHA-256，PKCS#1填充 true  
    VerifySign_Test_23,      //RSA-1408，SHA-384，PKCS#1填充 true   
    VerifySign_Test_24,      //RSA-1408，SHA-512，PKCS#1填充，true
    VerifySign_Test_25,      //RSA-1984，MD5，PKCS#1填充  true
    VerifySign_Test_26,      //RSA-1984，SHA-1，PKCS#1填充  true
    VerifySign_Test_27,      //RSA-1984，SHA-224，PKCS#1填充  true
    VerifySign_Test_28,      //RSA-1984，SHA-256，PKCS#1填充  true
    VerifySign_Test_29,      //RSA-1984，SHA-384，PKCS#1填充  true 
    VerifySign_Test_30,      //RSA-1984，SHA-512，PKCS#1填充，true
    VerifySign_Test_31,      //RSA-2048，MD5，PKCS#1填充，true
    VerifySign_Test_32,      //RSA-2048，SHA-1，PKCS#1填充，true
    VerifySign_Test_33,      //RSA-2048，SHA-224，PKCS#1填充，true
    VerifySign_Test_34,      //RSA-2048，SHA-256，PKCS#1填充，true 
    VerifySign_Test_35,      //RSA-2048，SHA-384，PKCS#1填充，true  
    VerifySign_Test_36,      //RSA-2048，SHA-512，PKCS#1填充，true
*/

    //5.9   RSA 公钥转加密（7.6.17 RSA 公私钥转加密）   (UE) zhaomx  20170424   passed
/*
    TransKeyOutofPK_Test_01,      //RSA-512  无填充  true

    TransKeyOutofPK_Test_02,      //true
    TransKeyOutofPK_Test_03,      //true 

    TransKeyOutofPK_Test_04,      //true 
    TransKeyOutofPK_Test_05,      //true
    TransKeyOutofPK_Test_06,      //true 
    TransKeyOutofPK_Test_07,      //RSA-512，PKCS#1填充，单倍长密钥，true
    TransKeyOutofPK_Test_08,      //true
    TransKeyOutofPK_Test_09,      //true
    TransKeyOutofPK_Test_10,      //true
    TransKeyOutofPK_Test_11,      //true
    TransKeyOutofPK_Test_12,      //true
    TransKeyOutofPK_Test_13,      //RSA-512，OAEP填充，单倍长密钥，true
    TransKeyOutofPK_Test_14,      //true
    TransKeyOutofPK_Test_15,      //true 
    TransKeyOutofPK_Test_16,      //true
    TransKeyOutofPK_Test_17,      //true  
    TransKeyOutofPK_Test_18,      //true
    TransKeyOutofPK_Test_19,      //RSA-512，PKCS#1填充，双倍长密钥，true
    TransKeyOutofPK_Test_20,      //true
    TransKeyOutofPK_Test_21,      //true
    TransKeyOutofPK_Test_22,      //true 
    TransKeyOutofPK_Test_23,      //true
    TransKeyOutofPK_Test_24,      //true
    TransKeyOutofPK_Test_25,      //RSA-512，OAEP填充，双倍长密钥，true
    TransKeyOutofPK_Test_26,      //true
    TransKeyOutofPK_Test_27,      //true
    TransKeyOutofPK_Test_28,      //true 
    TransKeyOutofPK_Test_29,      //true
    TransKeyOutofPK_Test_30,      //true
    TransKeyOutofPK_Test_31,      //RSA-512，PKCS#1填充，三倍长密钥，true
    TransKeyOutofPK_Test_32,      //true
    TransKeyOutofPK_Test_33,      //true
    TransKeyOutofPK_Test_34,      //true
    TransKeyOutofPK_Test_35,      //true
    TransKeyOutofPK_Test_36,      //true 
    TransKeyOutofPK_Test_37,      //RSA-512，OAEP填充，三倍长密钥，true
    TransKeyOutofPK_Test_38,      //true 
    TransKeyOutofPK_Test_39,      //true 
    TransKeyOutofPK_Test_40,      //true 
    TransKeyOutofPK_Test_41,      //true
    TransKeyOutofPK_Test_42,      //true 
*/
    //5.10 子密钥离散（7.6.15 分散卡密钥）
/*
    DisreteSubKey_Test_01,       //true       

    DisreteSubKey_Test_02,       //PBOC卡，二倍KEK，二次离散测试 true

    DisreteSubKey_Test_03,       //true

    DisreteSubKey_Test_04,       //VISA卡，二倍KEK，二次离散脚本会话密钥未成功 false

    DisreteSubKey_Test_05,       //true

    DisreteSubKey_Test_06,       //true 
    
    DisreteSubKey_Test_07,       //true   
    DisreteSubKey_Test_08,       //true
    DisreteSubKey_Test_09,       //无效Socket ID[-1]测试未失败

    DisreteSubKey_Test_10,        //无效Socket ID[8]测试未失败  
    DisreteSubKey_Test_11,        //true
    DisreteSubKey_Test_12,        //true

    DisreteSubKey_Test_13,        //true
    DisreteSubKey_Test_14,        //false
    DisreteSubKey_Test_15,        //true


    DisreteSubKey_Test_16,        //true
    DisreteSubKey_Test_17,        //true
    DisreteSubKey_Test_18,        //true 

    DisreteSubKey_Test_19,        //VISA卡，单倍KEK，二次离散（失败可）
    DisreteSubKey_Test_20,        //VISA卡，三倍KEK，二次离散（失败可）
    DisreteSubKey_Test_21,        //true
    DisreteSubKey_Test_22,        //true
    DisreteSubKey_Test_23,        //true 
    DisreteSubKey_Test_24,        //true
*/
    //5.11 ARQC 验证（7.3.2 ARQC/ARPC 产生或验证）
 /*
    VerifyARQC_Test_01,            //true
 
    VerifyARQC_Test_02,            //true
    VerifyARQC_Test_03,            //true
    VerifyARQC_Test_04,            //true
 
    VerifyARQC_Test_05,            //true

    VerifyARQC_Test_06,            //PBOC卡，Verify_ARQC测试未成功

    VerifyARQC_Test_07,            //VISA卡，Verify_ARQC测试未成功（失败可）

    VerifyARQC_Test_08,            //MASTER卡，Verify_ARQC测试未成功

    VerifyARQC_Test_09,            //PBOC卡，SM4, Verify_ARQC测试未成功
    VerifyARQC_Test_10,            //PBOC卡，SM4, Verify_ARQC测试未成功

*/
    //5.12 ARPC 计算（7.3.2 ARQC/ARPC 产生或验证） 
/*
    CalcARPC_Test_01,             //PBOC卡 true 

    CalcARPC_Test_02,             //VISA卡，false

    CalcARPC_Test_03,             //MASTER卡，false

    CalcARPC_Test_04,             //PBOC卡，SM4, true
  
    CalcARPC_Test_05,             //PBOC卡，SM4, true
*/

    //5.13 脚本加解密（7.3.3 脚本加解密） 
 /*   
    EncryptWithDerivedKey_Test_01,             //PBOC卡，ECB加密，true
    EncryptWithDerivedKey_Test_02,             //PBOC卡，ECB解密，true 

    EncryptWithDerivedKey_Test_03,             //VISA卡，ECB加密，true   
    EncryptWithDerivedKey_Test_04,             //VISA卡，ECB解密，true   

    EncryptWithDerivedKey_Test_05,             //true
    EncryptWithDerivedKey_Test_06,             //true


    EncryptWithDerivedKey_Test_07,             //true
    EncryptWithDerivedKey_Test_08,             //true
    EncryptWithDerivedKey_Test_09,             //无效Socket ID[-1]测试 false   
    EncryptWithDerivedKey_Test_10,             //无效Socket ID[8]测试 false 

    EncryptWithDerivedKey_Test_11,             //true
    EncryptWithDerivedKey_Test_13,             //true 
    EncryptWithDerivedKey_Test_14,             //true
    EncryptWithDerivedKey_Test_15,             //true

    EncryptWithDerivedKey_Test_16,             //true
    EncryptWithDerivedKey_Test_17,             //true
    EncryptWithDerivedKey_Test_18,             //true


    EncryptWithDerivedKey_Test_19,             //MASTER卡，ECB加密 true

    EncryptWithDerivedKey_Test_20,             //MASTER卡，ECB解密 true

    EncryptWithDerivedKey_Test_21,             //MASTER卡，CBC加密 true 

    EncryptWithDerivedKey_Test_22,             //MASTER卡，CBC解密 true
  
    EncryptWithDerivedKey_Test_23,             //PBOC卡，SM4, ECB加密 true

    EncryptWithDerivedKey_Test_24,             //PBOC卡，SM4, ECB解密 true

    EncryptWithDerivedKey_Test_25,             //PBOC卡，SM4, CBC加密 true
    EncryptWithDerivedKey_Test_26,             //PBOC卡，SM4, CBC解密 true 
*/
 
    //5.14 脚本数据计算MAC（7.3.4 计算脚本MAC）  
 /*  
    CalcMacWithDerivedKey_Test_01,            //PBOC卡 true

    CalcMacWithDerivedKey_Test_02,            //VISA卡 true
   
    CalcMacWithDerivedKey_Test_03,            //无效Socket ID[-1]测试未失败
    CalcMacWithDerivedKey_Test_04,            //无效Socket ID[8]测试未失败 
    CalcMacWithDerivedKey_Test_05,            //true
    CalcMacWithDerivedKey_Test_06,            //true

    CalcMacWithDerivedKey_Test_07,            //MASTER卡，true  
    CalcMacWithDerivedKey_Test_08,            //PBOC卡，SM4, true
    CalcMacWithDerivedKey_Test_09,            //PBOC卡，SM4, true
*/    

    //5.15 私钥解析（7.5.6 分解RSA 私钥分量）
/*  
    PrivateAnalyse_Test_01,    //RSA-512，单倍长密钥   true
    PrivateAnalyse_Test_02,    //RSA-512，双倍长密钥   true 

    PrivateAnalyse_Test_03,    //RSA-512，三倍长密钥   true

    PrivateAnalyse_Test_04,    //true
    PrivateAnalyse_Test_05,    //true
  
    PrivateAnalyse_Test_06,    //true
     
    PrivateAnalyse_Test_07,    //true
    PrivateAnalyse_Test_08,    //true
    
    PrivateAnalyse_Test_09,    //true

    PrivateAnalyse_Test_10,    //true
    PrivateAnalyse_Test_11,    //true
  
    PrivateAnalyse_Test_12,    //true
 
    PrivateAnalyse_Test_13,    //true
    PrivateAnalyse_Test_14,    //true
   
    PrivateAnalyse_Test_15,    //true

    PrivateAnalyse_Test_16,    //true
    PrivateAnalyse_Test_17,    //true
  
    PrivateAnalyse_Test_18,    //true
*/
    // 5.16 产生ECC 公私钥对（7.4.1 产生SM2 密钥对）  zhaomx   2017-4-12    passed
/*
    GenEccKey_Test_01,     //true
    GenEccKey_Test_02,     //true
    GenEccKey_Test_03,     //true
    GenEccKey_Test_04,     //SM2密钥对生成，异常椭圆曲线标识3，测试未失败
*/

    //5.17 根据ECC 私钥生成公钥  （7.6.19 根据ECC 私钥生成公钥）  (EB)

    GetEccPkBySk_Test_01,           //true 
/*
    GetEccPkBySk_Test_02,           //true 
    GetEccPkBySk_Test_03,           //true
    GetEccPkBySk_Test_04,           //true
    GetEccPkBySk_Test_05,           //false
    GetEccPkBySk_Test_06,           //true
    GetEccPkBySk_Test_07,           //true
    GetEccPkBySk_Test_08,           //根据ECC私钥生成公钥，特殊私钥d=n+1，测试未成功
*/
    //5.18 ECC 公钥加密（7.4.3 SM2 公钥加密）
 /*  
    EccPkEncrypt_Test_01,      //true  
    EccPkEncrypt_Test_02,      //false
    EccPkEncrypt_Test_03,      //false    
*/
    //5.19 ECC 私钥解密（7.4.4 SM2 私钥解密）
/*  
    EccSkDecrypt_Test_01,       //true

    EccSkDecrypt_Test_02,       //false       

    EccSkDecrypt_Test_03,       //ECC私钥解密，无效私钥，测试未成功 false 
*/

    //5.20 ECC 私钥签名（7.4.5 SM2 签名）
/* 
    EccSign_Test_01,             //SM2签名，256字节数据，测试失败

    EccSign_Test_02,             //SM2签名，无效私钥 true
*/
    //5.21 ECC 签名验证（7.4.6 SM2 验签）
/*
    EccVerify_Test_01,           //SM2签名验证，256字节数据，测试失败 
    EccVerify_Test_02,           //SM2签名验证，256字节数据，测试失败
    EccVerify_Test_03,           //SM2签名验证，无效公钥 true
*/
    //5.22 SM4 加解密（7.3.6 数据加解密）
/*
    Sm4Calc_Test_01,             //true
    Sm4Calc_Test_02,             //true
    Sm4Calc_Test_03,             //true
    Sm4Calc_Test_04,             //true
    Sm4Calc_Test_05,             //true
    Sm4Calc_Test_06,             //true  

    // 5.23 RSA 私钥转加密（7.6.17 RSA 公私钥转加密）  (UE)
  
    TransKeyIntoSK_Test_01,             //true

    TransKeyIntoSK_Test_02,             //true

    TransKeyIntoSK_Test_03,             //true

    TransKeyIntoSK_Test_04,             //true
    TransKeyIntoSK_Test_05,             //true 
    TransKeyIntoSK_Test_06,             //true


    // 5.24 SM2 公钥转加密（7.6.18 SM2 公私钥转加密） (UC)

    Sm2PKTransOutof_Test_01,            //true

    // 5.25 SM2 私钥转加密（7.6.18 SM2 公私钥转加密）(UC)
  
    Sm2SKTransInto_Test_01,             //true 

    //5.26 DES 到SM4 密钥转加密（7.3.5 数据转加密） (VS)
 
    TransKeyDesToSm4_Test_01,           //true
     
    TransKeyDesToSm4_Test_02,           //true

    TransKeyDesToSm4_Test_03,           //true

    TransKeyDesToSm4_Test_04,           //true


    //5.27 SM4 到DES 密钥转加密（7.3.5 数据转加密） (VS)
  
    TransKeySm4ToDes_Test_01,           //true

    TransKeySm4ToDes_Test_02,           //true

    TransKeySm4ToDes_Test_03,           //true

    TransKeySm4ToDes_Test_04,           //true  
*/



    testSDF_Encrypt2Decrypt,
    DisconnectSM_Test_01,
    NULL
};

/*
 *  <<LEVEL Error>>
 */
TESTFUNC TestFunc_E[] =
{
    ConnectSM_Test_01,
/*
    EncryptPinX98A_Test_10,
    EncryptPinX98A_Test_11,
    EncryptPinX98A_Test_14,
    EncryptPinX98A_Test_15,
    EncryptPinX98A_Test_16,
    EncryptPinX98A_Test_17,
    EncryptPinX98A_Test_18,
    EncryptPinX98A_Test_19,

    EncryptPinX98B_Test_10,
    EncryptPinX98B_Test_11,
    EncryptPinX98B_Test_14,
    EncryptPinX98B_Test_15,
    EncryptPinX98B_Test_16,
    EncryptPinX98B_Test_17,
    EncryptPinX98B_Test_24,
    EncryptPinX98B_Test_25,
    EncryptPinX98B_Test_26,
    EncryptPinX98B_Test_27,
    EncryptPinX98B_Test_28,
    EncryptPinX98B_Test_29,
    EncryptPinX98B_Test_30,

    DecryptPinX98A_Test_10,
    DecryptPinX98A_Test_11,
    DecryptPinX98A_Test_14,
    DecryptPinX98A_Test_15,
    DecryptPinX98A_Test_16,
    DecryptPinX98A_Test_17,
    DecryptPinX98A_Test_18,
    DecryptPinX98A_Test_19,

    DecryptPinX98B_Test_10,
    DecryptPinX98B_Test_11,
    DecryptPinX98B_Test_14,
    DecryptPinX98B_Test_15,
    DecryptPinX98B_Test_16,
    DecryptPinX98B_Test_17,
    DecryptPinX98B_Test_24,
    DecryptPinX98B_Test_25,
    DecryptPinX98B_Test_26,
    DecryptPinX98B_Test_27,
    DecryptPinX98B_Test_28,
    DecryptPinX98B_Test_29,
    DecryptPinX98B_Test_30,

    CalcMAC_Test_07,
    CalcMAC_Test_08,
    CalcMAC_Test_09,
    CalcMAC_Test_10,
    CalcMAC_Test_11,
    CalcMAC_Test_12,
    CalcMAC_Test_17,
    CalcMAC_Test_18,
    CalcMAC_Test_19,
    CalcMAC_Test_20,

    TranslateBlock_Test_10,
    TranslateBlock_Test_11,
    TranslateBlock_Test_12,
    TranslateBlock_Test_13,
    TranslateBlock_Test_14,
    TranslateBlock_Test_15,

    TranslateKeyOutOf_Test_10,
    TranslateKeyOutOf_Test_11,
    TranslateKeyOutOf_Test_12,
    TranslateKeyOutOf_Test_13,
    TranslateKeyOutOf_Test_18,
    TranslateKeyOutOf_Test_19,
    TranslateKeyOutOf_Test_20,
    TranslateKeyOutOf_Test_21,

    TranslateKeyInTo_Test_10,
    TranslateKeyInTo_Test_11,
    TranslateKeyInTo_Test_12,
    TranslateKeyInTo_Test_13,
    TranslateKeyInTo_Test_20,
    TranslateKeyInTo_Test_21,
    TranslateKeyInTo_Test_22,

    GenerateKey_Test_04,
    GenerateKey_Test_05,
    GenerateKey_Test_06,
    GenerateKey_Test_07,
    GenerateKey_Test_08,

    HideBlock_Test_03,
    HideBlock_Test_04,

    RevealBlock_Test_03,
    RevealBlock_Test_04,

    EncryptKey_Test_06,
    EncryptKey_Test_07,
    EncryptKey_Test_08,
    EncryptKey_Test_09,
    EncryptKey_Test_10,
    EncryptKey_Test_11,
    EncryptKey_Test_12,

    EncryptBlock_Test_08,
    EncryptBlock_Test_09,
    EncryptBlock_Test_10,
    EncryptBlock_Test_11,
    EncryptBlock_Test_12,
    EncryptBlock_Test_13,
    EncryptBlock_Test_14,
    EncryptBlock_Test_15,

    DecryptBlock_Test_08,
    DecryptBlock_Test_09,
    DecryptBlock_Test_10,
    DecryptBlock_Test_11,
    DecryptBlock_Test_12,
    DecryptBlock_Test_13,
    DecryptBlock_Test_14,
    DecryptBlock_Test_15,

    EncryptCBC_Test_08,
    EncryptCBC_Test_09,
    EncryptCBC_Test_10,
    EncryptCBC_Test_11,
    EncryptCBC_Test_12,
    EncryptCBC_Test_13,
    EncryptCBC_Test_14,
    EncryptCBC_Test_15,

    DecryptCBC_Test_08,
    DecryptCBC_Test_09,
    DecryptCBC_Test_10,
    DecryptCBC_Test_11,
    DecryptCBC_Test_12,
    DecryptCBC_Test_13,
    DecryptCBC_Test_14,
    DecryptCBC_Test_15,

    CalCVV_Test_05,
    CalCVV_Test_06,
    CalCVV_Test_07,
    CalCVV_Test_08,
    CalCVV_Test_09,
    CalCVV_Test_12,
    CalCVV_Test_13,
    CalCVV_Test_14,
    CalCVV_Test_15,
    CalCVV_Test_18,
    CalCVV_Test_21,

    CalPVV_Test_05,
    CalPVV_Test_06,
    CalPVV_Test_07,
    CalPVV_Test_08,
    CalPVV_Test_09,
    CalPVV_Test_10,
    CalPVV_Test_11,
    CalPVV_Test_12,
    CalPVV_Test_13,
    CalPVV_Test_26,
    CalPVV_Test_27,

    IBM3624_Test_05,
    IBM3624_Test_06,
    IBM3624_Test_07,
    IBM3624_Test_08,
    IBM3624_Test_09,
    IBM3624_Test_10,
    IBM3624_Test_11,
    IBM3624_Test_12,
    IBM3624_Test_13,
    IBM3624_Test_21,
    IBM3624_Test_22,
    IBM3624_Test_23,
    IBM3624_Test_24,
    IBM3624_Test_25,

    GenRandDigits_Test_01,
    GenRandDigits_Test_13,
    GenRandDigits_Test_14,
    GenRandDigits_Test_15,
    GenRandDigits_Test_16,
    GenRandDigits_Test_17,

    VerifyCheckValue_Test_06,
    VerifyCheckValue_Test_07,
    VerifyCheckValue_Test_08,
    VerifyCheckValue_Test_09,
    VerifyCheckValue_Test_10,
    VerifyCheckValue_Test_11,
    VerifyCheckValue_Test_12,
    VerifyCheckValue_Test_13,
    VerifyCheckValue_Test_14,
    VerifyCheckValue_Test_15,
    VerifyCheckValue_Test_16,
    VerifyCheckValue_Test_17,
    VerifyCheckValue_Test_18,

    GetHsmStatus_Test_02,
    GetHsmStatus_Test_03,

    ImportKey_Test_06,
    ImportKey_Test_07,
    ImportKey_Test_08,
    ImportKey_Test_09,
    ImportKey_Test_10,
    ImportKey_Test_11,
    ImportKey_Test_12,
    ImportKey_Test_13,
    ImportKey_Test_14,
    ImportKey_Test_15,
    ImportKey_Test_16,
    ImportKey_Test_17,
    ImportKey_Test_18,
    ImportKey_Test_19,
    ImportKey_Test_20,
    ImportKey_Test_21,
    ImportKey_Test_22,
    ImportKey_Test_23,
    ImportKey_Test_24,

    ExportKey_Test_04,
    ExportKey_Test_05,
    ExportKey_Test_06,

    GenMasterKey_Test_04,
    GenMasterKey_Test_05,
    GenMasterKey_Test_06,
    GenMasterKey_Test_07,
    GenMasterKey_Test_08,
    GenMasterKey_Test_09,
    GenMasterKey_Test_10,
    GenMasterKey_Test_11,
    GenMasterKey_Test_12,

    ExportMasterKey_Test_04,
    ExportMasterKey_Test_05,
    ExportMasterKey_Test_06,
    ExportMasterKey_Test_07,

    EncryptData_Test_17,
    EncryptData_Test_18,
    EncryptData_Test_19,
    EncryptData_Test_20,
    EncryptData_Test_21,
    EncryptData_Test_22,
    EncryptData_Test_23,
    EncryptData_Test_24,
    EncryptData_Test_25,
    EncryptData_Test_26,
    EncryptData_Test_27,

    GenRsaKey_Test_07,
    GenRsaKey_Test_08,
    GenRsaKey_Test_09,
    GenRsaKey_Test_10,
    GenRsaKey_Test_11,
    GenRsaKey_Test_12,
    GenRsaKey_Test_13,
    GenRsaKey_Test_14,

    Digest_Test_07,
    Digest_Test_08,
    Digest_Test_09,
    Digest_Test_10,
    Digest_Test_11,
    Digest_Test_13,

    PublicCalc_Test_31,
    PublicCalc_Test_32,
    PublicCalc_Test_33,
    PublicCalc_Test_34,
    PublicCalc_Test_35,
    PublicCalc_Test_36,
    PublicCalc_Test_37,
    PublicCalc_Test_38,
    PublicCalc_Test_39,
    PublicCalc_Test_40,
    PublicCalc_Test_41,
    PublicCalc_Test_42,
    PublicCalc_Test_43,
    PublicCalc_Test_44,
    PublicCalc_Test_45,
    PublicCalc_Test_46,
    PublicCalc_Test_47,
    PublicCalc_Test_48,
    PublicCalc_Test_49,
    PublicCalc_Test_50,
    PublicCalc_Test_51,

    PrivateCalc_Test_31,
    PrivateCalc_Test_32,
    PrivateCalc_Test_33,
    PrivateCalc_Test_34,
    PrivateCalc_Test_35,
    PrivateCalc_Test_36,
  */  PrivateCalc_Test_37,
    PrivateCalc_Test_38,
    PrivateCalc_Test_39,
/*    PrivateCalc_Test_40,
    PrivateCalc_Test_41,
    PrivateCalc_Test_42,
    PrivateCalc_Test_43,
    PrivateCalc_Test_44,
    PrivateCalc_Test_45,
    PrivateCalc_Test_46,
    PrivateCalc_Test_47,
    PrivateCalc_Test_48,
    PrivateCalc_Test_49,
    PrivateCalc_Test_50,
*/
/*
    PrivateSign_Test_06,
    PrivateSign_Test_37,
    PrivateSign_Test_38,
    PrivateSign_Test_39,
    PrivateSign_Test_40,
    PrivateSign_Test_41,
    PrivateSign_Test_42,
    PrivateSign_Test_43,
    PrivateSign_Test_44,
    PrivateSign_Test_45,
    PrivateSign_Test_46,

    VerifySign_Test_06,
    VerifySign_Test_37,
    VerifySign_Test_38,
    VerifySign_Test_39,
    VerifySign_Test_40,
    VerifySign_Test_41,
    VerifySign_Test_42,
    VerifySign_Test_43,
    VerifySign_Test_44,
    VerifySign_Test_45,
*/
/*
    TransKeyOutofPK_Test_37,
    TransKeyOutofPK_Test_43,
    TransKeyOutofPK_Test_44,
    TransKeyOutofPK_Test_45,
    TransKeyOutofPK_Test_46,
    TransKeyOutofPK_Test_47,
    TransKeyOutofPK_Test_48,
    TransKeyOutofPK_Test_49,
    TransKeyOutofPK_Test_50,
*/
   /* PrivateAnalyse_Test_19,
    PrivateAnalyse_Test_20,
    PrivateAnalyse_Test_21,
    PrivateAnalyse_Test_22,
    PrivateAnalyse_Test_23,
    PrivateAnalyse_Test_24,
*/

    DisconnectSM_Test_01,
    NULL
};

//卫士通
TESTFUNC TestFunc_C4[] =
{
    ConnectSM_Test_01,

	EncryptPinX98A_Test_01,
	EncryptPinX98A_Test_02,
	EncryptPinX98A_Test_03,
	EncryptPinX98A_Test_04,
	EncryptPinX98A_Test_05,
	EncryptPinX98A_Test_06,
	EncryptPinX98A_Test_07,
	EncryptPinX98A_Test_08,
	EncryptPinX98A_Test_09,
	EncryptPinX98A_Test_10,
	EncryptPinX98A_Test_11,
	EncryptPinX98A_Test_12,
	EncryptPinX98A_Test_13,
	EncryptPinX98A_Test_14,
	EncryptPinX98A_Test_15,
	EncryptPinX98A_Test_16,
	EncryptPinX98A_Test_17,
	EncryptPinX98A_Test_18,
	EncryptPinX98A_Test_19,

	EncryptPinX98B_Test_01,
	EncryptPinX98B_Test_02,
	EncryptPinX98B_Test_03,
	EncryptPinX98B_Test_04,
	EncryptPinX98B_Test_05,
	EncryptPinX98B_Test_06,
	EncryptPinX98B_Test_07,
	EncryptPinX98B_Test_08,
	EncryptPinX98B_Test_09,
	EncryptPinX98B_Test_10,
	EncryptPinX98B_Test_11,
	EncryptPinX98B_Test_12,
	EncryptPinX98B_Test_13,
	EncryptPinX98B_Test_14,
	EncryptPinX98B_Test_15,
	EncryptPinX98B_Test_16,
	EncryptPinX98B_Test_17,
	EncryptPinX98B_Test_18,
	EncryptPinX98B_Test_19,
	EncryptPinX98B_Test_20,
	EncryptPinX98B_Test_21,
	EncryptPinX98B_Test_22,
	EncryptPinX98B_Test_23,
	EncryptPinX98B_Test_24,
	EncryptPinX98B_Test_25,
	EncryptPinX98B_Test_26,
	EncryptPinX98B_Test_27,
	EncryptPinX98B_Test_28,
	EncryptPinX98B_Test_29,
	EncryptPinX98B_Test_30,

	DecryptPinX98A_Test_01,
	DecryptPinX98A_Test_02,
	DecryptPinX98A_Test_03,
	DecryptPinX98A_Test_04,
	DecryptPinX98A_Test_05,
	DecryptPinX98A_Test_06,
	DecryptPinX98A_Test_07,
	DecryptPinX98A_Test_08,
	DecryptPinX98A_Test_09,
	DecryptPinX98A_Test_10,
	DecryptPinX98A_Test_11,
	DecryptPinX98A_Test_12,
	DecryptPinX98A_Test_13,
	DecryptPinX98A_Test_14,
	DecryptPinX98A_Test_15,
	DecryptPinX98A_Test_16,
	DecryptPinX98A_Test_17,
	DecryptPinX98A_Test_18,
	DecryptPinX98A_Test_19,

	DecryptPinX98B_Test_01,
	DecryptPinX98B_Test_02,
	DecryptPinX98B_Test_03,
	DecryptPinX98B_Test_04,
	DecryptPinX98B_Test_05,
	DecryptPinX98B_Test_06,
	DecryptPinX98B_Test_07,
	DecryptPinX98B_Test_08,
	DecryptPinX98B_Test_09,
	DecryptPinX98B_Test_10,
	DecryptPinX98B_Test_11,
	DecryptPinX98B_Test_12,
	DecryptPinX98B_Test_13,
	DecryptPinX98B_Test_14,
	DecryptPinX98B_Test_15,
	DecryptPinX98B_Test_16,
	DecryptPinX98B_Test_17,
	DecryptPinX98B_Test_18,
	DecryptPinX98B_Test_19,
	DecryptPinX98B_Test_20,
	DecryptPinX98B_Test_21,
	DecryptPinX98B_Test_22,
	DecryptPinX98B_Test_23,
	DecryptPinX98B_Test_24,
	DecryptPinX98B_Test_25,
	DecryptPinX98B_Test_26,
	DecryptPinX98B_Test_27,
	DecryptPinX98B_Test_28,
	DecryptPinX98B_Test_29,
	DecryptPinX98B_Test_30,

	CalcMAC_Test_01,
	CalcMAC_Test_02,
	CalcMAC_Test_03,
	CalcMAC_Test_04,
	CalcMAC_Test_05,
	CalcMAC_Test_06,
	CalcMAC_Test_07,
	CalcMAC_Test_08,
	CalcMAC_Test_09,
	CalcMAC_Test_10,
	CalcMAC_Test_11,
	CalcMAC_Test_12,
	CalcMAC_Test_13,
	CalcMAC_Test_14,
	CalcMAC_Test_15,
	CalcMAC_Test_16,
	CalcMAC_Test_17,
	CalcMAC_Test_18,
	CalcMAC_Test_19,
	CalcMAC_Test_20,
	CalcMAC_Test_21,
	CalcMAC_Test_22,

	TranslateBlock_Test_01,
	TranslateBlock_Test_02,
	TranslateBlock_Test_03,
	TranslateBlock_Test_04,
	TranslateBlock_Test_05,
	TranslateBlock_Test_06,
	TranslateBlock_Test_07,
	TranslateBlock_Test_08,
	TranslateBlock_Test_09,
	TranslateBlock_Test_10,
	TranslateBlock_Test_11,
	TranslateBlock_Test_12,
	TranslateBlock_Test_13,
	TranslateBlock_Test_14,
	TranslateBlock_Test_15,
	TranslateBlock_Test_16,
	TranslateBlock_Test_17,
	TranslateBlock_Test_18,
	TranslateBlock_Test_19,
	TranslateBlock_Test_20,

	TranslateKeyOutOf_Test_01,
	TranslateKeyOutOf_Test_02,
	TranslateKeyOutOf_Test_03,
	TranslateKeyOutOf_Test_04,
	TranslateKeyOutOf_Test_05,
	TranslateKeyOutOf_Test_06,
	TranslateKeyOutOf_Test_07,
	TranslateKeyOutOf_Test_08,
	TranslateKeyOutOf_Test_09,
	TranslateKeyOutOf_Test_10,
	TranslateKeyOutOf_Test_11,
	TranslateKeyOutOf_Test_12,
	TranslateKeyOutOf_Test_13,
	TranslateKeyOutOf_Test_14,
	TranslateKeyOutOf_Test_15,
	TranslateKeyOutOf_Test_16,
	TranslateKeyOutOf_Test_17,
	TranslateKeyOutOf_Test_18,
	TranslateKeyOutOf_Test_19,
	TranslateKeyOutOf_Test_20,
	TranslateKeyOutOf_Test_21,

	TranslateKeyInTo_Test_01,
	TranslateKeyInTo_Test_02,
	TranslateKeyInTo_Test_03,
	TranslateKeyInTo_Test_04,
	TranslateKeyInTo_Test_05,
	TranslateKeyInTo_Test_06,
	TranslateKeyInTo_Test_07,
	TranslateKeyInTo_Test_08,
	TranslateKeyInTo_Test_09,
	TranslateKeyInTo_Test_10,
	TranslateKeyInTo_Test_11,
	TranslateKeyInTo_Test_12,
	TranslateKeyInTo_Test_13,
	TranslateKeyInTo_Test_14,
	TranslateKeyInTo_Test_15,
	TranslateKeyInTo_Test_16,
	TranslateKeyInTo_Test_17,
	TranslateKeyInTo_Test_18,
	TranslateKeyInTo_Test_19,
	TranslateKeyInTo_Test_20,
	TranslateKeyInTo_Test_21,
	TranslateKeyInTo_Test_22,

	GenerateKey_Test_P,
	GenerateKey_Test_K,
	GenerateKey_Test_01,
	GenerateKey_Test_02,
	GenerateKey_Test_03,
	GenerateKey_Test_04,
	GenerateKey_Test_05,
	GenerateKey_Test_06,
	GenerateKey_Test_07,
	GenerateKey_Test_08,

	HideBlock_Test_01,
	HideBlock_Test_02,
	HideBlock_Test_03,
	HideBlock_Test_04,
	
	RevealBlock_Test_01,
	RevealBlock_Test_02,
	RevealBlock_Test_03,
	RevealBlock_Test_04,

	EncryptKey_Test_01,
	EncryptKey_Test_02,
	EncryptKey_Test_03,
	EncryptKey_Test_04,
	EncryptKey_Test_05,
	EncryptKey_Test_06,
	EncryptKey_Test_07,
	EncryptKey_Test_08,
	EncryptKey_Test_09,
	EncryptKey_Test_10,
	EncryptKey_Test_11,
	EncryptKey_Test_12,

	EncryptBlock_Test_01,
	EncryptBlock_Test_02,
	EncryptBlock_Test_03,
	EncryptBlock_Test_04,
	EncryptBlock_Test_05,
	EncryptBlock_Test_06,
	EncryptBlock_Test_07,
	EncryptBlock_Test_08,
	EncryptBlock_Test_09,
	EncryptBlock_Test_10,
	EncryptBlock_Test_11,
	EncryptBlock_Test_12,
	EncryptBlock_Test_13,
	EncryptBlock_Test_14,
	EncryptBlock_Test_15,
	
	DecryptBlock_Test_01,
	DecryptBlock_Test_02,
	DecryptBlock_Test_03,
	DecryptBlock_Test_04,
	DecryptBlock_Test_05,
	DecryptBlock_Test_06,
	DecryptBlock_Test_07,
	DecryptBlock_Test_08,
	DecryptBlock_Test_09,
	DecryptBlock_Test_10,
	DecryptBlock_Test_11,
	DecryptBlock_Test_12,
	DecryptBlock_Test_13,
	DecryptBlock_Test_14,
	DecryptBlock_Test_15,

	EncryptCBC_Test_01,
	EncryptCBC_Test_02,
	EncryptCBC_Test_03,
	EncryptCBC_Test_04,
	EncryptCBC_Test_05,
	EncryptCBC_Test_06,
	EncryptCBC_Test_07,
	EncryptCBC_Test_08,
	EncryptCBC_Test_09,
	EncryptCBC_Test_10,
	EncryptCBC_Test_11,
	EncryptCBC_Test_12,
	EncryptCBC_Test_13,
	EncryptCBC_Test_14,
	EncryptCBC_Test_15,
	EncryptCBC_Test_16,
	EncryptCBC_Test_17,
	EncryptCBC_Test_18,

	DecryptCBC_Test_01,
	DecryptCBC_Test_02,
	DecryptCBC_Test_03,
	DecryptCBC_Test_04,
	DecryptCBC_Test_05,
	DecryptCBC_Test_06,
	DecryptCBC_Test_07,
	DecryptCBC_Test_08,
	DecryptCBC_Test_09,
	DecryptCBC_Test_10,
	DecryptCBC_Test_11,
	DecryptCBC_Test_12,
	DecryptCBC_Test_13,
	DecryptCBC_Test_14,
	DecryptCBC_Test_15,
	DecryptCBC_Test_16,
	DecryptCBC_Test_17,
	DecryptCBC_Test_18,

	CalCVV_Test_01,
	CalCVV_Test_02,
	CalCVV_Test_03,
	CalCVV_Test_04,
	CalCVV_Test_05,
	CalCVV_Test_06,
	CalCVV_Test_07,
	CalCVV_Test_08,
	CalCVV_Test_09,
	CalCVV_Test_10,
	CalCVV_Test_11,
	CalCVV_Test_12,
	CalCVV_Test_13,
	CalCVV_Test_14,
	CalCVV_Test_15,
	CalCVV_Test_16,
	CalCVV_Test_17,
	CalCVV_Test_18,
	CalCVV_Test_19,
	CalCVV_Test_20,
	CalCVV_Test_21,

	CalPVV_Test_01,
	CalPVV_Test_02,
	CalPVV_Test_03,
	CalPVV_Test_04,
	CalPVV_Test_05,
	CalPVV_Test_06,
	CalPVV_Test_07,
	CalPVV_Test_08,
	CalPVV_Test_09,
	CalPVV_Test_10,
	CalPVV_Test_11,
	CalPVV_Test_12,
	CalPVV_Test_13,
	CalPVV_Test_14,
	CalPVV_Test_15,
	CalPVV_Test_16,
	CalPVV_Test_17,
	CalPVV_Test_18,
	CalPVV_Test_19,
	CalPVV_Test_20,
	CalPVV_Test_21,
	CalPVV_Test_22,
	CalPVV_Test_23,
	CalPVV_Test_24,
	CalPVV_Test_25,
	CalPVV_Test_26,
	CalPVV_Test_27,

	IBM3624_Test_01,
	IBM3624_Test_02,
	IBM3624_Test_03,
	IBM3624_Test_04,
	IBM3624_Test_05,
	IBM3624_Test_06,
	IBM3624_Test_07,
	IBM3624_Test_08,
	IBM3624_Test_09,
	IBM3624_Test_10,
	IBM3624_Test_11,
	IBM3624_Test_12,
	IBM3624_Test_13,
	IBM3624_Test_14,
	IBM3624_Test_15,
	IBM3624_Test_16,
	IBM3624_Test_17,
	IBM3624_Test_18,
	IBM3624_Test_19,
	IBM3624_Test_20,
	IBM3624_Test_21,
	IBM3624_Test_22,
	IBM3624_Test_23,
	IBM3624_Test_24,
	IBM3624_Test_25,

	GenRandDigits_Test_01,
	GenRandDigits_Test_02,
	GenRandDigits_Test_03,
	GenRandDigits_Test_04,
	GenRandDigits_Test_05,
	GenRandDigits_Test_06,
	GenRandDigits_Test_07,
	GenRandDigits_Test_08,
	GenRandDigits_Test_09,
	GenRandDigits_Test_10,
	GenRandDigits_Test_11,
	GenRandDigits_Test_12,
	GenRandDigits_Test_13,
	GenRandDigits_Test_14,
	GenRandDigits_Test_15,
	GenRandDigits_Test_16,
	GenRandDigits_Test_17,

	VerifyCheckValue_Test_01,
	VerifyCheckValue_Test_02,
	VerifyCheckValue_Test_03,
	VerifyCheckValue_Test_04,
	VerifyCheckValue_Test_05,
	VerifyCheckValue_Test_06,
	VerifyCheckValue_Test_07,
	VerifyCheckValue_Test_08,
	VerifyCheckValue_Test_09,
	VerifyCheckValue_Test_10,
	VerifyCheckValue_Test_11,
	VerifyCheckValue_Test_12,
	VerifyCheckValue_Test_13,
	VerifyCheckValue_Test_14,
	VerifyCheckValue_Test_15,
	VerifyCheckValue_Test_16,
	VerifyCheckValue_Test_17,
	VerifyCheckValue_Test_18,

	GetHsmStatus_Test_01,
	GetHsmStatus_Test_02,
	GetHsmStatus_Test_03,
	
	ExpMod_Test_01,
	ExpMod_Test_02,
	ExpMod_Test_03,
	ExpMod_Test_04,
	ExpMod_Test_05,

	GenBigPrime_Test_01,
	GenBigPrime_Test_02,
	GenBigPrime_Test_03,

        DisconnectSM_Test_01,
	NULL
};


TESTFUNC TestFunc_C5[] =
{
        ConnectSM_Test_01,

	GenRsaKey_Test_01,
	GenRsaKey_Test_02,
	GenRsaKey_Test_03,
	GenRsaKey_Test_04,
	GenRsaKey_Test_05,
	GenRsaKey_Test_06,
	GenRsaKey_Test_06,
	GenRsaKey_Test_07,
	GenRsaKey_Test_08,
	GenRsaKey_Test_09,
	GenRsaKey_Test_10,
	GenRsaKey_Test_11,
	GenRsaKey_Test_12,
	GenRsaKey_Test_13,
	GenRsaKey_Test_14,

	GenMasterKey_Test_01,
	GenMasterKey_Test_02,
	GenMasterKey_Test_03,
	GenMasterKey_Test_04,
	GenMasterKey_Test_05,
	GenMasterKey_Test_06,
	GenMasterKey_Test_07,
	GenMasterKey_Test_08,
	GenMasterKey_Test_09,
	GenMasterKey_Test_10,
	GenMasterKey_Test_11,
	GenMasterKey_Test_12,

	ExportMasterKey_Test_01,
	ExportMasterKey_Test_02,
	ExportMasterKey_Test_03,
	ExportMasterKey_Test_04,
	ExportMasterKey_Test_05,
	ExportMasterKey_Test_06,
	ExportMasterKey_Test_07,

	Digest_Test_01,
	Digest_Test_02,
	Digest_Test_03,
	Digest_Test_04,
	Digest_Test_05,
	Digest_Test_06,
	Digest_Test_07,
	Digest_Test_08,
	Digest_Test_09,
	Digest_Test_10,
	Digest_Test_11,
	Digest_Test_12,
	Digest_Test_13,
	Digest_Test_14,
	Digest_Test_15,
	Digest_Test_16,
	Digest_Test_17,
	Digest_Test_18,
	Digest_Test_19,
	Digest_Test_20,

	PublicCalc_Test_01,
	PublicCalc_Test_02,
	PublicCalc_Test_03,
	PublicCalc_Test_04,
	PublicCalc_Test_05,
	PublicCalc_Test_06,
	PublicCalc_Test_07,
	PublicCalc_Test_08,
	PublicCalc_Test_09,
	PublicCalc_Test_10,
	PublicCalc_Test_11,
	PublicCalc_Test_12,
	PublicCalc_Test_13,
	PublicCalc_Test_14,
	PublicCalc_Test_15,
	PublicCalc_Test_16,
	PublicCalc_Test_17,
	PublicCalc_Test_18,
	PublicCalc_Test_19,
	PublicCalc_Test_20,
	PublicCalc_Test_21,
	PublicCalc_Test_22,
	PublicCalc_Test_23,
	PublicCalc_Test_24,
	PublicCalc_Test_25,
	PublicCalc_Test_26,
	PublicCalc_Test_27,
	PublicCalc_Test_28,
	PublicCalc_Test_29,
	PublicCalc_Test_30,
	PublicCalc_Test_31,
	PublicCalc_Test_32,
	PublicCalc_Test_33,
	PublicCalc_Test_34,
	PublicCalc_Test_35,
	PublicCalc_Test_36,
	PublicCalc_Test_37,
	PublicCalc_Test_38,
	PublicCalc_Test_39,
	PublicCalc_Test_40,
	PublicCalc_Test_41,
	PublicCalc_Test_42,
	PublicCalc_Test_43,
	PublicCalc_Test_44,
	PublicCalc_Test_45,
	PublicCalc_Test_46,
	PublicCalc_Test_47,
	PublicCalc_Test_48,
	PublicCalc_Test_49,
	PublicCalc_Test_50,
	PublicCalc_Test_51,

	PrivateCalc_Test_01,
	PrivateCalc_Test_02,
	PrivateCalc_Test_03,
	PrivateCalc_Test_04,
	PrivateCalc_Test_05,
	PrivateCalc_Test_06,
	PrivateCalc_Test_07,
	PrivateCalc_Test_08,
	PrivateCalc_Test_09,
	PrivateCalc_Test_10,
	PrivateCalc_Test_11,
	PrivateCalc_Test_12,
	PrivateCalc_Test_13,
	PrivateCalc_Test_14,
	PrivateCalc_Test_15,
	PrivateCalc_Test_16,
	PrivateCalc_Test_17,
	PrivateCalc_Test_18,
	PrivateCalc_Test_19,
	PrivateCalc_Test_20,
	PrivateCalc_Test_21,
	PrivateCalc_Test_22,
	PrivateCalc_Test_23,
	PrivateCalc_Test_24,
	PrivateCalc_Test_25,
	PrivateCalc_Test_26,
	PrivateCalc_Test_27,
	PrivateCalc_Test_28,
	PrivateCalc_Test_29,
	PrivateCalc_Test_30,
	PrivateCalc_Test_31,
	PrivateCalc_Test_32,
	PrivateCalc_Test_33,
	PrivateCalc_Test_34,
	PrivateCalc_Test_35,
	PrivateCalc_Test_36,
	PrivateCalc_Test_37,
	PrivateCalc_Test_38,
	PrivateCalc_Test_39,
	PrivateCalc_Test_40,
	PrivateCalc_Test_41,
	PrivateCalc_Test_42,
	PrivateCalc_Test_43,
	PrivateCalc_Test_44,
	PrivateCalc_Test_45,
	PrivateCalc_Test_46,
	PrivateCalc_Test_47,
	PrivateCalc_Test_48,
	PrivateCalc_Test_49,
	PrivateCalc_Test_50,

	PrivateSign_Test_01,
	PrivateSign_Test_02,
	PrivateSign_Test_03,
	PrivateSign_Test_04,
	PrivateSign_Test_05,
	PrivateSign_Test_06,
	PrivateSign_Test_07,
	PrivateSign_Test_08,
	PrivateSign_Test_09,
	PrivateSign_Test_10,
	PrivateSign_Test_11,
	PrivateSign_Test_12,
	PrivateSign_Test_13,
	PrivateSign_Test_14,
	PrivateSign_Test_15,
	PrivateSign_Test_16,
	PrivateSign_Test_17,
	PrivateSign_Test_18,
	PrivateSign_Test_19,
	PrivateSign_Test_20,
	PrivateSign_Test_21,
	PrivateSign_Test_22,
	PrivateSign_Test_23,
	PrivateSign_Test_24,
	PrivateSign_Test_25,
	PrivateSign_Test_26,
	PrivateSign_Test_27,
	PrivateSign_Test_28,
	PrivateSign_Test_29,
	PrivateSign_Test_30,
	PrivateSign_Test_31,
	PrivateSign_Test_32,
	PrivateSign_Test_33,
	PrivateSign_Test_34,
	PrivateSign_Test_35,
	PrivateSign_Test_36,
	PrivateSign_Test_37,
	PrivateSign_Test_38,
	PrivateSign_Test_39,
	PrivateSign_Test_40,
	PrivateSign_Test_41,
	PrivateSign_Test_42,
	PrivateSign_Test_43,
	PrivateSign_Test_44,
	PrivateSign_Test_45,
	PrivateSign_Test_46,

	VerifySign_Test_01,
	VerifySign_Test_02,
	VerifySign_Test_03,
	VerifySign_Test_04,
	VerifySign_Test_05,
	VerifySign_Test_06,
	VerifySign_Test_07,
	VerifySign_Test_08,
	VerifySign_Test_09,
	VerifySign_Test_10,
	VerifySign_Test_11,
	VerifySign_Test_12,
	VerifySign_Test_13,
	VerifySign_Test_14,
	VerifySign_Test_15,
	VerifySign_Test_16,
	VerifySign_Test_17,
	VerifySign_Test_18,
	VerifySign_Test_19,
	VerifySign_Test_20,
	VerifySign_Test_21,
	VerifySign_Test_22,
	VerifySign_Test_23,
	VerifySign_Test_24,
	VerifySign_Test_25,
	VerifySign_Test_26,
	VerifySign_Test_27,
	VerifySign_Test_28,
	VerifySign_Test_29,
	VerifySign_Test_30,
	VerifySign_Test_31,
	VerifySign_Test_32,
	VerifySign_Test_33,
	VerifySign_Test_34,
	VerifySign_Test_35,
	VerifySign_Test_36,
	VerifySign_Test_37,
	VerifySign_Test_38,
	VerifySign_Test_39,
	VerifySign_Test_40,
	VerifySign_Test_41,
	VerifySign_Test_42,
	VerifySign_Test_43,
	VerifySign_Test_44,
	VerifySign_Test_45,

	TransKeyOutofPK_Test_01,
	TransKeyOutofPK_Test_02,
	TransKeyOutofPK_Test_03,
	TransKeyOutofPK_Test_04,
	TransKeyOutofPK_Test_05,
	TransKeyOutofPK_Test_06,
	TransKeyOutofPK_Test_07,
	TransKeyOutofPK_Test_08,
	TransKeyOutofPK_Test_09,
	TransKeyOutofPK_Test_10,
	TransKeyOutofPK_Test_11,
	TransKeyOutofPK_Test_12,
	TransKeyOutofPK_Test_13,
	TransKeyOutofPK_Test_14,
	TransKeyOutofPK_Test_15,
	TransKeyOutofPK_Test_16,
	TransKeyOutofPK_Test_17,
	TransKeyOutofPK_Test_18,
	TransKeyOutofPK_Test_19,
	TransKeyOutofPK_Test_20,
	TransKeyOutofPK_Test_21,
	TransKeyOutofPK_Test_22,
	TransKeyOutofPK_Test_23,
	TransKeyOutofPK_Test_24,
	TransKeyOutofPK_Test_25,
	TransKeyOutofPK_Test_26,
	TransKeyOutofPK_Test_27,
	TransKeyOutofPK_Test_28,
	TransKeyOutofPK_Test_29,
	TransKeyOutofPK_Test_30,
	TransKeyOutofPK_Test_31,
	TransKeyOutofPK_Test_32,
	TransKeyOutofPK_Test_33,
	TransKeyOutofPK_Test_34,
	TransKeyOutofPK_Test_35,
	TransKeyOutofPK_Test_36,
	TransKeyOutofPK_Test_37,
	TransKeyOutofPK_Test_38,
	TransKeyOutofPK_Test_39,
	TransKeyOutofPK_Test_40,
	TransKeyOutofPK_Test_41,
	TransKeyOutofPK_Test_42,
	TransKeyOutofPK_Test_43,
	TransKeyOutofPK_Test_44,
	TransKeyOutofPK_Test_45,
	TransKeyOutofPK_Test_46,
	TransKeyOutofPK_Test_47,
	TransKeyOutofPK_Test_48,
	TransKeyOutofPK_Test_49,
	TransKeyOutofPK_Test_50,

	DisreteSubKey_Test_01,
	DisreteSubKey_Test_02,
	DisreteSubKey_Test_03,
	DisreteSubKey_Test_04,
	DisreteSubKey_Test_05,
	DisreteSubKey_Test_06,
	DisreteSubKey_Test_07,
	DisreteSubKey_Test_08,
	DisreteSubKey_Test_09,
	DisreteSubKey_Test_10,
	DisreteSubKey_Test_11,
	DisreteSubKey_Test_12,
	DisreteSubKey_Test_13,
	DisreteSubKey_Test_14,
	DisreteSubKey_Test_15,
	DisreteSubKey_Test_16,
	DisreteSubKey_Test_17,
	DisreteSubKey_Test_18,
	DisreteSubKey_Test_19,
	DisreteSubKey_Test_20,
	DisreteSubKey_Test_21,
	DisreteSubKey_Test_22,
	DisreteSubKey_Test_23,
	DisreteSubKey_Test_24,
	DisreteSubKey_Test_25,
	DisreteSubKey_Test_26,
	DisreteSubKey_Test_27,
	DisreteSubKey_Test_28,

	VerifyARQC_Test_01,
	VerifyARQC_Test_02,
	VerifyARQC_Test_03,
	VerifyARQC_Test_04,
	VerifyARQC_Test_05,
	VerifyARQC_Test_06,
	VerifyARQC_Test_07,
	VerifyARQC_Test_08,
	VerifyARQC_Test_09,
	VerifyARQC_Test_10,

	CalcARPC_Test_01,
	CalcARPC_Test_02,
	CalcARPC_Test_03,
	CalcARPC_Test_04,
	CalcARPC_Test_05,

	EncryptWithDerivedKey_Test_01,
	EncryptWithDerivedKey_Test_02,
	EncryptWithDerivedKey_Test_03,
	EncryptWithDerivedKey_Test_04,
	EncryptWithDerivedKey_Test_05,
	EncryptWithDerivedKey_Test_06,
	EncryptWithDerivedKey_Test_07,
	EncryptWithDerivedKey_Test_08,
	EncryptWithDerivedKey_Test_09,
	EncryptWithDerivedKey_Test_10,
	EncryptWithDerivedKey_Test_11,
	EncryptWithDerivedKey_Test_12,
	EncryptWithDerivedKey_Test_13,
	EncryptWithDerivedKey_Test_14,
	EncryptWithDerivedKey_Test_15,
	EncryptWithDerivedKey_Test_16,
	EncryptWithDerivedKey_Test_17,
	EncryptWithDerivedKey_Test_18,
	EncryptWithDerivedKey_Test_19,
	EncryptWithDerivedKey_Test_20,
	EncryptWithDerivedKey_Test_21,
	EncryptWithDerivedKey_Test_22,
	EncryptWithDerivedKey_Test_23,
	EncryptWithDerivedKey_Test_24,
	EncryptWithDerivedKey_Test_25,
	EncryptWithDerivedKey_Test_26,

	CalcMacWithDerivedKey_Test_01,
	CalcMacWithDerivedKey_Test_02,
	CalcMacWithDerivedKey_Test_03,
	CalcMacWithDerivedKey_Test_04,
	CalcMacWithDerivedKey_Test_05,
	CalcMacWithDerivedKey_Test_06,
	CalcMacWithDerivedKey_Test_07,
	CalcMacWithDerivedKey_Test_08,
	CalcMacWithDerivedKey_Test_09,

	PrivateAnalyse_Test_01,
	PrivateAnalyse_Test_02,
	PrivateAnalyse_Test_03,
	PrivateAnalyse_Test_04,
	PrivateAnalyse_Test_05,
	PrivateAnalyse_Test_06,
	PrivateAnalyse_Test_07,
	PrivateAnalyse_Test_08,
	PrivateAnalyse_Test_09,
	PrivateAnalyse_Test_10,
	PrivateAnalyse_Test_11,
	PrivateAnalyse_Test_12,
	PrivateAnalyse_Test_13,
	PrivateAnalyse_Test_14,
	PrivateAnalyse_Test_15,
	PrivateAnalyse_Test_16,
	PrivateAnalyse_Test_17,
	PrivateAnalyse_Test_18,
	PrivateAnalyse_Test_19,
	PrivateAnalyse_Test_20,
	PrivateAnalyse_Test_21,
	PrivateAnalyse_Test_22,
	PrivateAnalyse_Test_23,
	PrivateAnalyse_Test_24,

	GenEccKey_Test_01,
	GenEccKey_Test_02,
	GenEccKey_Test_03,
	GenEccKey_Test_04,

	GetEccPkBySk_Test_01,
	GetEccPkBySk_Test_02,
	GetEccPkBySk_Test_03,
	GetEccPkBySk_Test_04,
	GetEccPkBySk_Test_05,
	GetEccPkBySk_Test_06,
	GetEccPkBySk_Test_07,
	GetEccPkBySk_Test_08,

	EccPkEncrypt_Test_01,
	EccPkEncrypt_Test_02,
	EccPkEncrypt_Test_03,

	EccSkDecrypt_Test_01,
	EccSkDecrypt_Test_02,
	EccSkDecrypt_Test_03,

	EccSign_Test_01,
	EccSign_Test_02,

	EccVerify_Test_01,
	EccVerify_Test_02,
	EccVerify_Test_03,

	Sm4Calc_Test_01,
	Sm4Calc_Test_02,
	Sm4Calc_Test_03,
	Sm4Calc_Test_04,
	Sm4Calc_Test_05,
	Sm4Calc_Test_06,

	TransKeyIntoSK_Test_01,
	TransKeyIntoSK_Test_02,
	TransKeyIntoSK_Test_03,
	TransKeyIntoSK_Test_04,
	TransKeyIntoSK_Test_05,
	TransKeyIntoSK_Test_06,

	Sm2PKTransOutof_Test_01,

        DisconnectSM_Test_01,
	NULL
};

//三未信安
TESTFUNC TestFunc_C6[] =
{
    ConnectSM_Test_01,

	ConvertPinX98B_DoublePan_Test_01,
/*	ConvertPinX98B_DoublePan_Test_02,
	ConvertPinX98B_DoublePan_Test_03,
	ConvertPinX98B_DoublePan_Test_04,
	ConvertPinX98B_DoublePan_Test_05,
	ConvertPinX98B_DoublePan_Test_06,
	ConvertPinX98B_DoublePan_Test_07,
	ConvertPinX98B_DoublePan_Test_08,
	ConvertPinX98B_DoublePan_Test_09,
	ConvertPinX98B_DoublePan_Test_10,
	ConvertPinX98B_DoublePan_Test_11,
	ConvertPinX98B_DoublePan_Test_12,
	ConvertPinX98B_DoublePan_Test_13,
	ConvertPinX98B_DoublePan_Test_14,
	ConvertPinX98B_DoublePan_Test_15,
	ConvertPinX98B_DoublePan_Test_16,
	ConvertPinX98B_DoublePan_Test_17,
	ConvertPinX98B_DoublePan_Test_18,
	ConvertPinX98B_DoublePan_Test_19,

	ConvertPinX98ToIBM3624_Test_01,
	ConvertPinX98ToIBM3624_Test_02,
	ConvertPinX98ToIBM3624_Test_03,
	ConvertPinX98ToIBM3624_Test_04,
	ConvertPinX98ToIBM3624_Test_05,
	ConvertPinX98ToIBM3624_Test_06,
	ConvertPinX98ToIBM3624_Test_07,
	ConvertPinX98ToIBM3624_Test_08,
	ConvertPinX98ToIBM3624_Test_09,
	ConvertPinX98ToIBM3624_Test_10,
	ConvertPinX98ToIBM3624_Test_11,
	ConvertPinX98ToIBM3624_Test_12,
	ConvertPinX98ToIBM3624_Test_13,
	ConvertPinX98ToIBM3624_Test_14,
	ConvertPinX98ToIBM3624_Test_15,
	ConvertPinX98ToIBM3624_Test_16,
	ConvertPinX98ToIBM3624_Test_17,
	ConvertPinX98ToIBM3624_Test_18,
	ConvertPinX98ToIBM3624_Test_19,
	ConvertPinX98ToIBM3624_Test_20,
	ConvertPinX98ToIBM3624_Test_21,
	ConvertPinX98ToIBM3624_Test_22,
	ConvertPinX98ToIBM3624_Test_23,
	ConvertPinX98ToIBM3624_Test_24,
	ConvertPinX98ToIBM3624_Test_25,
	ConvertPinX98ToIBM3624_Test_26,
	ConvertPinX98ToIBM3624_Test_27,
	
	DisreteSubKeyExt1_Test_01,
	DisreteSubKeyExt1_Test_02,
	DisreteSubKeyExt1_Test_03,
	DisreteSubKeyExt1_Test_04,
	DisreteSubKeyExt1_Test_05,
	DisreteSubKeyExt1_Test_06,
*/
	DisreteSubKeyExt2_Test_01,

    DisconnectSM_Test_01,
	NULL
};

//卫士通
TESTFUNC TestFunc_X[] =
{
    ConnectSM_Test_01,

    DecryptEncrypt_Test_01,
    DecryptEncrypt_Test_02,
    DecryptEncrypt_Test_03,
    DecryptEncrypt_Test_04,

    DecryptEncrypt_Test_05,
    DecryptEncrypt_Test_06,
    DecryptEncrypt_Test_07,
    DecryptEncrypt_Test_08,

    Encrypt_Test_01,
    Encrypt_Test_02,
    Encrypt_Test_03,
    Encrypt_Test_04,

    EncryptIndex_Test_01,
    EncryptIndex_Test_02,
    EncryptIndex_Test_03,
    EncryptIndex_Test_04,

    Decrypt_Test_01,
    Decrypt_Test_02,
    Decrypt_Test_03,
    Decrypt_Test_04,

    DecryptIndex_Test_01,
    DecryptIndex_Test_02,
    DecryptIndex_Test_03,
    DecryptIndex_Test_04,

    DeriveKey_Test_01,
    DeriveKey_Test_02,
    DeriveKey_Test_03,
    DeriveKey_Test_04,

    DeriveKeyIndex_Test_01,
    DeriveKeyIndex_Test_02,
    DeriveKeyIndex_Test_03,
    DeriveKeyIndex_Test_04,

    GenerateRandom_Test_01,

    Wrap_Test_01,
    Wrap_Test_02,

    WrapIndex_Test_01,
    WrapIndex_Test_02,
    
    PBOCMAC_Test_01,
    PBOCMAC_Test_02,
    PBOCMAC_Test_03,
    
    PBOCMACIndex_Test_01,
    PBOCMACIndex_Test_02,
    PBOCMACIndex_Test_03,

    WrapEnhance_Test_01,
    WrapEnhance_Test_02,
    
    WrapEnhanceIndex_Test_01,
    WrapEnhanceIndex_Test_02,
    
    WrapExt_Test_01,
    WrapExt_Test_02,
    
    WrapExtIndex_Test_01,
    WrapExtIndex_Test_02,

//	GenMasterKey_Test_02,
    DisreteSubKeyExt1_Test_01,
//	DisreteSubKeyExt1_Test_06,
	/*
	DisreteSubKeyExt1_Test_02,
	DisreteSubKeyExt1_Test_03,
	DisreteSubKeyExt1_Test_04,
	DisreteSubKeyExt1_Test_05,
*/
/*	ConvertPinX98ToIBM3624_Test_01,
	ConvertPinX98ToIBM3624_Test_02,
	ConvertPinX98ToIBM3624_Test_03,
	ConvertPinX98ToIBM3624_Test_04,
	ConvertPinX98ToIBM3624_Test_05,
	ConvertPinX98ToIBM3624_Test_06,
	ConvertPinX98ToIBM3624_Test_07,
	ConvertPinX98ToIBM3624_Test_08,
	ConvertPinX98ToIBM3624_Test_09,
	ConvertPinX98ToIBM3624_Test_10,
	ConvertPinX98ToIBM3624_Test_11,
	ConvertPinX98ToIBM3624_Test_12,
	ConvertPinX98ToIBM3624_Test_13,
	ConvertPinX98ToIBM3624_Test_14,
	ConvertPinX98ToIBM3624_Test_15,
	ConvertPinX98ToIBM3624_Test_16,
	ConvertPinX98ToIBM3624_Test_17,
	ConvertPinX98ToIBM3624_Test_18,
	ConvertPinX98ToIBM3624_Test_19,
	ConvertPinX98ToIBM3624_Test_20,
	ConvertPinX98ToIBM3624_Test_21,
	ConvertPinX98ToIBM3624_Test_22,
	ConvertPinX98ToIBM3624_Test_23,
	ConvertPinX98ToIBM3624_Test_24,
	ConvertPinX98ToIBM3624_Test_25,
	ConvertPinX98ToIBM3624_Test_26,
	ConvertPinX98ToIBM3624_Test_27,
*/
/*
	Sm2SKTransInto_Test_01,
	TransKeyDesToSm4_Test_01,
	TransKeyDesToSm4_Test_02,
	TransKeyDesToSm4_Test_03,
	TransKeyDesToSm4_Test_04,
	TransKeySm4ToDes_Test_01,
	TransKeySm4ToDes_Test_02,
	TransKeySm4ToDes_Test_03,
	TransKeySm4ToDes_Test_04,
*/
	/*ConvertPinX98B_DoublePan_Test_01,
	ConvertPinX98B_DoublePan_Test_02,
	ConvertPinX98B_DoublePan_Test_03,
	ConvertPinX98B_DoublePan_Test_04,
	ConvertPinX98B_DoublePan_Test_05,
	ConvertPinX98B_DoublePan_Test_06,
	ConvertPinX98B_DoublePan_Test_07,
	ConvertPinX98B_DoublePan_Test_08,
	ConvertPinX98B_DoublePan_Test_09,
	ConvertPinX98B_DoublePan_Test_10,
	ConvertPinX98B_DoublePan_Test_11,
	ConvertPinX98B_DoublePan_Test_12,
	ConvertPinX98B_DoublePan_Test_13,
	ConvertPinX98B_DoublePan_Test_14,
	ConvertPinX98B_DoublePan_Test_15,
	ConvertPinX98B_DoublePan_Test_16,
	ConvertPinX98B_DoublePan_Test_17,
	ConvertPinX98B_DoublePan_Test_18,
	ConvertPinX98B_DoublePan_Test_19,
*//*	
	EncryptPinX98A_GM_Test_01,
	EncryptPinX98A_GM_Test_02,
	EncryptPinX98A_GM_Test_03,
	EncryptPinX98A_GM_Test_04,
	EncryptPinX98A_GM_Test_05,
	EncryptPinX98A_GM_Test_06,
	EncryptPinX98A_GM_Test_07,
	EncryptPinX98A_GM_Test_08,
	EncryptPinX98A_GM_Test_09,
	EncryptPinX98A_GM_Test_10,
	EncryptPinX98A_GM_Test_11,
	EncryptPinX98A_GM_Test_12,
	EncryptPinX98A_GM_Test_13,
	EncryptPinX98A_GM_Test_14,
	EncryptPinX98A_GM_Test_15,
	EncryptPinX98A_GM_Test_16,
	EncryptPinX98A_GM_Test_17,
	EncryptPinX98A_GM_Test_18,
	EncryptPinX98A_GM_Test_19,
	EncryptPinX98A_GM_Test_20,
	
	EncryptPinX98B_GM_Test_01,
	EncryptPinX98B_GM_Test_02,
	EncryptPinX98B_GM_Test_03,
	EncryptPinX98B_GM_Test_04,
	EncryptPinX98B_GM_Test_05,
	EncryptPinX98B_GM_Test_06,
	EncryptPinX98B_GM_Test_07,
	EncryptPinX98B_GM_Test_08,
	EncryptPinX98B_GM_Test_09,
	EncryptPinX98B_GM_Test_10,
	EncryptPinX98B_GM_Test_11,
	EncryptPinX98B_GM_Test_12,
	EncryptPinX98B_GM_Test_13,
	EncryptPinX98B_GM_Test_14,
	EncryptPinX98B_GM_Test_15,
	EncryptPinX98B_GM_Test_16,
	EncryptPinX98B_GM_Test_17,
	EncryptPinX98B_GM_Test_18,
	EncryptPinX98B_GM_Test_19,
	EncryptPinX98B_GM_Test_20,
	EncryptPinX98B_GM_Test_21,
	EncryptPinX98B_GM_Test_22,
	EncryptPinX98B_GM_Test_23,
	EncryptPinX98B_GM_Test_24,
	EncryptPinX98B_GM_Test_25,
	EncryptPinX98B_GM_Test_26,
	EncryptPinX98B_GM_Test_27,
	EncryptPinX98B_GM_Test_28,
	EncryptPinX98B_GM_Test_29,
	EncryptPinX98B_GM_Test_30,

	//CalcMAC_GM_Test_01,
	//CalcMAC_GM_Test_02,
	//CalcMAC_GM_Test_03,
	CalcMAC_GM_Test_04,
	CalcMAC_GM_Test_05,
	CalcMAC_GM_Test_06,
	CalcMAC_GM_Test_07,
	CalcMAC_GM_Test_08,
	CalcMAC_GM_Test_09,
	CalcMAC_GM_Test_10,
	CalcMAC_GM_Test_11,
	CalcMAC_GM_Test_12,
	CalcMAC_GM_Test_13,
	CalcMAC_GM_Test_14,
	CalcMAC_GM_Test_15,
	CalcMAC_GM_Test_16,
	CalcMAC_GM_Test_17,
	CalcMAC_GM_Test_18,
	CalcMAC_GM_Test_19,
	CalcMAC_GM_Test_20,
	CalcMAC_GM_Test_21,
	CalcMAC_GM_Test_22,
	CalcMAC_GM_Test_23,
	CalcMAC_GM_Test_24,
	CalcMAC_GM_Test_25,
	CalcMAC_GM_Test_26,
	CalcMAC_GM_Test_27,
	CalcMAC_GM_Test_28,
	CalcMAC_GM_Test_29,
	CalcMAC_GM_Test_30,
*/
/*
	ConvertPinX98A_Test_01,
	ConvertPinX98A_Test_02,
	ConvertPinX98A_Test_03,
	ConvertPinX98A_Test_04,
	ConvertPinX98A_Test_05,
	ConvertPinX98A_Test_06,
	ConvertPinX98A_Test_07,
	ConvertPinX98A_Test_08,
	ConvertPinX98A_Test_09,
	ConvertPinX98A_Test_10,
	ConvertPinX98A_Test_11,
	ConvertPinX98A_Test_12,
	ConvertPinX98A_Test_13,
	ConvertPinX98A_Test_14,
	ConvertPinX98A_Test_15,
	ConvertPinX98A_Test_16,
	
	ConvertPinX98B_Test_01,
	ConvertPinX98B_Test_02,
	ConvertPinX98B_Test_03,
	ConvertPinX98B_Test_04,
	ConvertPinX98B_Test_05,
	ConvertPinX98B_Test_06,
	ConvertPinX98B_Test_07,
	ConvertPinX98B_Test_08,
	ConvertPinX98B_Test_09,
	ConvertPinX98B_Test_10,
	ConvertPinX98B_Test_11,
	ConvertPinX98B_Test_12,
	ConvertPinX98B_Test_13,
	ConvertPinX98B_Test_14,
	ConvertPinX98B_Test_15,
	ConvertPinX98B_Test_16,
	ConvertPinX98B_Test_17,
	ConvertPinX98B_Test_18,
	ConvertPinX98B_Test_19,
	ConvertPinX98B_Test_20,
*/
/*
	TranslateKeyOutOf_GM_Test_01,
	TranslateKeyOutOf_GM_Test_02,
	TranslateKeyOutOf_GM_Test_03,
	TranslateKeyOutOf_GM_Test_04,
	TranslateKeyOutOf_GM_Test_05,
	TranslateKeyOutOf_GM_Test_06,
	TranslateKeyOutOf_GM_Test_07,
	TranslateKeyOutOf_GM_Test_08,
	TranslateKeyOutOf_GM_Test_09,
	TranslateKeyOutOf_GM_Test_10,
	TranslateKeyOutOf_GM_Test_11,
	TranslateKeyOutOf_GM_Test_12,
	TranslateKeyOutOf_GM_Test_13,
	TranslateKeyOutOf_GM_Test_14,
	TranslateKeyOutOf_GM_Test_15,
	TranslateKeyOutOf_GM_Test_16,
	TranslateKeyOutOf_GM_Test_17,
	TranslateKeyOutOf_GM_Test_18,
	TranslateKeyOutOf_GM_Test_19,

	TranslateKeyInTo_GM_Test_01,
	TranslateKeyInTo_GM_Test_02,
	TranslateKeyInTo_GM_Test_03,
	TranslateKeyInTo_GM_Test_04,
	TranslateKeyInTo_GM_Test_05,
	TranslateKeyInTo_GM_Test_06,
	TranslateKeyInTo_GM_Test_07,
	TranslateKeyInTo_GM_Test_08,
	TranslateKeyInTo_GM_Test_09,
	TranslateKeyInTo_GM_Test_10,
	TranslateKeyInTo_GM_Test_11,
	TranslateKeyInTo_GM_Test_12,
	TranslateKeyInTo_GM_Test_13,
	TranslateKeyInTo_GM_Test_14,
	TranslateKeyInTo_GM_Test_15,
	TranslateKeyInTo_GM_Test_16,
	TranslateKeyInTo_GM_Test_17,
	TranslateKeyInTo_GM_Test_18,
	TranslateKeyInTo_GM_Test_19,
	TranslateKeyInTo_GM_Test_20,
*/
/*
	GenerateKey_Test_P,
	GenerateKey_Test_K,
	GenerateKey_Test_01,
	GenerateKey_Test_02,
	GenerateKey_Test_03,
	GenerateKey_Test_03,
	GenerateKey_Test_04,
	GenerateKey_Test_05,
	GenerateKey_Test_06,
	GenerateKey_Test_07,
	GenerateKey_Test_08,

	HideBlock_Test_01,
	HideBlock_Test_xx,
	HideBlock_Test_02,
	HideBlock_Test_03,
	HideBlock_Test_04,

	RevealBlock_Test_01,
	RevealBlock_Test_02,
	RevealBlock_Test_03,
	RevealBlock_Test_04,

	EncryptKey_Test_01,
	EncryptKey_Test_02,
	EncryptKey_Test_03,
	EncryptKey_Test_04,
	EncryptKey_Test_05,
	EncryptKey_Test_06,
	EncryptKey_Test_07,
	EncryptKey_Test_08,
	EncryptKey_Test_09,
	EncryptKey_Test_10,
	EncryptKey_Test_11,
	EncryptKey_Test_12,
*/
/*
	EncryptBlock_Test_01,
	EncryptBlock_Test_02,
	EncryptBlock_Test_03,
	EncryptBlock_Test_04,
	EncryptBlock_Test_05,
	EncryptBlock_Test_06,
	EncryptBlock_Test_07,
	EncryptBlock_Test_08,
	EncryptBlock_Test_09,
	EncryptBlock_Test_10,
	EncryptBlock_Test_11,
	EncryptBlock_Test_12,
	EncryptBlock_Test_13,
	EncryptBlock_Test_14,
	EncryptBlock_Test_15,

	DecryptBlock_Test_01,
	DecryptBlock_Test_02,
	DecryptBlock_Test_03,
	DecryptBlock_Test_04,
	DecryptBlock_Test_05,
	DecryptBlock_Test_06,
	DecryptBlock_Test_07,
	DecryptBlock_Test_08,
	DecryptBlock_Test_09,
	DecryptBlock_Test_10,
	DecryptBlock_Test_11,
	DecryptBlock_Test_12,
	DecryptBlock_Test_13,
	DecryptBlock_Test_14,
	DecryptBlock_Test_15,
*/
/*
	EncryptCBC_Test_01,
	EncryptCBC_Test_02,
	EncryptCBC_Test_03,
	EncryptCBC_Test_04,
	EncryptCBC_Test_05,
	EncryptCBC_Test_06,
	EncryptCBC_Test_07,
	EncryptCBC_Test_08,
	EncryptCBC_Test_09,
	EncryptCBC_Test_10,
	EncryptCBC_Test_11,
	EncryptCBC_Test_12,
	EncryptCBC_Test_13,
	EncryptCBC_Test_14,
	EncryptCBC_Test_15,
	EncryptCBC_Test_16,
	EncryptCBC_Test_17,
	EncryptCBC_Test_18,

	DecryptCBC_Test_01,
	DecryptCBC_Test_02,
	DecryptCBC_Test_03,
	DecryptCBC_Test_04,
	DecryptCBC_Test_05,
	DecryptCBC_Test_06,
	DecryptCBC_Test_07,
	DecryptCBC_Test_08,
	DecryptCBC_Test_09,
	DecryptCBC_Test_10,
	DecryptCBC_Test_11,
	DecryptCBC_Test_12,
	DecryptCBC_Test_13,
	DecryptCBC_Test_14,
	DecryptCBC_Test_15,
	DecryptCBC_Test_16,
	DecryptCBC_Test_17,
	DecryptCBC_Test_18,
*/
/*
	CalCVV_Test_01,
	CalCVV_Test_02,
	CalCVV_Test_03,
	CalCVV_Test_04,
	CalCVV_Test_05,
	CalCVV_Test_06,
	CalCVV_Test_07,
	CalCVV_Test_08,
	CalCVV_Test_09,
	CalCVV_Test_10,
	CalCVV_Test_11,
	CalCVV_Test_12,
	CalCVV_Test_13,
	CalCVV_Test_14,
	CalCVV_Test_15,
	CalCVV_Test_16,
	CalCVV_Test_17,
	CalCVV_Test_18,
	CalCVV_Test_19,
	CalCVV_Test_20,
	CalCVV_Test_21,
*/
/*
	CalPVV_Test_01,
	CalPVV_Test_02,
	CalPVV_Test_03,
	CalPVV_Test_04,
	CalPVV_Test_05,
	CalPVV_Test_06,
	CalPVV_Test_07,
	CalPVV_Test_08,
	CalPVV_Test_09,*/
//	CalPVV_Test_10,
//	CalPVV_Test_11,
//	CalPVV_Test_12,
/*	CalPVV_Test_13,
	CalPVV_Test_14,
	CalPVV_Test_15,
	CalPVV_Test_16,
	CalPVV_Test_17,
	CalPVV_Test_18,
	CalPVV_Test_19,
	CalPVV_Test_20,
	CalPVV_Test_21,
	CalPVV_Test_22,
	CalPVV_Test_23,
	CalPVV_Test_24,
	CalPVV_Test_25,
	CalPVV_Test_26,
	CalPVV_Test_27,
*/

/*	IBM3624_Test_01,
	IBM3624_Test_02,
	IBM3624_Test_03,
	IBM3624_Test_04,
	IBM3624_Test_05,
	IBM3624_Test_06,
	IBM3624_Test_07,
	IBM3624_Test_08,
	IBM3624_Test_09,
	IBM3624_Test_10,
	IBM3624_Test_11,
	IBM3624_Test_12,
	IBM3624_Test_13,
	IBM3624_Test_14,
	IBM3624_Test_15,
	IBM3624_Test_16,
	IBM3624_Test_17,
	IBM3624_Test_18,
	IBM3624_Test_19,
	IBM3624_Test_20,
	IBM3624_Test_21,
	IBM3624_Test_22,
	IBM3624_Test_23,
	IBM3624_Test_24,
	IBM3624_Test_25,
*/
/*
	GenRandDigits_Test_01,
	GenRandDigits_Test_02,
	GenRandDigits_Test_03,
	GenRandDigits_Test_04,
	GenRandDigits_Test_05,
	GenRandDigits_Test_06,
	GenRandDigits_Test_07,
	GenRandDigits_Test_08,
	GenRandDigits_Test_09,
	GenRandDigits_Test_10,
	GenRandDigits_Test_11,
	GenRandDigits_Test_12,
	GenRandDigits_Test_13,
	GenRandDigits_Test_14,
	GenRandDigits_Test_15,
	GenRandDigits_Test_16,
	GenRandDigits_Test_17,
*/
/*
	VerifyCheckValue_Test_01,
	VerifyCheckValue_Test_02,
	VerifyCheckValue_Test_03,
	VerifyCheckValue_Test_04,
	VerifyCheckValue_Test_05,
	VerifyCheckValue_Test_06,
	VerifyCheckValue_Test_07,
	VerifyCheckValue_Test_08,
	VerifyCheckValue_Test_09,
	VerifyCheckValue_Test_10,
	VerifyCheckValue_Test_11,
	VerifyCheckValue_Test_12,
	VerifyCheckValue_Test_13,
	VerifyCheckValue_Test_14,
	VerifyCheckValue_Test_15,
	VerifyCheckValue_Test_16,
	VerifyCheckValue_Test_17,
	VerifyCheckValue_Test_18,
*/
/*
	GetHsmStatus_Test_01,
	GetHsmStatus_Test_02,
	GetHsmStatus_Test_03,
*/
/*
	ExpMod_Test_01,
	ExpMod_Test_02,
	ExpMod_Test_03,
	ExpMod_Test_04,
	ExpMod_Test_05,
*/

//	GenBigPrime_Test_01,
//	GenBigPrime_Test_02,
//	GenBigPrime_Test_03,


//	TransKeyIntoSKAndPrint_Test_01,
/*
	GenRsaKey_Test_01,
	GenRsaKey_Test_02,
	GenRsaKey_Test_03,
	GenRsaKey_Test_04,
	GenRsaKey_Test_05,
	GenRsaKey_Test_06,
	GenRsaKey_Test_06,
	GenRsaKey_Test_07,
	GenRsaKey_Test_08,
	GenRsaKey_Test_09,
	GenRsaKey_Test_10,
	GenRsaKey_Test_11,
	GenRsaKey_Test_12,
	GenRsaKey_Test_13,
	GenRsaKey_Test_14,
*/

//	GenMasterKey_Test_01,
//	GenMasterKey_Test_02,
/*	GenMasterKey_Test_03,
	GenMasterKey_Test_04,
	GenMasterKey_Test_05,
	GenMasterKey_Test_06,
	GenMasterKey_Test_07,
	GenMasterKey_Test_08,
	GenMasterKey_Test_09,
	GenMasterKey_Test_10,
	GenMasterKey_Test_11,
	GenMasterKey_Test_12,
*/
//	ExportMasterKey_Test_01,
//	ExportMasterKey_Test_02,
//	ExportMasterKey_Test_03,
//	ExportMasterKey_Test_04,
//	ExportMasterKey_Test_05,
//	ExportMasterKey_Test_06,
//	ExportMasterKey_Test_07,

    DisconnectSM_Test_01,
	NULL
};

void finish(int sig)
{
    iscontinue = 0;
    fprintf(stdout, "SYSTEM SIGNAL = %d \n", sig);
    fflush(stdout);
}

#define TEST_CYCLE(c, f, s) \
    { \
        c = 0; \
        while(iscontinue) \
        { \
            f = s[c++]; \
            if(f == NULL) break; \
            f(); \
        } \
    }

RESULT main(int argc, char **argv)
{
    TESTFUNC pFunc = NULL;
    unsigned int seed = (unsigned int)getpid();
    int cnt = 0;
    
    iscontinue = 1;
    testOpenDevice();
  /*  int nRet = SDF_OpenSession((void **)&nDeviceHandle, (void **)&nHandle);
    if (nRet)
    {
	fprintf(stderr, "SDF_OpenSession error:0x%x\n", nRet);
	fflush(stderr);
	return 1;
    }
	nRet = SDF_CloseDevice(&nDeviceHandle);
	if (nRet)
	{
		fprintf(stderr, "SDF_CloseDevice error:0x%x\n", nRet);
		fflush(stderr);
	}
        printf("1111111111111111111111111 %d\n",nRet);*/

    signal(SIGPIPE, finish);
    signal(SIGINT, finish);
    signal(SIGQUIT, finish);
    signal(SIGTERM, finish);
   /* 
    //PBOC卡，SM4  1025
    int nIccType = 0x00000401;
    int nTemp = nIccType >> 16;
    printf("nIccType is %d\n,  nIccType >> 16 is %d\n",nIccType,nTemp);

    // MASTER卡
    nIccType = 0X00020014;
    nTemp = nIccType >> 16;
    printf("nIccType is %d\n,  nIccType >> 16 is %d\n",nIccType,nTemp);

    //VISA卡
    nIccType = 0x0001000A;
    nTemp = nIccType >> 16;
    printf("nIccType is %d\n,  nIccType >> 16 is %d\n",nIccType,nTemp);

    //PBOC卡
    nIccType = 0x00000000;
    nTemp = nIccType >> 16;
    printf("nIccType is %d\n,  nIccType >> 16 is %d\n",nIccType,nTemp);

    //PBOC卡，SM4 1047
    nIccType = 0x00000417; 
    nTemp = nIccType >> 16;
    printf("nIccType is %d\n,  nIccType >> 16 is %d\n",nIccType,nTemp);
*/
    //TEST_CYCLE(cnt, pFunc, TestFunc_P)
    //卫士通
    TEST_CYCLE(cnt, pFunc,TestFunc_C4)     
    //TEST_CYCLE(cnt, pFunc,TestFunc_C5)  
    TEST_CYCLE(cnt, pFunc,TestFunc_C6)
    
    //三未信安
    //TEST_CYCLE(cnt, pFunc,TestFunc_X)
    //TEST_CYCLE(cnt, pFunc, TestFunc_B)

    //TEST_CYCLE(cnt, pFunc, TestFunc_E)

    //TEST_CYCLE(cnt, pFunc, TestFunc_G)
    //江南科友
    //TEST_CYCLE(cnt, pFunc, TestFunc_K)

    /*********** SP Test ***********/
//    ConnectSM_Test_01();

//    ExportMasterKey_Test_02();

//    DisconnectSM_Test_01();
    /*********** SP Test ***********/

    return NORMAL;
}


/* End of this file */
